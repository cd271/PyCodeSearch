{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/graph/find_all_cliques.py", "fileNameBase": "find_all_cliques", "extension": "py", "doc": {"long_description": "graph such that the subgraph is fully connected (ie. for any pair of nodes in\nthe subgraph there is an edge between them).", "short_description": "Finds all cliques in an undirected graph. A clique is a set of vertices in the", "full": "Finds all cliques in an undirected graph. A clique is a set of vertices in the\ngraph such that the subgraph is fully connected (ie. for any pair of nodes in\nthe subgraph there is an edge between them)."}}, "functions": {"find_all_cliques": {"doc": {"long_description": "each key is a vertex\nvalue is set of all edges connected to vertex\nreturns list of lists (each sub list is a maximal clique)\nimplementation of the basic algorithm described in:\nBron, Coen; Kerbosch, Joep (1973), \"Algorithm 457: finding all cliques of an undirected graph\",", "short_description": "takes dict of sets"}, "args": ["edges"], "returns": ["solutions", "new_set"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 43}, "calls": ["set", "find_all_cliques.find_all_cliques.expand_clique"], "store_vars_calls": {"possibles": "set", "new_set": "set", "candidates_temp": "get_connected", "nays_temp": "get_connected"}, "functions": {"expand_clique": {"args": ["candidates", "nays"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 30}, "calls": ["solutions.append", "candidates.copy", "compsub.copy", "candidates.remove", "get_connected", "compsub.append", "expand_clique", "nays.add", "compsub.pop"], "store_vars_calls": {"candidates_temp": "get_connected", "nays_temp": "get_connected"}, "source_code": "def expand_clique(candidates, nays):\n    nonlocal compsub\n    if not candidates and (not nays):\n        nonlocal solutions\n        solutions.append(compsub.copy())\n    else:\n        for selected in candidates.copy():\n            candidates.remove(selected)\n            candidates_temp = get_connected(selected, candidates)\n            nays_temp = get_connected(selected, nays)\n            compsub.append(selected)\n            expand_clique(candidates_temp, nays_temp)\n            nays.add(compsub.pop())"}, "get_connected": {"args": ["vertex", "old_set"], "returns": ["new_set"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 37}, "calls": ["set", "str", "set.add"], "store_vars_calls": {"new_set": "set"}, "source_code": "def get_connected(vertex, old_set):\n    new_set = set()\n    for neighbor in edges[str(vertex)]:\n        if neighbor in old_set:\n            new_set.add(neighbor)\n    return new_set"}}, "source_code": "def find_all_cliques(edges):\n    \"\"\"\n    takes dict of sets\n    each key is a vertex\n    value is set of all edges connected to vertex\n    returns list of lists (each sub list is a maximal clique)\n    implementation of the basic algorithm described in:\n    Bron, Coen; Kerbosch, Joep (1973), \"Algorithm 457: finding all cliques of an undirected graph\",\n    \"\"\"\n\n    def expand_clique(candidates, nays):\n        nonlocal compsub\n        if not candidates and (not nays):\n            nonlocal solutions\n            solutions.append(compsub.copy())\n        else:\n            for selected in candidates.copy():\n                candidates.remove(selected)\n                candidates_temp = get_connected(selected, candidates)\n                nays_temp = get_connected(selected, nays)\n                compsub.append(selected)\n                expand_clique(candidates_temp, nays_temp)\n                nays.add(compsub.pop())\n\n    def get_connected(vertex, old_set):\n        new_set = set()\n        for neighbor in edges[str(vertex)]:\n            if neighbor in old_set:\n                new_set.add(neighbor)\n        return new_set\n    compsub = []\n    solutions = []\n    possibles = set(edges.keys())\n    expand_clique(possibles, set())\n    return solutions"}}, "is_test": false}