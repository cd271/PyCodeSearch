{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/matrix/matrix_inversion.py", "fileNameBase": "matrix_inversion", "extension": "py", "doc": {"long_description": "an n x n matrix B such that AB = BA = In, the n x n identity matrix.\n\nFor a 2 x 2 matrix, inversion is simple using the cofactor equation. For\nlarger matrices, this is a four step process:\n1. calculate the matrix of minors: create an n x n matrix by considering each\nposition in the original matrix in turn. Exclude the current row and column\nand calculate the determinant of the remaining matrix, then place that value\nin the current position's equivalent in the matrix of minors.\n2. create the matrix of cofactors: take the matrix of minors and multiply\nalternate values by -1 in a checkerboard pattern.\n3. adjugate: hold the top left to bottom right diagonal constant, but swap all\nother values over it.\n4. multiply the adjugated matrix by 1 / the determinant of the original matrix\n\nThis code combines steps 1 and 2 into one method to reduce traversals of the\nmatrix.\n\nPossible edge cases: will not work for 0x0 or 1x1 matrix, though these are\ntrivial to calculate without use of this file.", "short_description": "Inverts an invertible n x n matrix -- i.e., given an n x n matrix A, returns", "full": "Inverts an invertible n x n matrix -- i.e., given an n x n matrix A, returns\nan n x n matrix B such that AB = BA = In, the n x n identity matrix.\n\nFor a 2 x 2 matrix, inversion is simple using the cofactor equation. For\nlarger matrices, this is a four step process:\n1. calculate the matrix of minors: create an n x n matrix by considering each\nposition in the original matrix in turn. Exclude the current row and column\nand calculate the determinant of the remaining matrix, then place that value\nin the current position's equivalent in the matrix of minors.\n2. create the matrix of cofactors: take the matrix of minors and multiply\nalternate values by -1 in a checkerboard pattern.\n3. adjugate: hold the top left to bottom right diagonal constant, but swap all\nother values over it.\n4. multiply the adjugated matrix by 1 / the determinant of the original matrix\n\nThis code combines steps 1 and 2 into one method to reduce traversals of the\nmatrix.\n\nPossible edge cases: will not work for 0x0 or 1x1 matrix, though these are\ntrivial to calculate without use of this file."}}, "dependencies": [{"import": "fractions", "type": "external", "type_element": "module"}], "functions": {"invert_matrix": {"doc": {"short_description": "invert an n x n matrix"}, "args": ["m"], "returns": ["[[-1]]", "[[-2]]", "[[-3]]", "[[-4]]", "inverted", "inverted"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 64}, "calls": ["matrix_inversion.array_is_matrix", "print", "len", "matrix_inversion.get_determinant", "matrix_inversion.get_matrix_of_minors", "fractions.Fraction", "matrix_inversion.transpose_and_multiply", "range"], "store_vars_calls": {"m_of_minors": "get_matrix_of_minors", "multiplier": "fractions.Fraction", "inverted": "transpose_and_multiply"}, "source_code": "def invert_matrix(m):\n    \"\"\"invert an n x n matrix\"\"\"\n    if not array_is_matrix(m):\n        print('Invalid matrix: array is not a matrix')\n        return [[-1]]\n    elif len(m) != len(m[0]):\n        print('Invalid matrix: matrix is not square')\n        return [[-2]]\n    elif len(m) < 2:\n        print('Invalid matrix: matrix is too small')\n        return [[-3]]\n    elif get_determinant(m) == 0:\n        print('Invalid matrix: matrix is square, but singular (determinant = 0)')\n        return [[-4]]\n    elif len(m) == 2:\n        multiplier = 1 / get_determinant(m)\n        inverted = [[multiplier] * len(m) for n in range(len(m))]\n        inverted[0][1] = inverted[0][1] * -1 * m[0][1]\n        inverted[1][0] = inverted[1][0] * -1 * m[1][0]\n        inverted[0][0] = multiplier * m[1][1]\n        inverted[1][1] = multiplier * m[0][0]\n        return inverted\n    else:\n        'some steps combined in helpers to reduce traversals'\n        m_of_minors = get_matrix_of_minors(m)\n        multiplier = fractions.Fraction(1, get_determinant(m))\n        inverted = transpose_and_multiply(m_of_minors, multiplier)\n        return inverted"}, "get_determinant": {"doc": {"short_description": "recursively calculate the determinant of an n x n matrix, n >= 2"}, "args": ["m"], "returns": ["m[0][0] * m[1][1] - m[0][1] * m[1][0]", "det"], "min_max_lineno": {"min_lineno": 66, "max_lineno": 78}, "calls": ["len", "range", "matrix_inversion.get_determinant", "matrix_inversion.get_minor"], "source_code": "def get_determinant(m):\n    \"\"\"recursively calculate the determinant of an n x n matrix, n >= 2\"\"\"\n    if len(m) == 2:\n        return m[0][0] * m[1][1] - m[0][1] * m[1][0]\n    else:\n        sign = 1\n        det = 0\n        for i in range(len(m)):\n            det += sign * m[0][i] * get_determinant(get_minor(m, 0, i))\n            sign *= -1\n        return det"}, "get_matrix_of_minors": {"doc": {"short_description": "get the matrix of minors and alternate signs"}, "args": ["m"], "returns": ["matrix_of_minors"], "min_max_lineno": {"min_lineno": 80, "max_lineno": 91}, "calls": ["range", "len", "matrix_inversion.get_determinant", "matrix_inversion.get_minor"], "source_code": "def get_matrix_of_minors(m):\n    \"\"\"get the matrix of minors and alternate signs\"\"\"\n    matrix_of_minors = [[0 for i in range(len(m))] for j in range(len(m))]\n    for row in range(len(m)):\n        for col in range(len(m[0])):\n            if (row + col) % 2 == 0:\n                sign = 1\n            else:\n                sign = -1\n            matrix_of_minors[row][col] = sign * get_determinant(get_minor(m, row, col))\n    return matrix_of_minors"}, "get_minor": {"doc": {"long_description": "(all values m[r][c] where r != row and c != col)", "short_description": "get the minor of the matrix position m[row][col]"}, "args": ["m", "row", "col"], "returns": ["minors"], "min_max_lineno": {"min_lineno": 93, "max_lineno": 105}, "calls": ["range", "len", "new_row.extend", "minors.append"], "source_code": "def get_minor(m, row, col):\n    \"\"\"\n    get the minor of the matrix position m[row][col]\n    (all values m[r][c] where r != row and c != col)\n    \"\"\"\n    minors = []\n    for i in range(len(m)):\n        if i != row:\n            new_row = m[i][:col]\n            new_row.extend(m[i][col + 1:])\n            minors.append(new_row)\n    return minors"}, "transpose_and_multiply": {"doc": {"short_description": "swap values along diagonal, optionally adding multiplier"}, "args": ["m", "multiplier"], "returns": ["m"], "min_max_lineno": {"min_lineno": 107, "max_lineno": 115}, "calls": ["range", "len"], "source_code": "def transpose_and_multiply(m, multiplier=1):\n    \"\"\"swap values along diagonal, optionally adding multiplier\"\"\"\n    for row in range(len(m)):\n        for col in range(row + 1):\n            temp = m[row][col] * multiplier\n            m[row][col] = m[col][row] * multiplier\n            m[col][row] = temp\n    return m"}, "array_is_matrix": {"args": ["m"], "returns": ["True", "False", "False"], "min_max_lineno": {"min_lineno": 117, "max_lineno": 125}, "calls": ["len"], "store_vars_calls": {"first_col": "len"}, "source_code": "def array_is_matrix(m):\n    if len(m) == 0:\n        return False\n    first_col = len(m[0])\n    for row in m:\n        if len(row) != first_col:\n            return False\n    return True"}}, "is_test": false}