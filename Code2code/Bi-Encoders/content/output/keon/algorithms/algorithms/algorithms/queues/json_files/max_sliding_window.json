{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/queues/max_sliding_window.py", "fileNameBase": "max_sliding_window", "extension": "py", "doc": {"long_description": "Find the max elements of each of its sub-arrays of length k.\n\nKeep indexes of good candidates in deque d.\nThe indexes in d are from the current window, they're increasing,\nand their corresponding nums are decreasing.\nThen the first deque element is the index of the largest window value.\n\nFor each index i:\n\n1. Pop (from the end) indexes of smaller elements (they'll be useless).\n2. Append the current index.\n3. Pop (from the front) the index i - k, if it's still in the deque\n   (it falls out of the window).\n4. If our window has reached size k,\n   append the current window maximum to the output.", "short_description": "Given an array and a number k", "full": "Given an array and a number k\nFind the max elements of each of its sub-arrays of length k.\n\nKeep indexes of good candidates in deque d.\nThe indexes in d are from the current window, they're increasing,\nand their corresponding nums are decreasing.\nThen the first deque element is the index of the largest window value.\n\nFor each index i:\n\n1. Pop (from the end) indexes of smaller elements (they'll be useless).\n2. Append the current index.\n3. Pop (from the front) the index i - k, if it's still in the deque\n   (it falls out of the window).\n4. If our window has reached size k,\n   append the current window maximum to the output."}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"max_sliding_window": {"args": ["arr", "k"], "returns": ["result"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 35}, "calls": ["collections.deque", "enumerate", "collections.deque.append", "collections.deque.pop", "collections.deque.popleft", "result.append"], "store_vars_calls": {"qi": "collections.deque"}, "source_code": "def max_sliding_window(arr, k):\n    qi = collections.deque()\n    result = []\n    for (i, n) in enumerate(arr):\n        while qi and arr[qi[-1]] < n:\n            qi.pop()\n        qi.append(i)\n        if qi[0] == i - k:\n            qi.popleft()\n        if i >= k - 1:\n            result.append(arr[qi[0]])\n    return result"}}, "is_test": false}