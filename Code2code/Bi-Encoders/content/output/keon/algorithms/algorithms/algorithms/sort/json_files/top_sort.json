{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/sort/top_sort.py", "fileNameBase": "top_sort", "extension": "py"}, "functions": {"top_sort_recursive": {"doc": {"long_description": "Space complexity: O(V)", "short_description": "Time complexity is the same as DFS, which is O(V + E)"}, "args": ["graph"], "returns": ["order"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 25}, "calls": ["set", "graph.get", "order.append", "top_sort.top_sort_recursive.dfs"], "store_vars_calls": {"sk": "state.get"}, "functions": {"dfs": {"args": ["node"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 22}, "calls": ["graph.get", "order.append", "state.get", "enter.discard", "dfs", "ValueError"], "store_vars_calls": {"sk": "state.get"}, "source_code": "def dfs(node):\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK"}}, "source_code": "def top_sort_recursive(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order"}, "top_sort": {"doc": {"long_description": "Space complexity: O(V)", "short_description": "Time complexity is the same as DFS, which is O(V + E)"}, "args": ["graph"], "returns": ["order", "True", "True", "False"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 67}, "calls": ["set", "graph.get", "enter.pop", "len", "state.get", "stack.append", "stack.pop", "ValueError", "enter.discard", "top_sort.top_sort.is_ready"], "store_vars_calls": {"lst": "graph.get", "node": "stack.pop", "sk": "state.get"}, "functions": {"is_ready": {"args": ["node"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 43}, "calls": ["graph.get", "len", "state.get", "ValueError"], "store_vars_calls": {"lst": "graph.get", "sk": "state.get"}, "source_code": "def is_ready(node):\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True"}}, "source_code": "def top_sort(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order"}}, "is_test": false}