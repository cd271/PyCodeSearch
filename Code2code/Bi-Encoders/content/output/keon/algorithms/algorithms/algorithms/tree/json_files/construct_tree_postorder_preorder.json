{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/tree/construct_tree_postorder_preorder.py", "fileNameBase": "construct_tree_postorder_preorder", "extension": "py", "doc": {"long_description": "binary tree, construct the binary tree and print the inorder traversal of the\ntree.\nA full binary tree has either 0 or 2 children.\nAlgorithm:\n    1. Assign the first element of preorder array as root of the tree.\n    2. Find the same element in the postorder array and divide the postorder\n        array into left and right subtree.\n    3. Repeat the above steps for all the elements and construct the tree.\nEg: pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7}\n    post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1}\n    Tree:\n            1\n          /                2     3\n        / \\   /            4   5 6   7\n      /          8   9\n  Output: 8 4 9 2 5 1 6 3 7", "short_description": "Given two arrays representing preorder and postorder traversal of a full", "full": "Given two arrays representing preorder and postorder traversal of a full\nbinary tree, construct the binary tree and print the inorder traversal of the\ntree.\nA full binary tree has either 0 or 2 children.\nAlgorithm:\n    1. Assign the first element of preorder array as root of the tree.\n    2. Find the same element in the postorder array and divide the postorder\n        array into left and right subtree.\n    3. Repeat the above steps for all the elements and construct the tree.\nEg: pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7}\n    post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1}\n    Tree:\n            1\n          /                2     3\n        / \\   /            4   5 6   7\n      /          8   9\n  Output: 8 4 9 2 5 1 6 3 7"}}, "classes": {"TreeNode": {"min_max_lineno": {"min_lineno": 24, "max_lineno": 30}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 30}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}}, "functions": {"construct_tree_util": {"doc": {"long_description": "preIndex is a global variable that keeps track of the index in preorder\narray.\npreorder and postorder array are represented are pre[] and post[] respectively.\nlow and high are the indices for the postorder array.", "short_description": "Recursive function that constructs tree from preorder and postorder array."}, "args": ["pre", "post", "low", "high", "size"], "annotated_arg_types": {"pre": "list", "post": "list", "low": "int", "high": "int", "size": "int"}, "returns": ["root", "None", "root"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 75}, "calls": ["construct_tree_postorder_preorder.construct_tree_util"], "store_vars_calls": {"root": "TreeNode", "root.left": "construct_tree_util", "root.right": "construct_tree_util"}, "source_code": "def construct_tree_util(pre: list, post: list, low: int, high: int, size: int):\n    \"\"\"\n        Recursive function that constructs tree from preorder and postorder array.\n        \n        preIndex is a global variable that keeps track of the index in preorder\n        array.\n        preorder and postorder array are represented are pre[] and post[] respectively.\n        low and high are the indices for the postorder array.\n    \"\"\"\n    global pre_index\n    if pre_index == -1:\n        pre_index = 0\n    if pre_index >= size or low > high:\n        return None\n    root = TreeNode(pre[pre_index])\n    pre_index += 1\n    if low == high or pre_index >= size:\n        return root\n    i = low\n    while i <= high:\n        if pre[pre_index] == post[i]:\n            break\n        i += 1\n    if i <= high:\n        root.left = construct_tree_util(pre, post, low, i, size)\n        root.right = construct_tree_util(pre, post, i + 1, high, size)\n    return root"}, "construct_tree": {"doc": {"long_description": "and postorder array.", "short_description": "Main Function that will construct the full binary tree from given preorder"}, "args": ["pre", "post", "size"], "annotated_arg_types": {"pre": "list", "post": "list", "size": "int"}, "returns": ["print_inorder(root)"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 87}, "calls": ["construct_tree_postorder_preorder.construct_tree_util", "construct_tree_postorder_preorder.print_inorder"], "store_vars_calls": {"root": "construct_tree_util"}, "source_code": "def construct_tree(pre: list, post: list, size: int):\n    \"\"\"\n        Main Function that will construct the full binary tree from given preorder\n        and postorder array.\n    \"\"\"\n    global pre_index\n    root = construct_tree_util(pre, post, 0, size - 1, size)\n    return print_inorder(root)"}, "print_inorder": {"doc": {"short_description": "Prints the tree constructed in inorder format"}, "args": ["root", "result"], "annotated_arg_types": {"root": "TreeNode"}, "returns": ["result", "[]"], "min_max_lineno": {"min_lineno": 90, "max_lineno": 103}, "calls": ["construct_tree_postorder_preorder.print_inorder", "result.append"], "source_code": "def print_inorder(root: TreeNode, result=None):\n    \"\"\"\n        Prints the tree constructed in inorder format\n    \"\"\"\n    if root is None:\n        return []\n    if result is None:\n        result = []\n    print_inorder(root.left, result)\n    result.append(root.val)\n    print_inorder(root.right, result)\n    return result"}}, "body": {"calls": ["len", "construct_tree_postorder_preorder.construct_tree", "print"], "store_vars_calls": {"size": "len", "result": "construct_tree"}, "source_code": ["len(pre)", "construct_tree(pre, post, size)", "print(result)"]}, "main_info": {"main_flag": 1, "main_function": "construct_tree_postorder_preorder.len", "type": "script"}, "is_test": false}