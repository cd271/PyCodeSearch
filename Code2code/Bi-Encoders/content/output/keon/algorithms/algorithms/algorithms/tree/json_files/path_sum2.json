{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/tree/path_sum2.py", "fileNameBase": "path_sum2", "extension": "py", "doc": {"long_description": "paths where each path's sum equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\    /         7    2  5   1\nreturn\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]", "short_description": "Given a binary tree and a sum, find all root-to-leaf", "full": "Given a binary tree and a sum, find all root-to-leaf\npaths where each path's sum equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\    /         7    2  5   1\nreturn\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]"}}, "functions": {"path_sum": {"args": ["root", "sum"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 28}, "calls": ["path_sum2.dfs"], "source_code": "def path_sum(root, sum):\n    if root is None:\n        return []\n    res = []\n    dfs(root, sum, [], res)\n    return res"}, "dfs": {"args": ["root", "sum", "ls", "res"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 38}, "calls": ["ls.append", "res.append", "path_sum2.dfs"], "source_code": "def dfs(root, sum, ls, res):\n    if root.left is None and root.right is None and (root.val == sum):\n        ls.append(root.val)\n        res.append(ls)\n    if root.left is not None:\n        dfs(root.left, sum - root.val, ls + [root.val], res)\n    if root.right is not None:\n        dfs(root.right, sum - root.val, ls + [root.val], res)"}, "path_sum2": {"args": ["root", "s"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 55}, "calls": ["stack.pop", "res.append", "stack.append", "sum"], "source_code": "def path_sum2(root, s):\n    if root is None:\n        return []\n    res = []\n    stack = [(root, [root.val])]\n    while stack:\n        (node, ls) = stack.pop()\n        if node.left is None and node.right is None and (sum(ls) == s):\n            res.append(ls)\n        if node.left is not None:\n            stack.append((node.left, ls + [node.left.val]))\n        if node.right is not None:\n            stack.append((node.right, ls + [node.right.val]))\n    return res"}, "path_sum3": {"args": ["root", "sum"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 72}, "calls": ["queue.pop", "res.append", "queue.append"], "source_code": "def path_sum3(root, sum):\n    if root is None:\n        return []\n    res = []\n    queue = [(root, root.val, [root.val])]\n    while queue:\n        (node, val, ls) = queue.pop(0)\n        if node.left is None and node.right is None and (val == sum):\n            res.append(ls)\n        if node.left is not None:\n            queue.append((node.left, val + node.left.val, ls + [node.left.val]))\n        if node.right is not None:\n            queue.append((node.right, val + node.right.val, ls + [node.right.val]))\n    return res"}}, "is_test": false}