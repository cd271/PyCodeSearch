{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/graph/clone_graph.py", "fileNameBase": "clone_graph", "extension": "py", "doc": {"long_description": "of its neighbors.\n\n\nOJ's undirected graph serialization:\nNodes are labeled uniquely.\n\nWe use # as a separator for each node, and , as a separator for node label and\neach neighbor of the node.\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\n\nThe graph has a total of three nodes, and therefore contains three parts as\nseparated by #.\n\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\nSecond node is labeled as 1. Connect node 1 to node 2.\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a\nself-cycle.\nVisually, the graph looks like the following:\n\n       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/", "short_description": "Clone an undirected graph. Each node in the graph contains a label and a list", "full": "Clone an undirected graph. Each node in the graph contains a label and a list\nof its neighbors.\n\n\nOJ's undirected graph serialization:\nNodes are labeled uniquely.\n\nWe use # as a separator for each node, and , as a separator for node label and\neach neighbor of the node.\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\n\nThe graph has a total of three nodes, and therefore contains three parts as\nseparated by #.\n\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\nSecond node is labeled as 1. Connect node 1 to node 2.\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a\nself-cycle.\nVisually, the graph looks like the following:\n\n       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "classes": {"UndirectedGraphNode": {"doc": {"long_description": "nodes (initially empty).", "short_description": "A node in an undirected graph. Contains a label and a list of neighbouring", "full": "A node in an undirected graph. Contains a label and a list of neighbouring\nnodes (initially empty)."}, "min_max_lineno": {"min_lineno": 32, "max_lineno": 53}, "methods": {"__init__": {"args": ["self", "label"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 41}, "source_code": "def __init__(self, label):\n    self.label = label\n    self.neighbors = []"}, "shallow_copy": {"doc": {"short_description": "Return a shallow copy of this node (ignoring any neighbors)"}, "args": ["self"], "returns": ["UndirectedGraphNode(self.label)"], "min_max_lineno": {"min_lineno": 42, "max_lineno": 47}, "source_code": "def shallow_copy(self):\n    \"\"\"\n        Return a shallow copy of this node (ignoring any neighbors)\n        \"\"\"\n    return UndirectedGraphNode(self.label)"}, "add_neighbor": {"doc": {"short_description": "Adds a new neighbor"}, "args": ["self", "node"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 53}, "calls": ["clone_graph.UndirectedGraphNode.neighbors.append"], "source_code": "def add_neighbor(self, node):\n    \"\"\"\n        Adds a new neighbor\n        \"\"\"\n    self.neighbors.append(node)"}}}}, "functions": {"clone_graph1": {"doc": {"short_description": "Returns a new graph as seen from the given node using a breadth first search (BFS)."}, "args": ["node"], "returns": ["node_copy", "None"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 75}, "calls": ["queue.popleft.shallow_copy", "collections.deque", "collections.deque.popleft", "neighbor.shallow_copy", "dic[].add_neighbor", "collections.deque.append"], "store_vars_calls": {"node_copy": "node.shallow_copy", "queue": "collections.deque", "node": "queue.popleft", "neighbor_copy": "neighbor.shallow_copy"}, "source_code": "def clone_graph1(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using a breadth first search (BFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    queue = collections.deque([node])\n    while queue:\n        node = queue.popleft()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                queue.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy"}, "clone_graph2": {"doc": {"short_description": "Returns a new graph as seen from the given node using an iterative depth first search (DFS)."}, "args": ["node"], "returns": ["node_copy", "None"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 97}, "calls": ["stack.pop.shallow_copy", "stack.pop", "neighbor.shallow_copy", "dic[].add_neighbor", "stack.append"], "store_vars_calls": {"node_copy": "node.shallow_copy", "node": "stack.pop", "neighbor_copy": "neighbor.shallow_copy"}, "source_code": "def clone_graph2(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using an iterative depth first search (DFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                stack.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy"}, "clone_graph": {"doc": {"short_description": "Returns a new graph as seen from the given node using a recursive depth first search (DFS)."}, "args": ["node"], "returns": ["node_copy", "None"], "min_max_lineno": {"min_lineno": 99, "max_lineno": 109}, "calls": ["node.shallow_copy", "clone_graph.dfs"], "store_vars_calls": {"node_copy": "node.shallow_copy"}, "source_code": "def clone_graph(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using a recursive depth first search (DFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    dfs(node, dic)\n    return node_copy"}, "dfs": {"doc": {"long_description": "the dictionary, keyed by the original nodes.", "short_description": "Clones a graph using a recursive depth first search. Stores the clones in"}, "args": ["node", "dic"], "min_max_lineno": {"min_lineno": 111, "max_lineno": 124}, "calls": ["neighbor.shallow_copy", "dic[].add_neighbor", "clone_graph.dfs"], "store_vars_calls": {"neighbor_copy": "neighbor.shallow_copy"}, "source_code": "def dfs(node, dic):\n    \"\"\"\n    Clones a graph using a recursive depth first search. Stores the clones in\n    the dictionary, keyed by the original nodes.\n    \"\"\"\n    for neighbor in node.neighbors:\n        if neighbor not in dic:\n            neighbor_copy = neighbor.shallow_copy()\n            dic[neighbor] = neighbor_copy\n            dic[node].add_neighbor(neighbor_copy)\n            dfs(neighbor, dic)\n        else:\n            dic[node].add_neighbor(dic[neighbor])"}}, "is_test": false}