{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/graph/maximum_flow_dfs.py", "fileNameBase": "maximum_flow_dfs", "extension": "py", "doc": {"long_description": "it will give you a maximum flow.\nThis version use DFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23", "short_description": "Given a n*n adjacency array.", "full": "Given a n*n adjacency array.\nit will give you a maximum flow.\nThis version use DFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23"}}, "dependencies": [{"import": "copy", "type": "external", "type_element": "module"}, {"import": "math", "type": "external", "type_element": "module"}], "functions": {"maximum_flow_dfs": {"doc": {"short_description": "Get the maximum flow through a graph using a depth first search"}, "args": ["adjacency_matrix"], "returns": ["total"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 88}, "calls": ["copy.deepcopy", "stack.append", "len", "stack.pop", "range"], "store_vars_calls": {"new_array": "copy.deepcopy", "src": "stack.pop"}, "source_code": "def maximum_flow_dfs(adjacency_matrix):\n    \"\"\"\n    Get the maximum flow through a graph using a depth first search\n    \"\"\"\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        stack = []\n        visited[0] = 1\n        stack.append(0)\n        while len(stack) > 0:\n            src = stack.pop()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    stack.append(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min > new_array[path[tmp]][tmp]:\n                min = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min\n            tmp = path[tmp]\n        total = total + min\n    return total"}}, "is_test": false}