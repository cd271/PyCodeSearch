{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/heap/k_closest_points.py", "fileNameBase": "k_closest_points", "extension": "py", "doc": {"long_description": "Idea: Maintain a max heap of k elements.\nWe can iterate through all points.\nIf a point p has a smaller distance to the origin than the top element of a\nheap, we add point p to the heap and remove the top element.\nAfter iterating through all points, our heap contains the k closest points to\nthe origin.", "short_description": "Given a list of points, find the k closest to the origin.", "full": "Given a list of points, find the k closest to the origin.\n\nIdea: Maintain a max heap of k elements.\nWe can iterate through all points.\nIf a point p has a smaller distance to the origin than the top element of a\nheap, we add point p to the heap and remove the top element.\nAfter iterating through all points, our heap contains the k closest points to\nthe origin."}}, "dependencies": [{"from_module": "heapq", "import": "heapify", "type": "external", "type_element": "module"}, {"from_module": "heapq", "import": "heappushpop", "type": "external", "type_element": "module"}], "functions": {"k_closest": {"doc": {"long_description": "Python does not support a max heap; thus we can use the default min heap\nwhere the keys (distance) are negated.", "short_description": "Initialize max heap with first k points."}, "args": ["points", "k", "origin"], "returns": ["[point for (nd, point) in heap]"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 44}, "calls": ["heapq.heapify", "k_closest_points.distance", "heapq.heappushpop"], "store_vars_calls": {"dist": "distance"}, "source_code": "def k_closest(points, k, origin=(0, 0)):\n    \"\"\"Initialize max heap with first k points.\n    Python does not support a max heap; thus we can use the default min heap\n    where the keys (distance) are negated.\n    \"\"\"\n    heap = [(-distance(p, origin), p) for p in points[:k]]\n    heapify(heap)\n    '\\n    For every point p in points[k:],\\n    check if p is smaller than the root of the max heap;\\n    if it is, add p to heap and remove root. Reheapify.\\n    '\n    for point in points[k:]:\n        dist = distance(point, origin)\n        heappushpop(heap, (-dist, point))\n        'Same as:\\n            if d < -heap[0][0]:\\n                heappush(heap, (-d,p))\\n                heappop(heap)\\n\\n        Note: heappushpop is more efficient than separate push and pop calls.\\n        Each heappushpop call takes O(logk) time.\\n        '\n    return [point for (nd, point) in heap]"}, "distance": {"doc": {"short_description": "Calculates the distance for a point from origo"}, "args": ["point", "origin"], "returns": ["(point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 49}, "source_code": "def distance(point, origin=(0, 0)):\n    \"\"\" Calculates the distance for a point from origo\"\"\"\n    return (point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2"}}, "is_test": false}