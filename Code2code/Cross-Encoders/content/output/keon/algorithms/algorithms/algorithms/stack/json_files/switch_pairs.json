{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/stack/switch_pairs.py", "fileNameBase": "switch_pairs", "extension": "py", "doc": {"long_description": "switches successive pairs of numbers starting at the bottom of the stack.\n\nFor example, if the stack initially stores these values:\nbottom [3, 8, 17, 9, 1, 10] top\nYour function should switch the first pair (3, 8),\nthe second pair (17, 9), ...:\nbottom [8, 3, 9, 17, 10, 1] top\n\nif there are an odd number of values in the stack, the value at the top of the\nstack is not moved: For example:\nbottom [3, 8, 17, 9, 1] top\nIt would again switch pairs of values, but the value at the\ntop of the stack (1)\nwould not be moved\nbottom [8, 3, 9, 17, 1] top\n\nNote: There are 2 solutions:\nfirst_switch_pairs: it uses a single stack as auxiliary storage\nsecond_switch_pairs: it uses a single queue as auxiliary storage", "short_description": "Given a stack, switch_pairs function takes a stack as a parameter and that", "full": "Given a stack, switch_pairs function takes a stack as a parameter and that\nswitches successive pairs of numbers starting at the bottom of the stack.\n\nFor example, if the stack initially stores these values:\nbottom [3, 8, 17, 9, 1, 10] top\nYour function should switch the first pair (3, 8),\nthe second pair (17, 9), ...:\nbottom [8, 3, 9, 17, 10, 1] top\n\nif there are an odd number of values in the stack, the value at the top of the\nstack is not moved: For example:\nbottom [3, 8, 17, 9, 1] top\nIt would again switch pairs of values, but the value at the\ntop of the stack (1)\nwould not be moved\nbottom [8, 3, 9, 17, 1] top\n\nNote: There are 2 solutions:\nfirst_switch_pairs: it uses a single stack as auxiliary storage\nsecond_switch_pairs: it uses a single queue as auxiliary storage"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"first_switch_pairs": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 41}, "calls": ["range", "len", "storage_stack.append", "storage_stack.pop", "stack.append", "stack.pop"], "store_vars_calls": {"first": "storage_stack.pop", "second": "storage_stack.pop"}, "source_code": "def first_switch_pairs(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        if len(storage_stack) == 0:\n            break\n        first = storage_stack.pop()\n        if len(storage_stack) == 0:\n            stack.append(first)\n            break\n        second = storage_stack.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack"}, "second_switch_pairs": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 67}, "calls": ["collections.deque", "range", "len", "collections.deque.append", "stack.append", "collections.deque.pop", "stack.pop"], "store_vars_calls": {"q": "collections.deque", "first": "q.pop", "second": "q.pop"}, "source_code": "def second_switch_pairs(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        if len(q) == 0:\n            break\n        first = q.pop()\n        if len(q) == 0:\n            stack.append(first)\n            break\n        second = q.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack"}}, "is_test": false}