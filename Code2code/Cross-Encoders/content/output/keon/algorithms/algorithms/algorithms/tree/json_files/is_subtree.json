{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/tree/is_subtree.py", "fileNameBase": "is_subtree", "extension": "py", "doc": {"long_description": "A subtree of a tree t is a tree consisting of a node in t and\nall of its descendants in t.\n\nExample 1:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n\nGiven t:\n\n   4\n  /  1   2\nReturn true, because t is a subtree of s.\n\nExample 2:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n    /\n   0\n\nGiven t:\n\n     3\n    /\n   4\n  /  1   2\nReturn false, because even though t is part of s,\nit does not contain all descendants of t.\n\nFollow up:\nWhat if one tree is significantly lager than the other?", "short_description": "Given two binary trees s and t, check if t is a subtree of s.", "full": "Given two binary trees s and t, check if t is a subtree of s.\nA subtree of a tree t is a tree consisting of a node in t and\nall of its descendants in t.\n\nExample 1:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n\nGiven t:\n\n   4\n  /  1   2\nReturn true, because t is a subtree of s.\n\nExample 2:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n    /\n   0\n\nGiven t:\n\n     3\n    /\n   4\n  /  1   2\nReturn false, because even though t is part of s,\nit does not contain all descendants of t.\n\nFollow up:\nWhat if one tree is significantly lager than the other?"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"is_subtree": {"args": ["big", "small"], "returns": ["flag"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 64}, "calls": ["collections.deque", "collections.deque.append", "collections.deque.popleft", "is_subtree.comp"], "store_vars_calls": {"queue": "collections.deque", "node": "queue.popleft", "flag": "comp"}, "source_code": "def is_subtree(big, small):\n    flag = False\n    queue = collections.deque()\n    queue.append(big)\n    while queue:\n        node = queue.popleft()\n        if node.val == small.val:\n            flag = comp(node, small)\n            break\n        else:\n            queue.append(node.left)\n            queue.append(node.right)\n    return flag"}, "comp": {"args": ["p", "q"], "returns": ["False", "True", "p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right)"], "min_max_lineno": {"min_lineno": 66, "max_lineno": 72}, "calls": ["is_subtree.comp"], "source_code": "def comp(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None and q is not None:\n        return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right)\n    return False"}}, "is_test": false}