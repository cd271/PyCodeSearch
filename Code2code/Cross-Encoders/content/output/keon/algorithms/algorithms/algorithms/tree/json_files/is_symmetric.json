{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/algorithms/tree/is_symmetric.py", "fileNameBase": "is_symmetric", "extension": "py", "doc": {"long_description": "itself (ie, symmetric around its center).\n\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n    1\n   /   2   2\n / \\ / 3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   /   2   2\n   \\      3    3\nNote:\nBonus points if you could solve it both recursively and iteratively.", "short_description": "Given a binary tree, check whether it is a mirror of", "full": "Given a binary tree, check whether it is a mirror of\nitself (ie, symmetric around its center).\n\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n    1\n   /   2   2\n / \\ / 3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   /   2   2\n   \\      3    3\nNote:\nBonus points if you could solve it both recursively and iteratively."}}, "functions": {"is_symmetric": {"args": ["root"], "returns": ["helper(root.left, root.right)", "True"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 27}, "calls": ["is_symmetric.helper"], "source_code": "def is_symmetric(root):\n    if root is None:\n        return True\n    return helper(root.left, root.right)"}, "helper": {"args": ["p", "q"], "returns": ["helper(p.left, q.right) and helper(p.right, q.left)", "True", "False"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 35}, "calls": ["is_symmetric.helper"], "source_code": "def helper(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None or q is not None or q.val != p.val:\n        return False\n    return helper(p.left, q.right) and helper(p.right, q.left)"}, "is_symmetric_iterative": {"args": ["root"], "returns": ["True", "True", "False", "False"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 53}, "calls": ["stack.pop", "stack.append"], "source_code": "def is_symmetric_iterative(root):\n    if root is None:\n        return True\n    stack = [[root.left, root.right]]\n    while stack:\n        (left, right) = stack.pop()\n        if left is None and right is None:\n            continue\n        if left is None or right is None:\n            return False\n        if left.val == right.val:\n            stack.append([left.left, right.right])\n            stack.append([left.right, right.left])\n        else:\n            return False\n    return True"}}, "is_test": false}