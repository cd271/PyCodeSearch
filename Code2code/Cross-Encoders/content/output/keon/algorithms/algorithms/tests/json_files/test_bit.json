{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/tests/test_bit.py", "fileNameBase": "test_bit", "extension": "py"}, "dependencies": [{"from_module": "algorithms.bit", "import": "add_bitwise_operator", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "count_ones_iter", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "count_ones_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "count_flips_to_convert", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "find_missing_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "find_missing_number2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "flip_bit_longest_seq", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "is_power_of_two", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "reverse_bits", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "single_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "single_number2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "single_number3", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "subsets", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "get_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "set_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "clear_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "update_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "int_to_bytes_big_endian", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "int_to_bytes_little_endian", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "bytes_big_endian_to_int", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "bytes_little_endian_to_int", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "swap_pair", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "find_difference", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "has_alternative_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "has_alternative_bit_fast", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "insert_one_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "insert_mult_bits", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "remove_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "binary_gap", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}, {"import": "random", "type": "external", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 271}, "methods": {"setUp": {"doc": {"short_description": "Initialize seed."}, "args": ["self"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 33}, "calls": ["random.seed"], "source_code": "def setUp(self):\n    \"\"\"Initialize seed.\"\"\"\n    random.seed('test')"}, "test_add_bitwise_operator": {"args": ["self"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 39}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.add_bitwise_operator"], "source_code": "def test_add_bitwise_operator(self):\n    self.assertEqual(5432 + 97823, add_bitwise_operator(5432, 97823))\n    self.assertEqual(0, add_bitwise_operator(0, 0))\n    self.assertEqual(10, add_bitwise_operator(10, 0))\n    self.assertEqual(10, add_bitwise_operator(0, 10))"}, "test_count_ones_recur": {"args": ["self"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 53}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.count_ones_recur"], "source_code": "def test_count_ones_recur(self):\n    self.assertEqual(1, count_ones_recur(8))\n    self.assertEqual(5, count_ones_recur(109))\n    self.assertEqual(6, count_ones_recur(63))\n    self.assertEqual(0, count_ones_recur(0))"}, "test_count_ones_iter": {"args": ["self"], "min_max_lineno": {"min_lineno": 54, "max_lineno": 67}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.count_ones_iter"], "source_code": "def test_count_ones_iter(self):\n    self.assertEqual(1, count_ones_iter(8))\n    self.assertEqual(5, count_ones_iter(109))\n    self.assertEqual(6, count_ones_iter(63))\n    self.assertEqual(0, count_ones_iter(0))"}, "test_count_flips_to_convert": {"args": ["self"], "min_max_lineno": {"min_lineno": 68, "max_lineno": 77}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.count_flips_to_convert"], "source_code": "def test_count_flips_to_convert(self):\n    self.assertEqual(2, count_flips_to_convert(29, 15))\n    self.assertEqual(8, count_flips_to_convert(45, 987))\n    self.assertEqual(0, count_flips_to_convert(34, 34))\n    self.assertEqual(4, count_flips_to_convert(34, 53))"}, "test_find_missing_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 78, "max_lineno": 87}, "calls": ["test_bit.TestSuite.assertEqual", "random.shuffle", "algorithms.bit.find_missing_number", "range"], "source_code": "def test_find_missing_number(self):\n    self.assertEqual(7, find_missing_number([4, 1, 3, 0, 6, 5, 2]))\n    self.assertEqual(0, find_missing_number([1]))\n    self.assertEqual(1, find_missing_number([0]))\n    nums = [i for i in range(100000) if i != 12345]\n    random.shuffle(nums)\n    self.assertEqual(12345, find_missing_number(nums))"}, "test_find_missing_number2": {"args": ["self"], "min_max_lineno": {"min_lineno": 88, "max_lineno": 97}, "calls": ["test_bit.TestSuite.assertEqual", "random.shuffle", "algorithms.bit.find_missing_number2", "range"], "source_code": "def test_find_missing_number2(self):\n    self.assertEqual(7, find_missing_number2([4, 1, 3, 0, 6, 5, 2]))\n    self.assertEqual(0, find_missing_number2([1]))\n    self.assertEqual(1, find_missing_number2([0]))\n    nums = [i for i in range(100000) if i != 12345]\n    random.shuffle(nums)\n    self.assertEqual(12345, find_missing_number2(nums))"}, "test_flip_bit_longest_seq": {"args": ["self"], "min_max_lineno": {"min_lineno": 98, "max_lineno": 107}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.flip_bit_longest_seq"], "source_code": "def test_flip_bit_longest_seq(self):\n    self.assertEqual(8, flip_bit_longest_seq(1775))\n    self.assertEqual(3, flip_bit_longest_seq(5))\n    self.assertEqual(4, flip_bit_longest_seq(71))\n    self.assertEqual(1, flip_bit_longest_seq(0))"}, "test_is_power_of_two": {"args": ["self"], "min_max_lineno": {"min_lineno": 108, "max_lineno": 115}, "calls": ["test_bit.TestSuite.assertTrue", "test_bit.TestSuite.assertFalse", "algorithms.bit.is_power_of_two"], "source_code": "def test_is_power_of_two(self):\n    self.assertTrue(is_power_of_two(64))\n    self.assertFalse(is_power_of_two(91))\n    self.assertTrue(is_power_of_two(2 ** 1001))\n    self.assertTrue(is_power_of_two(1))\n    self.assertFalse(is_power_of_two(0))"}, "test_reverse_bits": {"args": ["self"], "min_max_lineno": {"min_lineno": 116, "max_lineno": 127}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.reverse_bits"], "source_code": "def test_reverse_bits(self):\n    self.assertEqual(43261596, reverse_bits(964176192))\n    self.assertEqual(964176192, reverse_bits(43261596))\n    self.assertEqual(1, reverse_bits(2147483648))\n    self.assertEqual(0, reverse_bits(0))\n    self.assertEqual(2 ** 32 - 1, reverse_bits(2 ** 32 - 1))"}, "test_single_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 128, "max_lineno": 142}, "calls": ["random.seed", "test_bit.TestSuite.assertEqual", "random.randint", "nums.append", "random.shuffle", "algorithms.bit.single_number", "range"], "store_vars_calls": {"single": "random.randint"}, "source_code": "def test_single_number(self):\n    random.seed('test')\n    self.assertEqual(0, single_number([1, 0, 2, 1, 2, 3, 3]))\n    self.assertEqual(101, single_number([101]))\n    single = random.randint(1, 100000)\n    nums = [random.randint(1, 100000) for _ in range(1000)]\n    nums *= 2\n    nums.append(single)\n    random.shuffle(nums)\n    self.assertEqual(single, single_number(nums))"}, "test_single_number2": {"args": ["self"], "min_max_lineno": {"min_lineno": 143, "max_lineno": 152}, "calls": ["test_bit.TestSuite.assertEqual", "random.randint", "nums.append", "random.shuffle", "algorithms.bit.single_number2", "range"], "store_vars_calls": {"single": "random.randint"}, "source_code": "def test_single_number2(self):\n    self.assertEqual(3, single_number2([4, 2, 3, 2, 1, 1, 4, 2, 4, 1]))\n    single = random.randint(1, 100000)\n    nums = [random.randint(1, 100000) for _ in range(1000)]\n    nums *= 3\n    nums.append(single)\n    random.shuffle(nums)\n    self.assertEqual(single, single_number2(nums))"}, "test_single_number3": {"args": ["self"], "min_max_lineno": {"min_lineno": 153, "max_lineno": 158}, "calls": ["test_bit.TestSuite.assertEqual", "sorted", "algorithms.bit.single_number3"], "source_code": "def test_single_number3(self):\n    self.assertEqual(sorted([2, 5]), sorted(single_number3([2, 1, 5, 6, 6, 1])))\n    self.assertEqual(sorted([4, 3]), sorted(single_number3([9, 9, 4, 3])))"}, "test_subsets": {"args": ["self"], "min_max_lineno": {"min_lineno": 159, "max_lineno": 172}, "calls": ["test_bit.TestSuite.assertSetEqual", "algorithms.bit.subsets"], "source_code": "def test_subsets(self):\n    self.assertSetEqual(subsets([1, 2, 3]), {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)})\n    self.assertSetEqual(subsets([10, 20, 30, 40]), {(10, 40), (10, 20, 40), (10, 30), (10, 20, 30, 40), (40,), (10, 30, 40), (30,), (20, 30), (30, 40), (10,), (), (10, 20), (20, 40), (20, 30, 40), (10, 20, 30), (20,)})"}, "test_get_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 173, "max_lineno": 177}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.get_bit"], "source_code": "def test_get_bit(self):\n    self.assertEqual(1, get_bit(22, 2))\n    self.assertEqual(0, get_bit(22, 3))"}, "test_set_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 178, "max_lineno": 181}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.set_bit"], "source_code": "def test_set_bit(self):\n    self.assertEqual(30, set_bit(22, 3))"}, "test_clear_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 182, "max_lineno": 185}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.clear_bit"], "source_code": "def test_clear_bit(self):\n    self.assertEqual(18, clear_bit(22, 2))"}, "test_update_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 186, "max_lineno": 193}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.update_bit"], "source_code": "def test_update_bit(self):\n    self.assertEqual(30, update_bit(22, 3, 1))\n    self.assertEqual(18, update_bit(22, 2, 0))"}, "test_int_to_bytes_big_endian": {"args": ["self"], "min_max_lineno": {"min_lineno": 194, "max_lineno": 196}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.int_to_bytes_big_endian"], "source_code": "def test_int_to_bytes_big_endian(self):\n    self.assertEqual(b'\\x11', int_to_bytes_big_endian(17))"}, "test_int_to_bytes_little_endian": {"args": ["self"], "min_max_lineno": {"min_lineno": 197, "max_lineno": 199}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.int_to_bytes_little_endian"], "source_code": "def test_int_to_bytes_little_endian(self):\n    self.assertEqual(b'\\x11', int_to_bytes_little_endian(17))"}, "test_bytes_big_endian_to_int": {"args": ["self"], "min_max_lineno": {"min_lineno": 200, "max_lineno": 202}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.bytes_big_endian_to_int"], "source_code": "def test_bytes_big_endian_to_int(self):\n    self.assertEqual(17, bytes_big_endian_to_int(b'\\x11'))"}, "test_bytes_little_endian_to_int": {"args": ["self"], "min_max_lineno": {"min_lineno": 203, "max_lineno": 205}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.bytes_little_endian_to_int"], "source_code": "def test_bytes_little_endian_to_int(self):\n    self.assertEqual(17, bytes_little_endian_to_int(b'\\x11'))"}, "test_swap_pair": {"args": ["self"], "min_max_lineno": {"min_lineno": 206, "max_lineno": 211}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.swap_pair"], "source_code": "def test_swap_pair(self):\n    self.assertEqual(41, swap_pair(22))\n    self.assertEqual(5, swap_pair(10))"}, "test_find_difference": {"args": ["self"], "min_max_lineno": {"min_lineno": 212, "max_lineno": 214}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.find_difference"], "source_code": "def test_find_difference(self):\n    self.assertEqual('e', find_difference('abcd', 'abecd'))"}, "test_has_alternative_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 215, "max_lineno": 220}, "calls": ["test_bit.TestSuite.assertTrue", "test_bit.TestSuite.assertFalse", "algorithms.bit.has_alternative_bit"], "source_code": "def test_has_alternative_bit(self):\n    self.assertTrue(has_alternative_bit(5))\n    self.assertFalse(has_alternative_bit(7))\n    self.assertFalse(has_alternative_bit(11))\n    self.assertTrue(has_alternative_bit(10))"}, "test_has_alternative_bit_fast": {"args": ["self"], "min_max_lineno": {"min_lineno": 221, "max_lineno": 226}, "calls": ["test_bit.TestSuite.assertTrue", "test_bit.TestSuite.assertFalse", "algorithms.bit.has_alternative_bit_fast"], "source_code": "def test_has_alternative_bit_fast(self):\n    self.assertTrue(has_alternative_bit_fast(5))\n    self.assertFalse(has_alternative_bit_fast(7))\n    self.assertFalse(has_alternative_bit_fast(11))\n    self.assertTrue(has_alternative_bit_fast(10))"}, "test_insert_one_bit": {"doc": {"long_description": "insert_one_bit(num, 1, 2): 101101 (45)\ninsert_one_bit(num, 0 ,2): 101001 (41)\ninsert_one_bit(num, 1, 5): 110101 (53)\ninsert_one_bit(num, 1, 0): 101010 (42)", "short_description": "Input: num = 10101 (21)"}, "args": ["self"], "min_max_lineno": {"min_lineno": 227, "max_lineno": 239}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.insert_one_bit"], "source_code": "def test_insert_one_bit(self):\n    \"\"\"\n        Input: num = 10101 (21)\n        insert_one_bit(num, 1, 2): 101101 (45)\n        insert_one_bit(num, 0 ,2): 101001 (41)\n        insert_one_bit(num, 1, 5): 110101 (53)\n        insert_one_bit(num, 1, 0): 101010 (42)\n        \"\"\"\n    self.assertEqual(45, insert_one_bit(21, 1, 2))\n    self.assertEqual(41, insert_one_bit(21, 0, 2))\n    self.assertEqual(53, insert_one_bit(21, 1, 5))\n    self.assertEqual(43, insert_one_bit(21, 1, 0))"}, "test_insert_mult_bits": {"doc": {"long_description": "insert_mult_bits(num, 7, 3, 1): 101111 (47)\ninsert_mult_bits(num, 7, 3, 0): 101111 (47)\ninsert_mult_bits(num, 7, 3, 3): 111101 (61)", "short_description": "Input: num = 101 (5)"}, "args": ["self"], "min_max_lineno": {"min_lineno": 240, "max_lineno": 250}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.insert_mult_bits"], "source_code": "def test_insert_mult_bits(self):\n    \"\"\"\n        Input: num = 101 (5)\n        insert_mult_bits(num, 7, 3, 1): 101111 (47)\n        insert_mult_bits(num, 7, 3, 0): 101111 (47)\n        insert_mult_bits(num, 7, 3, 3): 111101 (61)\n        \"\"\"\n    self.assertEqual(47, insert_mult_bits(5, 7, 3, 1))\n    self.assertEqual(47, insert_mult_bits(5, 7, 3, 0))\n    self.assertEqual(61, insert_mult_bits(5, 7, 3, 3))"}, "test_remove_bit": {"doc": {"long_description": "remove_bit(num, 2): output = 1001 (9)\nremove_bit(num, 4): output = 101 (5)\nremove_bit(num, 0): output = 1010 (10)", "short_description": "Input: num = 10101 (21)"}, "args": ["self"], "min_max_lineno": {"min_lineno": 251, "max_lineno": 261}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.remove_bit"], "source_code": "def test_remove_bit(self):\n    \"\"\"\n        Input: num = 10101 (21)\n        remove_bit(num, 2): output = 1001 (9)\n        remove_bit(num, 4): output = 101 (5)\n        remove_bit(num, 0): output = 1010 (10)\n        \"\"\"\n    self.assertEqual(9, remove_bit(21, 2))\n    self.assertEqual(5, remove_bit(21, 4))\n    self.assertEqual(10, remove_bit(21, 0))"}, "test_binary_gap": {"args": ["self"], "min_max_lineno": {"min_lineno": 262, "max_lineno": 271}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.binary_gap"], "source_code": "def test_binary_gap(self):\n    self.assertEqual(2, binary_gap(22))\n    self.assertEqual(1, binary_gap(6))\n    self.assertEqual(0, binary_gap(8))\n    self.assertEqual(4, binary_gap(145))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_bit.unittest.main", "type": "script"}, "is_test": true}