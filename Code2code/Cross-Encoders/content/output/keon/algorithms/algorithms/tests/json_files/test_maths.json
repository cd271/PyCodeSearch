{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/tests/test_maths.py", "fileNameBase": "test_maths", "extension": "py"}, "dependencies": [{"from_module": "algorithms.maths", "import": "power", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "power_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "int_to_base", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "base_to_int", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "decimal_to_binary_ip", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "euler_totient", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "extended_gcd", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "factorial", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "factorial_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "gcd", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "lcm", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "trailing_zero", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "gcd_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "gen_strobogrammatic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "strobogrammatic_in_range", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "is_strobogrammatic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "is_strobogrammatic2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "modular_inverse", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "modular_exponential", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "find_next_square", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "find_next_square2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "prime_check", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "get_primes", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "pythagoras", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "is_prime", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "encrypt", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "decrypt", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "combination", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "combination_memo", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "hailstone", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "cosine_similarity", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "magic_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "find_order", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "find_primitive_root", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "num_digits", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "diffie_hellman_key_exchange", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "krishnamurthy_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "num_perfect_squares", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "chinese_remainder_theorem", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "fft", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}, {"import": "pytest", "type": "external", "type_element": "module"}], "classes": {"TestPower": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 55}, "methods": {"test_power": {"args": ["self"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 49}, "calls": ["test_maths.TestPower.assertEqual", "algorithms.maths.power"], "source_code": "def test_power(self):\n    self.assertEqual(8, power(2, 3))\n    self.assertEqual(1, power(5, 0))\n    self.assertEqual(0, power(10, 3, 5))\n    self.assertEqual(280380, power(2265, 1664, 465465))"}, "test_power_recur": {"args": ["self"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 55}, "calls": ["test_maths.TestPower.assertEqual", "algorithms.maths.power_recur"], "source_code": "def test_power_recur(self):\n    self.assertEqual(8, power_recur(2, 3))\n    self.assertEqual(1, power_recur(5, 0))\n    self.assertEqual(0, power_recur(10, 3, 5))\n    self.assertEqual(280380, power_recur(2265, 1664, 465465))"}}}, "TestBaseConversion": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 74}, "methods": {"test_int_to_base": {"args": ["self"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 69}, "calls": ["test_maths.TestBaseConversion.assertEqual", "algorithms.maths.int_to_base"], "source_code": "def test_int_to_base(self):\n    self.assertEqual('101', int_to_base(5, 2))\n    self.assertEqual('0', int_to_base(0, 2))\n    self.assertEqual('FF', int_to_base(255, 16))"}, "test_base_to_int": {"args": ["self"], "min_max_lineno": {"min_lineno": 70, "max_lineno": 74}, "calls": ["test_maths.TestBaseConversion.assertEqual", "algorithms.maths.base_to_int"], "source_code": "def test_base_to_int(self):\n    self.assertEqual(5, base_to_int('101', 2))\n    self.assertEqual(0, base_to_int('0', 2))\n    self.assertEqual(255, base_to_int('FF', 16))"}}}, "TestDecimalToBinaryIP": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 76, "max_lineno": 91}, "methods": {"test_decimal_to_binary_ip": {"args": ["self"], "min_max_lineno": {"min_lineno": 84, "max_lineno": 91}, "calls": ["test_maths.TestDecimalToBinaryIP.assertEqual", "algorithms.maths.decimal_to_binary_ip"], "source_code": "def test_decimal_to_binary_ip(self):\n    self.assertEqual('00000000.00000000.00000000.00000000', decimal_to_binary_ip('0.0.0.0'))\n    self.assertEqual('11111111.11111111.11111111.11111111', decimal_to_binary_ip('255.255.255.255'))\n    self.assertEqual('11000000.10101000.00000000.00000001', decimal_to_binary_ip('192.168.0.1'))"}}}, "TestEulerTotient": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 93, "max_lineno": 106}, "methods": {"test_euler_totient": {"args": ["self"], "min_max_lineno": {"min_lineno": 101, "max_lineno": 106}, "calls": ["test_maths.TestEulerTotient.assertEqual", "algorithms.maths.euler_totient"], "source_code": "def test_euler_totient(self):\n    self.assertEqual(4, euler_totient(8))\n    self.assertEqual(12, euler_totient(21))\n    self.assertEqual(311040, euler_totient(674614))\n    self.assertEqual(2354352, euler_totient(3435145))"}}}, "TestExtendedGcd": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 108, "max_lineno": 119}, "methods": {"test_extended_gcd": {"args": ["self"], "min_max_lineno": {"min_lineno": 116, "max_lineno": 119}, "calls": ["test_maths.TestExtendedGcd.assertEqual", "algorithms.maths.extended_gcd"], "source_code": "def test_extended_gcd(self):\n    self.assertEqual((0, 1, 2), extended_gcd(8, 2))\n    self.assertEqual((0, 1, 17), extended_gcd(13, 17))"}}}, "TestGcd": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 121, "max_lineno": 175}, "methods": {"test_gcd": {"args": ["self"], "min_max_lineno": {"min_lineno": 129, "max_lineno": 132}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.gcd"], "source_code": "def test_gcd(self):\n    self.assertEqual(4, gcd(8, 12))\n    self.assertEqual(1, gcd(13, 17))"}, "test_gcd_non_integer_input": {"args": ["self"], "min_max_lineno": {"min_lineno": 133, "max_lineno": 139}, "calls": ["pytest.raises", "algorithms.maths.gcd"], "source_code": "def test_gcd_non_integer_input(self):\n    with pytest.raises(ValueError, match='Input arguments are not integers'):\n        gcd(1.0, 5)\n        gcd(5, 6.7)\n        gcd(33.8649, 6.12312312)"}, "test_gcd_zero_input": {"args": ["self"], "min_max_lineno": {"min_lineno": 140, "max_lineno": 146}, "calls": ["pytest.raises", "algorithms.maths.gcd"], "source_code": "def test_gcd_zero_input(self):\n    with pytest.raises(ValueError, match='One or more input arguments equals zero'):\n        gcd(0, 12)\n        gcd(12, 0)\n        gcd(0, 0)"}, "test_gcd_negative_input": {"args": ["self"], "min_max_lineno": {"min_lineno": 147, "max_lineno": 151}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.gcd"], "source_code": "def test_gcd_negative_input(self):\n    self.assertEqual(1, gcd(-13, -17))\n    self.assertEqual(4, gcd(-8, 12))\n    self.assertEqual(8, gcd(24, -16))"}, "test_lcm": {"args": ["self"], "min_max_lineno": {"min_lineno": 152, "max_lineno": 155}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.lcm"], "source_code": "def test_lcm(self):\n    self.assertEqual(24, lcm(8, 12))\n    self.assertEqual(5767, lcm(73, 79))"}, "test_lcm_negative_numbers": {"args": ["self"], "min_max_lineno": {"min_lineno": 156, "max_lineno": 160}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.lcm"], "source_code": "def test_lcm_negative_numbers(self):\n    self.assertEqual(24, lcm(-8, -12))\n    self.assertEqual(5767, lcm(73, -79))\n    self.assertEqual(1, lcm(-1, 1))"}, "test_lcm_zero_input": {"args": ["self"], "min_max_lineno": {"min_lineno": 161, "max_lineno": 167}, "calls": ["pytest.raises", "algorithms.maths.lcm"], "source_code": "def test_lcm_zero_input(self):\n    with pytest.raises(ValueError, match='One or more input arguments equals zero'):\n        lcm(0, 12)\n        lcm(12, 0)\n        lcm(0, 0)"}, "test_trailing_zero": {"args": ["self"], "min_max_lineno": {"min_lineno": 168, "max_lineno": 171}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.trailing_zero"], "source_code": "def test_trailing_zero(self):\n    self.assertEqual(1, trailing_zero(34))\n    self.assertEqual(3, trailing_zero(40))"}, "test_gcd_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 172, "max_lineno": 175}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.gcd_bit", "algorithms.maths.gcd"], "source_code": "def test_gcd_bit(self):\n    self.assertEqual(4, gcd_bit(8, 12))\n    self.assertEqual(1, gcd(13, 17))"}}}, "TestGenerateStroboGrammatic": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 177, "max_lineno": 190}, "methods": {"test_gen_strobomatic": {"args": ["self"], "min_max_lineno": {"min_lineno": 185, "max_lineno": 187}, "calls": ["test_maths.TestGenerateStroboGrammatic.assertEqual", "algorithms.maths.gen_strobogrammatic"], "source_code": "def test_gen_strobomatic(self):\n    self.assertEqual(['88', '11', '96', '69'], gen_strobogrammatic(2))"}, "test_strobogrammatic_in_range": {"args": ["self"], "min_max_lineno": {"min_lineno": 188, "max_lineno": 190}, "calls": ["test_maths.TestGenerateStroboGrammatic.assertEqual", "algorithms.maths.strobogrammatic_in_range"], "source_code": "def test_strobogrammatic_in_range(self):\n    self.assertEqual(4, strobogrammatic_in_range('10', '100'))"}}}, "TestIsStrobogrammatic": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 192, "max_lineno": 207}, "methods": {"test_is_strobogrammatic": {"args": ["self"], "min_max_lineno": {"min_lineno": 200, "max_lineno": 203}, "calls": ["test_maths.TestIsStrobogrammatic.assertTrue", "test_maths.TestIsStrobogrammatic.assertFalse", "algorithms.maths.is_strobogrammatic"], "source_code": "def test_is_strobogrammatic(self):\n    self.assertTrue(is_strobogrammatic('69'))\n    self.assertFalse(is_strobogrammatic('14'))"}, "test_is_strobogrammatic2": {"args": ["self"], "min_max_lineno": {"min_lineno": 204, "max_lineno": 207}, "calls": ["test_maths.TestIsStrobogrammatic.assertTrue", "test_maths.TestIsStrobogrammatic.assertFalse", "algorithms.maths.is_strobogrammatic2"], "source_code": "def test_is_strobogrammatic2(self):\n    self.assertTrue(is_strobogrammatic2('69'))\n    self.assertFalse(is_strobogrammatic2('14'))"}}}, "TestModularInverse": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 209, "max_lineno": 224}, "methods": {"test_modular_inverse": {"args": ["self"], "min_max_lineno": {"min_lineno": 217, "max_lineno": 224}, "calls": ["test_maths.TestModularInverse.assertEqual", "test_maths.TestModularInverse.assertRaises", "algorithms.maths.modular_inverse.modular_inverse"], "source_code": "def test_modular_inverse(self):\n    self.assertEqual(1, 2 * modular_inverse.modular_inverse(2, 19) % 19)\n    self.assertEqual(1, 53 * modular_inverse.modular_inverse(53, 91) % 91)\n    self.assertEqual(1, 2 * modular_inverse.modular_inverse(2, 1000000007) % 1000000007)\n    self.assertRaises(ValueError, modular_inverse.modular_inverse, 2, 20)"}}}, "TestModularExponential": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 226, "max_lineno": 240}, "methods": {"test_modular_exponential": {"args": ["self"], "min_max_lineno": {"min_lineno": 234, "max_lineno": 240}, "calls": ["test_maths.TestModularExponential.assertEqual", "test_maths.TestModularExponential.assertRaises", "algorithms.maths.modular_exponential", "pow"], "source_code": "def test_modular_exponential(self):\n    self.assertEqual(1, modular_exponential(5, 117, 19))\n    self.assertEqual(pow(1243, 65321, 10 ** 9 + 7), modular_exponential(1243, 65321, 10 ** 9 + 7))\n    self.assertEqual(1, modular_exponential(12, 0, 78))\n    self.assertRaises(ValueError, modular_exponential, 12, -2, 455)"}}}, "TestNextPerfectSquare": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 242, "max_lineno": 257}, "methods": {"test_find_next_square": {"args": ["self"], "min_max_lineno": {"min_lineno": 250, "max_lineno": 253}, "calls": ["test_maths.TestNextPerfectSquare.assertEqual", "algorithms.maths.find_next_square"], "source_code": "def test_find_next_square(self):\n    self.assertEqual(36, find_next_square(25))\n    self.assertEqual(1, find_next_square(0))"}, "test_find_next_square2": {"args": ["self"], "min_max_lineno": {"min_lineno": 254, "max_lineno": 257}, "calls": ["test_maths.TestNextPerfectSquare.assertEqual", "algorithms.maths.find_next_square2"], "source_code": "def test_find_next_square2(self):\n    self.assertEqual(36, find_next_square2(25))\n    self.assertEqual(1, find_next_square2(0))"}}}, "TestPrimesSieveOfEratosthenes": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 259, "max_lineno": 270}, "methods": {"test_primes": {"args": ["self"], "min_max_lineno": {"min_lineno": 267, "max_lineno": 270}, "calls": ["test_maths.TestPrimesSieveOfEratosthenes.assertListEqual", "test_maths.TestPrimesSieveOfEratosthenes.assertRaises", "algorithms.maths.get_primes"], "source_code": "def test_primes(self):\n    self.assertListEqual([2, 3, 5, 7], get_primes(7))\n    self.assertRaises(ValueError, get_primes, -42)"}}}, "TestPrimeTest": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 272, "max_lineno": 290}, "methods": {"test_prime_test": {"doc": {"long_description": "Between 2 up to 100 exists 25 prime numbers!", "short_description": "checks all prime numbers between 2 up to 100."}, "args": ["self"], "min_max_lineno": {"min_lineno": 280, "max_lineno": 290}, "calls": ["range", "test_maths.TestPrimeTest.assertEqual", "algorithms.maths.prime_check"], "source_code": "def test_prime_test(self):\n    \"\"\"\n            checks all prime numbers between 2 up to 100.\n            Between 2 up to 100 exists 25 prime numbers!\n        \"\"\"\n    counter = 0\n    for i in range(2, 101):\n        if prime_check(i):\n            counter += 1\n    self.assertEqual(25, counter)"}}}, "TestPythagoras": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 292, "max_lineno": 303}, "methods": {"test_pythagoras": {"args": ["self"], "min_max_lineno": {"min_lineno": 300, "max_lineno": 303}, "calls": ["test_maths.TestPythagoras.assertEqual", "algorithms.maths.pythagoras"], "source_code": "def test_pythagoras(self):\n    self.assertEqual('Hypotenuse = 3.605551275463989', pythagoras(3, 2, '?'))"}}}, "TestRabinMiller": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 305, "max_lineno": 317}, "methods": {"test_is_prime": {"args": ["self"], "min_max_lineno": {"min_lineno": 313, "max_lineno": 317}, "calls": ["test_maths.TestRabinMiller.assertTrue", "test_maths.TestRabinMiller.assertFalse", "algorithms.maths.is_prime"], "source_code": "def test_is_prime(self):\n    self.assertTrue(is_prime(7, 2))\n    self.assertTrue(is_prime(13, 11))\n    self.assertFalse(is_prime(6, 2))"}}}, "TestRSA": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 319, "max_lineno": 329}, "methods": {"test_encrypt_decrypt": {"args": ["self"], "min_max_lineno": {"min_lineno": 327, "max_lineno": 329}, "calls": ["test_maths.TestRSA.assertEqual", "algorithms.maths.decrypt", "algorithms.maths.encrypt"], "source_code": "def test_encrypt_decrypt(self):\n    self.assertEqual(7, decrypt(encrypt(7, 23, 143), 47, 143))"}}}, "TestCombination": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 340, "max_lineno": 355}, "methods": {"test_combination": {"args": ["self"], "min_max_lineno": {"min_lineno": 348, "max_lineno": 351}, "calls": ["test_maths.TestCombination.assertEqual", "algorithms.maths.combination"], "source_code": "def test_combination(self):\n    self.assertEqual(10, combination(5, 2))\n    self.assertEqual(252, combination(10, 5))"}, "test_combination_memo": {"args": ["self"], "min_max_lineno": {"min_lineno": 352, "max_lineno": 355}, "calls": ["test_maths.TestCombination.assertEqual", "algorithms.maths.combination_memo"], "source_code": "def test_combination_memo(self):\n    self.assertEqual(10272278170, combination_memo(50, 10))\n    self.assertEqual(847660528, combination_memo(40, 10))"}}}, "TestFactorial": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 357, "max_lineno": 380}, "methods": {"test_factorial": {"args": ["self"], "min_max_lineno": {"min_lineno": 365, "max_lineno": 372}, "calls": ["test_maths.TestFactorial.assertEqual", "test_maths.TestFactorial.assertRaises", "algorithms.maths.factorial"], "source_code": "def test_factorial(self):\n    self.assertEqual(1, factorial(0))\n    self.assertEqual(120, factorial(5))\n    self.assertEqual(3628800, factorial(10))\n    self.assertEqual(637816310, factorial(34521, 10 ** 9 + 7))\n    self.assertRaises(ValueError, factorial, -42)\n    self.assertRaises(ValueError, factorial, 42, -1)"}, "test_factorial_recur": {"args": ["self"], "min_max_lineno": {"min_lineno": 373, "max_lineno": 380}, "calls": ["test_maths.TestFactorial.assertEqual", "test_maths.TestFactorial.assertRaises", "algorithms.maths.factorial_recur"], "source_code": "def test_factorial_recur(self):\n    self.assertEqual(1, factorial_recur(0))\n    self.assertEqual(120, factorial_recur(5))\n    self.assertEqual(3628800, factorial_recur(10))\n    self.assertEqual(637816310, factorial_recur(34521, 10 ** 9 + 7))\n    self.assertRaises(ValueError, factorial_recur, -42)\n    self.assertRaises(ValueError, factorial_recur, 42, -1)"}}}, "TestHailstone": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 382, "max_lineno": 393}, "methods": {"test_hailstone": {"args": ["self"], "min_max_lineno": {"min_lineno": 390, "max_lineno": 393}, "calls": ["test_maths.TestHailstone.assertEqual", "algorithms.maths.hailstone.hailstone"], "source_code": "def test_hailstone(self):\n    self.assertEqual([8, 4, 2, 1], hailstone.hailstone(8))\n    self.assertEqual([10, 5, 16, 8, 4, 2, 1], hailstone.hailstone(10))"}}}, "TestCosineSimilarity": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 395, "max_lineno": 410}, "methods": {"test_cosine_similarity": {"args": ["self"], "min_max_lineno": {"min_lineno": 403, "max_lineno": 410}, "calls": ["test_maths.TestCosineSimilarity.assertAlmostEqual", "algorithms.maths.cosine_similarity"], "source_code": "def test_cosine_similarity(self):\n    vec_a = [1, 1, 1]\n    vec_b = [-1, -1, -1]\n    vec_c = [1, 2, -1]\n    self.assertAlmostEqual(cosine_similarity(vec_a, vec_a), 1)\n    self.assertAlmostEqual(cosine_similarity(vec_a, vec_b), -1)\n    self.assertAlmostEqual(cosine_similarity(vec_a, vec_c), 0.4714045208)"}}}, "TestFindPrimitiveRoot": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 412, "max_lineno": 426}, "methods": {"test_find_primitive_root_simple": {"args": ["self"], "min_max_lineno": {"min_lineno": 420, "max_lineno": 426}, "calls": ["test_maths.TestFindPrimitiveRoot.assertListEqual", "algorithms.maths.find_primitive_root"], "source_code": "def test_find_primitive_root_simple(self):\n    self.assertListEqual([0], find_primitive_root(1))\n    self.assertListEqual([2, 3], find_primitive_root(5))\n    self.assertListEqual([], find_primitive_root(24))\n    self.assertListEqual([2, 5, 13, 15, 17, 18, 19, 20, 22, 24, 32, 35], find_primitive_root(37))"}}}, "TestFindOrder": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 428, "max_lineno": 441}, "methods": {"test_find_order_simple": {"args": ["self"], "min_max_lineno": {"min_lineno": 436, "max_lineno": 441}, "calls": ["test_maths.TestFindOrder.assertEqual", "algorithms.maths.find_order"], "source_code": "def test_find_order_simple(self):\n    self.assertEqual(1, find_order(1, 1))\n    self.assertEqual(6, find_order(3, 7))\n    self.assertEqual(-1, find_order(128, 256))\n    self.assertEqual(352, find_order(3, 353))"}}}, "TestKrishnamurthyNumber": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 443, "max_lineno": 457}, "methods": {"test_krishnamurthy_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 451, "max_lineno": 457}, "calls": ["test_maths.TestKrishnamurthyNumber.assertFalse", "test_maths.TestKrishnamurthyNumber.assertTrue", "algorithms.maths.krishnamurthy_number"], "source_code": "def test_krishnamurthy_number(self):\n    self.assertFalse(krishnamurthy_number(0))\n    self.assertTrue(krishnamurthy_number(2))\n    self.assertTrue(krishnamurthy_number(1))\n    self.assertTrue(krishnamurthy_number(145))\n    self.assertTrue(krishnamurthy_number(40585))"}}}, "TestMagicNumber": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 459, "max_lineno": 474}, "methods": {"test_magic_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 467, "max_lineno": 474}, "calls": ["test_maths.TestMagicNumber.assertTrue", "test_maths.TestMagicNumber.assertFalse", "algorithms.maths.magic_number"], "source_code": "def test_magic_number(self):\n    self.assertTrue(magic_number(50113))\n    self.assertTrue(magic_number(1234))\n    self.assertTrue(magic_number(100))\n    self.assertTrue(magic_number(199))\n    self.assertFalse(magic_number(2000))\n    self.assertFalse(magic_number(500000))"}}}, "TestDiffieHellmanKeyExchange": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 476, "max_lineno": 489}, "methods": {"test_find_order_simple": {"args": ["self"], "min_max_lineno": {"min_lineno": 484, "max_lineno": 489}, "calls": ["test_maths.TestDiffieHellmanKeyExchange.assertFalse", "test_maths.TestDiffieHellmanKeyExchange.assertTrue", "algorithms.maths.diffie_hellman_key_exchange"], "source_code": "def test_find_order_simple(self):\n    self.assertFalse(diffie_hellman_key_exchange(3, 6))\n    self.assertTrue(diffie_hellman_key_exchange(3, 353))\n    self.assertFalse(diffie_hellman_key_exchange(5, 211))\n    self.assertTrue(diffie_hellman_key_exchange(11, 971))"}}}, "TestNumberOfDigits": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 491, "max_lineno": 505}, "methods": {"test_num_digits": {"args": ["self"], "min_max_lineno": {"min_lineno": 498, "max_lineno": 505}, "calls": ["test_maths.TestNumberOfDigits.assertEqual", "algorithms.maths.num_digits"], "source_code": "def test_num_digits(self):\n    self.assertEqual(2, num_digits(12))\n    self.assertEqual(5, num_digits(99999))\n    self.assertEqual(1, num_digits(8))\n    self.assertEqual(1, num_digits(0))\n    self.assertEqual(1, num_digits(-5))\n    self.assertEqual(3, num_digits(-254))"}}}, "TestNumberOfPerfectSquares": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 508, "max_lineno": 524}, "methods": {"test_num_perfect_squares": {"args": ["self"], "min_max_lineno": {"min_lineno": 515, "max_lineno": 524}, "calls": ["test_maths.TestNumberOfPerfectSquares.assertEqual", "algorithms.maths.num_perfect_squares"], "source_code": "def test_num_perfect_squares(self):\n    self.assertEqual(4, num_perfect_squares(31))\n    self.assertEqual(3, num_perfect_squares(12))\n    self.assertEqual(2, num_perfect_squares(13))\n    self.assertEqual(2, num_perfect_squares(10))\n    self.assertEqual(4, num_perfect_squares(1500))\n    self.assertEqual(2, num_perfect_squares(1548524521))\n    self.assertEqual(3, num_perfect_squares(9999999993))\n    self.assertEqual(1, num_perfect_squares(9))"}}}, "TestChineseRemainderSolver": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 526, "max_lineno": 558}, "methods": {"test_k_three": {"args": ["self"], "min_max_lineno": {"min_lineno": 527, "max_lineno": 535}, "calls": ["test_maths.TestChineseRemainderSolver.assertEqual", "algorithms.maths.chinese_remainder_theorem.solve_chinese_remainder"], "source_code": "def test_k_three(self):\n    num = [3, 7, 10]\n    rem = [2, 3, 3]\n    self.assertEqual(chinese_remainder_theorem.solve_chinese_remainder(num, rem), 143)"}, "test_k_five": {"args": ["self"], "min_max_lineno": {"min_lineno": 536, "max_lineno": 544}, "calls": ["test_maths.TestChineseRemainderSolver.assertEqual", "algorithms.maths.chinese_remainder_theorem.solve_chinese_remainder"], "source_code": "def test_k_five(self):\n    num = [3, 5, 7, 11, 26]\n    rem = [2, 3, 2, 6, 3]\n    self.assertEqual(chinese_remainder_theorem.solve_chinese_remainder(num, rem), 3383)"}, "test_exception_non_coprime": {"args": ["self"], "min_max_lineno": {"min_lineno": 545, "max_lineno": 552}, "calls": ["test_maths.TestChineseRemainderSolver.assertRaises", "algorithms.maths.chinese_remainder_theorem.solve_chinese_remainder"], "source_code": "def test_exception_non_coprime(self):\n    num = [3, 7, 10, 14]\n    rem = [2, 3, 3, 1]\n    with self.assertRaises(Exception):\n        chinese_remainder_theorem.solve_chinese_remainder(num, rem)"}, "test_empty_lists": {"args": ["self"], "min_max_lineno": {"min_lineno": 553, "max_lineno": 558}, "calls": ["test_maths.TestChineseRemainderSolver.assertRaises", "algorithms.maths.chinese_remainder_theorem.solve_chinese_remainder"], "source_code": "def test_empty_lists(self):\n    num = []\n    rem = []\n    with self.assertRaises(Exception):\n        chinese_remainder_theorem.solve_chinese_remainder(num, rem)"}}}, "TestFFT": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 560, "max_lineno": 594}, "methods": {"test_real_numbers": {"args": ["self"], "min_max_lineno": {"min_lineno": 567, "max_lineno": 573}, "calls": ["test_maths.TestFFT.assertEqual", "float", "algorithms.maths.fft.fft", "abs"], "source_code": "def test_real_numbers(self):\n    x = [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n    y = [4.0, 2.613, 0.0, 1.082, 0.0, 1.082, 0.0, 2.613]\n    result = [float('%.3f' % abs(f)) for f in fft.fft(x)]\n    self.assertEqual(result, y)"}, "test_all_zero": {"args": ["self"], "min_max_lineno": {"min_lineno": 574, "max_lineno": 579}, "calls": ["test_maths.TestFFT.assertEqual", "float", "algorithms.maths.fft.fft", "abs"], "source_code": "def test_all_zero(self):\n    x = [0.0, 0.0, 0.0, 0.0]\n    y = [0.0, 0.0, 0.0, 0.0]\n    result = [float('%.1f' % abs(f)) for f in fft.fft(x)]\n    self.assertEqual(result, y)"}, "test_all_ones": {"args": ["self"], "min_max_lineno": {"min_lineno": 580, "max_lineno": 585}, "calls": ["test_maths.TestFFT.assertEqual", "float", "algorithms.maths.fft.fft", "abs"], "source_code": "def test_all_ones(self):\n    x = [1.0, 1.0, 1.0, 1.0]\n    y = [4.0, 0.0, 0.0, 0.0]\n    result = [float('%.1f' % abs(f)) for f in fft.fft(x)]\n    self.assertEqual(result, y)"}, "test_complex_numbers": {"args": ["self"], "min_max_lineno": {"min_lineno": 586, "max_lineno": 594}, "calls": ["test_maths.TestFFT.assertEqual", "float", "algorithms.maths.fft.fft"], "source_code": "def test_complex_numbers(self):\n    x = [2.0 + 2j, 1.0 + 3j, 3.0 + 1j, 2.0 + 2j]\n    real = [8.0, 0.0, 2.0, -2.0]\n    imag = [8.0, 2.0, -2.0, 0.0]\n    realResult = [float('%.1f' % f.real) for f in fft.fft(x)]\n    imagResult = [float('%.1f' % f.imag) for f in fft.fft(x)]\n    self.assertEqual(real, realResult)\n    self.assertEqual(imag, imagResult)"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_maths.unittest.main", "type": "script"}, "is_test": true}