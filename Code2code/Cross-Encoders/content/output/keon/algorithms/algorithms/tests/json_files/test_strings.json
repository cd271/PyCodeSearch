{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/CodeSearch/Code2code/content/keon/algorithms/tests/test_strings.py", "fileNameBase": "test_strings", "extension": "py"}, "dependencies": [{"from_module": "algorithms.strings", "import": "add_binary", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "match_symbol", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "match_symbol_1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "bracket", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "decode_string", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "delete_reoccurring_characters", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "domain_name_1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "domain_name_2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "encode", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "decode", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "group_anagrams", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "int_to_roman", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome_reverse", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome_two_pointer", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome_stack", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome_deque", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_rotated", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_rotated_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "license_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "make_sentence", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_merge_recursive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_merge_iterative", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "multiply", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_one_edit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_one_edit2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "rabin_karp", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "ultra_pythonic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "iterative", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "recursive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "pythonic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "reverse_vowel", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "reverse_words", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "roman_to_int", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_valid_coordinates_0", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "word_squares", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "convert_morse_word", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "unique_morse", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "judge_circle", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "strong_password", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "caesar_cipher", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "check_pangram", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "contain_string", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "count_binary_substring", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "repeat_string", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "text_justification", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "min_distance", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "min_distance_dp", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "longest_common_prefix_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "longest_common_prefix_v2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "longest_common_prefix_v3", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "rotate", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "rotate_alt", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "first_unique_char", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "repeat_substring", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "atbash", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "longest_palindrome", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "knuth_morris_pratt", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "panagram", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "fizzbuzz", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestAddBinary": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 63}, "methods": {"test_add_binary": {"args": ["self"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 63}, "calls": ["test_strings.TestAddBinary.assertEqual", "algorithms.strings.add_binary"], "source_code": "def test_add_binary(self):\n    self.assertEqual('100', add_binary('11', '1'))\n    self.assertEqual('101', add_binary('100', '1'))\n    self.assertEqual('10', add_binary('1', '1'))"}}}, "TestBreakingBad": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 92}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 77}, "source_code": "def setUp(self):\n    self.words = ['Amazon', 'Microsoft', 'Google']\n    self.symbols = ['i', 'Am', 'cro', 'le', 'abc']\n    self.result = ['M[i]crosoft', '[Am]azon', 'Mi[cro]soft', 'Goog[le]']"}, "test_match_symbol": {"args": ["self"], "min_max_lineno": {"min_lineno": 78, "max_lineno": 80}, "calls": ["test_strings.TestBreakingBad.assertEqual", "algorithms.strings.match_symbol"], "source_code": "def test_match_symbol(self):\n    self.assertEqual(self.result, match_symbol(self.words, self.symbols))"}, "test_match_symbol_1": {"args": ["self"], "min_max_lineno": {"min_lineno": 81, "max_lineno": 84}, "calls": ["test_strings.TestBreakingBad.assertEqual", "algorithms.strings.match_symbol_1"], "source_code": "def test_match_symbol_1(self):\n    self.assertEqual(['[Am]azon', 'Mi[cro]soft', 'Goog[le]'], match_symbol_1(self.words, self.symbols))"}, "test_bracket": {"args": ["self"], "min_max_lineno": {"min_lineno": 85, "max_lineno": 92}, "calls": ["test_strings.TestBreakingBad.assertEqual", "algorithms.strings.bracket"], "source_code": "def test_bracket(self):\n    self.assertEqual(('[Am]azon', 'Mi[cro]soft', 'Goog[le]'), bracket(self.words, self.symbols))\n    self.assertEqual(('Amazon', 'Microsoft', 'Google'), bracket(self.words, ['thisshouldnotmatch']))\n    self.assertEqual(('Amazon', 'M[i]crosoft', 'Google'), bracket(self.words, ['i', 'i']))"}}}, "TestDecodeString": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 94, "max_lineno": 105}, "methods": {"test_decode_string": {"args": ["self"], "min_max_lineno": {"min_lineno": 102, "max_lineno": 105}, "calls": ["test_strings.TestDecodeString.assertEqual", "algorithms.strings.decode_string"], "source_code": "def test_decode_string(self):\n    self.assertEqual('aaabcbc', decode_string('3[a]2[bc]'))\n    self.assertEqual('accaccacc', decode_string('3[a2[c]]'))"}}}, "TestDeleteReoccurring": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 107, "max_lineno": 117}, "methods": {"test_delete_reoccurring_characters": {"args": ["self"], "min_max_lineno": {"min_lineno": 115, "max_lineno": 117}, "calls": ["test_strings.TestDeleteReoccurring.assertEqual", "algorithms.strings.delete_reoccurring_characters"], "source_code": "def test_delete_reoccurring_characters(self):\n    self.assertEqual('abc', delete_reoccurring_characters('aaabcccc'))"}}}, "TestDomainExtractor": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 119, "max_lineno": 133}, "methods": {"test_valid": {"args": ["self"], "min_max_lineno": {"min_lineno": 127, "max_lineno": 130}, "calls": ["test_strings.TestDomainExtractor.assertEqual", "algorithms.strings.domain_name_1"], "source_code": "def test_valid(self):\n    self.assertEqual(domain_name_1('https://github.com/SaadBenn'), 'github')"}, "test_invalid": {"args": ["self"], "min_max_lineno": {"min_lineno": 131, "max_lineno": 133}, "calls": ["test_strings.TestDomainExtractor.assertEqual", "algorithms.strings.domain_name_2"], "source_code": "def test_invalid(self):\n    self.assertEqual(domain_name_2('http://google.com'), 'google')"}}}, "TestEncodeDecode": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 135, "max_lineno": 149}, "methods": {"test_encode": {"args": ["self"], "min_max_lineno": {"min_lineno": 143, "max_lineno": 145}, "calls": ["test_strings.TestEncodeDecode.assertEqual", "algorithms.strings.encode"], "source_code": "def test_encode(self):\n    self.assertEqual('4:keon2:is7:awesome', encode('keon is awesome'))"}, "test_decode": {"args": ["self"], "min_max_lineno": {"min_lineno": 146, "max_lineno": 149}, "calls": ["test_strings.TestEncodeDecode.assertEqual", "algorithms.strings.decode"], "source_code": "def test_decode(self):\n    self.assertEqual(['keon', 'is', 'awesome'], decode('4:keon2:is7:awesome'))"}}}, "TestGroupAnagrams": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 151, "max_lineno": 163}, "methods": {"test_group_anagrams": {"args": ["self"], "min_max_lineno": {"min_lineno": 159, "max_lineno": 163}, "calls": ["test_strings.TestGroupAnagrams.assertEqual", "algorithms.strings.group_anagrams"], "source_code": "def test_group_anagrams(self):\n    self.assertEqual([['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']], group_anagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']))"}}}, "TestIntToRoman": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 165, "max_lineno": 177}, "methods": {"test_int_to_roman": {"args": ["self"], "min_max_lineno": {"min_lineno": 173, "max_lineno": 177}, "calls": ["test_strings.TestIntToRoman.assertEqual", "algorithms.strings.int_to_roman"], "source_code": "def test_int_to_roman(self):\n    self.assertEqual('DCXLIV', int_to_roman(644))\n    self.assertEqual('I', int_to_roman(1))\n    self.assertEqual('MMMCMXCIX', int_to_roman(3999))"}}}, "TestIsPalindrome": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 179, "max_lineno": 211}, "methods": {"test_is_palindrome": {"args": ["self"], "min_max_lineno": {"min_lineno": 187, "max_lineno": 191}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome"], "source_code": "def test_is_palindrome(self):\n    self.assertTrue(is_palindrome('Otto'))\n    self.assertFalse(is_palindrome('house'))"}, "test_is_palindrome_reverse": {"args": ["self"], "min_max_lineno": {"min_lineno": 192, "max_lineno": 196}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome_reverse"], "source_code": "def test_is_palindrome_reverse(self):\n    self.assertTrue(is_palindrome_reverse('Otto'))\n    self.assertFalse(is_palindrome_reverse('house'))"}, "test_is_palindrome_two_pointer": {"args": ["self"], "min_max_lineno": {"min_lineno": 197, "max_lineno": 201}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome_two_pointer"], "source_code": "def test_is_palindrome_two_pointer(self):\n    self.assertTrue(is_palindrome_two_pointer('Otto'))\n    self.assertFalse(is_palindrome_two_pointer('house'))"}, "test_is_palindrome_stack": {"args": ["self"], "min_max_lineno": {"min_lineno": 202, "max_lineno": 206}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome_stack"], "source_code": "def test_is_palindrome_stack(self):\n    self.assertTrue(is_palindrome_stack('Otto'))\n    self.assertFalse(is_palindrome_stack('house'))"}, "test_is_palindrome_deque": {"args": ["self"], "min_max_lineno": {"min_lineno": 207, "max_lineno": 211}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome_deque"], "source_code": "def test_is_palindrome_deque(self):\n    self.assertTrue(is_palindrome_deque('Otto'))\n    self.assertFalse(is_palindrome_deque('house'))"}}}, "TestIsRotated": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 213, "max_lineno": 234}, "methods": {"test_is_rotated": {"args": ["self"], "min_max_lineno": {"min_lineno": 221, "max_lineno": 227}, "calls": ["test_strings.TestIsRotated.assertTrue", "test_strings.TestIsRotated.assertFalse", "algorithms.strings.is_rotated"], "source_code": "def test_is_rotated(self):\n    self.assertTrue(is_rotated('hello', 'hello'))\n    self.assertTrue(is_rotated('hello', 'llohe'))\n    self.assertFalse(is_rotated('hello', 'helol'))\n    self.assertFalse(is_rotated('hello', 'lloh'))\n    self.assertTrue(is_rotated('', ''))"}, "test_is_rotated_v1": {"args": ["self"], "min_max_lineno": {"min_lineno": 228, "max_lineno": 234}, "calls": ["test_strings.TestIsRotated.assertTrue", "test_strings.TestIsRotated.assertFalse", "algorithms.strings.is_rotated_v1"], "source_code": "def test_is_rotated_v1(self):\n    self.assertTrue(is_rotated_v1('hello', 'hello'))\n    self.assertTrue(is_rotated_v1('hello', 'llohe'))\n    self.assertFalse(is_rotated_v1('hello', 'helol'))\n    self.assertFalse(is_rotated_v1('hello', 'lloh'))\n    self.assertTrue(is_rotated_v1('', ''))"}}}, "TestRotated": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 236, "max_lineno": 248}, "methods": {"test_rotate": {"args": ["self"], "min_max_lineno": {"min_lineno": 237, "max_lineno": 242}, "calls": ["test_strings.TestRotated.assertEqual", "algorithms.strings.rotate"], "source_code": "def test_rotate(self):\n    self.assertEqual('llohe', rotate('hello', 2))\n    self.assertEqual('hello', rotate('hello', 5))\n    self.assertEqual('elloh', rotate('hello', 6))\n    self.assertEqual('llohe', rotate('hello', 7))"}, "test_rotate_alt": {"args": ["self"], "min_max_lineno": {"min_lineno": 243, "max_lineno": 248}, "calls": ["test_strings.TestRotated.assertEqual", "algorithms.strings.rotate_alt"], "source_code": "def test_rotate_alt(self):\n    self.assertEqual('llohe', rotate_alt('hello', 2))\n    self.assertEqual('hello', rotate_alt('hello', 5))\n    self.assertEqual('elloh', rotate_alt('hello', 6))\n    self.assertEqual('llohe', rotate_alt('hello', 7))"}}}, "TestLicenseNumber": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 250, "max_lineno": 264}, "methods": {"test_license_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 258, "max_lineno": 264}, "calls": ["test_strings.TestLicenseNumber.assertEqual", "algorithms.strings.license_number"], "source_code": "def test_license_number(self):\n    self.assertEqual('a-b-c-d-f-d-d-f', license_number('a-bc-dfd-df', 1))\n    self.assertEqual('ab-cd-fd-df', license_number('a-bc-dfd-df', 2))\n    self.assertEqual('ab-cdf-ddf', license_number('a-bc-dfd-df', 3))\n    self.assertEqual('abcd-fddf', license_number('a-bc-dfd-df', 4))\n    self.assertEqual('abc-dfddf', license_number('a-bc-dfd-df', 5))"}}}, "TestMakeSentence": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 266, "max_lineno": 278}, "methods": {"test_make_sentence": {"args": ["self"], "min_max_lineno": {"min_lineno": 274, "max_lineno": 278}, "calls": ["test_strings.TestMakeSentence.assertTrue", "algorithms.strings.make_sentence"], "source_code": "def test_make_sentence(self):\n    dictionarys = ['', 'app', 'let', 't', 'apple', 'applet']\n    word = 'applet'\n    self.assertTrue(make_sentence(word, dictionarys))"}}}, "TestMergeStringChecker": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 280, "max_lineno": 293}, "methods": {"test_is_merge_recursive": {"args": ["self"], "min_max_lineno": {"min_lineno": 288, "max_lineno": 290}, "calls": ["test_strings.TestMergeStringChecker.assertTrue", "algorithms.strings.is_merge_recursive"], "source_code": "def test_is_merge_recursive(self):\n    self.assertTrue(is_merge_recursive('codewars', 'cdw', 'oears'))"}, "test_is_merge_iterative": {"args": ["self"], "min_max_lineno": {"min_lineno": 291, "max_lineno": 293}, "calls": ["test_strings.TestMergeStringChecker.assertTrue", "algorithms.strings.is_merge_iterative"], "source_code": "def test_is_merge_iterative(self):\n    self.assertTrue(is_merge_iterative('codewars', 'cdw', 'oears'))"}}}, "TestMultiplyStrings": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 295, "max_lineno": 308}, "methods": {"test_multiply": {"args": ["self"], "min_max_lineno": {"min_lineno": 303, "max_lineno": 308}, "calls": ["test_strings.TestMultiplyStrings.assertEqual", "algorithms.strings.multiply"], "source_code": "def test_multiply(self):\n    self.assertEqual('23', multiply('1', '23'))\n    self.assertEqual('529', multiply('23', '23'))\n    self.assertEqual('0', multiply('0', '23'))\n    self.assertEqual('1000000', multiply('100', '10000'))"}}}, "TestOneEditDistance": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 310, "max_lineno": 327}, "methods": {"test_is_one_edit": {"args": ["self"], "min_max_lineno": {"min_lineno": 318, "max_lineno": 322}, "calls": ["test_strings.TestOneEditDistance.assertTrue", "test_strings.TestOneEditDistance.assertFalse", "algorithms.strings.is_one_edit"], "source_code": "def test_is_one_edit(self):\n    self.assertTrue(is_one_edit('abc', 'abd'))\n    self.assertFalse(is_one_edit('abc', 'aed'))\n    self.assertFalse(is_one_edit('abcd', 'abcd'))"}, "test_is_one_edit2": {"args": ["self"], "min_max_lineno": {"min_lineno": 323, "max_lineno": 327}, "calls": ["test_strings.TestOneEditDistance.assertTrue", "test_strings.TestOneEditDistance.assertFalse", "algorithms.strings.is_one_edit2"], "source_code": "def test_is_one_edit2(self):\n    self.assertTrue(is_one_edit2('abc', 'abd'))\n    self.assertFalse(is_one_edit2('abc', 'aed'))\n    self.assertFalse(is_one_edit2('abcd', 'abcd'))"}}}, "TestRabinKarp": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 329, "max_lineno": 340}, "methods": {"test_rabin_karp": {"args": ["self"], "min_max_lineno": {"min_lineno": 337, "max_lineno": 340}, "calls": ["test_strings.TestRabinKarp.assertEqual", "algorithms.strings.rabin_karp"], "source_code": "def test_rabin_karp(self):\n    self.assertEqual(3, rabin_karp('abc', 'zsnabckfkd'))\n    self.assertEqual(None, rabin_karp('abc', 'zsnajkskfkd'))"}}}, "TestReverseString": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 342, "max_lineno": 361}, "methods": {"test_recursive": {"args": ["self"], "min_max_lineno": {"min_lineno": 350, "max_lineno": 352}, "calls": ["test_strings.TestReverseString.assertEqual", "algorithms.strings.recursive"], "source_code": "def test_recursive(self):\n    self.assertEqual('ereht olleh', recursive('hello there'))"}, "test_iterative": {"args": ["self"], "min_max_lineno": {"min_lineno": 353, "max_lineno": 355}, "calls": ["test_strings.TestReverseString.assertEqual", "algorithms.strings.iterative"], "source_code": "def test_iterative(self):\n    self.assertEqual('ereht olleh', iterative('hello there'))"}, "test_pythonic": {"args": ["self"], "min_max_lineno": {"min_lineno": 356, "max_lineno": 358}, "calls": ["test_strings.TestReverseString.assertEqual", "algorithms.strings.pythonic"], "source_code": "def test_pythonic(self):\n    self.assertEqual('ereht olleh', pythonic('hello there'))"}, "test_ultra_pythonic": {"args": ["self"], "min_max_lineno": {"min_lineno": 359, "max_lineno": 361}, "calls": ["test_strings.TestReverseString.assertEqual", "algorithms.strings.ultra_pythonic"], "source_code": "def test_ultra_pythonic(self):\n    self.assertEqual('ereht olleh', ultra_pythonic('hello there'))"}}}, "TestReverseVowel": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 363, "max_lineno": 373}, "methods": {"test_reverse_vowel": {"args": ["self"], "min_max_lineno": {"min_lineno": 371, "max_lineno": 373}, "calls": ["test_strings.TestReverseVowel.assertEqual", "algorithms.strings.reverse_vowel"], "source_code": "def test_reverse_vowel(self):\n    self.assertEqual('holle', reverse_vowel('hello'))"}}}, "TestReverseWords": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 375, "max_lineno": 386}, "methods": {"test_reverse_words": {"args": ["self"], "min_max_lineno": {"min_lineno": 383, "max_lineno": 386}, "calls": ["test_strings.TestReverseWords.assertEqual", "algorithms.strings.reverse_words"], "source_code": "def test_reverse_words(self):\n    self.assertEqual('pizza like I and kim keon am I', reverse_words('I am keon kim and I like pizza'))"}}}, "TestRomanToInt": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 388, "max_lineno": 400}, "methods": {"test_roman_to_int": {"args": ["self"], "min_max_lineno": {"min_lineno": 396, "max_lineno": 400}, "calls": ["test_strings.TestRomanToInt.assertEqual", "algorithms.strings.roman_to_int"], "source_code": "def test_roman_to_int(self):\n    self.assertEqual(621, roman_to_int('DCXXI'))\n    self.assertEqual(1, roman_to_int('I'))\n    self.assertEqual(3999, roman_to_int('MMMCMXCIX'))"}}}, "TestValidateCoordinates": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 427, "max_lineno": 446}, "methods": {"test_valid": {"args": ["self"], "min_max_lineno": {"min_lineno": 435, "max_lineno": 439}, "calls": ["test_strings.TestValidateCoordinates.assertTrue", "algorithms.strings.is_valid_coordinates_0"], "source_code": "def test_valid(self):\n    valid_coordinates = ['-23, 25', '4, -3', '90, 180', '-90, -180']\n    for coordinate in valid_coordinates:\n        self.assertTrue(is_valid_coordinates_0(coordinate))"}, "test_invalid": {"args": ["self"], "min_max_lineno": {"min_lineno": 440, "max_lineno": 446}, "calls": ["test_strings.TestValidateCoordinates.assertFalse", "algorithms.strings.is_valid_coordinates_0"], "source_code": "def test_invalid(self):\n    invalid_coordinates = ['23.234, - 23.4234', '99.234, 12.324', '6.325624, 43.34345.345', '0, 1,2', '23.245, 1e1']\n    for coordinate in invalid_coordinates:\n        self.assertFalse(is_valid_coordinates_0(coordinate))"}}}, "TestWordSquares": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 448, "max_lineno": 461}, "methods": {"test_word_squares": {"args": ["self"], "min_max_lineno": {"min_lineno": 456, "max_lineno": 461}, "calls": ["test_strings.TestWordSquares.assertEqual", "algorithms.strings.word_squares"], "source_code": "def test_word_squares(self):\n    self.assertEqual([['wall', 'area', 'lead', 'lady'], ['ball', 'area', 'lead', 'lady']], word_squares(['area', 'lead', 'wall', 'lady', 'ball']))"}}}, "TestUniqueMorse": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 463, "max_lineno": 470}, "methods": {"test_convert_morse_word": {"args": ["self"], "min_max_lineno": {"min_lineno": 464, "max_lineno": 467}, "calls": ["test_strings.TestUniqueMorse.assertEqual", "algorithms.strings.convert_morse_word"], "source_code": "def test_convert_morse_word(self):\n    self.assertEqual('--...-.', convert_morse_word('gin'))\n    self.assertEqual('--...--.', convert_morse_word('msg'))"}, "test_unique_morse": {"args": ["self"], "min_max_lineno": {"min_lineno": 468, "max_lineno": 470}, "calls": ["test_strings.TestUniqueMorse.assertEqual", "algorithms.strings.unique_morse"], "source_code": "def test_unique_morse(self):\n    self.assertEqual(2, unique_morse(['gin', 'zen', 'gig', 'msg']))"}}}, "TestJudgeCircle": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 472, "max_lineno": 476}, "methods": {"test_judge_circle": {"args": ["self"], "min_max_lineno": {"min_lineno": 473, "max_lineno": 476}, "calls": ["test_strings.TestJudgeCircle.assertTrue", "test_strings.TestJudgeCircle.assertFalse", "algorithms.strings.judge_circle"], "source_code": "def test_judge_circle(self):\n    self.assertTrue(judge_circle('UDLRUD'))\n    self.assertFalse(judge_circle('LLRU'))"}}}, "TestStrongPassword": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 478, "max_lineno": 482}, "methods": {"test_strong_password": {"args": ["self"], "min_max_lineno": {"min_lineno": 479, "max_lineno": 482}, "calls": ["test_strings.TestStrongPassword.assertEqual", "algorithms.strings.strong_password"], "source_code": "def test_strong_password(self):\n    self.assertEqual(3, strong_password(3, 'Ab1'))\n    self.assertEqual(1, strong_password(11, '#Algorithms'))"}}}, "TestCaesarCipher": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 484, "max_lineno": 488}, "methods": {"test_caesar_cipher": {"args": ["self"], "min_max_lineno": {"min_lineno": 485, "max_lineno": 488}, "calls": ["test_strings.TestCaesarCipher.assertEqual", "algorithms.strings.caesar_cipher"], "source_code": "def test_caesar_cipher(self):\n    self.assertEqual('Lipps_Asvph!', caesar_cipher('Hello_World!', 4))\n    self.assertEqual('okffng-Qwvb', caesar_cipher('middle-Outz', 2))"}}}, "TestCheckPangram": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 490, "max_lineno": 494}, "methods": {"test_check_pangram": {"args": ["self"], "min_max_lineno": {"min_lineno": 491, "max_lineno": 494}, "calls": ["test_strings.TestCheckPangram.assertTrue", "test_strings.TestCheckPangram.assertFalse", "algorithms.strings.check_pangram"], "source_code": "def test_check_pangram(self):\n    self.assertTrue(check_pangram('The quick brown fox jumps over the lazy dog'))\n    self.assertFalse(check_pangram('The quick brown fox'))"}}}, "TestContainString": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 496, "max_lineno": 501}, "methods": {"test_contain_string": {"args": ["self"], "min_max_lineno": {"min_lineno": 497, "max_lineno": 501}, "calls": ["test_strings.TestContainString.assertEqual", "algorithms.strings.contain_string"], "source_code": "def test_contain_string(self):\n    self.assertEqual(-1, contain_string('mississippi', 'issipi'))\n    self.assertEqual(0, contain_string('Hello World', ''))\n    self.assertEqual(2, contain_string('hello', 'll'))"}}}, "TestCountBinarySubstring": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 510, "max_lineno": 514}, "methods": {"test_repeat_string": {"args": ["self"], "min_max_lineno": {"min_lineno": 511, "max_lineno": 514}, "calls": ["test_strings.TestCountBinarySubstring.assertEqual", "algorithms.strings.repeat_string"], "source_code": "def test_repeat_string(self):\n    self.assertEqual(3, repeat_string('abcd', 'cdabcdab'))\n    self.assertEqual(4, repeat_string('bb', 'bbbbbbb'))"}}}, "TestTextJustification": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 516, "max_lineno": 532}, "methods": {"test_text_justification": {"args": ["self"], "min_max_lineno": {"min_lineno": 517, "max_lineno": 532}, "calls": ["test_strings.TestTextJustification.assertEqual", "algorithms.strings.text_justification"], "source_code": "def test_text_justification(self):\n    self.assertEqual(['This    is    an', 'example  of text', 'justification.  '], text_justification(['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 16))\n    self.assertEqual(['What   must   be', 'acknowledgment  ', 'shall be        '], text_justification(['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 16))"}}}, "TestMinDistance": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 535, "max_lineno": 540}, "methods": {"test_min_distance": {"args": ["self"], "min_max_lineno": {"min_lineno": 536, "max_lineno": 540}, "calls": ["test_strings.TestMinDistance.assertEqual", "algorithms.strings.min_distance"], "source_code": "def test_min_distance(self):\n    self.assertEqual(2, min_distance('sea', 'eat'))\n    self.assertEqual(6, min_distance('abAlgocrithmf', 'Algorithmmd'))\n    self.assertEqual(4, min_distance('acbbd', 'aabcd'))"}}}, "TestMinDistanceDP": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 541, "max_lineno": 546}, "methods": {"test_min_distance": {"args": ["self"], "min_max_lineno": {"min_lineno": 542, "max_lineno": 546}, "calls": ["test_strings.TestMinDistanceDP.assertEqual", "algorithms.strings.min_distance_dp", "algorithms.strings.min_distance"], "source_code": "def test_min_distance(self):\n    self.assertEqual(2, min_distance_dp('sea', 'eat'))\n    self.assertEqual(6, min_distance_dp('abAlgocrithmf', 'Algorithmmd'))\n    self.assertEqual(4, min_distance('acbbd', 'aabcd'))"}}}, "TestLongestCommonPrefix": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 548, "max_lineno": 565}, "methods": {"test_longest_common_prefix": {"args": ["self"], "min_max_lineno": {"min_lineno": 549, "max_lineno": 565}, "calls": ["test_strings.TestLongestCommonPrefix.assertEqual", "algorithms.strings.longest_common_prefix_v1", "algorithms.strings.longest_common_prefix_v2", "algorithms.strings.longest_common_prefix_v3"], "source_code": "def test_longest_common_prefix(self):\n    self.assertEqual('fl', longest_common_prefix_v1(['flower', 'flow', 'flight']))\n    self.assertEqual('', longest_common_prefix_v1(['dog', 'racecar', 'car']))\n    self.assertEqual('fl', longest_common_prefix_v2(['flower', 'flow', 'flight']))\n    self.assertEqual('', longest_common_prefix_v2(['dog', 'racecar', 'car']))\n    self.assertEqual('fl', longest_common_prefix_v3(['flower', 'flow', 'flight']))\n    self.assertEqual('', longest_common_prefix_v3(['dog', 'racecar', 'car']))"}}}, "TestFirstUniqueChar": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 567, "max_lineno": 571}, "methods": {"test_first_unique_char": {"args": ["self"], "min_max_lineno": {"min_lineno": 568, "max_lineno": 571}, "calls": ["test_strings.TestFirstUniqueChar.assertEqual", "algorithms.strings.first_unique_char"], "source_code": "def test_first_unique_char(self):\n    self.assertEqual(0, first_unique_char('leetcode'))\n    self.assertEqual(2, first_unique_char('loveleetcode'))"}}}, "TestRepeatSubstring": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 573, "max_lineno": 578}, "methods": {"test_repeat_substring": {"args": ["self"], "min_max_lineno": {"min_lineno": 574, "max_lineno": 578}, "calls": ["test_strings.TestRepeatSubstring.assertTrue", "test_strings.TestRepeatSubstring.assertFalse", "algorithms.strings.repeat_substring"], "source_code": "def test_repeat_substring(self):\n    self.assertTrue(repeat_substring('abab'))\n    self.assertFalse(repeat_substring('aba'))\n    self.assertTrue(repeat_substring('abcabcabcabc'))"}}}, "TestAtbashCipher": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 580, "max_lineno": 593}, "methods": {"test_atbash_cipher": {"args": ["self"], "min_max_lineno": {"min_lineno": 588, "max_lineno": 593}, "calls": ["test_strings.TestAtbashCipher.assertEqual", "algorithms.strings.atbash"], "source_code": "def test_atbash_cipher(self):\n    self.assertEqual('zyxwvutsrqponml', atbash('abcdefghijklmno'))\n    self.assertEqual('KbgslM', atbash('PythoN'))\n    self.assertEqual('AttaCK at DawN', atbash('ZggzXP zg WzdM'))\n    self.assertEqual('ZggzXP zg WzdM', atbash('AttaCK at DawN'))"}}}, "TestLongestPalindromicSubstring": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 595, "max_lineno": 606}, "methods": {"test_longest_palindromic_substring": {"args": ["self"], "min_max_lineno": {"min_lineno": 601, "max_lineno": 606}, "calls": ["test_strings.TestLongestPalindromicSubstring.assertEqual", "algorithms.strings.longest_palindrome"], "source_code": "def test_longest_palindromic_substring(self):\n    self.assertEqual('bb', longest_palindrome('cbbd'))\n    self.assertEqual('abba', longest_palindrome('abba'))\n    self.assertEqual('asdadsa', longest_palindrome('dasdasdasdasdasdadsa'))\n    self.assertEqual('abba', longest_palindrome('cabba'))"}}}, "TestKnuthMorrisPratt": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 608, "max_lineno": 622}, "methods": {"test_knuth_morris_pratt": {"args": ["self"], "min_max_lineno": {"min_lineno": 617, "max_lineno": 622}, "calls": ["test_strings.TestKnuthMorrisPratt.assertEqual", "algorithms.strings.knuth_morris_pratt"], "source_code": "def test_knuth_morris_pratt(self):\n    self.assertEqual([0, 1, 2, 3, 4], knuth_morris_pratt('aaaaaaa', 'aaa'))\n    self.assertEqual([0, 4], knuth_morris_pratt('abcdabc', 'abc'))\n    self.assertEqual([], knuth_morris_pratt('aabcdaab', 'aba'))\n    self.assertEqual([0, 4], knuth_morris_pratt([0, 0, 1, 1, 0, 0, 1, 0], [0, 0]))"}}}, "TestPanagram": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 624, "max_lineno": 701}, "methods": {"test_empty_string": {"args": ["self"], "min_max_lineno": {"min_lineno": 632, "max_lineno": 641}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_empty_string(self):\n    string = ''\n    res = panagram(string)\n    self.assertEqual(False, res)"}, "test_single_word_non_panagram": {"args": ["self"], "min_max_lineno": {"min_lineno": 642, "max_lineno": 651}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_single_word_non_panagram(self):\n    string = 'sentence'\n    res = panagram(string)\n    self.assertEqual(False, res)"}, "test_fox_panagram_no_spaces": {"args": ["self"], "min_max_lineno": {"min_lineno": 652, "max_lineno": 661}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_fox_panagram_no_spaces(self):\n    string = 'thequickbrownfoxjumpsoverthelazydog'\n    res = panagram(string)\n    self.assertEqual(True, res)"}, "test_fox_panagram_mixed_case": {"args": ["self"], "min_max_lineno": {"min_lineno": 662, "max_lineno": 671}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_fox_panagram_mixed_case(self):\n    string = 'theqUiCkbrOwnfOxjUMPSOVErThELAzYDog'\n    res = panagram(string)\n    self.assertEqual(True, res)"}, "test_whitespace_punctuation": {"args": ["self"], "min_max_lineno": {"min_lineno": 672, "max_lineno": 681}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_whitespace_punctuation(self):\n    string = '\\n\\t\\r,.-_!?'\n    res = panagram(string)\n    self.assertEqual(False, res)"}, "test_fox_panagram": {"args": ["self"], "min_max_lineno": {"min_lineno": 682, "max_lineno": 691}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_fox_panagram(self):\n    string = 'the quick brown fox jumps over the lazy dog'\n    res = panagram(string)\n    self.assertEqual(True, res)"}, "test_swedish_panagram": {"args": ["self"], "min_max_lineno": {"min_lineno": 692, "max_lineno": 701}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_swedish_panagram(self):\n    string = 'Yxm\u00f6rdaren Julia Blomqvist p\u00e5 f\u00e4ktning i Schweiz'\n    res = panagram(string)\n    self.assertEqual(True, res)"}}}, "TestFizzbuzz": {"doc": {"long_description": "Tests for the fizzbuzz method in file fizzbuzz.py", "short_description": "[summary]", "full": "[summary]\nTests for the fizzbuzz method in file fizzbuzz.py"}, "extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 703, "max_lineno": 729}, "methods": {"test_fizzbuzz": {"args": ["self"], "min_max_lineno": {"min_lineno": 707, "max_lineno": 729}, "calls": ["test_strings.TestFizzbuzz.assertRaises", "algorithms.strings.fizzbuzz.fizzbuzz", "test_strings.TestFizzbuzz.assertEqual"], "store_vars_calls": {"result": "fizzbuzz.fizzbuzz"}, "source_code": "def test_fizzbuzz(self):\n    self.assertRaises(ValueError, fizzbuzz.fizzbuzz, -2)\n    self.assertRaises(TypeError, fizzbuzz.fizzbuzz, 'hello')\n    result = fizzbuzz.fizzbuzz(3)\n    expected = [1, 2, 'Fizz']\n    self.assertEqual(result, expected)\n    result = fizzbuzz.fizzbuzz(5)\n    expected = [1, 2, 'Fizz', 4, 'Buzz']\n    self.assertEqual(result, expected)\n    result = fizzbuzz.fizzbuzz(15)\n    expected = [1, 2, 'Fizz', 4, 'Buzz', 'Fizz', 7, 8, 'Fizz', 'Buzz', 11, 'Fizz', 13, 14, 'FizzBuzz']\n    self.assertEqual(result, expected)"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_strings.unittest.main", "type": "script"}, "is_test": true}