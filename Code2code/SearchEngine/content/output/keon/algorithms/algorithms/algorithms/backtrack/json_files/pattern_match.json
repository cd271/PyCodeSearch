{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/pattern_match.py", "fileNameBase": "pattern_match", "extension": "py", "doc": {"long_description": "find if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between\na letter in pattern and a non-empty substring in str.\n\nExamples:\npattern = \"abab\", str = \"redblueredblue\" should return true.\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters.", "short_description": "Given a pattern and a string str,", "full": "Given a pattern and a string str,\nfind if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between\na letter in pattern and a non-empty substring in str.\n\nExamples:\npattern = \"abab\", str = \"redblueredblue\" should return true.\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters."}}, "functions": {"pattern_match": {"args": ["pattern", "string"], "returns": ["backtrack(pattern, string, {})", "False", "False", "True", "True", "True"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 43}, "calls": ["pattern_match.pattern_match.backtrack"], "functions": {"backtrack": {"args": ["pattern", "string", "dic"], "returns": ["False", "False", "True", "True", "True"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 41}, "calls": ["range", "len", "backtrack", "dic.values"], "source_code": "def backtrack(pattern, string, dic):\n    if len(pattern) == 0 and len(string) > 0:\n        return False\n    if len(pattern) == len(string) == 0:\n        return True\n    for end in range(1, len(string) - len(pattern) + 2):\n        if pattern[0] not in dic and string[:end] not in dic.values():\n            dic[pattern[0]] = string[:end]\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n            del dic[pattern[0]]\n        elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n    return False"}}, "source_code": "def pattern_match(pattern, string):\n    \"\"\"\n    :type pattern: str\n    :type string: str\n    :rtype: bool\n    \"\"\"\n\n    def backtrack(pattern, string, dic):\n        if len(pattern) == 0 and len(string) > 0:\n            return False\n        if len(pattern) == len(string) == 0:\n            return True\n        for end in range(1, len(string) - len(pattern) + 2):\n            if pattern[0] not in dic and string[:end] not in dic.values():\n                dic[pattern[0]] = string[:end]\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n                del dic[pattern[0]]\n            elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n        return False\n    return backtrack(pattern, string, {})"}}, "is_test": false}