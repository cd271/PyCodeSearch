{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bfs/word_ladder.py", "fileNameBase": "word_ladder", "extension": "py", "doc": {"long_description": "find the length of shortest transformation sequence\nfrom beginWord to endWord, such that:\n\nOnly one letter can be changed at a time\nEach intermediate word must exist in the word list\nFor example,\n\nGiven:\nbegin_word = \"hit\"\nend_word = \"cog\"\nword_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n\nNote:\nReturn -1 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.", "short_description": "Given two words (begin_word and end_word), and a dictionary's word list,", "full": "Given two words (begin_word and end_word), and a dictionary's word list,\nfind the length of shortest transformation sequence\nfrom beginWord to endWord, such that:\n\nOnly one letter can be changed at a time\nEach intermediate word must exist in the word list\nFor example,\n\nGiven:\nbegin_word = \"hit\"\nend_word = \"cog\"\nword_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n\nNote:\nReturn -1 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters."}}, "functions": {"ladder_length": {"doc": {"short_description": "Bidirectional BFS!!!"}, "args": ["begin_word", "end_word", "word_list"], "returns": ["-1", "-1", "0", "1", "result"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 65}, "calls": ["set", "set.add", "set.add", "len", "sum", "word_ladder.word_range", "zip", "set.add", "word_list.remove"], "store_vars_calls": {"begin_set": "set", "end_set": "set", "next_begin_set": "set"}, "source_code": "def ladder_length(begin_word, end_word, word_list):\n    \"\"\"\n    Bidirectional BFS!!!\n    :type begin_word: str\n    :type end_word: str\n    :type word_list: Set[str]\n    :rtype: int\n    \"\"\"\n    if len(begin_word) != len(end_word):\n        return -1\n    if begin_word == end_word:\n        return 0\n    if sum((c1 != c2 for (c1, c2) in zip(begin_word, end_word))) == 1:\n        return 1\n    begin_set = set()\n    end_set = set()\n    begin_set.add(begin_word)\n    end_set.add(end_word)\n    result = 2\n    while begin_set and end_set:\n        if len(begin_set) > len(end_set):\n            (begin_set, end_set) = (end_set, begin_set)\n        next_begin_set = set()\n        for word in begin_set:\n            for ladder_word in word_range(word):\n                if ladder_word in end_set:\n                    return result\n                if ladder_word in word_list:\n                    next_begin_set.add(ladder_word)\n                    word_list.remove(ladder_word)\n        begin_set = next_begin_set\n        result += 1\n    return -1"}, "word_range": {"args": ["word"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 73}, "calls": ["range", "len", "chr", "ord"], "source_code": "def word_range(word):\n    for ind in range(len(word)):\n        temp = word[ind]\n        for c in [chr(x) for x in range(ord('a'), ord('z') + 1)]:\n            if c != temp:\n                yield (word[:ind] + c + word[ind + 1:])"}}, "is_test": false}