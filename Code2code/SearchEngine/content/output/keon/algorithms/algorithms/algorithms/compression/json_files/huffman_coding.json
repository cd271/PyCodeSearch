{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/compression/huffman_coding.py", "fileNameBase": "huffman_coding", "extension": "py", "doc": {"long_description": "This algorithm analyzes the symbols that appear in a message.\nSymbols that appear more often will be encoded as a shorter-bit string\nwhile symbols that aren't used as much will be encoded as longer strings.", "short_description": "Huffman coding is an efficient method of compressing data without losing information.", "full": "Huffman coding is an efficient method of compressing data without losing information.\nThis algorithm analyzes the symbols that appear in a message.\nSymbols that appear more often will be encoded as a shorter-bit string\nwhile symbols that aren't used as much will be encoded as longer strings."}}, "dependencies": [{"from_module": "collections", "import": "defaultdict", "type": "external", "type_element": "module"}, {"from_module": "collections", "import": "deque", "type": "external", "type_element": "module"}, {"import": "heapq", "type": "external", "type_element": "module"}], "classes": {"Node": {"min_max_lineno": {"min_lineno": 12, "max_lineno": 33}, "methods": {"__init__": {"args": ["self", "frequency", "sign", "left", "right"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 18}, "source_code": "def __init__(self, frequency=0, sign=None, left=None, right=None):\n    self.frequency = frequency\n    self.sign = sign\n    self.left = left\n    self.right = right"}, "__lt__": {"args": ["self", "other"], "returns": ["self.frequency < other.frequency"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 21}, "source_code": "def __lt__(self, other):\n    return self.frequency < other.frequency"}, "__gt__": {"args": ["self", "other"], "returns": ["self.frequency > other.frequency"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 24}, "source_code": "def __gt__(self, other):\n    return self.frequency > other.frequency"}, "__eq__": {"args": ["self", "other"], "returns": ["self.frequency == other.frequency"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 27}, "source_code": "def __eq__(self, other):\n    return self.frequency == other.frequency"}, "__str__": {"args": ["self"], "returns": ["'<ch: {0}: {1}>'.format(self.sign, self.frequency)"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 30}, "source_code": "def __str__(self):\n    return '<ch: {0}: {1}>'.format(self.sign, self.frequency)"}, "__repr__": {"args": ["self"], "returns": ["'<ch: {0}: {1}>'.format(self.sign, self.frequency)"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 33}, "source_code": "def __repr__(self):\n    return '<ch: {0}: {1}>'.format(self.sign, self.frequency)"}}}, "HuffmanReader": {"min_max_lineno": {"min_lineno": 35, "max_lineno": 119}, "methods": {"__init__": {"args": ["self", "file"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 40}, "source_code": "def __init__(self, file):\n    self.file = file\n    self.buffer = []\n    self.is_last_byte = False"}, "get_number_of_additional_bits_in_the_last_byte": {"args": ["self"], "annotated_return_type": "int", "returns": ["int(bin_num, 2)"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 44}, "calls": ["int", "huffman_coding.HuffmanReader.get_bit"], "source_code": "def get_number_of_additional_bits_in_the_last_byte(self) -> int:\n    bin_num = self.get_bit() + self.get_bit() + self.get_bit()\n    return int(bin_num, 2)"}, "load_tree": {"doc": {"short_description": "Load tree from file", "returns": {"is_generator": false}}, "args": ["self"], "annotated_return_type": "Node", "returns": ["root"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 74}, "calls": ["collections.deque", "huffman_coding.HuffmanReader._fill_tree", "huffman_coding.HuffmanReader.get_bit", "huffman_coding.Node", "collections.deque.append", "collections.deque.append", "collections.deque.pop"], "store_vars_calls": {"node_stack": "deque", "queue_leaves": "deque", "root": "Node", "current_bit": "self.get_bit", "current_node.left": "Node", "current_node.right": "Node", "current_node": "node_stack.pop"}, "source_code": "def load_tree(self) -> Node:\n    \"\"\"\n        Load tree from file\n\n        :return:\n        \"\"\"\n    node_stack = deque()\n    queue_leaves = deque()\n    root = Node()\n    current_node = root\n    is_end_of_tree = False\n    while not is_end_of_tree:\n        current_bit = self.get_bit()\n        if current_bit == '0':\n            current_node.left = Node()\n            current_node.right = Node()\n            node_stack.append(current_node.right)\n            current_node = current_node.left\n        else:\n            queue_leaves.append(current_node)\n            if node_stack:\n                current_node = node_stack.pop()\n            else:\n                is_end_of_tree = True\n    self._fill_tree(queue_leaves)\n    return root"}, "_fill_tree": {"doc": {"short_description": "Load values to tree after reading tree", "returns": {"is_generator": false}}, "args": ["self", "leaves_queue"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 86}, "calls": ["leaves_queue.reverse", "leaves_queue.pop", "int", "huffman_coding.HuffmanReader.get_byte"], "store_vars_calls": {"node": "leaves_queue.pop", "s": "int"}, "source_code": "def _fill_tree(self, leaves_queue):\n    \"\"\"\n        Load values to tree after reading tree\n        :param leaves_queue:\n        :return:\n        \"\"\"\n    leaves_queue.reverse()\n    while leaves_queue:\n        node = leaves_queue.pop()\n        s = int(self.get_byte(), 2)\n        node.sign = s"}, "_load_byte": {"doc": {"short_description": "Load next byte is buffer is less than buff_limit", "returns": {"description": "True if there is enough bits in buffer to read", "is_generator": false}}, "args": ["self", "buff_limit"], "annotated_return_type": "bool", "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 87, "max_lineno": 103}, "calls": ["len", "huffman_coding.HuffmanReader.file.read", "int.from_bytes", "huffman_coding.HuffmanReader.buffer.extend", "list"], "store_vars_calls": {"byte": "self.file.read", "i": "int.from_bytes"}, "source_code": "def _load_byte(self, buff_limit=8) -> bool:\n    \"\"\"\n        Load next byte is buffer is less than buff_limit\n        :param buff_limit:\n        :return: True if there is enough bits in buffer to read\n        \"\"\"\n    if len(self.buffer) <= buff_limit:\n        byte = self.file.read(1)\n        if not byte:\n            return False\n        i = int.from_bytes(byte, 'big')\n        self.buffer.extend(list('{0:08b}'.format(i)))\n    return True"}, "get_bit": {"args": ["self", "buff_limit"], "returns": ["bit", "-1"], "min_max_lineno": {"min_lineno": 104, "max_lineno": 110}, "calls": ["huffman_coding.HuffmanReader._load_byte", "huffman_coding.HuffmanReader.buffer.pop"], "store_vars_calls": {"bit": "self.buffer.pop"}, "source_code": "def get_bit(self, buff_limit=8):\n    if self._load_byte(buff_limit):\n        bit = self.buffer.pop(0)\n        return bit\n    else:\n        return -1"}, "get_byte": {"args": ["self"], "returns": ["''.join(byte_list)", "-1"], "min_max_lineno": {"min_lineno": 111, "max_lineno": 119}, "calls": ["huffman_coding.HuffmanReader._load_byte"], "source_code": "def get_byte(self):\n    if self._load_byte():\n        byte_list = self.buffer[:8]\n        self.buffer = self.buffer[8:]\n        return ''.join(byte_list)\n    else:\n        return -1"}}}, "HuffmanWriter": {"min_max_lineno": {"min_lineno": 121, "max_lineno": 190}, "methods": {"__init__": {"args": ["self", "file"], "min_max_lineno": {"min_lineno": 122, "max_lineno": 126}, "source_code": "def __init__(self, file):\n    self.file = file\n    self.buffer = ''\n    self.saved_bits = 0"}, "write_char": {"args": ["self", "char"], "min_max_lineno": {"min_lineno": 127, "max_lineno": 129}, "calls": ["huffman_coding.HuffmanWriter.write_int", "ord"], "source_code": "def write_char(self, char):\n    self.write_int(ord(char))"}, "write_int": {"args": ["self", "num"], "min_max_lineno": {"min_lineno": 130, "max_lineno": 133}, "calls": ["huffman_coding.HuffmanWriter.write_bits"], "source_code": "def write_int(self, num):\n    bin_int = '{0:08b}'.format(num)\n    self.write_bits(bin_int)"}, "write_bits": {"args": ["self", "bits"], "min_max_lineno": {"min_lineno": 134, "max_lineno": 143}, "calls": ["len", "int", "huffman_coding.HuffmanWriter.file.write", "bytes"], "store_vars_calls": {"i": "int"}, "source_code": "def write_bits(self, bits):\n    self.saved_bits += len(bits)\n    self.buffer += bits\n    while len(self.buffer) >= 8:\n        i = int(self.buffer[:8], 2)\n        self.file.write(bytes([i]))\n        self.buffer = self.buffer[8:]"}, "save_tree": {"doc": {"short_description": "Generate and save tree code to file", "returns": {"is_generator": false}}, "args": ["self", "tree"], "min_max_lineno": {"min_lineno": 144, "max_lineno": 168}, "calls": ["huffman_coding.HuffmanWriter.save_tree.get_code_tree"], "functions": {"get_code_tree": {"args": ["T"], "min_max_lineno": {"min_lineno": 153, "max_lineno": 163}, "calls": ["signs.append", "get_code_tree"], "source_code": "def get_code_tree(T):\n    nonlocal tree_code\n    if T.sign is not None:\n        signs.append(T.sign)\n    if T.left:\n        tree_code += '0'\n        get_code_tree(T.left)\n    if T.right:\n        tree_code += '1'\n        get_code_tree(T.right)"}}, "source_code": "def save_tree(self, tree):\n    \"\"\"\n        Generate and save tree code to file\n        :param tree:\n        :return:\n        \"\"\"\n    signs = []\n    tree_code = ''\n\n    def get_code_tree(T):\n        nonlocal tree_code\n        if T.sign is not None:\n            signs.append(T.sign)\n        if T.left:\n            tree_code += '0'\n            get_code_tree(T.left)\n        if T.right:\n            tree_code += '1'\n            get_code_tree(T.right)\n    get_code_tree(tree)\n    self.write_bits(tree_code + '1')\n    for int_sign in signs:\n        self.write_int(int_sign)"}, "_save_information_about_additional_bits": {"doc": {"short_description": "Overwrite first three bits in the file", "args": {"additional_bits": {"description": "number of bits that were appended to fill last byte"}}, "returns": {"is_generator": false}}, "args": ["self", "additional_bits"], "annotated_arg_types": {"additional_bits": "int"}, "min_max_lineno": {"min_lineno": 169, "max_lineno": 184}, "calls": ["huffman_coding.HuffmanWriter.file.seek", "huffman_coding.HuffmanWriter.file.read", "huffman_coding.HuffmanWriter.write_bits", "int.from_bytes"], "store_vars_calls": {"first_byte_raw": "self.file.read"}, "source_code": "def _save_information_about_additional_bits(self, additional_bits: int):\n    \"\"\"\n        Overwrite first three bits in the file\n        :param additional_bits: number of bits that were appended to fill last byte\n        :return:\n        \"\"\"\n    self.file.seek(0)\n    first_byte_raw = self.file.read(1)\n    self.file.seek(0)\n    first_byte = '{0:08b}'.format(int.from_bytes(first_byte_raw, 'big'))\n    first_byte = first_byte[3:]\n    first_byte = '{0:03b}'.format(additional_bits) + first_byte\n    self.write_bits(first_byte)"}, "close": {"args": ["self"], "min_max_lineno": {"min_lineno": 185, "max_lineno": 190}, "calls": ["len", "huffman_coding.HuffmanWriter.write_bits", "huffman_coding.HuffmanWriter._save_information_about_additional_bits"], "source_code": "def close(self):\n    additional_bits = 8 - len(self.buffer)\n    if additional_bits != 8:\n        self.write_bits('0' * additional_bits)\n        self._save_information_about_additional_bits(additional_bits)"}}}, "TreeFinder": {"doc": {"short_description": "Class to help find signs in tree", "full": "Class to help find signs in tree"}, "min_max_lineno": {"min_lineno": 192, "max_lineno": 225}, "methods": {"__init__": {"args": ["self", "tree"], "min_max_lineno": {"min_lineno": 197, "max_lineno": 201}, "source_code": "def __init__(self, tree):\n    self.root = tree\n    self.current_node = tree\n    self.found = None"}, "find": {"doc": {"short_description": "Find sign in tree", "returns": {"description": "True if sign is found", "is_generator": false}}, "args": ["self", "bit"], "returns": ["True", "False", "True"], "min_max_lineno": {"min_lineno": 202, "max_lineno": 221}, "calls": ["huffman_coding.TreeFinder._reset"], "source_code": "def find(self, bit):\n    \"\"\"\n        Find sign in tree\n        :param bit:\n        :return: True if sign is found\n        \"\"\"\n    if bit == '0':\n        self.current_node = self.current_node.left\n    elif bit == '1':\n        self.current_node = self.current_node.right\n    else:\n        self._reset()\n        return True\n    if self.current_node.sign is not None:\n        self._reset(self.current_node.sign)\n        return True\n    else:\n        return False"}, "_reset": {"args": ["self", "found"], "min_max_lineno": {"min_lineno": 222, "max_lineno": 225}, "source_code": "def _reset(self, found=''):\n    self.found = found\n    self.current_node = self.root"}}}, "HuffmanCoding": {"min_max_lineno": {"min_lineno": 227, "max_lineno": 329}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 228, "max_lineno": 230}, "source_code": "def __init__(self):\n    pass"}, "decode_file": {"args": ["file_in_name", "file_out_name"], "min_max_lineno": {"min_lineno": 231, "max_lineno": 241}, "calls": ["print", "open", "huffman_coding.HuffmanReader.get_number_of_additional_bits_in_the_last_byte", "huffman_coding.HuffmanReader.load_tree", "huffman_coding.HuffmanCoding._decode_and_write_signs_to_file"], "store_vars_calls": {"reader": "HuffmanReader", "additional_bits": "reader.get_number_of_additional_bits_in_the_last_byte", "tree": "reader.load_tree"}, "source_code": "@staticmethod\ndef decode_file(file_in_name, file_out_name):\n    with open(file_in_name, 'rb') as file_in, open(file_out_name, 'wb') as file_out:\n        reader = HuffmanReader(file_in)\n        additional_bits = reader.get_number_of_additional_bits_in_the_last_byte()\n        tree = reader.load_tree()\n        HuffmanCoding._decode_and_write_signs_to_file(file_out, reader, tree, additional_bits)\n    print('File decoded.')"}, "_decode_and_write_signs_to_file": {"args": ["file", "reader", "tree", "additional_bits"], "annotated_arg_types": {"reader": "HuffmanReader", "tree": "Node", "additional_bits": "int"}, "min_max_lineno": {"min_lineno": 242, "max_lineno": 260}, "calls": ["reader.get_bit", "file.write", "huffman_coding.TreeFinder.find", "bytes"], "store_vars_calls": {"tree_finder": "TreeFinder", "bit": "reader.get_bit"}, "source_code": "@staticmethod\ndef _decode_and_write_signs_to_file(file, reader: HuffmanReader, tree: Node, additional_bits: int):\n    tree_finder = TreeFinder(tree)\n    is_end_of_file = False\n    while not is_end_of_file:\n        bit = reader.get_bit()\n        if bit != -1:\n            while not tree_finder.find(bit):\n                bit = reader.get_bit(0)\n            file.write(bytes([tree_finder.found]))\n        else:\n            is_end_of_file = True\n            last_byte = reader.buffer\n            last_byte = last_byte[:-additional_bits]\n            for bit in last_byte:\n                if tree_finder.find(bit):\n                    file.write(bytes([tree_finder.found]))"}, "encode_file": {"args": ["file_in_name", "file_out_name"], "min_max_lineno": {"min_lineno": 261, "max_lineno": 276}, "calls": ["print", "open", "huffman_coding.HuffmanCoding._get_char_frequency", "file_in.seek", "huffman_coding.HuffmanCoding._create_tree", "huffman_coding.HuffmanCoding._generate_codes", "huffman_coding.HuffmanWriter.write_bits", "huffman_coding.HuffmanWriter.save_tree", "huffman_coding.HuffmanCoding._encode_and_write_signs_to_file", "huffman_coding.HuffmanWriter.close"], "store_vars_calls": {"signs_frequency": "HuffmanCoding._get_char_frequency", "tree": "HuffmanCoding._create_tree", "codes": "HuffmanCoding._generate_codes", "writer": "HuffmanWriter"}, "source_code": "@staticmethod\ndef encode_file(file_in_name, file_out_name):\n    with open(file_in_name, 'rb') as file_in, open(file_out_name, mode='wb+') as file_out:\n        signs_frequency = HuffmanCoding._get_char_frequency(file_in)\n        file_in.seek(0)\n        tree = HuffmanCoding._create_tree(signs_frequency)\n        codes = HuffmanCoding._generate_codes(tree)\n        writer = HuffmanWriter(file_out)\n        writer.write_bits('000')\n        writer.save_tree(tree)\n        HuffmanCoding._encode_and_write_signs_to_file(file_in, writer, codes)\n        writer.close()\n    print('File encoded.')"}, "_encode_and_write_signs_to_file": {"args": ["file", "writer", "codes"], "annotated_arg_types": {"writer": "HuffmanWriter", "codes": "dict"}, "min_max_lineno": {"min_lineno": 277, "max_lineno": 284}, "calls": ["file.read", "int.from_bytes", "writer.write_bits"], "store_vars_calls": {"sign": "file.read", "int_char": "int.from_bytes"}, "source_code": "@staticmethod\ndef _encode_and_write_signs_to_file(file, writer: HuffmanWriter, codes: dict):\n    sign = file.read(1)\n    while sign:\n        int_char = int.from_bytes(sign, 'big')\n        writer.write_bits(codes[int_char])\n        sign = file.read(1)"}, "_get_char_frequency": {"args": ["file"], "annotated_return_type": "dict", "returns": ["signs_frequency"], "min_max_lineno": {"min_lineno": 285, "max_lineno": 299}, "calls": ["collections.defaultdict", "file.tell", "file.read", "int.from_bytes"], "store_vars_calls": {"signs_frequency": "defaultdict", "prev_pos": "file.tell", "sign": "file.read", "curr_pos": "file.tell"}, "source_code": "@staticmethod\ndef _get_char_frequency(file) -> dict:\n    is_end_of_file = False\n    signs_frequency = defaultdict(lambda : 0)\n    while not is_end_of_file:\n        prev_pos = file.tell()\n        sign = file.read(1)\n        curr_pos = file.tell()\n        if prev_pos == curr_pos:\n            is_end_of_file = True\n        else:\n            signs_frequency[int.from_bytes(sign, 'big')] += 1\n    return signs_frequency"}, "_generate_codes": {"args": ["tree"], "annotated_arg_types": {"tree": "Node"}, "annotated_return_type": "dict", "returns": ["codes"], "min_max_lineno": {"min_lineno": 300, "max_lineno": 305}, "calls": ["dict", "huffman_coding.HuffmanCoding._go_through_tree_and_create_codes"], "store_vars_calls": {"codes": "dict"}, "source_code": "@staticmethod\ndef _generate_codes(tree: Node) -> dict:\n    codes = dict()\n    HuffmanCoding._go_through_tree_and_create_codes(tree, '', codes)\n    return codes"}, "_create_tree": {"args": ["signs_frequency"], "annotated_arg_types": {"signs_frequency": "dict"}, "annotated_return_type": "Node", "returns": ["nodes[0]"], "min_max_lineno": {"min_lineno": 306, "max_lineno": 318}, "calls": ["heapq.heapify", "len", "heapq.heappop", "huffman_coding.Node", "heapq.heappush", "signs_frequency.items"], "store_vars_calls": {"left": "heapq.heappop", "right": "heapq.heappop", "new_node": "Node"}, "source_code": "@staticmethod\ndef _create_tree(signs_frequency: dict) -> Node:\n    nodes = [Node(frequency=frequency, sign=char_int) for (char_int, frequency) in signs_frequency.items()]\n    heapq.heapify(nodes)\n    while len(nodes) > 1:\n        left = heapq.heappop(nodes)\n        right = heapq.heappop(nodes)\n        new_node = Node(frequency=left.frequency + right.frequency, left=left, right=right)\n        heapq.heappush(nodes, new_node)\n    return nodes[0]"}, "_go_through_tree_and_create_codes": {"args": ["tree", "code", "dict_codes"], "annotated_arg_types": {"tree": "Node", "code": "str", "dict_codes": "dict"}, "min_max_lineno": {"min_lineno": 319, "max_lineno": 329}, "calls": ["huffman_coding.HuffmanCoding._go_through_tree_and_create_codes"], "source_code": "@staticmethod\ndef _go_through_tree_and_create_codes(tree: Node, code: str, dict_codes: dict):\n    if tree.sign is not None:\n        dict_codes[tree.sign] = code\n    if tree.left:\n        HuffmanCoding._go_through_tree_and_create_codes(tree.left, code + '0', dict_codes)\n    if tree.right:\n        HuffmanCoding._go_through_tree_and_create_codes(tree.right, code + '1', dict_codes)"}}}}, "is_test": false}