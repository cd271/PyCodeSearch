{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dfs/sudoku_solver.py", "fileNameBase": "sudoku_solver", "extension": "py", "doc": {"long_description": "create a hash table (dictionary) val to store possible values in every location.\nEach time, start from the location with fewest possible values, choose one value\nfrom it and then update the board and possible values at other locations.\nIf this update is valid, keep solving (DFS). If this update is invalid (leaving\nzero possible values at some locations) or this value doesn't lead to the\nsolution, undo the updates and then choose the next value.\nSince we calculated val at the beginning and start filling the board from the\nlocation with fewest possible values, the amount of calculation and thus the\nruntime can be significantly reduced:\n\n\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest\npython solutions here.\n\n\nThe PossibleVals function may be further simplified/optimized, but it works just\nfine for now. (it would look less lengthy if we are allowed to use numpy array\nfor the board lol).", "short_description": "It's similar to how human solve Sudoku.", "full": "It's similar to how human solve Sudoku.\n\ncreate a hash table (dictionary) val to store possible values in every location.\nEach time, start from the location with fewest possible values, choose one value\nfrom it and then update the board and possible values at other locations.\nIf this update is valid, keep solving (DFS). If this update is invalid (leaving\nzero possible values at some locations) or this value doesn't lead to the\nsolution, undo the updates and then choose the next value.\nSince we calculated val at the beginning and start filling the board from the\nlocation with fewest possible values, the amount of calculation and thus the\nruntime can be significantly reduced:\n\n\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest\npython solutions here.\n\n\nThe PossibleVals function may be further simplified/optimized, but it works just\nfine for now. (it would look less lengthy if we are allowed to use numpy array\nfor the board lol)."}}, "classes": {"Sudoku": {"min_max_lineno": {"min_lineno": 23, "max_lineno": 96}, "methods": {"__init__": {"args": ["self", "board", "row", "col"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 29}, "calls": ["sudoku_solver.Sudoku.possible_values"], "store_vars_calls": {"self.val": "self.possible_values"}, "source_code": "def __init__(self, board, row, col):\n    self.board = board\n    self.row = row\n    self.col = col\n    self.val = self.possible_values()"}, "possible_values": {"args": ["self"], "returns": ["val"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 46}, "calls": ["range", "val.keys", "d.get"], "source_code": "def possible_values(self):\n    a = '123456789'\n    (d, val) = ({}, {})\n    for i in range(self.row):\n        for j in range(self.col):\n            ele = self.board[i][j]\n            if ele != '.':\n                d['r', i] = d.get(('r', i), []) + [ele]\n                d['c', j] = d.get(('c', j), []) + [ele]\n                d[i // 3, j // 3] = d.get((i // 3, j // 3), []) + [ele]\n            else:\n                val[i, j] = []\n    for (i, j) in val.keys():\n        inval = d.get(('r', i), []) + d.get(('c', j), []) + d.get((i / 3, j / 3), [])\n        val[i, j] = [n for n in a if n not in inval]\n    return val"}, "solve": {"args": ["self"], "returns": ["False", "True", "True"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 59}, "calls": ["min", "len", "sudoku_solver.Sudoku.val.keys", "sudoku_solver.Sudoku.valid_one", "sudoku_solver.Sudoku.undo", "sudoku_solver.Sudoku.solve"], "store_vars_calls": {"kee": "min"}, "source_code": "def solve(self):\n    if len(self.val) == 0:\n        return True\n    kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\n    nums = self.val[kee]\n    for n in nums:\n        update = {kee: self.val[kee]}\n        if self.valid_one(n, kee, update):\n            if self.solve():\n                return True\n        self.undo(kee, update)\n    return False"}, "valid_one": {"args": ["self", "n", "kee", "update"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 60, "max_lineno": 72}, "calls": ["sudoku_solver.Sudoku.val.keys", "sudoku_solver.Sudoku.val[].remove", "len"], "source_code": "def valid_one(self, n, kee, update):\n    self.board[kee[0]][kee[1]] = n\n    del self.val[kee]\n    (i, j) = kee\n    for ind in self.val.keys():\n        if n in self.val[ind]:\n            if ind[0] == i or ind[1] == j or (ind[0] / 3, ind[1] / 3) == (i / 3, j / 3):\n                update[ind] = n\n                self.val[ind].remove(n)\n                if len(self.val[ind]) == 0:\n                    return False\n    return True"}, "undo": {"args": ["self", "kee", "update"], "returns": ["None"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 81}, "calls": ["sudoku_solver.Sudoku.val[].append"], "source_code": "def undo(self, kee, update):\n    self.board[kee[0]][kee[1]] = '.'\n    for k in update:\n        if k not in self.val:\n            self.val[k] = update[k]\n        else:\n            self.val[k].append(update[k])\n    return None"}, "__str__": {"doc": {"long_description": "Generates a board representation as string.", "short_description": "[summary]", "returns": {"description": "[str] -- [board representation]", "is_generator": false}}, "args": ["self"], "returns": ["resp"], "min_max_lineno": {"min_lineno": 82, "max_lineno": 96}, "calls": ["range"], "source_code": "def __str__(self):\n    \"\"\"[summary]\n        Generates a board representation as string.\n\n        Returns:\n            [str] -- [board representation]\n        \"\"\"\n    resp = ''\n    for i in range(self.row):\n        for j in range(self.col):\n            resp += ' {0} '.format(self.board[i][j])\n        resp += '\\n'\n    return resp"}}}}, "is_test": false}