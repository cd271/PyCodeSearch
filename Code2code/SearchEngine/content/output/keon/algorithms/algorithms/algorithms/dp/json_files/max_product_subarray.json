{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/max_product_subarray.py", "fileNameBase": "max_product_subarray", "extension": "py", "doc": {"long_description": "(containing at least one number) which has the largest product.\n\nFor example, given the array [2,3,-2,4],\nthe contiguous subarray [2,3] has the largest product = 6.", "short_description": "Find the contiguous subarray within an array", "full": "Find the contiguous subarray within an array\n(containing at least one number) which has the largest product.\n\nFor example, given the array [2,3,-2,4],\nthe contiguous subarray [2,3] has the largest product = 6."}}, "dependencies": [{"from_module": "functools", "import": "reduce", "type": "external", "type_element": "module"}], "functions": {"max_product": {"args": ["nums"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 23}, "calls": ["max", "min"], "store_vars_calls": {"lmax": "max", "lmin": "min", "gmax": "max"}, "source_code": "def max_product(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    lmin = lmax = gmax = nums[0]\n    for num in nums:\n        t_1 = num * lmax\n        t_2 = num * lmin\n        lmax = max(max(t_1, t_2), num)\n        lmin = min(min(t_1, t_2), num)\n        gmax = max(gmax, lmax)"}, "subarray_with_max_product": {"doc": {"short_description": "arr is list of positive/negative numbers "}, "args": ["arr"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 67}, "calls": ["len", "range", "print", "functools.reduce"], "store_vars_calls": {"length": "len"}, "source_code": "def subarray_with_max_product(arr):\n    \"\"\" arr is list of positive/negative numbers \"\"\"\n    length = len(arr)\n    product_so_far = max_product_end = 1\n    max_start_i = 0\n    so_far_start_i = so_far_end_i = 0\n    all_negative_flag = True\n    for i in range(length):\n        max_product_end *= arr[i]\n        if arr[i] > 0:\n            all_negative_flag = False\n        if max_product_end <= 0:\n            max_product_end = arr[i]\n            max_start_i = i\n        if product_so_far <= max_product_end:\n            product_so_far = max_product_end\n            so_far_end_i = i\n            so_far_start_i = max_start_i\n    if all_negative_flag:\n        print(f'max_product_so_far: {reduce(lambda x, y: x * y, arr)}, {arr}')\n    else:\n        print(f'max_product_so_far: {product_so_far},{arr[so_far_start_i:so_far_end_i + 1]}')"}}, "is_test": false}