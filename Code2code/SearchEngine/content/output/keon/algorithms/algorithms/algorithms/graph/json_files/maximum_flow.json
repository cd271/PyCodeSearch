{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/maximum_flow.py", "fileNameBase": "maximum_flow", "extension": "py", "doc": {"long_description": "computes the maximum flow from source to sink.\nInput : capacity, source, sink\nOutput : maximum flow from source to sink\nCapacity is a two-dimensional array that is v*v.\ncapacity[i][j] implies the capacity of the edge from i to j.\nIf there is no edge from i to j, capacity[i][j] should be zero.", "short_description": "Given the capacity, source and sink of a graph,", "full": "Given the capacity, source and sink of a graph,\ncomputes the maximum flow from source to sink.\nInput : capacity, source, sink\nOutput : maximum flow from source to sink\nCapacity is a two-dimensional array that is v*v.\ncapacity[i][j] implies the capacity of the edge from i to j.\nIf there is no edge from i to j, capacity[i][j] should be zero."}}, "dependencies": [{"from_module": "queue", "import": "Queue", "type": "external", "type_element": "module"}], "functions": {"dfs": {"doc": {"short_description": "Depth First Search implementation for Ford-Fulkerson algorithm."}, "args": ["capacity", "flow", "visit", "vertices", "idx", "sink", "current_flow"], "returns": ["0", "current_flow", "tmp"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 32}, "calls": ["range", "min", "maximum_flow.dfs"], "store_vars_calls": {"available_flow": "min", "tmp": "dfs"}, "source_code": "def dfs(capacity, flow, visit, vertices, idx, sink, current_flow=1 << 63):\n    \"\"\"\n    Depth First Search implementation for Ford-Fulkerson algorithm.\n    \"\"\"\n    if idx == sink:\n        return current_flow\n    visit[idx] = True\n    for nxt in range(vertices):\n        if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dfs(capacity, flow, visit, vertices, nxt, sink, available_flow)\n            if tmp:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n    return 0"}, "ford_fulkerson": {"doc": {"long_description": "Time Complexity : O(Ef)\nE is the number of edges and f is the maximum flow in the graph.", "short_description": "Computes maximum flow from source to sink using DFS."}, "args": ["capacity", "source", "sink"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 50}, "calls": ["len", "maximum_flow.dfs", "range"], "store_vars_calls": {"vertices": "len", "tmp": "dfs"}, "source_code": "def ford_fulkerson(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using DFS.\n    Time Complexity : O(Ef)\n    E is the number of edges and f is the maximum flow in the graph.\n    \"\"\"\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        visit = [False for _ in range(vertices)]\n        tmp = dfs(capacity, flow, visit, vertices, source, sink)\n        if tmp:\n            ret += tmp\n        else:\n            break\n    return ret"}, "edmonds_karp": {"doc": {"long_description": "Time complexity : O(V*E^2)\nV is the number of vertices and E is the number of edges.", "short_description": "Computes maximum flow from source to sink using BFS."}, "args": ["capacity", "source", "sink"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 91}, "calls": ["len", "queue.Queue", "queue.Queue.put", "queue.Queue.qsize", "range", "queue.Queue.get", "min"], "store_vars_calls": {"vertices": "len", "queue": "Queue", "front": "queue.get"}, "source_code": "def edmonds_karp(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using BFS.\n    Time complexity : O(V*E^2)\n    V is the number of vertices and E is the number of edges.\n    \"\"\"\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        tmp = 0\n        queue = Queue()\n        visit = [False for _ in range(vertices)]\n        par = [-1 for _ in range(vertices)]\n        visit[source] = True\n        queue.put((source, 1 << 63))\n        while queue.qsize():\n            front = queue.get()\n            (idx, current_flow) = front\n            if idx == sink:\n                tmp = current_flow\n                break\n            for nxt in range(vertices):\n                if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n                    visit[nxt] = True\n                    par[nxt] = idx\n                    queue.put((nxt, min(current_flow, capacity[idx][nxt] - flow[idx][nxt])))\n        if par[sink] == -1:\n            break\n        ret += tmp\n        parent = par[sink]\n        idx = sink\n        while parent != -1:\n            flow[parent][idx] += tmp\n            flow[idx][parent] -= tmp\n            idx = parent\n            parent = par[parent]\n    return ret"}, "dinic_bfs": {"doc": {"long_description": "Check whether sink is reachable only using edges that is not full.", "short_description": "BFS function for Dinic algorithm."}, "args": ["capacity", "flow", "level", "source", "sink"], "returns": ["level[sink] != -1"], "min_max_lineno": {"min_lineno": 92, "max_lineno": 108}, "calls": ["len", "queue.Queue", "queue.Queue.put", "queue.Queue.qsize", "queue.Queue.get", "range"], "store_vars_calls": {"vertices": "len", "queue": "Queue", "front": "queue.get"}, "source_code": "def dinic_bfs(capacity, flow, level, source, sink):\n    \"\"\"\n    BFS function for Dinic algorithm.\n    Check whether sink is reachable only using edges that is not full.\n    \"\"\"\n    vertices = len(capacity)\n    queue = Queue()\n    queue.put(source)\n    level[source] = 0\n    while queue.qsize():\n        front = queue.get()\n        for nxt in range(vertices):\n            if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]:\n                level[nxt] = level[front] + 1\n                queue.put(nxt)\n    return level[sink] != -1"}, "dinic_dfs": {"doc": {"long_description": "Finds new flow using edges that is not full.", "short_description": "DFS function for Dinic algorithm."}, "args": ["capacity", "flow", "level", "idx", "sink", "work", "current_flow"], "returns": ["0", "current_flow", "tmp"], "min_max_lineno": {"min_lineno": 109, "max_lineno": 128}, "calls": ["len", "min", "maximum_flow.dinic_dfs"], "store_vars_calls": {"vertices": "len", "available_flow": "min", "tmp": "dinic_dfs"}, "source_code": "def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow=1 << 63):\n    \"\"\"\n    DFS function for Dinic algorithm.\n    Finds new flow using edges that is not full.\n    \"\"\"\n    if idx == sink:\n        return current_flow\n    vertices = len(capacity)\n    while work[idx] < vertices:\n        nxt = work[idx]\n        if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, available_flow)\n            if tmp > 0:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n        work[idx] += 1\n    return 0"}, "dinic": {"doc": {"long_description": "Time complexity : O(V^2*E)\nV is the number of vertices and E is the number of edges.", "short_description": "Computes maximum flow from source to sink using Dinic algorithm."}, "args": ["capacity", "source", "sink"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 129, "max_lineno": 150}, "calls": ["len", "range", "maximum_flow.dinic_bfs", "maximum_flow.dinic_dfs"], "store_vars_calls": {"vertices": "len", "tmp": "dinic_dfs"}, "source_code": "def dinic(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using Dinic algorithm.\n    Time complexity : O(V^2*E)\n    V is the number of vertices and E is the number of edges.\n    \"\"\"\n    vertices = len(capacity)\n    flow = [[0] * vertices for i in range(vertices)]\n    ret = 0\n    while True:\n        level = [-1 for i in range(vertices)]\n        work = [0 for i in range(vertices)]\n        if not dinic_bfs(capacity, flow, level, source, sink):\n            break\n        while True:\n            tmp = dinic_dfs(capacity, flow, level, source, sink, work)\n            if tmp > 0:\n                ret += tmp\n            else:\n                break\n    return ret"}}, "is_test": false}