{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/maximum_flow_bfs.py", "fileNameBase": "maximum_flow_bfs", "extension": "py", "doc": {"long_description": "it will give you a maximum flow.\nThis version use BFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23", "short_description": "Given a n*n adjacency array.", "full": "Given a n*n adjacency array.\nit will give you a maximum flow.\nThis version use BFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23"}}, "dependencies": [{"import": "copy", "type": "external", "type_element": "module"}, {"import": "queue", "type": "external", "type_element": "module"}, {"import": "math", "type": "external", "type_element": "module"}], "functions": {"maximum_flow_bfs": {"doc": {"short_description": "Get the maximum flow through a graph using a breadth first search"}, "args": ["adjacency_matrix"], "returns": ["total"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 88}, "calls": ["copy.deepcopy", "queue.Queue", "queue.Queue.put", "len", "queue.Queue.qsize", "queue.Queue.get", "range"], "store_vars_calls": {"new_array": "copy.deepcopy", "bfs": "queue.Queue", "src": "bfs.get"}, "source_code": "def maximum_flow_bfs(adjacency_matrix):\n    \"\"\"\n    Get the maximum flow through a graph using a breadth first search\n    \"\"\"\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min_flow = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        bfs = queue.Queue()\n        visited[0] = 1\n        bfs.put(0)\n        while bfs.qsize() > 0:\n            src = bfs.get()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    bfs.put(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min_flow > new_array[path[tmp]][tmp]:\n                min_flow = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min_flow\n            tmp = path[tmp]\n        total = total + min_flow\n    return total"}}, "is_test": false}