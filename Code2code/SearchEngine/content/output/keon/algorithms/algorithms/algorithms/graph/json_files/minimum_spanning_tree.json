{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/minimum_spanning_tree.py", "fileNameBase": "minimum_spanning_tree", "extension": "py", "doc": {"short_description": "Minimum spanning tree (MST) is going to use an undirected graph", "full": "Minimum spanning tree (MST) is going to use an undirected graph"}}, "dependencies": [{"import": "sys", "type": "external", "type_element": "module"}], "classes": {"Edge": {"doc": {"short_description": "An edge of an undirected graph", "full": "An edge of an undirected graph"}, "min_max_lineno": {"min_lineno": 8, "max_lineno": 17}, "methods": {"__init__": {"args": ["self", "source", "target", "weight"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 17}, "source_code": "def __init__(self, source, target, weight):\n    self.source = source\n    self.target = target\n    self.weight = weight"}}}, "DisjointSet": {"doc": {"long_description": "<n[i]> is the parent of the node at position <i>.\nIf <n[i]> = <i>, <i> it's a root, or a head, of a set", "short_description": "The disjoint set is represented with an list <n> of integers where", "full": "The disjoint set is represented with an list <n> of integers where\n<n[i]> is the parent of the node at position <i>.\nIf <n[i]> = <i>, <i> it's a root, or a head, of a set"}, "min_max_lineno": {"min_lineno": 19, "max_lineno": 68}, "methods": {"__init__": {"doc": {"long_description": "n (int): Number of vertices in the graph", "short_description": "Args:"}, "args": ["self", "size"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 36}, "calls": ["range"], "source_code": "def __init__(self, size):\n    \"\"\"\n        Args:\n            n (int): Number of vertices in the graph\n        \"\"\"\n    self.parent = [None] * size\n    self.size = [1] * size\n    for i in range(size):\n        self.parent[i] = i"}, "merge_set": {"doc": {"long_description": "node1, node2 (int): Indexes of nodes whose sets will be merged.", "short_description": "Args:"}, "args": ["self", "node1", "node2"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 55}, "calls": ["minimum_spanning_tree.DisjointSet.find_set"], "store_vars_calls": {"node1": "self.find_set", "node2": "self.find_set"}, "source_code": "def merge_set(self, node1, node2):\n    \"\"\"\n        Args:\n            node1, node2 (int): Indexes of nodes whose sets will be merged.\n        \"\"\"\n    node1 = self.find_set(node1)\n    node2 = self.find_set(node2)\n    if self.size[node1] < self.size[node2]:\n        self.parent[node1] = node2\n        self.size[node2] += self.size[node1]\n    else:\n        self.parent[node2] = node1\n        self.size[node1] += self.size[node2]"}, "find_set": {"doc": {"short_description": "Get the root element of the set containing <a>"}, "args": ["self", "node"], "returns": ["self.parent[node]"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 68}, "calls": ["minimum_spanning_tree.DisjointSet.find_set"], "source_code": "def find_set(self, node):\n    \"\"\"\n        Get the root element of the set containing <a>\n        \"\"\"\n    if self.parent[node] != node:\n        self.parent[node] = self.find_set(self.parent[node])\n    return self.parent[node]"}}}}, "functions": {"kruskal": {"doc": {"args": {"vertex_count": {"description": "Number of vertices in the graph", "type_name": "int", "is_optional": false}, "edges": {"description": "Edges of the graph", "type_name": "list of Edge", "is_optional": false}, "forest": {"description": "DisjointSet of the vertices", "type_name": "DisjointSet", "is_optional": false}}, "returns": {"description": "sum of weights of the minnimum spanning tree\nKruskal algorithm:\n    This algorithm will find the optimal graph with less edges and less\n    total weight to connect all vertices (MST), the MST will always contain\n    n-1 edges because it's the minimum required to connect n vertices.\n\nProcedure:\n    Sort the edges (criteria: less weight).\n    Only take edges of nodes in different sets.\n    If we take a edge, we need to merge the sets to discard these.\n    After repeat this until select n-1 edges, we will have the complete MST.", "type_name": "int", "is_generator": false}}, "args": ["vertex_count", "edges", "forest"], "returns": ["sum([edge.weight for edge in mst])"], "min_max_lineno": {"min_lineno": 70, "max_lineno": 106}, "calls": ["edges.sort", "sum", "forest.find_set", "forest.merge_set", "mst.append", "len"], "store_vars_calls": {"set_u": "forest.find_set", "set_v": "forest.find_set"}, "source_code": "def kruskal(vertex_count, edges, forest):\n    \"\"\"\n    Args:\n        vertex_count (int): Number of vertices in the graph\n        edges (list of Edge): Edges of the graph\n        forest (DisjointSet): DisjointSet of the vertices\n    Returns:\n        int: sum of weights of the minnimum spanning tree\n\n    Kruskal algorithm:\n        This algorithm will find the optimal graph with less edges and less\n        total weight to connect all vertices (MST), the MST will always contain\n        n-1 edges because it's the minimum required to connect n vertices.\n\n    Procedure:\n        Sort the edges (criteria: less weight).\n        Only take edges of nodes in different sets.\n        If we take a edge, we need to merge the sets to discard these.\n        After repeat this until select n-1 edges, we will have the complete MST.\n    \"\"\"\n    edges.sort(key=lambda edge: edge.weight)\n    mst = []\n    for edge in edges:\n        set_u = forest.find_set(edge.u)\n        set_v = forest.find_set(edge.v)\n        if set_u != set_v:\n            forest.merge_set(set_u, set_v)\n            mst.append(edge)\n            if len(mst) == vertex_count - 1:\n                break\n    return sum([edge.weight for edge in mst])"}, "main": {"doc": {"long_description": "Input consists of different weighted, connected, undirected graphs.\nline 1:\n  integers n, m\nlines 2..m+2:\n  edge with the format -> node index u, node index v, integer weight\n\nSamples of input:\n\n5 6\n1 2 3\n1 3 8\n2 4 5\n3 4 2\n3 5 4\n4 5 6\n\n3 3\n2 1 20\n3 1 20\n2 3 100\n\nSum of weights of the optimal paths:\n14, 40", "short_description": "Test. How input works:"}, "min_max_lineno": {"min_lineno": 108, "max_lineno": 149}, "calls": ["map", "range", "print", "size.split", "minimum_spanning_tree.kruskal", "input().split", "input"], "store_vars_calls": {"forest": "DisjointSet"}, "source_code": "def main():\n    \"\"\"\n    Test. How input works:\n    Input consists of different weighted, connected, undirected graphs.\n    line 1:\n      integers n, m\n    lines 2..m+2:\n      edge with the format -> node index u, node index v, integer weight\n\n    Samples of input:\n\n    5 6\n    1 2 3\n    1 3 8\n    2 4 5\n    3 4 2\n    3 5 4\n    4 5 6\n\n    3 3\n    2 1 20\n    3 1 20\n    2 3 100\n\n    Sum of weights of the optimal paths:\n    14, 40\n    \"\"\"\n    for size in sys.stdin:\n        (vertex_count, edge_count) = map(int, size.split())\n        forest = DisjointSet(edge_count)\n        edges = [None] * edge_count\n        for i in range(edge_count):\n            (source, target, weight) = map(int, input().split())\n            source -= 1\n            target -= 1\n            edges[i] = Edge(source, target, weight)\n        print('MST weights sum:', kruskal(vertex_count, edges, forest))"}}, "body": {"calls": ["minimum_spanning_tree.main"], "source_code": ["main()"]}, "main_info": {"main_flag": 1, "main_function": "minimum_spanning_tree.main", "type": "script"}, "is_test": false}