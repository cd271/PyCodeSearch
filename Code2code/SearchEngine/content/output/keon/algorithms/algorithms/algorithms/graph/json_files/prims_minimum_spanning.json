{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/prims_minimum_spanning.py", "fileNameBase": "prims_minimum_spanning", "extension": "py", "doc": {"long_description": "of a connected graph.\nFor argument graph, it should be a dictionary type such as:\n\n    graph = {\n        'a': [ [3, 'b'], [8,'c'] ],\n        'b': [ [3, 'a'], [5, 'd'] ],\n        'c': [ [8, 'a'], [2, 'd'], [4, 'e'] ],\n        'd': [ [5, 'b'], [2, 'c'], [6, 'e'] ],\n        'e': [ [4, 'c'], [6, 'd'] ]\n    }\n\nwhere 'a','b','c','d','e' are nodes (these can be 1,2,3,4,5 as well)", "short_description": "This Prim's Algorithm Code is for finding weight of minimum spanning tree", "full": "This Prim's Algorithm Code is for finding weight of minimum spanning tree\nof a connected graph.\nFor argument graph, it should be a dictionary type such as:\n\n    graph = {\n        'a': [ [3, 'b'], [8,'c'] ],\n        'b': [ [3, 'a'], [5, 'd'] ],\n        'c': [ [8, 'a'], [2, 'd'], [4, 'e'] ],\n        'd': [ [5, 'b'], [2, 'c'], [6, 'e'] ],\n        'e': [ [4, 'c'], [6, 'd'] ]\n    }\n\nwhere 'a','b','c','d','e' are nodes (these can be 1,2,3,4,5 as well)"}}, "dependencies": [{"import": "heapq", "type": "external", "type_element": "module"}], "functions": {"prims_minimum_spanning": {"doc": {"short_description": "Prim's algorithm to find weight of minimum spanning tree"}, "args": ["graph_used"], "returns": ["mincost"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 43}, "calls": ["set", "len", "heapq.heappop", "set.add", "vis.append", "heapq.heappush"], "store_vars_calls": {"prim": "set"}, "source_code": "def prims_minimum_spanning(graph_used):\n    \"\"\"\n    Prim's algorithm to find weight of minimum spanning tree\n    \"\"\"\n    vis = []\n    heap = [[0, 1]]\n    prim = set()\n    mincost = 0\n    while len(heap) > 0:\n        (cost, node) = heapq.heappop(heap)\n        if node in vis:\n            continue\n        mincost += cost\n        prim.add(node)\n        vis.append(node)\n        for (distance, adjacent) in graph_used[node]:\n            if adjacent not in vis:\n                heapq.heappush(heap, [distance, adjacent])\n    return mincost"}}, "is_test": false}