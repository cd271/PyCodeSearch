{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/satisfiability.py", "fileNameBase": "satisfiability", "extension": "py", "doc": {"long_description": "True/False values to all variables to satisfy all clauses, or reports there\nis no solution.\n\nhttps://en.wikipedia.org/wiki/2-satisfiability\n\n\nFormat:\n        - each clause is a pair of literals\n        - each literal in the form (name, is_neg)\n          where name is an arbitrary identifier,\n          and is_neg is true if the literal is negated", "short_description": "Given a formula in conjunctive normal form (2-CNF), finds a way to assign", "full": "Given a formula in conjunctive normal form (2-CNF), finds a way to assign\nTrue/False values to all variables to satisfy all clauses, or reports there\nis no solution.\n\nhttps://en.wikipedia.org/wiki/2-satisfiability\n\n\nFormat:\n        - each clause is a pair of literals\n        - each literal in the form (name, is_neg)\n          where name is an arbitrary identifier,\n          and is_neg is true if the literal is negated"}}, "functions": {"dfs_transposed": {"doc": {"long_description": "Stores the order in which nodes were visited to the list, in transposed order.", "short_description": "Perform a depth first search traversal of the graph starting at the given vertex."}, "args": ["vertex", "graph", "order", "visited"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 28}, "calls": ["order.append", "satisfiability.dfs_transposed"], "source_code": "def dfs_transposed(vertex, graph, order, visited):\n    \"\"\"\n    Perform a depth first search traversal of the graph starting at the given vertex.\n    Stores the order in which nodes were visited to the list, in transposed order.\n    \"\"\"\n    visited[vertex] = True\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs_transposed(adjacent, graph, order, visited)\n    order.append(vertex)"}, "dfs": {"doc": {"long_description": "Records all visited nodes as being of a certain strongly connected component.", "short_description": "Perform a depth first search traversal of the graph starting at the given vertex."}, "args": ["vertex", "current_comp", "vertex_scc", "graph", "visited"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 41}, "calls": ["satisfiability.dfs"], "source_code": "def dfs(vertex, current_comp, vertex_scc, graph, visited):\n    \"\"\"\n    Perform a depth first search traversal of the graph starting at the given vertex.\n    Records all visited nodes as being of a certain strongly connected component.\n    \"\"\"\n    visited[vertex] = True\n    vertex_scc[vertex] = current_comp\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs(adjacent, current_comp, vertex_scc, graph, visited)"}, "add_edge": {"doc": {"short_description": "Add a directed edge to the graph."}, "args": ["graph", "vertex_from", "vertex_to"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 51}, "calls": ["graph[].append"], "source_code": "def add_edge(graph, vertex_from, vertex_to):\n    \"\"\"\n    Add a directed edge to the graph.\n    \"\"\"\n    if vertex_from not in graph:\n        graph[vertex_from] = []\n    graph[vertex_from].append(vertex_to)"}, "scc": {"doc": {"short_description": "Computes the strongly connected components of a graph "}, "args": ["graph"], "returns": ["vertex_scc"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 79}, "calls": ["graph.iteritems", "reversed", "satisfiability.add_edge", "satisfiability.dfs_transposed", "satisfiability.dfs"], "source_code": "def scc(graph):\n    \"\"\" Computes the strongly connected components of a graph \"\"\"\n    order = []\n    visited = {vertex: False for vertex in graph}\n    graph_transposed = {vertex: [] for vertex in graph}\n    for (source, neighbours) in graph.iteritems():\n        for target in neighbours:\n            add_edge(graph_transposed, target, source)\n    for vertex in graph:\n        if not visited[vertex]:\n            dfs_transposed(vertex, graph_transposed, order, visited)\n    visited = {vertex: False for vertex in graph}\n    vertex_scc = {}\n    current_comp = 0\n    for vertex in reversed(order):\n        if not visited[vertex]:\n            dfs(vertex, current_comp, vertex_scc, graph, visited)\n            current_comp += 1\n    return vertex_scc"}, "build_graph": {"doc": {"short_description": "Builds the implication graph from the formula "}, "args": ["formula"], "returns": ["graph"], "min_max_lineno": {"min_lineno": 81, "max_lineno": 95}, "calls": ["satisfiability.add_edge"], "source_code": "def build_graph(formula):\n    \"\"\" Builds the implication graph from the formula \"\"\"\n    graph = {}\n    for clause in formula:\n        for (lit, _) in clause:\n            for neg in [False, True]:\n                graph[lit, neg] = []\n    for ((a_lit, a_neg), (b_lit, b_neg)) in formula:\n        add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg))\n        add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg))\n    return graph"}, "solve_sat": {"doc": {"short_description": "Solves the 2-SAT problem"}, "args": ["formula"], "returns": ["value", "None"], "min_max_lineno": {"min_lineno": 97, "max_lineno": 127}, "calls": ["satisfiability.build_graph", "satisfiability.scc", "sorted", "scc.values"], "store_vars_calls": {"graph": "build_graph", "vertex_scc": "scc", "components": "sorted"}, "source_code": "def solve_sat(formula):\n    \"\"\"\n    Solves the 2-SAT problem\n    \"\"\"\n    graph = build_graph(formula)\n    vertex_scc = scc(graph)\n    for (var, _) in graph:\n        if vertex_scc[var, False] == vertex_scc[var, True]:\n            return None\n    comp_repr = {}\n    for vertex in graph:\n        if not vertex_scc[vertex] in comp_repr:\n            comp_repr[vertex_scc[vertex]] = vertex\n    comp_value = {}\n    components = sorted(vertex_scc.values())\n    for comp in components:\n        if comp not in comp_value:\n            comp_value[comp] = False\n            (lit, neg) = comp_repr[comp]\n            comp_value[vertex_scc[lit, not neg]] = True\n    value = {var: comp_value[vertex_scc[var, False]] for (var, _) in graph}\n    return value"}, "main": {"doc": {"short_description": "Entry point for testing"}, "min_max_lineno": {"min_lineno": 129, "max_lineno": 143}, "calls": ["satisfiability.solve_sat", "solve_sat.items", "print"], "store_vars_calls": {"result": "solve_sat"}, "source_code": "def main():\n    \"\"\"\n    Entry point for testing\n    \"\"\"\n    formula = [(('x', False), ('y', False)), (('y', True), ('y', True)), (('a', False), ('b', False)), (('a', True), ('c', True)), (('c', False), ('b', True))]\n    result = solve_sat(formula)\n    for (variable, assign) in result.items():\n        print(f'{variable}:{assign}')"}}, "body": {"calls": ["satisfiability.main"], "source_code": ["main()"]}, "main_info": {"main_flag": 1, "main_function": "satisfiability.main", "type": "script"}, "is_test": false}