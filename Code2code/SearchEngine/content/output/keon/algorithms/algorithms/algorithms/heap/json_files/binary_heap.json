{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/heap/binary_heap.py", "fileNameBase": "binary_heap", "extension": "py", "doc": {"long_description": "its children. The root, therefore, is the minimum element in the tree. The min\nheap uses an array to represent the data and operation. For example a min heap:\n\n     4\n   /   \\\n  50    7\n / \\   /\n55 90 87\n\nHeap [0, 4, 50, 7, 55, 90, 87]\n\nMethod in class: insert, remove_min\nFor example insert(2) in a min heap:\n\n     4                     4                     2\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     2       -->     50    4\n / \\   /  \\           /  \\   / \\             /  \\  /  \\\n55 90 87   2         55  90 87  7           55  90 87  7\n\nFor example remove_min() in a min heap:\n\n     4                     87                    7\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     7       -->     50    87\n / \\   /              /  \\                   /  \\\n55 90 87             55  90                 55  90", "short_description": "Binary Heap. A min heap is a complete binary tree where each node is smaller than", "full": "Binary Heap. A min heap is a complete binary tree where each node is smaller than\nits children. The root, therefore, is the minimum element in the tree. The min\nheap uses an array to represent the data and operation. For example a min heap:\n\n     4\n   /   \\\n  50    7\n / \\   /\n55 90 87\n\nHeap [0, 4, 50, 7, 55, 90, 87]\n\nMethod in class: insert, remove_min\nFor example insert(2) in a min heap:\n\n     4                     4                     2\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     2       -->     50    4\n / \\   /  \\           /  \\   / \\             /  \\  /  \\\n55 90 87   2         55  90 87  7           55  90 87  7\n\nFor example remove_min() in a min heap:\n\n     4                     87                    7\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     7       -->     50    87\n / \\   /              /  \\                   /  \\\n55 90 87             55  90                 55  90"}}, "dependencies": [{"from_module": "abc", "import": "ABCMeta", "type": "external", "type_element": "module"}, {"from_module": "abc", "import": "abstractmethod", "type": "external", "type_element": "module"}], "classes": {"AbstractHeap": {"doc": {"short_description": "Abstract Class for Binary Heap.", "full": "Abstract Class for Binary Heap."}, "min_max_lineno": {"min_lineno": 35, "max_lineno": 60}, "methods": {"__init__": {"doc": {"short_description": "Pass."}, "args": ["self"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 40}, "source_code": "def __init__(self):\n    \"\"\"Pass.\"\"\""}, "perc_up": {"doc": {"short_description": "Pass."}, "args": ["self", "i"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 44}, "source_code": "@abstractmethod\ndef perc_up(self, i):\n    \"\"\"Pass.\"\"\""}, "insert": {"doc": {"short_description": "Pass."}, "args": ["self", "val"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 48}, "source_code": "@abstractmethod\ndef insert(self, val):\n    \"\"\"Pass.\"\"\""}, "perc_down": {"doc": {"short_description": "Pass."}, "args": ["self", "i"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 52}, "source_code": "@abstractmethod\ndef perc_down(self, i):\n    \"\"\"Pass.\"\"\""}, "min_child": {"doc": {"short_description": "Pass."}, "args": ["self", "i"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 56}, "source_code": "@abstractmethod\ndef min_child(self, i):\n    \"\"\"Pass.\"\"\""}, "remove_min": {"doc": {"short_description": "Pass."}, "args": ["self"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 60}, "source_code": "@abstractmethod\ndef remove_min(self):\n    \"\"\"Pass.\"\"\""}}}, "BinaryHeap": {"doc": {"short_description": "Binary Heap Class", "full": "Binary Heap Class"}, "extend": ["AbstractHeap"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 123}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 68}, "source_code": "def __init__(self):\n    self.current_size = 0\n    self.heap = [0]"}, "perc_up": {"args": ["self", "i"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 75}, "source_code": "def perc_up(self, i):\n    while i // 2 > 0:\n        if self.heap[i] < self.heap[i // 2]:\n            (self.heap[i], self.heap[i // 2]) = (self.heap[i // 2], self.heap[i])\n        i = i // 2"}, "insert": {"doc": {"long_description": "It inserts rightmost spot so as to maintain the complete tree property.\nThen, it fixes the tree by swapping the new element with its parent,\nuntil it finds an appropriate spot for the element. It essentially\nperc_up the minimum element\nComplexity: O(logN)", "short_description": "Method insert always start by inserting the element at the bottom."}, "args": ["self", "val"], "min_max_lineno": {"min_lineno": 76, "max_lineno": 90}, "calls": ["binary_heap.BinaryHeap.heap.append", "binary_heap.BinaryHeap.perc_up"], "source_code": "def insert(self, val):\n    \"\"\"\n        Method insert always start by inserting the element at the bottom.\n        It inserts rightmost spot so as to maintain the complete tree property.\n        Then, it fixes the tree by swapping the new element with its parent,\n        until it finds an appropriate spot for the element. It essentially\n        perc_up the minimum element\n        Complexity: O(logN)\n        \"\"\"\n    self.heap.append(val)\n    self.current_size = self.current_size + 1\n    self.perc_up(self.current_size)\n    '\\n        Method min_child returns the index of smaller of 2 children of parent at index i\\n        '"}, "min_child": {"args": ["self", "i"], "returns": ["2 * i", "2 * i", "2 * i + 1"], "min_max_lineno": {"min_lineno": 93, "max_lineno": 99}, "source_code": "def min_child(self, i):\n    if 2 * i + 1 > self.current_size:\n        return 2 * i\n    if self.heap[2 * i] > self.heap[2 * i + 1]:\n        return 2 * i + 1\n    return 2 * i"}, "perc_down": {"args": ["self", "i"], "min_max_lineno": {"min_lineno": 100, "max_lineno": 107}, "calls": ["binary_heap.BinaryHeap.min_child"], "store_vars_calls": {"min_child": "self.min_child"}, "source_code": "def perc_down(self, i):\n    while 2 * i < self.current_size:\n        min_child = self.min_child(i)\n        if self.heap[min_child] < self.heap[i]:\n            (self.heap[min_child], self.heap[i]) = (self.heap[i], self.heap[min_child])\n        i = min_child"}, "remove_min": {"args": ["self"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 115, "max_lineno": 123}, "calls": ["binary_heap.BinaryHeap.heap.pop", "binary_heap.BinaryHeap.perc_down"], "source_code": "def remove_min(self):\n    ret = self.heap[1]\n    self.heap[1] = self.heap[self.current_size]\n    self.current_size = self.current_size - 1\n    self.heap.pop()\n    self.perc_down(1)\n    return ret"}}}}, "is_test": false}