{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/modular_inverse.py", "fileNameBase": "modular_inverse", "extension": "py"}, "functions": {"extended_gcd": {"doc": {"long_description": "Return s, t, g\nsuch that a * s + b * t = GCD(a, b)\nand s and t are co-prime.", "short_description": "Extended GCD algorithm."}, "args": ["a", "b"], "annotated_arg_types": {"a": "int", "b": "int"}, "annotated_return_type": "[int, int, int]", "returns": [["old_s", "old_t", "old_r"]], "min_max_lineno": {"min_lineno": 4, "max_lineno": 23}, "source_code": "def extended_gcd(a: int, b: int) -> [int, int, int]:\n    \"\"\"Extended GCD algorithm.\n    Return s, t, g\n    such that a * s + b * t = GCD(a, b)\n    and s and t are co-prime.\n    \"\"\"\n    (old_s, s) = (1, 0)\n    (old_t, t) = (0, 1)\n    (old_r, r) = (a, b)\n    while r != 0:\n        quotient = old_r // r\n        (old_r, r) = (r, old_r - quotient * r)\n        (old_s, s) = (s, old_s - quotient * s)\n        (old_t, t) = (t, old_t - quotient * t)\n    return (old_s, old_t, old_r)"}, "modular_inverse": {"doc": {"long_description": "a and m must be coprime", "short_description": "Returns x such that a * x = 1 (mod m)"}, "args": ["a", "m"], "annotated_arg_types": {"a": "int", "m": "int"}, "annotated_return_type": "int", "returns": ["s % m"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 35}, "calls": ["modular_inverse.extended_gcd", "ValueError"], "source_code": "def modular_inverse(a: int, m: int) -> int:\n    \"\"\"\n    Returns x such that a * x = 1 (mod m)\n    a and m must be coprime\n    \"\"\"\n    (s, _, g) = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError('a and m must be coprime')\n    return s % m"}}, "is_test": false}