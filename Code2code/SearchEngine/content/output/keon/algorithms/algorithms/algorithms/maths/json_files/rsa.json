{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/rsa.py", "fileNameBase": "rsa", "extension": "py", "doc": {"long_description": "a method for encrypting a number that uses seperate encryption and decryption keys\nthis file only implements the key generation algorithm\n\nthere are three important numbers in RSA called n, e, and d\ne is called the encryption exponent\nd is called the decryption exponent\nn is called the modulus\n\nthese three numbers satisfy\n((x ** e) ** d) % n == x % n\n\nto use this system for encryption, n and e are made publicly available, and d is kept secret\na number x can be encrypted by computing (x ** e) % n\nthe original number can then be recovered by computing (E ** d) % n, where E is\nthe encrypted number\n\nfortunately, python provides a three argument version of pow() that can compute powers modulo\na number very quickly:\n(a ** b) % c == pow(a,b,c)", "short_description": "RSA encryption algorithm", "full": "RSA encryption algorithm\na method for encrypting a number that uses seperate encryption and decryption keys\nthis file only implements the key generation algorithm\n\nthere are three important numbers in RSA called n, e, and d\ne is called the encryption exponent\nd is called the decryption exponent\nn is called the modulus\n\nthese three numbers satisfy\n((x ** e) ** d) % n == x % n\n\nto use this system for encryption, n and e are made publicly available, and d is kept secret\na number x can be encrypted by computing (x ** e) % n\nthe original number can then be recovered by computing (E ** d) % n, where E is\nthe encrypted number\n\nfortunately, python provides a three argument version of pow() that can compute powers modulo\na number very quickly:\n(a ** b) % c == pow(a,b,c)"}}, "dependencies": [{"import": "random", "type": "external", "type_element": "module"}], "functions": {"generate_key": {"doc": {"long_description": "k is the number of bits in n", "short_description": "the RSA key generating algorithm"}, "args": ["k", "seed"], "returns": [["int(n)", "int(e)", "int(d)"], "b", "True", "True", "key", "False"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 86}, "calls": ["rsa.generate_key.gen_prime"], "store_vars_calls": {"e": "gen_prime", "d": "modinv", "p": "gen_prime", "q": "gen_prime", "key": "random.randrange"}, "functions": {"modinv": {"doc": {"long_description": "that is, find b such that (a * b) % m == 1", "short_description": "calculate the inverse of a mod m"}, "args": ["a", "m"], "returns": ["b"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 47}, "source_code": "def modinv(a, m):\n    \"\"\"calculate the inverse of a mod m\n        that is, find b such that (a * b) % m == 1\"\"\"\n    b = 1\n    while not a * b % m == 1:\n        b += 1\n    return b"}, "gen_prime": {"doc": {"short_description": "generate a prime with k bits"}, "args": ["k", "seed"], "returns": ["True", "True", "key", "False"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 64}, "calls": ["random.seed", "range", "random.randrange", "rsa.generate_key.gen_prime.is_prime"], "store_vars_calls": {"key": "random.randrange"}, "functions": {"is_prime": {"args": ["num"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 58}, "calls": ["range", "int"], "source_code": "def is_prime(num):\n    if num == 2:\n        return True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True"}}, "source_code": "def gen_prime(k, seed=None):\n    \"\"\"generate a prime with k bits\"\"\"\n\n    def is_prime(num):\n        if num == 2:\n            return True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    random.seed(seed)\n    while True:\n        key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n        if is_prime(key):\n            return key"}}, "source_code": "def generate_key(k, seed=None):\n    \"\"\"\n    the RSA key generating algorithm\n    k is the number of bits in n\n    \"\"\"\n\n    def modinv(a, m):\n        \"\"\"calculate the inverse of a mod m\n        that is, find b such that (a * b) % m == 1\"\"\"\n        b = 1\n        while not a * b % m == 1:\n            b += 1\n        return b\n\n    def gen_prime(k, seed=None):\n        \"\"\"generate a prime with k bits\"\"\"\n\n        def is_prime(num):\n            if num == 2:\n                return True\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        random.seed(seed)\n        while True:\n            key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n            if is_prime(key):\n                return key\n    p_size = k / 2\n    q_size = k - p_size\n    e = gen_prime(k, seed)\n    while True:\n        p = gen_prime(p_size, seed)\n        if p % e != 1:\n            break\n    while True:\n        q = gen_prime(q_size, seed)\n        if q % e != 1:\n            break\n    n = p * q\n    l = (p - 1) * (q - 1)\n    d = modinv(e, l)\n    return (int(n), int(e), int(d))"}, "encrypt": {"args": ["data", "e", "n"], "returns": ["pow(int(data), int(e), int(n))"], "min_max_lineno": {"min_lineno": 88, "max_lineno": 90}, "calls": ["pow", "int"], "source_code": "def encrypt(data, e, n):\n    return pow(int(data), int(e), int(n))"}, "decrypt": {"args": ["data", "d", "n"], "returns": ["pow(int(data), int(d), int(n))"], "min_max_lineno": {"min_lineno": 92, "max_lineno": 94}, "calls": ["pow", "int"], "source_code": "def decrypt(data, d, n):\n    return pow(int(data), int(d), int(n))"}}, "is_test": false}