{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/symmetry_group_cycle_index.py", "fileNameBase": "symmetry_group_cycle_index", "extension": "py", "doc": {"long_description": "is deeply rooted in counting the number of configurations\nof an object excluding those that are symmetric (in terms of permutations).\n\nFor example, the following problem can be solved as a direct\napplication of the cycle index polynomial of the symmetry\ngroup.\n\nNote: I came across this problem as a Google's foo.bar challenge at Level 5\nand solved it using a purely Group Theoretic approach. :)\n-----\n\nProblem:\n\nGiven positive integers\nw, h, and s,\ncompute the number of distinct 2D\ngrids of dimensions w x h that contain\nentries from {0, 1, ..., s-1}.\nNote that two grids are defined\nto be equivalent if one can be\nobtained from the other by\nswitching rows and columns\nsome number of times.\n\n-----\n\nApproach:\n\nCompute the cycle index (polynomials)\nof S_w, and S_h, i.e. the Symmetry\ngroup on w and h symbols respectively.\n\nCompute the product of the two\ncycle indices while combining two\nmonomials in such a way that\nfor any pair of cycles c1, and c2\nin the elements of S_w X S_h,\nthe resultant monomial contains\nterms of the form:\n$$ x_{lcm(|c1|, |c2|)}^{gcd(|c1|, |c2|)} $$\n\nReturn the specialization of\nthe product of cycle indices\nat x_i = s (for all the valid i).\n\n-----\n\nCode:\n\ndef solve(w, h, s):\n    s1 = get_cycle_index_sym(w)\n    s2 = get_cycle_index_sym(h)\n\n    result = cycle_product_for_two_polynomials(s1, s2, s)\n\n    return str(result)", "short_description": "The significance of the cycle index (polynomial) of symmetry group", "full": "The significance of the cycle index (polynomial) of symmetry group\nis deeply rooted in counting the number of configurations\nof an object excluding those that are symmetric (in terms of permutations).\n\nFor example, the following problem can be solved as a direct\napplication of the cycle index polynomial of the symmetry\ngroup.\n\nNote: I came across this problem as a Google's foo.bar challenge at Level 5\nand solved it using a purely Group Theoretic approach. :)\n-----\n\nProblem:\n\nGiven positive integers\nw, h, and s,\ncompute the number of distinct 2D\ngrids of dimensions w x h that contain\nentries from {0, 1, ..., s-1}.\nNote that two grids are defined\nto be equivalent if one can be\nobtained from the other by\nswitching rows and columns\nsome number of times.\n\n-----\n\nApproach:\n\nCompute the cycle index (polynomials)\nof S_w, and S_h, i.e. the Symmetry\ngroup on w and h symbols respectively.\n\nCompute the product of the two\ncycle indices while combining two\nmonomials in such a way that\nfor any pair of cycles c1, and c2\nin the elements of S_w X S_h,\nthe resultant monomial contains\nterms of the form:\n$$ x_{lcm(|c1|, |c2|)}^{gcd(|c1|, |c2|)} $$\n\nReturn the specialization of\nthe product of cycle indices\nat x_i = s (for all the valid i).\n\n-----\n\nCode:\n\ndef solve(w, h, s):\n    s1 = get_cycle_index_sym(w)\n    s2 = get_cycle_index_sym(h)\n\n    result = cycle_product_for_two_polynomials(s1, s2, s)\n\n    return str(result)"}}, "dependencies": [{"from_module": "fractions", "import": "Fraction", "type": "external", "type_element": "module"}, {"from_module": "typing", "import": "Dict", "type": "external", "type_element": "module"}, {"from_module": "typing", "import": "Union", "type": "external", "type_element": "module"}, {"from_module": "polynomial", "import": "Monomial", "type": "internal", "type_element": "module"}, {"from_module": "polynomial", "import": "Polynomial", "type": "internal", "type_element": "module"}, {"from_module": "gcd", "import": "lcm", "type": "internal", "type_element": "module"}], "functions": {"cycle_product": {"doc": {"long_description": "cycle index of a symmetry group),\ncompute the resultant monomial\nin the cartesian product\ncorresponding to their merging.", "short_description": "Given two monomials (from the"}, "args": ["m1", "m2"], "annotated_arg_types": {"m1": "Monomial", "m2": "Monomial"}, "annotated_return_type": "Monomial", "returns": ["Monomial(result_variables, Fraction(m1.coeff * m2.coeff, 1))"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 89}, "calls": ["dict", "polynomial.Monomial", "isinstance", "fractions.Fraction", "gcd.lcm"], "store_vars_calls": {"result_variables": "dict", "k": "lcm"}, "source_code": "def cycle_product(m1: Monomial, m2: Monomial) -> Monomial:\n    \"\"\"\n    Given two monomials (from the\n    cycle index of a symmetry group),\n    compute the resultant monomial\n    in the cartesian product\n    corresponding to their merging.\n    \"\"\"\n    assert isinstance(m1, Monomial) and isinstance(m2, Monomial)\n    A = m1.variables\n    B = m2.variables\n    result_variables = dict()\n    for i in A:\n        for j in B:\n            k = lcm(i, j)\n            g = i * j // k\n            if k in result_variables:\n                result_variables[k] += A[i] * B[j] * g\n            else:\n                result_variables[k] = A[i] * B[j] * g\n    return Monomial(result_variables, Fraction(m1.coeff * m2.coeff, 1))"}, "cycle_product_for_two_polynomials": {"doc": {"long_description": "given cycle indices p1,\nand p2 and evaluate it at q.", "short_description": "Compute the product of"}, "args": ["p1", "p2", "q"], "annotated_arg_types": {"p1": "Polynomial", "p2": "Polynomial", "q": "Union[float, int, Fraction]"}, "annotated_return_type": "Union[float, int, Fraction]", "returns": ["ans"], "min_max_lineno": {"min_lineno": 91, "max_lineno": 103}, "calls": ["fractions.Fraction", "cycle_product().substitute", "symmetry_group_cycle_index.cycle_product"], "store_vars_calls": {"ans": "Fraction"}, "source_code": "def cycle_product_for_two_polynomials(p1: Polynomial, p2: Polynomial, q: Union[float, int, Fraction]) -> Union[float, int, Fraction]:\n    \"\"\"\n    Compute the product of\n    given cycle indices p1,\n    and p2 and evaluate it at q.\n    \"\"\"\n    ans = Fraction(0, 1)\n    for m1 in p1.monomials:\n        for m2 in p2.monomials:\n            ans += cycle_product(m1, m2).substitute(q)\n    return ans"}, "cycle_index_sym_helper": {"doc": {"long_description": "of the cycle index.\n\nThe recurrence is given in:\nhttps://en.wikipedia.org/wiki/Cycle_index#Symmetric_group_Sn", "short_description": "A helper for the dp-style evaluation"}, "args": ["n", "memo"], "annotated_arg_types": {"n": "int", "memo": "Dict[int, Polynomial]"}, "annotated_return_type": "Polynomial", "returns": ["memo[n]", "memo[n]"], "min_max_lineno": {"min_lineno": 105, "max_lineno": 122}, "calls": ["polynomial.Polynomial", "range", "fractions.Fraction", "ans.__add__.__add__", "polynomial.Monomial", "symmetry_group_cycle_index.cycle_index_sym_helper"], "store_vars_calls": {"ans": "ans.__add__"}, "source_code": "def cycle_index_sym_helper(n: int, memo: Dict[int, Polynomial]) -> Polynomial:\n    \"\"\"\n    A helper for the dp-style evaluation\n    of the cycle index.\n\n    The recurrence is given in:\n    https://en.wikipedia.org/wiki/Cycle_index#Symmetric_group_Sn\n\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    ans = Polynomial([Monomial({}, Fraction(0, 1))])\n    for t in range(1, n + 1):\n        ans = ans.__add__(Polynomial([Monomial({t: 1}, Fraction(1, 1))]) * cycle_index_sym_helper(n - t, memo))\n    ans *= Fraction(1, n)\n    memo[n] = ans\n    return memo[n]"}, "get_cycle_index_sym": {"doc": {"long_description": "of S_n, i.e. the symmetry\ngroup of n symbols.", "short_description": "Compute the cycle index"}, "args": ["n"], "annotated_arg_types": {"n": "int"}, "annotated_return_type": "Polynomial", "returns": ["result"], "min_max_lineno": {"min_lineno": 124, "max_lineno": 160}, "calls": ["symmetry_group_cycle_index.cycle_index_sym_helper", "ValueError", "polynomial.Polynomial", "polynomial.Monomial", "fractions.Fraction"], "store_vars_calls": {"result": "cycle_index_sym_helper"}, "source_code": "def get_cycle_index_sym(n: int) -> Polynomial:\n    \"\"\"\n    Compute the cycle index\n    of S_n, i.e. the symmetry\n    group of n symbols.\n\n    \"\"\"\n    if n < 0:\n        raise ValueError('n should be a non-negative integer.')\n    memo = {0: Polynomial([Monomial({}, Fraction(1, 1))]), 1: Polynomial([Monomial({1: 1}, Fraction(1, 1))]), 2: Polynomial([Monomial({1: 2}, Fraction(1, 2)), Monomial({2: 1}, Fraction(1, 2))]), 3: Polynomial([Monomial({1: 3}, Fraction(1, 6)), Monomial({1: 1, 2: 1}, Fraction(1, 2)), Monomial({3: 1}, Fraction(1, 3))]), 4: Polynomial([Monomial({1: 4}, Fraction(1, 24)), Monomial({2: 1, 1: 2}, Fraction(1, 4)), Monomial({3: 1, 1: 1}, Fraction(1, 3)), Monomial({2: 2}, Fraction(1, 8)), Monomial({4: 1}, Fraction(1, 4))])}\n    result = cycle_index_sym_helper(n, memo)\n    return result"}}, "is_test": true}