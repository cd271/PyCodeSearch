{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/cholesky_matrix_decomposition.py", "fileNameBase": "cholesky_matrix_decomposition", "extension": "py", "doc": {"long_description": "Hermitian positive-definite matrix A\ninto matrix V, so that V * V* = A, where V* denotes the conjugate\ntranspose of L.\nThe dimensions of the matrix A must match.\n\nThis method is mainly used for numeric solution of linear equations Ax = b.\n\nexample:\nInput matrix A:\n[[  4,  12, -16],\n [ 12,  37, -43],\n [-16, -43,  98]]\n\nResult:\n[[2.0, 0.0, 0.0],\n[6.0, 1.0, 0.0],\n[-8.0, 5.0, 3.0]]\n\nTime complexity of this algorithm is O(n^3), specifically about (n^3)/3", "short_description": "Cholesky matrix decomposition is used to find the decomposition of a", "full": "Cholesky matrix decomposition is used to find the decomposition of a\nHermitian positive-definite matrix A\ninto matrix V, so that V * V* = A, where V* denotes the conjugate\ntranspose of L.\nThe dimensions of the matrix A must match.\n\nThis method is mainly used for numeric solution of linear equations Ax = b.\n\nexample:\nInput matrix A:\n[[  4,  12, -16],\n [ 12,  37, -43],\n [-16, -43,  98]]\n\nResult:\n[[2.0, 0.0, 0.0],\n[6.0, 1.0, 0.0],\n[-8.0, 5.0, 3.0]]\n\nTime complexity of this algorithm is O(n^3), specifically about (n^3)/3"}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"cholesky_decomposition": {"doc": {"args": {"A": {"description": "Hermitian positive-definite matrix of type List[List[float]]"}}, "returns": {"description": "matrix of type List[List[float]] if A can be decomposed,\notherwise None", "is_generator": false}}, "args": ["A"], "returns": ["V", "None", "None"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 52}, "calls": ["len", "range", "math.pow"], "store_vars_calls": {"n": "len"}, "source_code": "def cholesky_decomposition(A):\n    \"\"\"\n    :param A: Hermitian positive-definite matrix of type List[List[float]]\n    :return: matrix of type List[List[float]] if A can be decomposed,\n    otherwise None\n    \"\"\"\n    n = len(A)\n    for ai in A:\n        if len(ai) != n:\n            return None\n    V = [[0.0] * n for _ in range(n)]\n    for j in range(n):\n        sum_diagonal_element = 0\n        for k in range(j):\n            sum_diagonal_element = sum_diagonal_element + math.pow(V[j][k], 2)\n        sum_diagonal_element = A[j][j] - sum_diagonal_element\n        if sum_diagonal_element <= 0:\n            return None\n        V[j][j] = math.pow(sum_diagonal_element, 0.5)\n        for i in range(j + 1, n):\n            sum_other_element = 0\n            for k in range(j):\n                sum_other_element += V[i][k] * V[j][k]\n            V[i][j] = (A[i][j] - sum_other_element) / V[j][j]\n    return V"}}, "is_test": false}