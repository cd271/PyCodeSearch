{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/next_greatest_letter.py", "fileNameBase": "next_greatest_letter", "extension": "py", "doc": {"long_description": "and given a target letter target, find the smallest element in the list that\nis larger than the given target.\n\nLetters also wrap around. For example, if the target is target = 'z' and\nletters = ['a', 'b'], the answer is 'a'.\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nOutput: \"c\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\n\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/", "short_description": "Given a list of sorted characters letters containing only lowercase letters,", "full": "Given a list of sorted characters letters containing only lowercase letters,\nand given a target letter target, find the smallest element in the list that\nis larger than the given target.\n\nLetters also wrap around. For example, if the target is target = 'z' and\nletters = ['a', 'b'], the answer is 'a'.\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nOutput: \"c\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\n\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/"}}, "dependencies": [{"import": "bisect", "type": "external", "type_element": "module"}], "functions": {"next_greatest_letter": {"doc": {"short_description": "Using bisect libarary"}, "args": ["letters", "target"], "returns": ["letters[index % len(letters)]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 35}, "calls": ["bisect.bisect", "len"], "store_vars_calls": {"index": "bisect.bisect"}, "source_code": "def next_greatest_letter(letters, target):\n    \"\"\"\n    Using bisect libarary\n    \"\"\"\n    index = bisect.bisect(letters, target)\n    return letters[index % len(letters)]"}, "next_greatest_letter_v1": {"doc": {"short_description": "Using binary search: complexity O(logN)"}, "args": ["letters", "target"], "returns": ["letters[left]", "letters[0]", "letters[0]"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 52}, "calls": ["len"], "source_code": "def next_greatest_letter_v1(letters, target):\n    \"\"\"\n    Using binary search: complexity O(logN)\n    \"\"\"\n    if letters[0] > target:\n        return letters[0]\n    if letters[len(letters) - 1] <= target:\n        return letters[0]\n    (left, right) = (0, len(letters) - 1)\n    while left <= right:\n        mid = left + (right - left) // 2\n        if letters[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return letters[left]"}, "next_greatest_letter_v2": {"doc": {"short_description": "Brute force: complexity O(N)"}, "args": ["letters", "target"], "returns": ["letters[0]", "index"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 61}, "source_code": "def next_greatest_letter_v2(letters, target):\n    \"\"\"\n    Brute force: complexity O(N)\n    \"\"\"\n    for index in letters:\n        if index > target:\n            return index\n    return letters[0]"}}, "is_test": false}