{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/set/set_covering.py", "fileNameBase": "set_covering", "extension": "py"}, "dependencies": [{"from_module": "itertools", "import": "chain", "type": "external", "type_element": "module"}, {"from_module": "itertools", "import": "combinations", "type": "external", "type_element": "module"}], "functions": {"powerset": {"doc": {"long_description": "For a range of integers up to the length of the given list,\nmake all possible combinations and chain them together as one object.\nFrom https://docs.python.org/3/library/itertools.html#itertools-recipes", "short_description": "Calculate the powerset of any iterable."}, "args": ["iterable"], "returns": ["chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 35}, "calls": ["list", "itertools.chain.from_iterable", "itertools.combinations", "range", "len"], "store_vars_calls": {"s": "list"}, "source_code": "def powerset(iterable):\n    \"\"\"Calculate the powerset of any iterable.\n\n    For a range of integers up to the length of the given list,\n    make all possible combinations and chain them together as one object.\n    From https://docs.python.org/3/library/itertools.html#itertools-recipes\n    \"\"\"\n    'list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]'\n    s = list(iterable)\n    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))"}, "optimal_set_cover": {"doc": {"long_description": "Finds the minimum cost subcollection os S that covers all elements of U", "short_description": "Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!", "args": {"universe": {"description": "Universe of elements", "type_name": "list", "is_optional": false}, "subsets": {"description": "Subsets of U {S1:elements,S2:elements}", "type_name": "dict", "is_optional": false}, "costs": {"description": "Costs of each subset in S - {S1:cost, S2:cost...}", "type_name": "dict", "is_optional": false}}}, "args": ["universe", "subsets", "costs"], "returns": ["best_set"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 59}, "calls": ["set_covering.powerset", "float", "subsets.keys", "set", "set.update", "len"], "store_vars_calls": {"pset": "powerset", "best_cost": "float", "covered": "set"}, "source_code": "def optimal_set_cover(universe, subsets, costs):\n    \"\"\" Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!\n    Finds the minimum cost subcollection os S that covers all elements of U\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    pset = powerset(subsets.keys())\n    best_set = None\n    best_cost = float('inf')\n    for subset in pset:\n        covered = set()\n        cost = 0\n        for s in subset:\n            covered.update(subsets[s])\n            cost += costs[s]\n        if len(covered) == len(universe) and cost < best_cost:\n            best_set = subset\n            best_cost = cost\n    return best_set"}, "greedy_set_cover": {"doc": {"long_description": "inputs - though not an optimal solution.", "short_description": "Approximate greedy algorithm for set-covering. Can be used on large", "args": {"universe": {"description": "Universe of elements", "type_name": "list", "is_optional": false}, "subsets": {"description": "Subsets of U {S1:elements,S2:elements}", "type_name": "dict", "is_optional": false}, "costs": {"description": "Costs of each subset in S - {S1:cost, S2:cost...}", "type_name": "dict", "is_optional": false}}}, "args": ["universe", "subsets", "costs"], "returns": ["cover_sets", "None"], "min_max_lineno": {"min_lineno": 61, "max_lineno": 96}, "calls": ["set", "float", "subsets.items", "cover_sets.append", "len", "subsets.keys"], "store_vars_calls": {"elements": "set", "covered": "set", "min_cost_elem_ratio": "float", "new_elements": "len"}, "source_code": "def greedy_set_cover(universe, subsets, costs):\n    \"\"\"Approximate greedy algorithm for set-covering. Can be used on large\n    inputs - though not an optimal solution.\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    elements = set((e for s in subsets.keys() for e in subsets[s]))\n    if elements != universe:\n        return None\n    covered = set()\n    cover_sets = []\n    while covered != universe:\n        min_cost_elem_ratio = float('inf')\n        min_set = None\n        for (s, elements) in subsets.items():\n            new_elements = len(elements - covered)\n            if new_elements != 0:\n                cost_elem_ratio = costs[s] / new_elements\n                if cost_elem_ratio < min_cost_elem_ratio:\n                    min_cost_elem_ratio = cost_elem_ratio\n                    min_set = s\n        cover_sets.append(min_set)\n        covered |= subsets[min_set]\n    return cover_sets"}}, "body": {"calls": ["set_covering.optimal_set_cover", "sum", "set_covering.greedy_set_cover", "print"], "store_vars_calls": {"optimal_cover": "optimal_set_cover", "optimal_cost": "sum", "greedy_cover": "greedy_set_cover", "greedy_cost": "sum"}, "source_code": ["optimal_set_cover(universe, subsets, costs)", "sum((costs[s] for s in optimal_cover))", "greedy_set_cover(universe, subsets, costs)", "sum((costs[s] for s in greedy_cover))", "print('Optimal Set Cover:')", "print(optimal_cover)", "print('Cost = %s' % optimal_cost)", "print('Greedy Set Cover:')", "print(greedy_cover)", "print('Cost = %s' % greedy_cost)"]}, "main_info": {"main_flag": 1, "main_function": "set_covering.optimal_set_cover", "type": "script"}, "is_test": false}