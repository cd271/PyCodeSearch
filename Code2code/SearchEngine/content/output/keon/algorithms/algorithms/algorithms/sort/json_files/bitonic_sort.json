{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/bitonic_sort.py", "fileNameBase": "bitonic_sort", "extension": "py"}, "functions": {"bitonic_sort": {"doc": {"long_description": "It can sort only array that sizes power of 2\nIt can sort array in both increasing order and decreasing order by giving argument true(increasing) and false(decreasing)\n\nWorst-case in parallel: O(log(n)^2)\nWorst-case in non-parallel: O(nlog(n)^2)\n\nreference: https://en.wikipedia.org/wiki/Bitonic_sorter", "short_description": "bitonic sort is sorting algorithm to use multiple process, but this code not containing parallel process"}, "args": ["arr", "reverse"], "returns": ["arr", "arr", "left + right", "arr", "arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 44}, "calls": ["len", "bitonic_sort.bitonic_sort", "bitonic_sort.bitonic_sort.bitonic_merge"], "store_vars_calls": {"n": "len", "left": "bitonic_merge", "right": "bitonic_merge", "arr": "compare"}, "functions": {"compare": {"args": ["arr", "reverse"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 18}, "calls": ["range", "len"], "source_code": "def compare(arr, reverse):\n    n = len(arr) // 2\n    for i in range(n):\n        if reverse != (arr[i] > arr[i + n]):\n            (arr[i], arr[i + n]) = (arr[i + n], arr[i])\n    return arr"}, "bitonic_merge": {"args": ["arr", "reverse"], "returns": ["left + right", "arr"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 29}, "calls": ["len", "compare", "bitonic_merge"], "store_vars_calls": {"n": "len", "arr": "compare", "left": "bitonic_merge", "right": "bitonic_merge"}, "source_code": "def bitonic_merge(arr, reverse):\n    n = len(arr)\n    if n <= 1:\n        return arr\n    arr = compare(arr, reverse)\n    left = bitonic_merge(arr[:n // 2], reverse)\n    right = bitonic_merge(arr[n // 2:], reverse)\n    return left + right"}}, "source_code": "def bitonic_sort(arr, reverse=False):\n    \"\"\"\n    bitonic sort is sorting algorithm to use multiple process, but this code not containing parallel process\n    It can sort only array that sizes power of 2\n    It can sort array in both increasing order and decreasing order by giving argument true(increasing) and false(decreasing)\n    \n    Worst-case in parallel: O(log(n)^2)\n    Worst-case in non-parallel: O(nlog(n)^2)\n    \n    reference: https://en.wikipedia.org/wiki/Bitonic_sorter\n    \"\"\"\n\n    def compare(arr, reverse):\n        n = len(arr) // 2\n        for i in range(n):\n            if reverse != (arr[i] > arr[i + n]):\n                (arr[i], arr[i + n]) = (arr[i + n], arr[i])\n        return arr\n\n    def bitonic_merge(arr, reverse):\n        n = len(arr)\n        if n <= 1:\n            return arr\n        arr = compare(arr, reverse)\n        left = bitonic_merge(arr[:n // 2], reverse)\n        right = bitonic_merge(arr[n // 2:], reverse)\n        return left + right\n    n = len(arr)\n    if n <= 1:\n        return arr\n    if not (n and (not n & n - 1)):\n        raise ValueError('the size of input should be power of two')\n    left = bitonic_sort(arr[:n // 2], True)\n    right = bitonic_sort(arr[n // 2:], False)\n    arr = bitonic_merge(left + right, reverse)\n    return arr"}}, "is_test": false}