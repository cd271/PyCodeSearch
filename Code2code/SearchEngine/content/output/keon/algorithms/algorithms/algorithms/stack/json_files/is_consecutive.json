{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/is_consecutive.py", "fileNameBase": "is_consecutive", "extension": "py", "doc": {"long_description": "returns whether or not the stack contains a sequence of consecutive integers\nstarting from the bottom of the stack (returning true if it does, returning\nfalse if it does not).\n\nFor example:\nbottom [3, 4, 5, 6, 7] top\nThen the call of is_consecutive(s) should return true.\nbottom [3, 4, 6, 7] top\nThen the call of is_consecutive(s) should return false.\nbottom [3, 2, 1] top\nThe function should return false due to reverse order.\n\nNote: There are 2 solutions:\nfirst_is_consecutive: it uses a single stack as auxiliary storage\nsecond_is_consecutive: it uses a single queue as auxiliary storage", "short_description": "Given a stack, a function is_consecutive takes a stack as a parameter and that", "full": "Given a stack, a function is_consecutive takes a stack as a parameter and that\nreturns whether or not the stack contains a sequence of consecutive integers\nstarting from the bottom of the stack (returning true if it does, returning\nfalse if it does not).\n\nFor example:\nbottom [3, 4, 5, 6, 7] top\nThen the call of is_consecutive(s) should return true.\nbottom [3, 4, 6, 7] top\nThen the call of is_consecutive(s) should return false.\nbottom [3, 2, 1] top\nThe function should return false due to reverse order.\n\nNote: There are 2 solutions:\nfirst_is_consecutive: it uses a single stack as auxiliary storage\nsecond_is_consecutive: it uses a single queue as auxiliary storage"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"first_is_consecutive": {"args": ["stack"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 38}, "calls": ["range", "len", "stack.pop", "stack.append", "storage_stack.append", "storage_stack.pop"], "store_vars_calls": {"first_value": "stack.pop", "second_value": "stack.pop"}, "source_code": "def first_is_consecutive(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        storage_stack.append(first_value)\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True"}, "second_is_consecutive": {"args": ["stack"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 61}, "calls": ["collections.deque", "range", "len", "stack.pop", "stack.append", "collections.deque.append", "collections.deque.pop"], "store_vars_calls": {"q": "collections.deque", "first_value": "stack.pop", "second_value": "stack.pop"}, "source_code": "def second_is_consecutive(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        q.append(first_value)\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    return True"}}, "is_test": false}