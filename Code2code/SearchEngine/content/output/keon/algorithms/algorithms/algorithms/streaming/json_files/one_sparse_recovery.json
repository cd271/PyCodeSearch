{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/streaming/one_sparse_recovery.py", "fileNameBase": "one_sparse_recovery", "extension": "py", "doc": {"long_description": "This algorithm assumes we have a non negative dynamic stream.\n\nGiven a stream of tuples, where each tuple contains a number and a sign (+/-), it check if the\nstream is 1-sparse, meaning if the elements in the stream cancel eacheother out in such\na way that ther is only a unique number at the end.\n\nExamples:\n#1\nInput:  [(4,'+'), (2,'+'),(2,'-'),(4,'+'),(3,'+'),(3,'-')],\nOutput: 4\nComment: Since 2 and 3 gets removed.\n#2\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+')]\nOutput: 2\nComment: No other numbers present\n#3\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(1,'+')]\nOutput: None\nComment: Not 1-sparse", "short_description": "Non-negative 1-sparse recovery problem.", "full": "Non-negative 1-sparse recovery problem.\nThis algorithm assumes we have a non negative dynamic stream.\n\nGiven a stream of tuples, where each tuple contains a number and a sign (+/-), it check if the\nstream is 1-sparse, meaning if the elements in the stream cancel eacheother out in such\na way that ther is only a unique number at the end.\n\nExamples:\n#1\nInput:  [(4,'+'), (2,'+'),(2,'-'),(4,'+'),(3,'+'),(3,'-')],\nOutput: 4\nComment: Since 2 and 3 gets removed.\n#2\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+')]\nOutput: 2\nComment: No other numbers present\n#3\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(1,'+')]\nOutput: None\nComment: Not 1-sparse"}}, "functions": {"one_sparse": {"doc": {"long_description": "Keyword arguments:\narray -- stream of tuples", "short_description": "1-sparse algorithm"}, "args": ["array"], "returns": ["int(sum_values / sum_signs)", "None"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 47}, "calls": ["one_sparse_recovery._get_bit_sum", "one_sparse_recovery._check_every_number_in_bitsum", "int"], "source_code": "def one_sparse(array):\n    \"\"\"1-sparse algorithm\n\n    Keyword arguments:\n    array -- stream of tuples\n    \"\"\"\n    sum_signs = 0\n    bitsum = [0] * 32\n    sum_values = 0\n    for (val, sign) in array:\n        if sign == '+':\n            sum_signs += 1\n            sum_values += val\n        else:\n            sum_signs -= 1\n            sum_values -= val\n        _get_bit_sum(bitsum, val, sign)\n    if sum_signs > 0 and _check_every_number_in_bitsum(bitsum, sum_signs):\n        return int(sum_values / sum_signs)\n    else:\n        return None"}, "_check_every_number_in_bitsum": {"args": ["bitsum", "sum_signs"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 55}, "source_code": "def _check_every_number_in_bitsum(bitsum, sum_signs):\n    for val in bitsum:\n        if val != 0 and val != sum_signs:\n            return False\n    return True"}, "_get_bit_sum": {"args": ["bitsum", "val", "sign"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 69}, "source_code": "def _get_bit_sum(bitsum, val, sign):\n    i = 0\n    if sign == '+':\n        while val:\n            bitsum[i] += val & 1\n            i += 1\n            val >>= 1\n    else:\n        while val:\n            bitsum[i] -= val & 1\n            i += 1\n            val >>= 1"}}, "is_test": false}