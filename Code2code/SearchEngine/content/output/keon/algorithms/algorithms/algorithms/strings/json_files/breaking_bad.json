{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/breaking_bad.py", "fileNameBase": "breaking_bad", "extension": "py", "doc": {"long_description": "the word with their matched symbol surrounded by square brackets.\n\nIf the word string matches more than one symbol, then choose the one with\nlongest length. (ex. 'Microsoft' matches 'i' and 'cro'):\n\nExample:\nWords array: ['Amazon', 'Microsoft', 'Google']\nSymbols: ['i', 'Am', 'cro', 'Na', 'le', 'abc']\n\nOutput:\n[Am]azon, Mi[cro]soft, Goog[le]\n\nMy solution(Wrong):\n(I sorted the symbols array in descending order of length and ran loop over\nwords array to find a symbol match(using indexOf in javascript) which\nworked. But I didn't make it through the interview, I am guessing my solution\nwas O(n^2) and they expected an efficient algorithm.\n\noutput:\n['[Am]azon', 'Mi[cro]soft', 'Goog[le]', 'Amaz[o]n', 'Micr[o]s[o]ft', 'G[o][o]gle']", "short_description": "Given an api which returns an array of words and an array of symbols, display", "full": "Given an api which returns an array of words and an array of symbols, display\nthe word with their matched symbol surrounded by square brackets.\n\nIf the word string matches more than one symbol, then choose the one with\nlongest length. (ex. 'Microsoft' matches 'i' and 'cro'):\n\nExample:\nWords array: ['Amazon', 'Microsoft', 'Google']\nSymbols: ['i', 'Am', 'cro', 'Na', 'le', 'abc']\n\nOutput:\n[Am]azon, Mi[cro]soft, Goog[le]\n\nMy solution(Wrong):\n(I sorted the symbols array in descending order of length and ran loop over\nwords array to find a symbol match(using indexOf in javascript) which\nworked. But I didn't make it through the interview, I am guessing my solution\nwas O(n^2) and they expected an efficient algorithm.\n\noutput:\n['[Am]azon', 'Mi[cro]soft', 'Goog[le]', 'Amaz[o]n', 'Micr[o]s[o]ft', 'G[o][o]gle']"}}, "dependencies": [{"from_module": "functools", "import": "reduce", "type": "external", "type_element": "module"}], "classes": {"TreeNode": {"min_max_lineno": {"min_lineno": 63, "max_lineno": 67}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 64, "max_lineno": 67}, "calls": ["dict"], "store_vars_calls": {"self.c": "dict"}, "source_code": "def __init__(self):\n    self.c = dict()\n    self.sym = None"}}}}, "functions": {"match_symbol": {"args": ["words", "symbols"], "returns": ["combined"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 37}, "calls": ["re.search", "combined.append", "re.sub"], "store_vars_calls": {"r": "re.search"}, "source_code": "def match_symbol(words, symbols):\n    import re\n    combined = []\n    for s in symbols:\n        for c in words:\n            r = re.search(s, c)\n            if r:\n                combined.append(re.sub(s, '[{}]'.format(s), c))\n    return combined"}, "match_symbol_1": {"args": ["words", "symbols"], "returns": ["res"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 54}, "calls": ["sorted", "res.append", "len", "word.find", "word.replace"], "store_vars_calls": {"symbols": "sorted", "word_replaced": "word.replace"}, "source_code": "def match_symbol_1(words, symbols):\n    res = []\n    symbols = sorted(symbols, key=lambda _: len(_), reverse=True)\n    for word in words:\n        for symbol in symbols:\n            word_replaced = ''\n            if word.find(symbol) != -1:\n                word_replaced = word.replace(symbol, '[' + symbol + ']')\n                res.append(word_replaced)\n                break\n        if word_replaced == '':\n            res.append(word)\n    return res"}, "bracket": {"args": ["words", "symbols"], "returns": ["tuple((word if word not in result else result[word] for word in words))"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 96}, "calls": ["dict", "tuple", "list", "len", "functools.reduce", "breaking_bad.TreeNode", "list.append"], "store_vars_calls": {"root": "TreeNode", "result": "dict", "symlist": "list", "sym": "reduce"}, "source_code": "def bracket(words, symbols):\n    root = TreeNode()\n    for s in symbols:\n        t = root\n        for char in s:\n            if char not in t.c:\n                t.c[char] = TreeNode()\n            t = t.c[char]\n        t.sym = s\n    result = dict()\n    for word in words:\n        i = 0\n        symlist = list()\n        while i < len(word):\n            (j, t) = (i, root)\n            while j < len(word) and word[j] in t.c:\n                t = t.c[word[j]]\n                if t.sym is not None:\n                    symlist.append((j + 1 - len(t.sym), j + 1, t.sym))\n                j += 1\n            i += 1\n        if len(symlist) > 0:\n            sym = reduce(lambda x, y: x if x[1] - x[0] >= y[1] - y[0] else y, symlist)\n            result[word] = '{}[{}]{}'.format(word[:sym[0]], sym[2], word[sym[1]:])\n    return tuple((word if word not in result else result[word] for word in words))"}}, "is_test": false}