{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/fenwick_tree/fenwick_tree.py", "fileNameBase": "fenwick_tree", "extension": "py", "doc": {"long_description": "Consider we have an array arr[0 . . . n-1]. We would like to\n1. Compute the sum of the first i elements.\n2. Modify the value of a specified element of the array arr[i] = x where 0 <= i <= n-1.\n\nA simple solution is to run a loop from 0 to i-1 and calculate the sum of the elements. To update a value, simply do arr[i] = x.\nThe first operation takes O(n) time and the second operation takes O(1) time.\nAnother simple solution is to create an extra array and store the sum of the first i-th elements at the i-th index in this new array.\nThe sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now.\nThis works well if there are a large number of query operations but a very few number of update operations.\n\n\nThere are two solutions that can perform both the query and update operations in O(logn) time.\n1. Fenwick Tree\n2. Segment Tree\n\nCompared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement.", "short_description": "Fenwick Tree / Binary Indexed Tree", "full": "Fenwick Tree / Binary Indexed Tree\n\nConsider we have an array arr[0 . . . n-1]. We would like to\n1. Compute the sum of the first i elements.\n2. Modify the value of a specified element of the array arr[i] = x where 0 <= i <= n-1.\n\nA simple solution is to run a loop from 0 to i-1 and calculate the sum of the elements. To update a value, simply do arr[i] = x.\nThe first operation takes O(n) time and the second operation takes O(1) time.\nAnother simple solution is to create an extra array and store the sum of the first i-th elements at the i-th index in this new array.\nThe sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now.\nThis works well if there are a large number of query operations but a very few number of update operations.\n\n\nThere are two solutions that can perform both the query and update operations in O(logn) time.\n1. Fenwick Tree\n2. Segment Tree\n\nCompared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement."}}, "classes": {"Fenwick_Tree": {"extend": ["object"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 78}, "methods": {"__init__": {"args": ["self", "freq"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 26}, "calls": ["len"], "store_vars_calls": {"self.n": "len"}, "source_code": "def __init__(self, freq):\n    self.arr = freq\n    self.n = len(freq)"}, "get_sum": {"doc": {"short_description": "Returns sum of arr[0..index]. This function assumes that the array is preprocessed and partial sums of array elements are stored in bit_tree[]. "}, "args": ["self", "bit_tree", "i"], "returns": ["s"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 46}, "source_code": "def get_sum(self, bit_tree, i):\n    \"\"\"\n             Returns sum of arr[0..index]. This function assumes that the array is preprocessed and partial sums of array elements are stored in bit_tree[]. \n        \"\"\"\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += bit_tree[i]\n        i -= i & -i\n    return s"}, "update_bit": {"doc": {"short_description": "Updates a node in Binary Index Tree (bit_tree) at given index in bit_tree. The given value 'val' is added to bit_tree[i] and all of its ancestors in tree. "}, "args": ["self", "bit_tree", "i", "v"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 63}, "source_code": "def update_bit(self, bit_tree, i, v):\n    \"\"\"\n             Updates a node in Binary Index Tree (bit_tree) at given index in bit_tree. The given value 'val' is added to bit_tree[i] and all of its ancestors in tree. \n        \"\"\"\n    i += 1\n    while i <= self.n:\n        bit_tree[i] += v\n        i += i & -i"}, "construct": {"doc": {"short_description": "Constructs and returns a Binary Indexed Tree for given array of size n. "}, "args": ["self"], "returns": ["bit_tree"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 78}, "calls": ["range", "fenwick_tree.Fenwick_Tree.update_bit"], "source_code": "def construct(self):\n    \"\"\"\n             Constructs and returns a Binary Indexed Tree for given array of size n. \n        \"\"\"\n    bit_tree = [0] * (self.n + 1)\n    for i in range(self.n):\n        self.update_bit(bit_tree, i, self.arr[i])\n    return bit_tree"}}}}, "is_test": false}