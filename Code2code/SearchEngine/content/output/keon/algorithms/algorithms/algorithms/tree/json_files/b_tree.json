{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/b_tree.py", "fileNameBase": "b_tree", "extension": "py", "doc": {"long_description": "at least t-1 keys (t children) and at most 2*t - 1 keys (2*t children)\nwhere t is the degree of b-tree. It is not a kind of typical bst tree, because\nthis tree grows up.\nB-tree is balanced which means that the difference between height of left\nsubtree and right subtree is at most 1.\n\nComplexity\n    n - number of elements\n    t - degree of tree\n    Tree always has height at most logt (n+1)/2\n    Algorithm        Average        Worst case\n    Space            O(n)           O(n)\n    Search           O(log n)       O(log n)\n    Insert           O(log n)       O(log n)\n    Delete           O(log n)       O(log n)", "short_description": "B-tree is used to disk operations. Each node (except root) contains", "full": "B-tree is used to disk operations. Each node (except root) contains\nat least t-1 keys (t children) and at most 2*t - 1 keys (2*t children)\nwhere t is the degree of b-tree. It is not a kind of typical bst tree, because\nthis tree grows up.\nB-tree is balanced which means that the difference between height of left\nsubtree and right subtree is at most 1.\n\nComplexity\n    n - number of elements\n    t - degree of tree\n    Tree always has height at most logt (n+1)/2\n    Algorithm        Average        Worst case\n    Space            O(n)           O(n)\n    Search           O(log n)       O(log n)\n    Insert           O(log n)       O(log n)\n    Delete           O(log n)       O(log n)"}}, "classes": {"Node": {"doc": {"short_description": "Class of Node", "full": "Class of Node"}, "min_max_lineno": {"min_lineno": 21, "max_lineno": 36}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 28}, "source_code": "def __init__(self):\n    self.keys = []\n    self.children = []"}, "__repr__": {"args": ["self"], "returns": ["'<id_node: {0}>'.format(self.keys)"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 31}, "source_code": "def __repr__(self):\n    return '<id_node: {0}>'.format(self.keys)"}, "is_leaf": {"doc": {"short_description": "Return if it is a leaf"}, "args": ["self"], "returns": ["len(self.children) == 0"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 36}, "calls": ["len"], "source_code": "@property\ndef is_leaf(self):\n    \"\"\" Return if it is a leaf\"\"\"\n    return len(self.children) == 0"}}}, "BTree": {"doc": {"short_description": "Class of BTree ", "full": "Class of BTree "}, "min_max_lineno": {"min_lineno": 38, "max_lineno": 252}, "methods": {"__init__": {"args": ["self", "t_val"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 46}, "store_vars_calls": {"self.root": "Node"}, "source_code": "def __init__(self, t_val=2):\n    self.min_numbers_of_keys = t_val - 1\n    self.max_number_of_keys = 2 * t_val - 1\n    self.root = Node()"}, "_split_child": {"args": ["self", "parent", "child_index"], "annotated_arg_types": {"parent": "Node", "child_index": "int"}, "min_max_lineno": {"min_lineno": 47, "max_lineno": 62}, "calls": ["parent.keys.insert", "parent.children.insert"], "store_vars_calls": {"new_right_child": "Node"}, "source_code": "def _split_child(self, parent: Node, child_index: int):\n    new_right_child = Node()\n    half_max = self.max_number_of_keys // 2\n    child = parent.children[child_index]\n    middle_key = child.keys[half_max]\n    new_right_child.keys = child.keys[half_max + 1:]\n    child.keys = child.keys[:half_max]\n    if not child.is_leaf:\n        new_right_child.children = child.children[half_max + 1:]\n        child.children = child.children[:half_max + 1]\n    parent.keys.insert(child_index, middle_key)\n    parent.children.insert(child_index + 1, new_right_child)"}, "insert_key": {"doc": {"short_description": "overflow, tree increases in height "}, "args": ["self", "key"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 73}, "calls": ["len", "Node.children.append", "b_tree.BTree._split_child", "b_tree.BTree._insert_to_nonfull_node"], "store_vars_calls": {"new_root": "Node"}, "source_code": "def insert_key(self, key):\n    \"\"\" overflow, tree increases in height \"\"\"\n    if len(self.root.keys) >= self.max_number_of_keys:\n        new_root = Node()\n        new_root.children.append(self.root)\n        self.root = new_root\n        self._split_child(new_root, 0)\n        self._insert_to_nonfull_node(self.root, key)\n    else:\n        self._insert_to_nonfull_node(self.root, key)"}, "_insert_to_nonfull_node": {"args": ["self", "node", "key"], "annotated_arg_types": {"node": "Node"}, "min_max_lineno": {"min_lineno": 74, "max_lineno": 90}, "calls": ["len", "node.keys.insert", "b_tree.BTree._insert_to_nonfull_node", "b_tree.BTree._split_child"], "source_code": "def _insert_to_nonfull_node(self, node: Node, key):\n    i = len(node.keys) - 1\n    while i >= 0 and node.keys[i] >= key:\n        i -= 1\n    if node.is_leaf:\n        node.keys.insert(i + 1, key)\n    else:\n        if len(node.children[i + 1].keys) >= self.max_number_of_keys:\n            self._split_child(node, i + 1)\n            if node.keys[i + 1] < key:\n                i += 1\n        self._insert_to_nonfull_node(node.children[i + 1], key)"}, "find": {"doc": {"short_description": "Finds key "}, "args": ["self", "key"], "annotated_return_type": "bool", "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 91, "max_lineno": 103}, "calls": ["len"], "source_code": "def find(self, key) -> bool:\n    \"\"\" Finds key \"\"\"\n    current_node = self.root\n    while True:\n        i = len(current_node.keys) - 1\n        while i >= 0 and current_node.keys[i] > key:\n            i -= 1\n        if i >= 0 and current_node.keys[i] == key:\n            return True\n        if current_node.is_leaf:\n            return False\n        current_node = current_node.children[i + 1]"}, "remove_key": {"args": ["self", "key"], "min_max_lineno": {"min_lineno": 104, "max_lineno": 106}, "calls": ["b_tree.BTree._remove_key"], "source_code": "def remove_key(self, key):\n    self._remove_key(self.root, key)"}, "_remove_key": {"args": ["self", "node", "key"], "annotated_arg_types": {"node": "Node"}, "annotated_return_type": "bool", "returns": ["True", "False", "self._remove_key(node, key)", "self._remove_key(node.children[i], key)"], "min_max_lineno": {"min_lineno": 107, "max_lineno": 132}, "calls": ["node.keys.index", "node.keys.remove", "b_tree.BTree._remove_from_nonleaf_node", "print", "len", "b_tree.BTree._repair_tree", "b_tree.BTree._remove_key"], "store_vars_calls": {"key_index": "node.keys.index", "number_of_keys": "len", "action_performed": "self._repair_tree"}, "source_code": "def _remove_key(self, node: Node, key) -> bool:\n    try:\n        key_index = node.keys.index(key)\n        if node.is_leaf:\n            node.keys.remove(key)\n        else:\n            self._remove_from_nonleaf_node(node, key_index)\n        return True\n    except ValueError:\n        if node.is_leaf:\n            print('Key not found.')\n            return False\n        else:\n            i = 0\n            number_of_keys = len(node.keys)\n            while i < number_of_keys and key > node.keys[i]:\n                i += 1\n            action_performed = self._repair_tree(node, i)\n            if action_performed:\n                return self._remove_key(node, key)\n            else:\n                return self._remove_key(node.children[i], key)"}, "_repair_tree": {"args": ["self", "node", "child_index"], "annotated_arg_types": {"node": "Node", "child_index": "int"}, "annotated_return_type": "bool", "returns": ["True", "False", "True", "True"], "min_max_lineno": {"min_lineno": 133, "max_lineno": 156}, "calls": ["len", "b_tree.BTree._rotate_right", "b_tree.BTree._rotate_left", "b_tree.BTree._merge"], "source_code": "def _repair_tree(self, node: Node, child_index: int) -> bool:\n    child = node.children[child_index]\n    if self.min_numbers_of_keys < len(child.keys) <= self.max_number_of_keys:\n        return False\n    if child_index > 0 and len(node.children[child_index - 1].keys) > self.min_numbers_of_keys:\n        self._rotate_right(node, child_index)\n        return True\n    if child_index < len(node.children) - 1 and len(node.children[child_index + 1].keys) > self.min_numbers_of_keys:\n        self._rotate_left(node, child_index)\n        return True\n    if child_index > 0:\n        self._merge(node, child_index - 1, child_index)\n    else:\n        self._merge(node, child_index, child_index + 1)\n    return True"}, "_rotate_left": {"doc": {"short_description": "Take key from right brother of the child and transfer to the child"}, "args": ["self", "parent_node", "child_index"], "annotated_arg_types": {"parent_node": "Node", "child_index": "int"}, "min_max_lineno": {"min_lineno": 157, "max_lineno": 172}, "calls": ["parent_node.children[].keys.pop", "parent_node.children[].keys.append", "parent_node.children[].children.pop", "parent_node.children[].children.append"], "store_vars_calls": {"new_parent_key": "parent_node.children[].keys.pop", "ownerless_child": "parent_node.children[].children.pop"}, "source_code": "def _rotate_left(self, parent_node: Node, child_index: int):\n    \"\"\"\n        Take key from right brother of the child and transfer to the child\n        \"\"\"\n    new_child_key = parent_node.keys[child_index]\n    new_parent_key = parent_node.children[child_index + 1].keys.pop(0)\n    parent_node.children[child_index].keys.append(new_child_key)\n    parent_node.keys[child_index] = new_parent_key\n    if not parent_node.children[child_index + 1].is_leaf:\n        ownerless_child = parent_node.children[child_index + 1].children.pop(0)\n        parent_node.children[child_index].children.append(ownerless_child)"}, "_rotate_right": {"doc": {"short_description": "Take key from left brother of the child and transfer to the child"}, "args": ["self", "parent_node", "child_index"], "annotated_arg_types": {"parent_node": "Node", "child_index": "int"}, "min_max_lineno": {"min_lineno": 173, "max_lineno": 189}, "calls": ["parent_node.children[].keys.pop", "parent_node.children[].keys.insert", "parent_node.children[].children.pop", "parent_node.children[].children.insert"], "store_vars_calls": {"new_parent_key": "parent_node.children[].keys.pop", "ownerless_child": "parent_node.children[].children.pop"}, "source_code": "def _rotate_right(self, parent_node: Node, child_index: int):\n    \"\"\"\n        Take key from left brother of the child and transfer to the child\n        \"\"\"\n    parent_key = parent_node.keys[child_index - 1]\n    new_parent_key = parent_node.children[child_index - 1].keys.pop()\n    parent_node.children[child_index].keys.insert(0, parent_key)\n    parent_node.keys[child_index - 1] = new_parent_key\n    if not parent_node.children[child_index - 1].is_leaf:\n        ownerless_child = parent_node.children[child_index - 1].children.pop()\n        parent_node.children[child_index].children.insert(0, ownerless_child)"}, "_merge": {"args": ["self", "parent_node", "to_merge_index", "transfered_child_index"], "annotated_arg_types": {"parent_node": "Node", "to_merge_index": "int", "transfered_child_index": "int"}, "min_max_lineno": {"min_lineno": 190, "max_lineno": 202}, "calls": ["parent_node.children.pop", "parent_node.keys.pop", "to_merge_node.keys.append", "to_merge_node.keys.extend", "to_merge_node.children.extend"], "store_vars_calls": {"from_merge_node": "parent_node.children.pop", "parent_key_to_merge": "parent_node.keys.pop"}, "source_code": "def _merge(self, parent_node: Node, to_merge_index: int, transfered_child_index: int):\n    from_merge_node = parent_node.children.pop(transfered_child_index)\n    parent_key_to_merge = parent_node.keys.pop(to_merge_index)\n    to_merge_node = parent_node.children[to_merge_index]\n    to_merge_node.keys.append(parent_key_to_merge)\n    to_merge_node.keys.extend(from_merge_node.keys)\n    if not to_merge_node.is_leaf:\n        to_merge_node.children.extend(from_merge_node.children)\n    if parent_node == self.root and (not parent_node.keys):\n        self.root = to_merge_node"}, "_remove_from_nonleaf_node": {"args": ["self", "node", "key_index"], "annotated_arg_types": {"node": "Node", "key_index": "int"}, "returns": ["self._remove_key(node, key)"], "min_max_lineno": {"min_lineno": 203, "max_lineno": 217}, "calls": ["len", "b_tree.BTree._find_largest_and_delete_in_left_subtree", "b_tree.BTree._find_largest_and_delete_in_right_subtree", "b_tree.BTree._merge", "b_tree.BTree._remove_key"], "store_vars_calls": {"largest_key": "self._find_largest_and_delete_in_right_subtree"}, "source_code": "def _remove_from_nonleaf_node(self, node: Node, key_index: int):\n    key = node.keys[key_index]\n    left_subtree = node.children[key_index]\n    if len(left_subtree.keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_left_subtree(left_subtree)\n    elif len(node.children[key_index + 1].keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_right_subtree(node.children[key_index + 1])\n    else:\n        self._merge(node, key_index, key_index + 1)\n        return self._remove_key(node, key)\n    node.keys[key_index] = largest_key"}, "_find_largest_and_delete_in_left_subtree": {"args": ["self", "node"], "annotated_arg_types": {"node": "Node"}, "returns": ["node.keys.pop()", "largest_key_in_subtree"], "min_max_lineno": {"min_lineno": 218, "max_lineno": 228}, "calls": ["node.keys.pop", "b_tree.BTree._repair_tree", "b_tree.BTree._find_largest_and_delete_in_left_subtree", "len"], "store_vars_calls": {"largest_key_in_subtree": "self._find_largest_and_delete_in_left_subtree"}, "source_code": "def _find_largest_and_delete_in_left_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop()\n    else:\n        ch_index = len(node.children) - 1\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_left_subtree(node.children[len(node.children) - 1])\n        return largest_key_in_subtree"}, "_find_largest_and_delete_in_right_subtree": {"args": ["self", "node"], "annotated_arg_types": {"node": "Node"}, "returns": ["node.keys.pop(0)", "largest_key_in_subtree"], "min_max_lineno": {"min_lineno": 229, "max_lineno": 239}, "calls": ["node.keys.pop", "b_tree.BTree._repair_tree", "b_tree.BTree._find_largest_and_delete_in_right_subtree"], "store_vars_calls": {"largest_key_in_subtree": "self._find_largest_and_delete_in_right_subtree"}, "source_code": "def _find_largest_and_delete_in_right_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop(0)\n    else:\n        ch_index = 0\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_right_subtree(node.children[0])\n        return largest_key_in_subtree"}, "traverse_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 240, "max_lineno": 243}, "calls": ["b_tree.BTree._traverse_tree", "print"], "source_code": "def traverse_tree(self):\n    self._traverse_tree(self.root)\n    print()"}, "_traverse_tree": {"args": ["self", "node"], "annotated_arg_types": {"node": "Node"}, "min_max_lineno": {"min_lineno": 244, "max_lineno": 252}, "calls": ["print", "enumerate", "b_tree.BTree._traverse_tree"], "source_code": "def _traverse_tree(self, node: Node):\n    if node.is_leaf:\n        print(node.keys, end=' ')\n    else:\n        for (i, key) in enumerate(node.keys):\n            self._traverse_tree(node.children[i])\n            print(key, end=' ')\n        self._traverse_tree(node.children[-1])"}}}}, "is_test": false}