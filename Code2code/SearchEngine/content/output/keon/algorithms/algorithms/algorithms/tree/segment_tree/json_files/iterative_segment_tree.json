{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/segment_tree/iterative_segment_tree.py", "fileNameBase": "iterative_segment_tree", "extension": "py", "doc": {"long_description": "this non-recursive version uses less memory than the recursive version and include:\n1. range queries in log(N) time\n2. update an element in log(N) time\nthe function should be commutative and takes 2 values and returns the same type value\n\nExamples -\nmytree = SegmentTree([2, 4, 5, 3, 4],max)\nprint(mytree.query(2, 4))\nmytree.update(3, 6)\nprint(mytree.query(0, 3)) ...\n\nmytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b)\nprint(mytree.query(0, 6))\nmytree.update(2, -10)\nprint(mytree.query(0, 6)) ...\n\nmytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))\nmytree.update(2, (-1, 2))\nprint(mytree.query(0, 2)) ...", "short_description": "SegmentTree creates a segment tree with a given array and a \"commutative\" function,", "full": "SegmentTree creates a segment tree with a given array and a \"commutative\" function,\nthis non-recursive version uses less memory than the recursive version and include:\n1. range queries in log(N) time\n2. update an element in log(N) time\nthe function should be commutative and takes 2 values and returns the same type value\n\nExamples -\nmytree = SegmentTree([2, 4, 5, 3, 4],max)\nprint(mytree.query(2, 4))\nmytree.update(3, 6)\nprint(mytree.query(0, 3)) ...\n\nmytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b)\nprint(mytree.query(0, 6))\nmytree.update(2, -10)\nprint(mytree.query(0, 6)) ...\n\nmytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))\nmytree.update(2, (-1, 2))\nprint(mytree.query(0, 2)) ..."}}, "classes": {"SegmentTree": {"min_max_lineno": {"min_lineno": 26, "max_lineno": 54}, "methods": {"__init__": {"args": ["self", "arr", "function"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 32}, "calls": ["len", "iterative_segment_tree.SegmentTree.build_tree", "range"], "store_vars_calls": {"self.size": "len"}, "source_code": "def __init__(self, arr, function):\n    self.tree = [None for _ in range(len(arr))] + arr\n    self.size = len(arr)\n    self.fn = function\n    self.build_tree()"}, "build_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 36}, "calls": ["range", "iterative_segment_tree.SegmentTree.fn"], "source_code": "def build_tree(self):\n    for i in range(self.size - 1, 0, -1):\n        self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])"}, "update": {"args": ["self", "p", "v"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 43}, "calls": ["iterative_segment_tree.SegmentTree.fn"], "source_code": "def update(self, p, v):\n    p += self.size\n    self.tree[p] = v\n    while p > 1:\n        p = p // 2\n        self.tree[p] = self.fn(self.tree[p * 2], self.tree[p * 2 + 1])"}, "query": {"args": ["self", "l", "r"], "returns": ["res"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 54}, "calls": ["iterative_segment_tree.SegmentTree.fn"], "source_code": "def query(self, l, r):\n    (l, r) = (l + self.size, r + self.size)\n    res = None\n    while l <= r:\n        if l % 2 == 1:\n            res = self.tree[l] if res is None else self.fn(res, self.tree[l])\n        if r % 2 == 0:\n            res = self.tree[r] if res is None else self.fn(res, self.tree[r])\n        (l, r) = ((l + 1) // 2, (r - 1) // 2)\n    return res"}}}}, "is_test": false}