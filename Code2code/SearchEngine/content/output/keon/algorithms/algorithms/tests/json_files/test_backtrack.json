{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_backtrack.py", "fileNameBase": "test_backtrack", "extension": "py"}, "dependencies": [{"from_module": "algorithms.backtrack", "import": "add_operators", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "permute_iter", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "anagram", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "array_sum_combinations", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "unique_array_sum_combinations", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "combination_sum", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "get_factors", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "recursive_get_factors", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "find_words", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "generate_abbreviations", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "generate_parenthesis_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "generate_parenthesis_v2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "letter_combinations", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "palindromic_substrings", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "pattern_match", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "permute_unique", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "permute", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "permute_recursive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "subsets_unique", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "subsets", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "subsets_v2", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestAddOperator": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 54}, "methods": {"test_add_operators": {"args": ["self"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 54}, "calls": ["test_backtrack.TestAddOperator.assertEqual", "algorithms.backtrack.add_operators"], "source_code": "def test_add_operators(self):\n    s = '123'\n    target = 6\n    self.assertEqual(add_operators(s, target), ['1+2+3', '1*2*3'])\n    s = '232'\n    target = 8\n    self.assertEqual(add_operators(s, target), ['2+3*2', '2*3+2'])\n    s = '123045'\n    target = 3\n    answer = ['1+2+3*0*4*5', '1+2+3*0*45', '1+2-3*0*4*5', '1+2-3*0*45', '1-2+3+0-4+5', '1-2+3-0-4+5', '1*2+3*0-4+5', '1*2-3*0-4+5', '1*23+0-4*5', '1*23-0-4*5', '12+3*0-4-5', '12-3*0-4-5']\n    self.assertEqual(add_operators(s, target), answer)"}}}, "TestPermuteAndAnagram": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 71}, "methods": {"test_permute": {"args": ["self"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 61}, "calls": ["test_backtrack.TestPermuteAndAnagram.assertEqual", "algorithms.backtrack.permute"], "source_code": "def test_permute(self):\n    perms = ['abc', 'bac', 'bca', 'acb', 'cab', 'cba']\n    self.assertEqual(perms, permute('abc'))"}, "test_permute_iter": {"args": ["self"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 67}, "calls": ["algorithms.backtrack.permute_iter", "range", "len", "test_backtrack.TestPermuteAndAnagram.assertEqual", "next"], "store_vars_calls": {"it": "permute_iter"}, "source_code": "def test_permute_iter(self):\n    it = permute_iter('abc')\n    perms = ['abc', 'bac', 'bca', 'acb', 'cab', 'cba']\n    for i in range(len(perms)):\n        self.assertEqual(perms[i], next(it))"}, "test_angram": {"args": ["self"], "min_max_lineno": {"min_lineno": 68, "max_lineno": 71}, "calls": ["test_backtrack.TestPermuteAndAnagram.assertTrue", "test_backtrack.TestPermuteAndAnagram.assertFalse", "algorithms.backtrack.anagram"], "source_code": "def test_angram(self):\n    self.assertTrue(anagram('apple', 'pleap'))\n    self.assertFalse(anagram('apple', 'cherry'))"}}}, "TestArrayCombinationSum": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 98}, "methods": {"test_array_sum_combinations": {"args": ["self"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 86}, "calls": ["answer.sort", "test_backtrack.TestArrayCombinationSum.assertListEqual", "sorted", "algorithms.backtrack.array_sum_combinations"], "source_code": "def test_array_sum_combinations(self):\n    A = [1, 2, 3, 3]\n    B = [2, 3, 3, 4]\n    C = [2, 3, 3, 4]\n    target = 7\n    answer = [[1, 2, 4], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 4, 2], [2, 2, 3], [2, 2, 3], [2, 3, 2], [2, 3, 2], [3, 2, 2], [3, 2, 2]]\n    answer.sort()\n    self.assertListEqual(sorted(array_sum_combinations(A, B, C, target)), answer)"}, "test_unique_array_sum_combinations": {"args": ["self"], "min_max_lineno": {"min_lineno": 87, "max_lineno": 98}, "calls": ["answer.sort", "test_backtrack.TestArrayCombinationSum.assertListEqual", "sorted", "algorithms.backtrack.unique_array_sum_combinations"], "source_code": "def test_unique_array_sum_combinations(self):\n    A = [1, 2, 3, 3]\n    B = [2, 3, 3, 4]\n    C = [2, 3, 3, 4]\n    target = 7\n    answer = [(2, 3, 2), (3, 2, 2), (1, 2, 4), (1, 4, 2), (2, 2, 3), (1, 3, 3)]\n    answer.sort()\n    self.assertListEqual(sorted(unique_array_sum_combinations(A, B, C, target)), answer)"}}}, "TestCombinationSum": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 100, "max_lineno": 125}, "methods": {"check_sum": {"args": ["self", "nums", "target"], "returns": [["True", "nums"], ["False", "nums"]], "min_max_lineno": {"min_lineno": 102, "max_lineno": 107}, "calls": ["sum"], "source_code": "def check_sum(self, nums, target):\n    if sum(nums) == target:\n        return (True, nums)\n    else:\n        return (False, nums)"}, "test_combination_sum": {"args": ["self"], "min_max_lineno": {"min_lineno": 108, "max_lineno": 125}, "calls": ["test_backtrack.TestCombinationSum.assertEqual", "algorithms.backtrack.combination_sum"], "source_code": "def test_combination_sum(self):\n    candidates1 = [2, 3, 6, 7]\n    target1 = 7\n    answer1 = [[2, 2, 3], [7]]\n    self.assertEqual(combination_sum(candidates1, target1), answer1)\n    candidates2 = [2, 3, 5]\n    target2 = 8\n    answer2 = [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    self.assertEqual(combination_sum(candidates2, target2), answer2)"}}}, "TestFactorCombinations": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 127, "max_lineno": 174}, "methods": {"test_get_factors": {"args": ["self"], "min_max_lineno": {"min_lineno": 129, "max_lineno": 150}, "calls": ["test_backtrack.TestFactorCombinations.assertEqual", "sorted", "algorithms.backtrack.get_factors"], "source_code": "def test_get_factors(self):\n    target1 = 32\n    answer1 = [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]]\n    self.assertEqual(sorted(get_factors(target1)), sorted(answer1))\n    target2 = 12\n    answer2 = [[2, 6], [2, 2, 3], [3, 4]]\n    self.assertEqual(sorted(get_factors(target2)), sorted(answer2))\n    self.assertEqual(sorted(get_factors(1)), [])\n    self.assertEqual(sorted(get_factors(37)), [])"}, "test_recursive_get_factors": {"args": ["self"], "min_max_lineno": {"min_lineno": 151, "max_lineno": 174}, "calls": ["test_backtrack.TestFactorCombinations.assertEqual", "sorted", "algorithms.backtrack.recursive_get_factors"], "source_code": "def test_recursive_get_factors(self):\n    target1 = 32\n    answer1 = [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]]\n    self.assertEqual(sorted(recursive_get_factors(target1)), sorted(answer1))\n    target2 = 12\n    answer2 = [[2, 6], [2, 2, 3], [3, 4]]\n    self.assertEqual(sorted(recursive_get_factors(target2)), sorted(answer2))\n    self.assertEqual(sorted(recursive_get_factors(1)), [])\n    self.assertEqual(sorted(recursive_get_factors(37)), [])"}}}, "TestFindWords": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 176, "max_lineno": 223}, "methods": {"test_normal": {"args": ["self"], "min_max_lineno": {"min_lineno": 178, "max_lineno": 190}, "calls": ["algorithms.backtrack.find_words", "test_backtrack.TestFindWords.assertEqual", "sorted"], "store_vars_calls": {"result": "find_words"}, "source_code": "def test_normal(self):\n    board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']]\n    words = ['oath', 'pea', 'eat', 'rain']\n    result = find_words(board, words)\n    test_result = ['oath', 'eat']\n    self.assertEqual(sorted(result), sorted(test_result))"}, "test_none": {"args": ["self"], "min_max_lineno": {"min_lineno": 191, "max_lineno": 201}, "calls": ["test_backtrack.TestFindWords.assertEqual", "algorithms.backtrack.find_words"], "source_code": "def test_none(self):\n    board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']]\n    words = ['chicken', 'nugget', 'hello', 'world']\n    self.assertEqual(find_words(board, words), [])"}, "test_empty": {"args": ["self"], "min_max_lineno": {"min_lineno": 202, "max_lineno": 206}, "calls": ["test_backtrack.TestFindWords.assertEqual", "algorithms.backtrack.find_words"], "source_code": "def test_empty(self):\n    board = []\n    words = []\n    self.assertEqual(find_words(board, words), [])"}, "test_uneven": {"args": ["self"], "min_max_lineno": {"min_lineno": 207, "max_lineno": 214}, "calls": ["test_backtrack.TestFindWords.assertEqual", "algorithms.backtrack.find_words"], "source_code": "def test_uneven(self):\n    board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e']]\n    words = ['oath', 'pea', 'eat', 'rain']\n    self.assertEqual(find_words(board, words), ['eat'])"}, "test_repeat": {"args": ["self"], "min_max_lineno": {"min_lineno": 215, "max_lineno": 223}, "calls": ["test_backtrack.TestFindWords.assertTrue", "len", "algorithms.backtrack.find_words"], "source_code": "def test_repeat(self):\n    board = [['a', 'a', 'a'], ['a', 'a', 'a'], ['a', 'a', 'a']]\n    words = ['a', 'aa', 'aaa', 'aaaa', 'aaaaa']\n    self.assertTrue(len(find_words(board, words)) == 5)"}}}, "TestGenerateAbbreviations": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 225, "max_lineno": 241}, "methods": {"test_generate_abbreviations": {"args": ["self"], "min_max_lineno": {"min_lineno": 226, "max_lineno": 241}, "calls": ["test_backtrack.TestGenerateAbbreviations.assertEqual", "sorted", "algorithms.backtrack.generate_abbreviations"], "source_code": "def test_generate_abbreviations(self):\n    word1 = 'word'\n    answer1 = ['word', 'wor1', 'wo1d', 'wo2', 'w1rd', 'w1r1', 'w2d', 'w3', '1ord', '1or1', '1o1d', '1o2', '2rd', '2r1', '3d', '4']\n    self.assertEqual(sorted(generate_abbreviations(word1)), sorted(answer1))\n    word2 = 'hello'\n    answer2 = ['hello', 'hell1', 'hel1o', 'hel2', 'he1lo', 'he1l1', 'he2o', 'he3', 'h1llo', 'h1ll1', 'h1l1o', 'h1l2', 'h2lo', 'h2l1', 'h3o', 'h4', '1ello', '1ell1', '1el1o', '1el2', '1e1lo', '1e1l1', '1e2o', '1e3', '2llo', '2ll1', '2l1o', '2l2', '3lo', '3l1', '4o', '5']\n    self.assertEqual(sorted(generate_abbreviations(word2)), sorted(answer2))"}}}, "TestPatternMatch": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 243, "max_lineno": 256}, "methods": {"test_pattern_match": {"args": ["self"], "min_max_lineno": {"min_lineno": 245, "max_lineno": 256}, "calls": ["test_backtrack.TestPatternMatch.assertTrue", "test_backtrack.TestPatternMatch.assertFalse", "algorithms.backtrack.pattern_match"], "source_code": "def test_pattern_match(self):\n    pattern1 = 'abab'\n    string1 = 'redblueredblue'\n    pattern2 = 'aaaa'\n    string2 = 'asdasdasdasd'\n    pattern3 = 'aabb'\n    string3 = 'xyzabcxzyabc'\n    self.assertTrue(pattern_match(pattern1, string1))\n    self.assertTrue(pattern_match(pattern2, string2))\n    self.assertFalse(pattern_match(pattern3, string3))"}}}, "TestGenerateParenthesis": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 258, "max_lineno": 267}, "methods": {"test_generate_parenthesis": {"args": ["self"], "min_max_lineno": {"min_lineno": 260, "max_lineno": 267}, "calls": ["test_backtrack.TestGenerateParenthesis.assertEqual", "algorithms.backtrack.generate_parenthesis_v1", "algorithms.backtrack.generate_parenthesis_v2"], "source_code": "def test_generate_parenthesis(self):\n    self.assertEqual(generate_parenthesis_v1(2), ['()()', '(())'])\n    self.assertEqual(generate_parenthesis_v1(3), ['()()()', '()(())', '(())()', '(()())', '((()))'])\n    self.assertEqual(generate_parenthesis_v2(2), ['(())', '()()'])\n    self.assertEqual(generate_parenthesis_v2(3), ['((()))', '(()())', '(())()', '()(())', '()()()'])"}}}, "TestLetterCombinations": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 269, "max_lineno": 279}, "methods": {"test_letter_combinations": {"args": ["self"], "min_max_lineno": {"min_lineno": 271, "max_lineno": 279}, "calls": ["test_backtrack.TestLetterCombinations.assertEqual", "sorted", "algorithms.backtrack.letter_combinations"], "source_code": "def test_letter_combinations(self):\n    digit1 = '23'\n    answer1 = ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n    self.assertEqual(sorted(letter_combinations(digit1)), sorted(answer1))\n    digit2 = '34'\n    answer2 = ['dg', 'dh', 'di', 'eg', 'eh', 'ei', 'fg', 'fh', 'fi']\n    self.assertEqual(sorted(letter_combinations(digit2)), sorted(answer2))"}}}, "TestPalindromicSubstrings": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 281, "max_lineno": 301}, "methods": {"test_palindromic_substrings": {"args": ["self"], "min_max_lineno": {"min_lineno": 283, "max_lineno": 301}, "calls": ["test_backtrack.TestPalindromicSubstrings.assertEqual", "algorithms.backtrack.palindromic_substrings", "sorted"], "source_code": "def test_palindromic_substrings(self):\n    string1 = 'abc'\n    answer1 = [['a', 'b', 'c']]\n    self.assertEqual(palindromic_substrings(string1), sorted(answer1))\n    string2 = 'abcba'\n    answer2 = [['abcba'], ['a', 'bcb', 'a'], ['a', 'b', 'c', 'b', 'a']]\n    self.assertEqual(sorted(palindromic_substrings(string2)), sorted(answer2))\n    string3 = 'abcccba'\n    answer3 = [['abcccba'], ['a', 'bcccb', 'a'], ['a', 'b', 'ccc', 'b', 'a'], ['a', 'b', 'cc', 'c', 'b', 'a'], ['a', 'b', 'c', 'cc', 'b', 'a'], ['a', 'b', 'c', 'c', 'c', 'b', 'a']]\n    self.assertEqual(sorted(palindromic_substrings(string3)), sorted(answer3))"}}}, "TestPermuteUnique": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 303, "max_lineno": 320}, "methods": {"test_permute_unique": {"args": ["self"], "min_max_lineno": {"min_lineno": 305, "max_lineno": 320}, "calls": ["test_backtrack.TestPermuteUnique.assertEqual", "sorted", "algorithms.backtrack.permute_unique"], "source_code": "def test_permute_unique(self):\n    nums1 = [1, 1, 2]\n    answer1 = [[2, 1, 1], [1, 2, 1], [1, 1, 2]]\n    self.assertEqual(sorted(permute_unique(nums1)), sorted(answer1))\n    nums2 = [1, 2, 1, 3]\n    answer2 = [[3, 1, 2, 1], [1, 3, 2, 1], [1, 2, 3, 1], [1, 2, 1, 3], [3, 2, 1, 1], [2, 3, 1, 1], [2, 1, 3, 1], [2, 1, 1, 3], [3, 1, 1, 2], [1, 3, 1, 2], [1, 1, 3, 2], [1, 1, 2, 3]]\n    self.assertEqual(sorted(permute_unique(nums2)), sorted(answer2))\n    nums3 = [1, 2, 3]\n    answer3 = [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]]\n    self.assertEqual(sorted(permute_unique(nums3)), sorted(answer3))"}}}, "TestPermute": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 322, "max_lineno": 353}, "methods": {"test_permute": {"args": ["self"], "min_max_lineno": {"min_lineno": 324, "max_lineno": 338}, "calls": ["test_backtrack.TestPermute.assertEqual", "sorted", "algorithms.backtrack.permute"], "source_code": "def test_permute(self):\n    nums1 = [1, 2, 3, 4]\n    answer1 = [[1, 2, 3, 4], [2, 1, 3, 4], [2, 3, 1, 4], [2, 3, 4, 1], [1, 3, 2, 4], [3, 1, 2, 4], [3, 2, 1, 4], [3, 2, 4, 1], [1, 3, 4, 2], [3, 1, 4, 2], [3, 4, 1, 2], [3, 4, 2, 1], [1, 2, 4, 3], [2, 1, 4, 3], [2, 4, 1, 3], [2, 4, 3, 1], [1, 4, 2, 3], [4, 1, 2, 3], [4, 2, 1, 3], [4, 2, 3, 1], [1, 4, 3, 2], [4, 1, 3, 2], [4, 3, 1, 2], [4, 3, 2, 1]]\n    self.assertEqual(sorted(permute(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3]\n    answer2 = [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]]\n    self.assertEqual(sorted(permute(nums2)), sorted(answer2))"}, "test_permute_recursive": {"args": ["self"], "min_max_lineno": {"min_lineno": 339, "max_lineno": 353}, "calls": ["test_backtrack.TestPermute.assertEqual", "sorted", "algorithms.backtrack.permute_recursive"], "source_code": "def test_permute_recursive(self):\n    nums1 = [1, 2, 3, 4]\n    answer1 = [[1, 2, 3, 4], [2, 1, 3, 4], [2, 3, 1, 4], [2, 3, 4, 1], [1, 3, 2, 4], [3, 1, 2, 4], [3, 2, 1, 4], [3, 2, 4, 1], [1, 3, 4, 2], [3, 1, 4, 2], [3, 4, 1, 2], [3, 4, 2, 1], [1, 2, 4, 3], [2, 1, 4, 3], [2, 4, 1, 3], [2, 4, 3, 1], [1, 4, 2, 3], [4, 1, 2, 3], [4, 2, 1, 3], [4, 2, 3, 1], [1, 4, 3, 2], [4, 1, 3, 2], [4, 3, 1, 2], [4, 3, 2, 1]]\n    self.assertEqual(sorted(permute_recursive(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3]\n    answer2 = [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]]\n    self.assertEqual(sorted(permute_recursive(nums2)), sorted(answer2))"}}}, "TestSubsetsUnique": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 355, "max_lineno": 367}, "methods": {"test_subsets_unique": {"args": ["self"], "min_max_lineno": {"min_lineno": 357, "max_lineno": 367}, "calls": ["test_backtrack.TestSubsetsUnique.assertEqual", "sorted", "algorithms.backtrack.subsets_unique"], "source_code": "def test_subsets_unique(self):\n    nums1 = [1, 2, 2]\n    answer1 = [(1, 2), (1,), (1, 2, 2), (2,), (), (2, 2)]\n    self.assertEqual(sorted(subsets_unique(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3, 4]\n    answer2 = [(1, 2), (1, 3), (1, 2, 3, 4), (1,), (2,), (3,), (1, 4), (1, 2, 3), (4,), (), (2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 4), (2, 4)]\n    self.assertEqual(sorted(subsets_unique(nums2)), sorted(answer2))"}}}, "TestSubsets": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 369, "max_lineno": 392}, "methods": {"test_subsets": {"args": ["self"], "min_max_lineno": {"min_lineno": 371, "max_lineno": 381}, "calls": ["test_backtrack.TestSubsets.assertEqual", "sorted", "algorithms.backtrack.subsets"], "source_code": "def test_subsets(self):\n    nums1 = [1, 2, 3]\n    answer1 = [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]\n    self.assertEqual(sorted(subsets(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3, 4]\n    answer2 = [[1, 2, 3, 4], [1, 2, 3], [1, 2, 4], [1, 2], [1, 3, 4], [1, 3], [1, 4], [1], [2, 3, 4], [2, 3], [2, 4], [2], [3, 4], [3], [4], []]\n    self.assertEqual(sorted(subsets(nums2)), sorted(answer2))"}, "test_subsets_v2": {"args": ["self"], "min_max_lineno": {"min_lineno": 382, "max_lineno": 392}, "calls": ["test_backtrack.TestSubsets.assertEqual", "sorted", "algorithms.backtrack.subsets_v2"], "source_code": "def test_subsets_v2(self):\n    nums1 = [1, 2, 3]\n    answer1 = [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]\n    self.assertEqual(sorted(subsets_v2(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3, 4]\n    answer2 = [[1, 2, 3, 4], [1, 2, 3], [1, 2, 4], [1, 2], [1, 3, 4], [1, 3], [1, 4], [1], [2, 3, 4], [2, 3], [2, 4], [2], [3, 4], [3], [4], []]\n    self.assertEqual(sorted(subsets_v2(nums2)), sorted(answer2))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_backtrack.unittest.main", "type": "script"}, "is_test": true}