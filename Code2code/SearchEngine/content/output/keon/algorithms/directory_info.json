{"output/keon/algorithms/algorithms": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/setup.py", "fileNameBase": "setup", "extension": "py"}, "dependencies": [{"import": "io", "type": "external", "type_element": "module"}, {"from_module": "setuptools", "import": "find_packages", "type": "external", "type_element": "module"}, {"from_module": "setuptools", "import": "setup", "type": "external", "type_element": "module"}], "functions": {"long_description": {"returns": ["readme"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 9}, "calls": ["io.open", "f.read"], "store_vars_calls": {"readme": "f.read"}, "source_code": "def long_description():\n    with io.open('README.md', 'r', encoding='utf-8') as f:\n        readme = f.read()\n    return readme"}}, "body": {"calls": ["setuptools.setup", "setup.long_description", "setuptools.find_packages"], "source_code": ["setup(name='algorithms', version='0.1.4', description='Pythonic Data Structures and Algorithms', long_description=long_description(), long_description_content_type='text/markdown', url='https://github.com/keon/algorithms', author='Algorithms Team & Contributors', author_email='kwk236@gmail.com', license='MIT', packages=find_packages(exclude=('tests', 'tests.*')), classifiers=['Programming Language :: Python :: 3', 'Programming Language :: Python :: 3.4', 'Programming Language :: Python :: 3.5', 'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: 3.7'], zip_safe=False)", "long_description()", "find_packages(exclude=('tests', 'tests.*'))"]}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/matrix": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/multiply.py", "fileNameBase": "multiply", "extension": "py", "doc": {"long_description": "and return their product\nSpace complexity: O(n^2)\nPossible edge case: the number of columns of multiplicand not consistent with\nthe number of rows of multiplier, will raise exception", "short_description": "This algorithm takes two compatible two dimensional matrix", "full": "This algorithm takes two compatible two dimensional matrix\nand return their product\nSpace complexity: O(n^2)\nPossible edge case: the number of columns of multiplicand not consistent with\nthe number of rows of multiplier, will raise exception"}}, "functions": {"multiply": {"args": ["multiplicand", "multiplier"], "annotated_arg_types": {"multiplicand": "list", "multiplier": "list"}, "annotated_return_type": "list", "returns": ["result"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 29}, "calls": ["range", "len", "Exception"], "source_code": "def multiply(multiplicand: list, multiplier: list) -> list:\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    (multiplicand_row, multiplicand_col) = (len(multiplicand), len(multiplicand[0]))\n    (multiplier_row, multiplier_col) = (len(multiplier), len(multiplier[0]))\n    if multiplicand_col != multiplier_row:\n        raise Exception('Multiplicand matrix not compatible with Multiplier matrix.')\n    result = [[0] * multiplier_col for i in range(multiplicand_row)]\n    for i in range(multiplicand_row):\n        for j in range(multiplier_col):\n            for k in range(len(multiplier)):\n                result[i][j] += multiplicand[i][k] * multiplier[k][j]\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/cholesky_matrix_decomposition.py", "fileNameBase": "cholesky_matrix_decomposition", "extension": "py", "doc": {"long_description": "Hermitian positive-definite matrix A\ninto matrix V, so that V * V* = A, where V* denotes the conjugate\ntranspose of L.\nThe dimensions of the matrix A must match.\n\nThis method is mainly used for numeric solution of linear equations Ax = b.\n\nexample:\nInput matrix A:\n[[  4,  12, -16],\n [ 12,  37, -43],\n [-16, -43,  98]]\n\nResult:\n[[2.0, 0.0, 0.0],\n[6.0, 1.0, 0.0],\n[-8.0, 5.0, 3.0]]\n\nTime complexity of this algorithm is O(n^3), specifically about (n^3)/3", "short_description": "Cholesky matrix decomposition is used to find the decomposition of a", "full": "Cholesky matrix decomposition is used to find the decomposition of a\nHermitian positive-definite matrix A\ninto matrix V, so that V * V* = A, where V* denotes the conjugate\ntranspose of L.\nThe dimensions of the matrix A must match.\n\nThis method is mainly used for numeric solution of linear equations Ax = b.\n\nexample:\nInput matrix A:\n[[  4,  12, -16],\n [ 12,  37, -43],\n [-16, -43,  98]]\n\nResult:\n[[2.0, 0.0, 0.0],\n[6.0, 1.0, 0.0],\n[-8.0, 5.0, 3.0]]\n\nTime complexity of this algorithm is O(n^3), specifically about (n^3)/3"}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"cholesky_decomposition": {"doc": {"args": {"A": {"description": "Hermitian positive-definite matrix of type List[List[float]]"}}, "returns": {"description": "matrix of type List[List[float]] if A can be decomposed,\notherwise None", "is_generator": false}}, "args": ["A"], "returns": ["V", "None", "None"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 52}, "calls": ["len", "range", "math.pow"], "store_vars_calls": {"n": "len"}, "source_code": "def cholesky_decomposition(A):\n    \"\"\"\n    :param A: Hermitian positive-definite matrix of type List[List[float]]\n    :return: matrix of type List[List[float]] if A can be decomposed,\n    otherwise None\n    \"\"\"\n    n = len(A)\n    for ai in A:\n        if len(ai) != n:\n            return None\n    V = [[0.0] * n for _ in range(n)]\n    for j in range(n):\n        sum_diagonal_element = 0\n        for k in range(j):\n            sum_diagonal_element = sum_diagonal_element + math.pow(V[j][k], 2)\n        sum_diagonal_element = A[j][j] - sum_diagonal_element\n        if sum_diagonal_element <= 0:\n            return None\n        V[j][j] = math.pow(sum_diagonal_element, 0.5)\n        for i in range(j + 1, n):\n            sum_other_element = 0\n            for k in range(j):\n                sum_other_element += V[i][k] * V[j][k]\n            V[i][j] = (A[i][j] - sum_other_element) / V[j][j]\n    return V"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/crout_matrix_decomposition.py", "fileNameBase": "crout_matrix_decomposition", "extension": "py", "doc": {"long_description": "give our input matrix, so L * U = A.\nL stands for lower and L has non-zero elements only on diagonal and below.\nU stands for upper and U has non-zero elements only on diagonal and above.\n\nThis can for example be used to solve systems of linear equations.\nThe last if is used  if  to avoid dividing by zero.\n\nExample:\nWe input the A matrix:\n[[1,2,3],\n[3,4,5],\n[6,7,8]]\n\nWe get:\nL = [1.0,  0.0, 0.0]\n    [3.0, -2.0, 0.0]\n    [6.0, -5.0, 0.0]\nU = [1.0,  2.0, 3.0]\n    [0.0,  1.0, 2.0]\n    [0.0,  0.0, 1.0]\n\nWe can check that L * U = A.\n\nI think the complexity should be O(n^3).", "short_description": "Crout matrix decomposition is used to find two matrices that, when multiplied", "full": "Crout matrix decomposition is used to find two matrices that, when multiplied\ngive our input matrix, so L * U = A.\nL stands for lower and L has non-zero elements only on diagonal and below.\nU stands for upper and U has non-zero elements only on diagonal and above.\n\nThis can for example be used to solve systems of linear equations.\nThe last if is used  if  to avoid dividing by zero.\n\nExample:\nWe input the A matrix:\n[[1,2,3],\n[3,4,5],\n[6,7,8]]\n\nWe get:\nL = [1.0,  0.0, 0.0]\n    [3.0, -2.0, 0.0]\n    [6.0, -5.0, 0.0]\nU = [1.0,  2.0, 3.0]\n    [0.0,  1.0, 2.0]\n    [0.0,  0.0, 1.0]\n\nWe can check that L * U = A.\n\nI think the complexity should be O(n^3)."}}, "functions": {"crout_matrix_decomposition": {"args": ["A"], "returns": [["L", "U"]], "min_max_lineno": {"min_lineno": 30, "max_lineno": 49}, "calls": ["len", "range", "float", "int"], "store_vars_calls": {"n": "len", "alpha": "float", "tempU": "float"}, "source_code": "def crout_matrix_decomposition(A):\n    n = len(A)\n    L = [[0.0] * n for i in range(n)]\n    U = [[0.0] * n for i in range(n)]\n    for j in range(n):\n        U[j][j] = 1.0\n        for i in range(j, n):\n            alpha = float(A[i][j])\n            for k in range(j):\n                alpha -= L[i][k] * U[k][j]\n            L[i][j] = float(alpha)\n        for i in range(j + 1, n):\n            tempU = float(A[j][i])\n            for k in range(j):\n                tempU -= float(L[j][k] * U[k][i])\n            if int(L[j][j]) == 0:\n                L[j][j] = float(0.1 ** 40)\n            U[j][i] = float(tempU / L[j][j])\n    return (L, U)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/bomb_enemy.py", "fileNameBase": "bomb_enemy", "extension": "py", "doc": {"long_description": "an enemy 'E' or empty '0' (the number zero),\nreturn the maximum enemies you can kill using one bomb.\nThe bomb kills all the enemies in the same row and column from\nthe planted point until it hits the wall since the wall is too strong\nto be destroyed.\nNote that you can only put the bomb at an empty cell.\n\nExample:\nFor the given grid\n\n0 E 0 0\nE 0 W E\n0 E 0 0\n\nreturn 3. (Placing a bomb at (1,1) kills 3 enemies)", "short_description": "Given a 2D grid, each cell is either a wall 'W',", "full": "Given a 2D grid, each cell is either a wall 'W',\nan enemy 'E' or empty '0' (the number zero),\nreturn the maximum enemies you can kill using one bomb.\nThe bomb kills all the enemies in the same row and column from\nthe planted point until it hits the wall since the wall is too strong\nto be destroyed.\nNote that you can only put the bomb at an empty cell.\n\nExample:\nFor the given grid\n\n0 E 0 0\nE 0 W E\n0 E 0 0\n\nreturn 3. (Placing a bomb at (1,1) kills 3 enemies)"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestBombEnemy": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 95}, "methods": {"test_3x4": {"args": ["self"], "min_max_lineno": {"min_lineno": 76, "max_lineno": 81}, "calls": ["bomb_enemy.TestBombEnemy.assertEqual", "bomb_enemy.max_killed_enemies"], "source_code": "def test_3x4(self):\n    grid1 = [['0', 'E', '0', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    self.assertEqual(3, max_killed_enemies(grid1))"}, "test_4x4": {"args": ["self"], "min_max_lineno": {"min_lineno": 82, "max_lineno": 95}, "calls": ["bomb_enemy.TestBombEnemy.assertEqual", "bomb_enemy.max_killed_enemies"], "source_code": "def test_4x4(self):\n    grid1 = [['0', 'E', '0', 'E'], ['E', 'E', 'E', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    grid2 = [['0', '0', '0', 'E'], ['E', '0', '0', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    self.assertEqual(5, max_killed_enemies(grid1))\n    self.assertEqual(3, max_killed_enemies(grid2))"}}}}, "functions": {"max_killed_enemies": {"args": ["grid"], "returns": ["max_killed", "0"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 42}, "calls": ["range", "len", "bomb_enemy.row_kills", "bomb_enemy.col_kills", "max"], "store_vars_calls": {"row_e": "row_kills", "max_killed": "max"}, "source_code": "def max_killed_enemies(grid):\n    if not grid:\n        return 0\n    (m, n) = (len(grid), len(grid[0]))\n    max_killed = 0\n    (row_e, col_e) = (0, [0] * n)\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                row_e = row_kills(grid, i, j)\n            if i == 0 or grid[i - 1][j] == 'W':\n                col_e[j] = col_kills(grid, i, j)\n            if grid[i][j] == '0':\n                max_killed = max(max_killed, row_e + col_e[j])\n    return max_killed"}, "row_kills": {"args": ["grid", "i", "j"], "returns": ["num"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 53}, "calls": ["len"], "store_vars_calls": {"len_row": "len"}, "source_code": "def row_kills(grid, i, j):\n    num = 0\n    len_row = len(grid[0])\n    while j < len_row and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        j += 1\n    return num"}, "col_kills": {"args": ["grid", "i", "j"], "returns": ["num"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 64}, "calls": ["len"], "store_vars_calls": {"len_col": "len"}, "source_code": "def col_kills(grid, i, j):\n    num = 0\n    len_col = len(grid)\n    while i < len_col and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        i += 1\n    return num"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "bomb_enemy.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/copy_transform.py", "fileNameBase": "copy_transform", "extension": "py"}, "functions": {"rotate_clockwise": {"args": ["matrix"], "returns": ["new"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 11}, "calls": ["reversed", "enumerate", "new[].append", "new.insert"], "source_code": "def rotate_clockwise(matrix):\n    new = []\n    for row in reversed(matrix):\n        for (i, elem) in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new"}, "rotate_counterclockwise": {"args": ["matrix"], "returns": ["new"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 23}, "calls": ["enumerate", "reversed", "new[].append", "new.insert"], "source_code": "def rotate_counterclockwise(matrix):\n    new = []\n    for row in matrix:\n        for (i, elem) in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new"}, "top_left_invert": {"args": ["matrix"], "returns": ["new"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 35}, "calls": ["enumerate", "new[].append", "new.insert"], "source_code": "def top_left_invert(matrix):\n    new = []\n    for row in matrix:\n        for (i, elem) in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new"}, "bottom_left_invert": {"args": ["matrix"], "returns": ["new"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 47}, "calls": ["reversed", "enumerate", "new[].append", "new.insert"], "source_code": "def bottom_left_invert(matrix):\n    new = []\n    for row in reversed(matrix):\n        for (i, elem) in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new"}, "print_matrix": {"args": ["matrix", "name"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 55}, "calls": ["print"], "source_code": "def print_matrix(matrix, name):\n    print('{}:\\n['.format(name))\n    for row in matrix:\n        print('  {}'.format(row))\n    print(']\\n')"}}, "body": {"calls": ["copy_transform.print_matrix", "copy_transform.rotate_clockwise", "copy_transform.rotate_counterclockwise", "copy_transform.top_left_invert", "copy_transform.bottom_left_invert"], "source_code": ["print_matrix(matrix, 'initial')", "print_matrix(rotate_clockwise(matrix), 'clockwise')", "rotate_clockwise(matrix)", "print_matrix(rotate_counterclockwise(matrix), 'counterclockwise')", "rotate_counterclockwise(matrix)", "print_matrix(top_left_invert(matrix), 'top left invert')", "top_left_invert(matrix)", "print_matrix(bottom_left_invert(matrix), 'bottom left invert')", "bottom_left_invert(matrix)"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/spiral_traversal.py", "fileNameBase": "spiral_traversal", "extension": "py", "doc": {"long_description": "return all elements of the matrix in spiral order.\nFor example,\nGiven the following matrix:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\n\nYou should return [1,2,3,6,9,8,7,4,5].", "short_description": "Given a matrix of m x n elements (m rows, n columns),", "full": "Given a matrix of m x n elements (m rows, n columns),\nreturn all elements of the matrix in spiral order.\nFor example,\nGiven the following matrix:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\n\nYou should return [1,2,3,6,9,8,7,4,5]."}}, "functions": {"spiral_traversal": {"args": ["matrix"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 46}, "calls": ["len", "range", "res.append"], "source_code": "def spiral_traversal(matrix):\n    res = []\n    if len(matrix) == 0:\n        return res\n    row_begin = 0\n    row_end = len(matrix) - 1\n    col_begin = 0\n    col_end = len(matrix[0]) - 1\n    while row_begin <= row_end and col_begin <= col_end:\n        for i in range(col_begin, col_end + 1):\n            res.append(matrix[row_begin][i])\n        row_begin += 1\n        for i in range(row_begin, row_end + 1):\n            res.append(matrix[i][col_end])\n        col_end -= 1\n        if row_begin <= row_end:\n            for i in range(col_end, col_begin - 1, -1):\n                res.append(matrix[row_end][i])\n        row_end -= 1\n        if col_begin <= col_end:\n            for i in range(row_end, row_begin - 1, -1):\n                res.append(matrix[i][col_begin])\n        col_begin += 1\n    return res"}}, "body": {"calls": ["print", "spiral_traversal.spiral_traversal"], "source_code": ["print(spiral_traversal(mat))", "spiral_traversal(mat)"]}, "main_info": {"main_flag": 1, "main_function": "spiral_traversal.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/matrix_inversion.py", "fileNameBase": "matrix_inversion", "extension": "py", "doc": {"long_description": "an n x n matrix B such that AB = BA = In, the n x n identity matrix.\n\nFor a 2 x 2 matrix, inversion is simple using the cofactor equation. For\nlarger matrices, this is a four step process:\n1. calculate the matrix of minors: create an n x n matrix by considering each\nposition in the original matrix in turn. Exclude the current row and column\nand calculate the determinant of the remaining matrix, then place that value\nin the current position's equivalent in the matrix of minors.\n2. create the matrix of cofactors: take the matrix of minors and multiply\nalternate values by -1 in a checkerboard pattern.\n3. adjugate: hold the top left to bottom right diagonal constant, but swap all\nother values over it.\n4. multiply the adjugated matrix by 1 / the determinant of the original matrix\n\nThis code combines steps 1 and 2 into one method to reduce traversals of the\nmatrix.\n\nPossible edge cases: will not work for 0x0 or 1x1 matrix, though these are\ntrivial to calculate without use of this file.", "short_description": "Inverts an invertible n x n matrix -- i.e., given an n x n matrix A, returns", "full": "Inverts an invertible n x n matrix -- i.e., given an n x n matrix A, returns\nan n x n matrix B such that AB = BA = In, the n x n identity matrix.\n\nFor a 2 x 2 matrix, inversion is simple using the cofactor equation. For\nlarger matrices, this is a four step process:\n1. calculate the matrix of minors: create an n x n matrix by considering each\nposition in the original matrix in turn. Exclude the current row and column\nand calculate the determinant of the remaining matrix, then place that value\nin the current position's equivalent in the matrix of minors.\n2. create the matrix of cofactors: take the matrix of minors and multiply\nalternate values by -1 in a checkerboard pattern.\n3. adjugate: hold the top left to bottom right diagonal constant, but swap all\nother values over it.\n4. multiply the adjugated matrix by 1 / the determinant of the original matrix\n\nThis code combines steps 1 and 2 into one method to reduce traversals of the\nmatrix.\n\nPossible edge cases: will not work for 0x0 or 1x1 matrix, though these are\ntrivial to calculate without use of this file."}}, "dependencies": [{"import": "fractions", "type": "external", "type_element": "module"}], "functions": {"invert_matrix": {"doc": {"short_description": "invert an n x n matrix"}, "args": ["m"], "returns": ["[[-1]]", "[[-2]]", "[[-3]]", "[[-4]]", "inverted", "inverted"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 64}, "calls": ["matrix_inversion.array_is_matrix", "print", "len", "matrix_inversion.get_determinant", "matrix_inversion.get_matrix_of_minors", "fractions.Fraction", "matrix_inversion.transpose_and_multiply", "range"], "store_vars_calls": {"m_of_minors": "get_matrix_of_minors", "multiplier": "fractions.Fraction", "inverted": "transpose_and_multiply"}, "source_code": "def invert_matrix(m):\n    \"\"\"invert an n x n matrix\"\"\"\n    if not array_is_matrix(m):\n        print('Invalid matrix: array is not a matrix')\n        return [[-1]]\n    elif len(m) != len(m[0]):\n        print('Invalid matrix: matrix is not square')\n        return [[-2]]\n    elif len(m) < 2:\n        print('Invalid matrix: matrix is too small')\n        return [[-3]]\n    elif get_determinant(m) == 0:\n        print('Invalid matrix: matrix is square, but singular (determinant = 0)')\n        return [[-4]]\n    elif len(m) == 2:\n        multiplier = 1 / get_determinant(m)\n        inverted = [[multiplier] * len(m) for n in range(len(m))]\n        inverted[0][1] = inverted[0][1] * -1 * m[0][1]\n        inverted[1][0] = inverted[1][0] * -1 * m[1][0]\n        inverted[0][0] = multiplier * m[1][1]\n        inverted[1][1] = multiplier * m[0][0]\n        return inverted\n    else:\n        'some steps combined in helpers to reduce traversals'\n        m_of_minors = get_matrix_of_minors(m)\n        multiplier = fractions.Fraction(1, get_determinant(m))\n        inverted = transpose_and_multiply(m_of_minors, multiplier)\n        return inverted"}, "get_determinant": {"doc": {"short_description": "recursively calculate the determinant of an n x n matrix, n >= 2"}, "args": ["m"], "returns": ["m[0][0] * m[1][1] - m[0][1] * m[1][0]", "det"], "min_max_lineno": {"min_lineno": 66, "max_lineno": 78}, "calls": ["len", "range", "matrix_inversion.get_determinant", "matrix_inversion.get_minor"], "source_code": "def get_determinant(m):\n    \"\"\"recursively calculate the determinant of an n x n matrix, n >= 2\"\"\"\n    if len(m) == 2:\n        return m[0][0] * m[1][1] - m[0][1] * m[1][0]\n    else:\n        sign = 1\n        det = 0\n        for i in range(len(m)):\n            det += sign * m[0][i] * get_determinant(get_minor(m, 0, i))\n            sign *= -1\n        return det"}, "get_matrix_of_minors": {"doc": {"short_description": "get the matrix of minors and alternate signs"}, "args": ["m"], "returns": ["matrix_of_minors"], "min_max_lineno": {"min_lineno": 80, "max_lineno": 91}, "calls": ["range", "len", "matrix_inversion.get_determinant", "matrix_inversion.get_minor"], "source_code": "def get_matrix_of_minors(m):\n    \"\"\"get the matrix of minors and alternate signs\"\"\"\n    matrix_of_minors = [[0 for i in range(len(m))] for j in range(len(m))]\n    for row in range(len(m)):\n        for col in range(len(m[0])):\n            if (row + col) % 2 == 0:\n                sign = 1\n            else:\n                sign = -1\n            matrix_of_minors[row][col] = sign * get_determinant(get_minor(m, row, col))\n    return matrix_of_minors"}, "get_minor": {"doc": {"long_description": "(all values m[r][c] where r != row and c != col)", "short_description": "get the minor of the matrix position m[row][col]"}, "args": ["m", "row", "col"], "returns": ["minors"], "min_max_lineno": {"min_lineno": 93, "max_lineno": 105}, "calls": ["range", "len", "new_row.extend", "minors.append"], "source_code": "def get_minor(m, row, col):\n    \"\"\"\n    get the minor of the matrix position m[row][col]\n    (all values m[r][c] where r != row and c != col)\n    \"\"\"\n    minors = []\n    for i in range(len(m)):\n        if i != row:\n            new_row = m[i][:col]\n            new_row.extend(m[i][col + 1:])\n            minors.append(new_row)\n    return minors"}, "transpose_and_multiply": {"doc": {"short_description": "swap values along diagonal, optionally adding multiplier"}, "args": ["m", "multiplier"], "returns": ["m"], "min_max_lineno": {"min_lineno": 107, "max_lineno": 115}, "calls": ["range", "len"], "source_code": "def transpose_and_multiply(m, multiplier=1):\n    \"\"\"swap values along diagonal, optionally adding multiplier\"\"\"\n    for row in range(len(m)):\n        for col in range(row + 1):\n            temp = m[row][col] * multiplier\n            m[row][col] = m[col][row] * multiplier\n            m[col][row] = temp\n    return m"}, "array_is_matrix": {"args": ["m"], "returns": ["True", "False", "False"], "min_max_lineno": {"min_lineno": 117, "max_lineno": 125}, "calls": ["len"], "store_vars_calls": {"first_col": "len"}, "source_code": "def array_is_matrix(m):\n    if len(m) == 0:\n        return False\n    first_col = len(m[0])\n    for row in m:\n        if len(row) != first_col:\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/sparse_mul.py", "fileNameBase": "sparse_mul", "extension": "py", "doc": {"long_description": "You may assume that A's column number is equal to B's row number.\n\nExample:\n\nA = [\n  [ 1, 0, 0],\n  [-1, 0, 3]\n]\n\nB = [\n  [ 7, 0, 0 ],\n  [ 0, 0, 0 ],\n  [ 0, 0, 1 ]\n]\n\n\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\nAB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\n                  | 0 0 1 |", "short_description": "Given two sparse matrices A and B, return the result of AB.", "full": "Given two sparse matrices A and B, return the result of AB.\n\nYou may assume that A's column number is equal to B's row number.\n\nExample:\n\nA = [\n  [ 1, 0, 0],\n  [-1, 0, 3]\n]\n\nB = [\n  [ 7, 0, 0 ],\n  [ 0, 0, 0 ],\n  [ 0, 0, 1 ]\n]\n\n\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\nAB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\n                  | 0 0 1 |"}}, "functions": {"multiply": {"args": ["self", "a", "b"], "returns": ["c", "None"], "min_max_lineno": {"min_lineno": 76, "max_lineno": 109}, "calls": ["len", "enumerate", "Exception", "range"], "store_vars_calls": {"l": "len"}, "source_code": "def multiply(self, a, b):\n    \"\"\"\n    :type A: List[List[int]]\n    :type B: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if a is None or b is None:\n        return None\n    (m, n) = (len(a), len(b[0]))\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    l = len(b[0])\n    (table_a, table_b) = ({}, {})\n    for (i, row) in enumerate(a):\n        for (j, ele) in enumerate(row):\n            if ele:\n                if i not in table_a:\n                    table_a[i] = {}\n                table_a[i][j] = ele\n    for (i, row) in enumerate(b):\n        for (j, ele) in enumerate(row):\n            if ele:\n                if i not in table_b:\n                    table_b[i] = {}\n                table_b[i][j] = ele\n    c = [[0 for j in range(l)] for i in range(m)]\n    for i in table_a:\n        for k in table_a[i]:\n            if k not in table_b:\n                continue\n            for j in table_b[k]:\n                c[i][j] += table_a[i][k] * table_b[k][j]\n    return c"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/matrix_exponentiation.py", "fileNameBase": "matrix_exponentiation", "extension": "py"}, "functions": {"multiply": {"doc": {"long_description": "Time Complexity: O(n^3)", "short_description": "Multiplies two square matrices matA and matB of size n x n"}, "args": ["matA", "matB"], "annotated_arg_types": {"matA": "list", "matB": "list"}, "annotated_return_type": "list", "returns": ["matC"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 15}, "calls": ["len", "range"], "store_vars_calls": {"n": "len"}, "source_code": "def multiply(matA: list, matB: list) -> list:\n    \"\"\"\n    Multiplies two square matrices matA and matB of size n x n\n    Time Complexity: O(n^3)\n    \"\"\"\n    n = len(matA)\n    matC = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                matC[i][j] += matA[i][k] * matB[k][j]\n    return matC"}, "identity": {"doc": {"long_description": "Time Complexity: O(n^2)", "short_description": "Returns the Identity matrix of size n x n"}, "args": ["n"], "annotated_arg_types": {"n": "int"}, "annotated_return_type": "list", "returns": ["I"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 28}, "calls": ["range"], "source_code": "def identity(n: int) -> list:\n    \"\"\"\n    Returns the Identity matrix of size n x n\n    Time Complexity: O(n^2)\n    \"\"\"\n    I = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        I[i][i] = 1\n    return I"}, "matrix_exponentiation": {"doc": {"long_description": "Time Complexity: O(d^3 log(n))\n                 d: dimension of the square matrix mat\n                 n: power the matrix is raised to", "short_description": "Calculates mat^n by repeated squaring"}, "args": ["mat", "n"], "annotated_arg_types": {"mat": "list", "n": "int"}, "annotated_return_type": "list", "returns": ["identity(len(mat))", "multiply(matrix_exponentiation(mat, n - 1), mat)", "multiply(tmp, tmp)"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 44}, "calls": ["matrix_exponentiation.identity", "len", "matrix_exponentiation.multiply", "matrix_exponentiation.matrix_exponentiation"], "store_vars_calls": {"tmp": "matrix_exponentiation"}, "source_code": "def matrix_exponentiation(mat: list, n: int) -> list:\n    \"\"\"\n    Calculates mat^n by repeated squaring\n    Time Complexity: O(d^3 log(n))\n                     d: dimension of the square matrix mat\n                     n: power the matrix is raised to\n    \"\"\"\n    if n == 0:\n        return identity(len(mat))\n    elif n % 2 == 1:\n        return multiply(matrix_exponentiation(mat, n - 1), mat)\n    else:\n        tmp = matrix_exponentiation(mat, n // 2)\n        return multiply(tmp, tmp)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/sort_matrix_diagonally.py", "fileNameBase": "sort_matrix_diagonally", "extension": "py", "doc": {"long_description": "sort it diagonally in ascending order\nfrom the top-left to the bottom-right\nthen return the sorted array.\n\nmat = [\n    [3,3,1,1],\n    [2,2,1,2],\n    [1,1,1,2]\n]\n\nShould return:\n[\n    [1,1,1,1],\n    [1,2,2,2],\n    [1,2,3,3]\n]", "short_description": "Given a m * n matrix mat of integers,", "full": "Given a m * n matrix mat of integers,\nsort it diagonally in ascending order\nfrom the top-left to the bottom-right\nthen return the sorted array.\n\nmat = [\n    [3,3,1,1],\n    [2,2,1,2],\n    [1,1,1,2]\n]\n\nShould return:\n[\n    [1,1,1,1],\n    [1,2,2,2],\n    [1,2,3,3]\n]"}}, "dependencies": [{"from_module": "heapq", "import": "heappush", "type": "external", "type_element": "module"}, {"from_module": "heapq", "import": "heappop", "type": "external", "type_element": "module"}, {"from_module": "typing", "import": "List", "type": "external", "type_element": "module"}], "functions": {"sort_diagonally": {"args": ["mat"], "annotated_arg_types": {"mat": "List[List[int]]"}, "annotated_return_type": "List[List[int]]", "returns": ["mat", "mat"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 78}, "calls": ["range", "len", "heapq.heappush", "heapq.heappop"], "store_vars_calls": {"ele": "heappop"}, "source_code": "def sort_diagonally(mat: List[List[int]]) -> List[List[int]]:\n    if len(mat) == 1 or len(mat[0]) == 1:\n        return mat\n    for i in range(len(mat) + len(mat[0]) - 1):\n        if i + 1 < len(mat):\n            h = []\n            row = len(mat) - (i + 1)\n            col = 0\n            while row < len(mat):\n                heappush(h, mat[row][col])\n                row += 1\n                col += 1\n            row = len(mat) - (i + 1)\n            col = 0\n            while h:\n                ele = heappop(h)\n                mat[row][col] = ele\n                row += 1\n                col += 1\n        else:\n            h = []\n            row = 0\n            col = i - (len(mat) - 1)\n            while col < len(mat[0]) and row < len(mat):\n                heappush(h, mat[row][col])\n                row += 1\n                col += 1\n            row = 0\n            col = i - (len(mat) - 1)\n            while h:\n                ele = heappop(h)\n                mat[row][col] = ele\n                row += 1\n                col += 1\n    return mat"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/count_paths.py", "fileNameBase": "count_paths", "extension": "py"}, "functions": {"count_paths": {"args": ["m", "n"], "returns": ["-1"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 31}, "calls": ["range", "print"], "source_code": "def count_paths(m, n):\n    if m < 1 or n < 1:\n        return -1\n    count = [[None for j in range(n)] for i in range(m)]\n    for i in range(n):\n        count[0][i] = 1\n    for j in range(m):\n        count[j][0] = 1\n    for i in range(1, m):\n        for j in range(1, n):\n            count[i][j] = count[i - 1][j] + count[i][j - 1]\n    print(count[m - 1][n - 1])"}, "main": {"min_max_lineno": {"min_lineno": 33, "max_lineno": 36}, "calls": ["map", "count_paths.count_paths", "input().split", "input"], "source_code": "def main():\n    (m, n) = map(int, input('Enter two positive integers: ').split())\n    count_paths(m, n)"}}, "body": {"calls": ["count_paths.main"], "source_code": ["main()"]}, "main_info": {"main_flag": 1, "main_function": "count_paths.main", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/sudoku_validator.py", "fileNameBase": "sudoku_validator", "extension": "py", "doc": {"long_description": "that accepts a 2D array representing a Sudoku board, and returns true\nif it is a valid solution, or false otherwise. The cells of the sudoku\nboard may also contain 0's, which will represent empty cells.\nBoards containing one or more zeroes are considered to be invalid solutions.\nThe board is always 9 cells by 9 cells, and every cell only contains integers\nfrom 0 to 9.\n\n(More info at: http://en.wikipedia.org/wiki/Sudoku)", "short_description": "Write a function validSolution/ValidateSolution/valid_solution()", "full": "Write a function validSolution/ValidateSolution/valid_solution()\nthat accepts a 2D array representing a Sudoku board, and returns true\nif it is a valid solution, or false otherwise. The cells of the sudoku\nboard may also contain 0's, which will represent empty cells.\nBoards containing one or more zeroes are considered to be invalid solutions.\nThe board is always 9 cells by 9 cells, and every cell only contains integers\nfrom 0 to 9.\n\n(More info at: http://en.wikipedia.org/wiki/Sudoku)"}}, "dependencies": [{"from_module": "collections", "import": "defaultdict", "type": "external", "type_element": "module"}], "functions": {"valid_solution_hashtable": {"args": ["board"], "returns": ["True", "False", "False", "False", "False"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 45}, "calls": ["range", "len", "collections.defaultdict"], "store_vars_calls": {"dict_row": "defaultdict", "dict_col": "defaultdict"}, "source_code": "def valid_solution_hashtable(board):\n    for i in range(len(board)):\n        dict_row = defaultdict(int)\n        dict_col = defaultdict(int)\n        for j in range(len(board[0])):\n            value_row = board[i][j]\n            value_col = board[j][i]\n            if not value_row or value_col == 0:\n                return False\n            if value_row in dict_row:\n                return False\n            else:\n                dict_row[value_row] += 1\n            if value_col in dict_col:\n                return False\n            else:\n                dict_col[value_col] += 1\n    for i in range(3):\n        for j in range(3):\n            grid_add = 0\n            for k in range(3):\n                for l in range(3):\n                    grid_add += board[i * 3 + k][j * 3 + l]\n            if grid_add != 45:\n                return False\n    return True"}, "valid_solution": {"args": ["board"], "returns": ["True", "False", "False", "False"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 72}, "calls": ["zip", "range", "sorted"], "source_code": "def valid_solution(board):\n    correct = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    for row in board:\n        if sorted(row) != correct:\n            return False\n    for column in zip(*board):\n        if sorted(column) != correct:\n            return False\n    for i in range(3):\n        for j in range(3):\n            region = []\n            for line in board[i * 3:(i + 1) * 3]:\n                region += line[j * 3:(j + 1) * 3]\n            if sorted(region) != correct:\n                return False\n    return True"}, "valid_solution_set": {"args": ["board"], "returns": ["True", "False", "False", "False"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 92}, "calls": ["set", "range", "sum"], "store_vars_calls": {"valid": "set"}, "source_code": "def valid_solution_set(board):\n    valid = set(range(1, 10))\n    for row in board:\n        if set(row) != valid:\n            return False\n    for col in [[row[i] for row in board] for i in range(9)]:\n        if set(col) != valid:\n            return False\n    for x in range(3):\n        for y in range(3):\n            if set(sum([row[x * 3:(x + 1) * 3] for row in board[y * 3:(y + 1) * 3]], [])) != valid:\n                return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/sparse_dot_vector.py", "fileNameBase": "sparse_dot_vector", "extension": "py", "doc": {"long_description": "zeros and double .\n\nfind a data structure to store them\nget the dot product of them", "short_description": "Suppose we have very large sparse vectors, which contains a lot of", "full": "Suppose we have very large sparse vectors, which contains a lot of\nzeros and double .\n\nfind a data structure to store them\nget the dot product of them"}}, "functions": {"vector_to_index_value_list": {"args": ["vector"], "returns": ["[(i, v) for (i, v) in enumerate(vector) if v != 0.0]"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 14}, "calls": ["enumerate"], "source_code": "def vector_to_index_value_list(vector):\n    return [(i, v) for (i, v) in enumerate(vector) if v != 0.0]"}, "dot_product": {"args": ["iv_list1", "iv_list2"], "returns": ["product"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 36}, "calls": ["len"], "source_code": "def dot_product(iv_list1, iv_list2):\n    product = 0\n    p1 = len(iv_list1) - 1\n    p2 = len(iv_list2) - 1\n    while p1 >= 0 and p2 >= 0:\n        (i1, v1) = iv_list1[p1]\n        (i2, v2) = iv_list2[p2]\n        if i1 < i2:\n            p1 -= 1\n        elif i2 < i1:\n            p2 -= 1\n        else:\n            product += v1 * v2\n            p1 -= 1\n            p2 -= 1\n    return product"}, "__test_simple": {"min_max_lineno": {"min_lineno": 38, "max_lineno": 41}, "calls": ["print", "sparse_dot_vector.dot_product", "sparse_dot_vector.vector_to_index_value_list"], "source_code": "def __test_simple():\n    print(dot_product(vector_to_index_value_list([1.0, 2.0, 3.0]), vector_to_index_value_list([0.0, 2.0, 2.0])))"}, "__test_time": {"returns": ["vector"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 68}, "calls": ["time.time", "range", "print", "random.sample", "sparse_dot_vector.__test_time.random_vector"], "store_vars_calls": {"time_start": "time.time", "time_end": "time.time"}, "functions": {"random_vector": {"returns": ["vector"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 55}, "calls": ["random.sample", "range", "random.random"], "source_code": "def random_vector():\n    import random\n    vector = [0 for _ in range(vector_length)]\n    for i in random.sample(range(vector_length), nozero_counut):\n        vector[i] = random.random()\n    return vector"}}, "source_code": "def __test_time():\n    vector_length = 1024\n    vector_count = 1024\n    nozero_counut = 10\n\n    def random_vector():\n        import random\n        vector = [0 for _ in range(vector_length)]\n        for i in random.sample(range(vector_length), nozero_counut):\n            vector[i] = random.random()\n        return vector\n    vectors = [random_vector() for _ in range(vector_count)]\n    iv_lists = [vector_to_index_value_list(vector) for vector in vectors]\n    import time\n    time_start = time.time()\n    for i in range(vector_count):\n        for j in range(i):\n            dot_product(iv_lists[i], iv_lists[j])\n    time_end = time.time()\n    print(time_end - time_start, 'seconds')"}}, "body": {"calls": ["sparse_dot_vector.__test_simple", "sparse_dot_vector.__test_time"], "source_code": ["__test_simple()", "__test_time()"]}, "main_info": {"main_flag": 1, "main_function": "sparse_dot_vector.__test_simple", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/matrix/rotate_image.py", "fileNameBase": "rotate_image", "extension": "py", "doc": {"long_description": "Rotate the image by 90 degrees (clockwise).\n\nFollow up:\nCould you do this in-place?", "short_description": "You are given an n x n 2D mat representing an image.", "full": "You are given an n x n 2D mat representing an image.\n\nRotate the image by 90 degrees (clockwise).\n\nFollow up:\nCould you do this in-place?"}}, "functions": {"rotate": {"args": ["mat"], "returns": ["mat", "mat"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 25}, "calls": ["mat.reverse", "range", "len"], "source_code": "def rotate(mat):\n    if not mat:\n        return mat\n    mat.reverse()\n    for i in range(len(mat)):\n        for j in range(i):\n            (mat[i][j], mat[j][i]) = (mat[j][i], mat[i][j])\n    return mat"}}, "body": {"calls": ["print", "rotate_image.rotate"], "source_code": ["print(mat)", "rotate(mat)", "print(mat)"]}, "main_info": {"main_flag": 1, "main_function": "rotate_image.print", "type": "script"}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/set": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/set/find_keyboard_row.py", "fileNameBase": "find_keyboard_row", "extension": "py", "doc": {"long_description": "alphabet on only one row's of American keyboard.\n\nFor example:\nInput: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\nOutput: [\"Alaska\", \"Dad\"]\n\nReference: https://leetcode.com/problems/keyboard-row/description/", "short_description": "Given a List of words, return the words that can be typed using letters of", "full": "Given a List of words, return the words that can be typed using letters of\nalphabet on only one row's of American keyboard.\n\nFor example:\nInput: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\nOutput: [\"Alaska\", \"Dad\"]\n\nReference: https://leetcode.com/problems/keyboard-row/description/"}}, "functions": {"find_keyboard_row": {"args": ["words"], "returns": ["result"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 28}, "calls": ["set", "set().issubset", "result.append", "word.lower"], "source_code": "def find_keyboard_row(words):\n    \"\"\"\n    :type words: List[str]\n    :rtype: List[str]\n    \"\"\"\n    keyboard = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]\n    result = []\n    for word in words:\n        for key in keyboard:\n            if set(word.lower()).issubset(key):\n                result.append(word)\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/set/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "find_keyboard_row", "import": "find_keyboard_row", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/set/set_covering.py", "fileNameBase": "set_covering", "extension": "py"}, "dependencies": [{"from_module": "itertools", "import": "chain", "type": "external", "type_element": "module"}, {"from_module": "itertools", "import": "combinations", "type": "external", "type_element": "module"}], "functions": {"powerset": {"doc": {"long_description": "For a range of integers up to the length of the given list,\nmake all possible combinations and chain them together as one object.\nFrom https://docs.python.org/3/library/itertools.html#itertools-recipes", "short_description": "Calculate the powerset of any iterable."}, "args": ["iterable"], "returns": ["chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 35}, "calls": ["list", "itertools.chain.from_iterable", "itertools.combinations", "range", "len"], "store_vars_calls": {"s": "list"}, "source_code": "def powerset(iterable):\n    \"\"\"Calculate the powerset of any iterable.\n\n    For a range of integers up to the length of the given list,\n    make all possible combinations and chain them together as one object.\n    From https://docs.python.org/3/library/itertools.html#itertools-recipes\n    \"\"\"\n    'list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]'\n    s = list(iterable)\n    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))"}, "optimal_set_cover": {"doc": {"long_description": "Finds the minimum cost subcollection os S that covers all elements of U", "short_description": "Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!", "args": {"universe": {"description": "Universe of elements", "type_name": "list", "is_optional": false}, "subsets": {"description": "Subsets of U {S1:elements,S2:elements}", "type_name": "dict", "is_optional": false}, "costs": {"description": "Costs of each subset in S - {S1:cost, S2:cost...}", "type_name": "dict", "is_optional": false}}}, "args": ["universe", "subsets", "costs"], "returns": ["best_set"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 59}, "calls": ["set_covering.powerset", "float", "subsets.keys", "set", "set.update", "len"], "store_vars_calls": {"pset": "powerset", "best_cost": "float", "covered": "set"}, "source_code": "def optimal_set_cover(universe, subsets, costs):\n    \"\"\" Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!\n    Finds the minimum cost subcollection os S that covers all elements of U\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    pset = powerset(subsets.keys())\n    best_set = None\n    best_cost = float('inf')\n    for subset in pset:\n        covered = set()\n        cost = 0\n        for s in subset:\n            covered.update(subsets[s])\n            cost += costs[s]\n        if len(covered) == len(universe) and cost < best_cost:\n            best_set = subset\n            best_cost = cost\n    return best_set"}, "greedy_set_cover": {"doc": {"long_description": "inputs - though not an optimal solution.", "short_description": "Approximate greedy algorithm for set-covering. Can be used on large", "args": {"universe": {"description": "Universe of elements", "type_name": "list", "is_optional": false}, "subsets": {"description": "Subsets of U {S1:elements,S2:elements}", "type_name": "dict", "is_optional": false}, "costs": {"description": "Costs of each subset in S - {S1:cost, S2:cost...}", "type_name": "dict", "is_optional": false}}}, "args": ["universe", "subsets", "costs"], "returns": ["cover_sets", "None"], "min_max_lineno": {"min_lineno": 61, "max_lineno": 96}, "calls": ["set", "float", "subsets.items", "cover_sets.append", "len", "subsets.keys"], "store_vars_calls": {"elements": "set", "covered": "set", "min_cost_elem_ratio": "float", "new_elements": "len"}, "source_code": "def greedy_set_cover(universe, subsets, costs):\n    \"\"\"Approximate greedy algorithm for set-covering. Can be used on large\n    inputs - though not an optimal solution.\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    elements = set((e for s in subsets.keys() for e in subsets[s]))\n    if elements != universe:\n        return None\n    covered = set()\n    cover_sets = []\n    while covered != universe:\n        min_cost_elem_ratio = float('inf')\n        min_set = None\n        for (s, elements) in subsets.items():\n            new_elements = len(elements - covered)\n            if new_elements != 0:\n                cost_elem_ratio = costs[s] / new_elements\n                if cost_elem_ratio < min_cost_elem_ratio:\n                    min_cost_elem_ratio = cost_elem_ratio\n                    min_set = s\n        cover_sets.append(min_set)\n        covered |= subsets[min_set]\n    return cover_sets"}}, "body": {"calls": ["set_covering.optimal_set_cover", "sum", "set_covering.greedy_set_cover", "print"], "store_vars_calls": {"optimal_cover": "optimal_set_cover", "optimal_cost": "sum", "greedy_cover": "greedy_set_cover", "greedy_cost": "sum"}, "source_code": ["optimal_set_cover(universe, subsets, costs)", "sum((costs[s] for s in optimal_cover))", "greedy_set_cover(universe, subsets, costs)", "sum((costs[s] for s in greedy_cover))", "print('Optimal Set Cover:')", "print(optimal_cover)", "print('Cost = %s' % optimal_cost)", "print('Greedy Set Cover:')", "print(greedy_cover)", "print('Cost = %s' % greedy_cost)"]}, "main_info": {"main_flag": 1, "main_function": "set_covering.optimal_set_cover", "type": "script"}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/bit": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/bit_operation.py", "fileNameBase": "bit_operation", "extension": "py", "doc": {"long_description": "get_bit(num, i): get an exact bit at specific index\nset_bit(num, i): set a bit at specific index\nclear_bit(num, i): clear a bit at specific index\nupdate_bit(num, i, bit): update a bit at specific index", "short_description": "Fundamental bit operation:", "full": "Fundamental bit operation:\n    get_bit(num, i): get an exact bit at specific index\n    set_bit(num, i): set a bit at specific index\n    clear_bit(num, i): clear a bit at specific index\n    update_bit(num, i, bit): update a bit at specific index"}}, "functions": {"get_bit": {"args": ["num", "i"], "returns": ["num & 1 << i != 0"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 16}, "source_code": "def get_bit(num, i):\n    return num & 1 << i != 0"}, "set_bit": {"args": ["num", "i"], "returns": ["num | 1 << i"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 23}, "source_code": "def set_bit(num, i):\n    return num | 1 << i"}, "clear_bit": {"args": ["num", "i"], "returns": ["num & mask"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 30}, "source_code": "def clear_bit(num, i):\n    mask = ~(1 << i)\n    return num & mask"}, "update_bit": {"args": ["num", "i", "bit"], "returns": ["num & mask | bit << i"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 38}, "source_code": "def update_bit(num, i, bit):\n    mask = ~(1 << i)\n    return num & mask | bit << i"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/has_alternative_bit.py", "fileNameBase": "has_alternative_bit", "extension": "py", "doc": {"long_description": "if two adjacent bits will always have different values.\n\nFor example:\nInput: 5\nOutput: True because the binary representation of 5 is: 101.\n\nInput: 7\nOutput: False because the binary representation of 7 is: 111.\n\nInput: 11\nOutput: False because the binary representation of 11 is: 1011.\n\nInput: 10\nOutput: True because The binary representation of 10 is: 1010.", "short_description": "Given a positive integer, check whether it has alternating bits: namely,", "full": "Given a positive integer, check whether it has alternating bits: namely,\nif two adjacent bits will always have different values.\n\nFor example:\nInput: 5\nOutput: True because the binary representation of 5 is: 101.\n\nInput: 7\nOutput: False because the binary representation of 7 is: 111.\n\nInput: 11\nOutput: False because the binary representation of 11 is: 1011.\n\nInput: 10\nOutput: True because The binary representation of 10 is: 1010."}}, "functions": {"has_alternative_bit": {"args": ["n"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 33}, "source_code": "def has_alternative_bit(n):\n    first_bit = 0\n    second_bit = 0\n    while n:\n        first_bit = n & 1\n        if n >> 1:\n            second_bit = n >> 1 & 1\n            if not first_bit ^ second_bit:\n                return False\n        else:\n            return True\n        n = n >> 1\n    return True"}, "has_alternative_bit_fast": {"args": ["n"], "returns": ["mask1 == n + (n ^ mask1) or mask2 == n + (n ^ mask2)"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 39}, "calls": ["int"], "store_vars_calls": {"mask1": "int", "mask2": "int"}, "source_code": "def has_alternative_bit_fast(n):\n    mask1 = int('aaaaaaaa', 16)\n    mask2 = int('55555555', 16)\n    return mask1 == n + (n ^ mask1) or mask2 == n + (n ^ mask2)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/single_number.py", "fileNameBase": "single_number", "extension": "py", "doc": {"long_description": "twice except for one. Find that single one.\n\nNOTE: This also works for finding a number occurring odd\n      number of times, where all the other numbers appear\n      even number of times.\n\nNote:\nYour algorithm should have a linear runtime complexity.\nCould you implement it without using extra memory?", "short_description": "Given an array of integers, every element appears", "full": "Given an array of integers, every element appears\ntwice except for one. Find that single one.\n\nNOTE: This also works for finding a number occurring odd\n      number of times, where all the other numbers appear\n      even number of times.\n\nNote:\nYour algorithm should have a linear runtime complexity.\nCould you implement it without using extra memory?"}}, "functions": {"single_number": {"doc": {"long_description": "Else if all numbers appear twice, returns 0.", "short_description": "Returns single number, if found."}, "args": ["nums"], "returns": ["i"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 24}, "source_code": "def single_number(nums):\n    \"\"\"\n    Returns single number, if found.\n    Else if all numbers appear twice, returns 0.\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    i = 0\n    for num in nums:\n        i ^= num\n    return i"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/remove_bit.py", "fileNameBase": "remove_bit", "extension": "py", "doc": {"long_description": "For example:\n\nInput: num = 10101 (21)\nremove_bit(num, 2): output = 1001 (9)\nremove_bit(num, 4): output = 101 (5)\nremove_bit(num, 0): output = 1010 (10)", "short_description": "Remove_bit(num, i): remove a bit at specific position.", "full": "Remove_bit(num, i): remove a bit at specific position.\nFor example:\n\nInput: num = 10101 (21)\nremove_bit(num, 2): output = 1001 (9)\nremove_bit(num, 4): output = 101 (5)\nremove_bit(num, 0): output = 1010 (10)"}}, "functions": {"remove_bit": {"args": ["num", "i"], "returns": ["mask | right"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 16}, "source_code": "def remove_bit(num, i):\n    mask = num >> i + 1\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return mask | right"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/flip_bit_longest_sequence.py", "fileNameBase": "flip_bit_longest_sequence", "extension": "py", "doc": {"long_description": "Write code to find the length of the longest sequence of 1s you could create.\nFor example:\nInput: 1775 ( or: 11011101111)\nOutput: 8", "short_description": "You have an integer and you can flip exactly one bit from a 0 to 1.", "full": "You have an integer and you can flip exactly one bit from a 0 to 1.\nWrite code to find the length of the longest sequence of 1s you could create.\nFor example:\nInput: 1775 ( or: 11011101111)\nOutput: 8"}}, "functions": {"flip_bit_longest_seq": {"args": ["num"], "returns": ["max_len + 1"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 31}, "calls": ["max"], "store_vars_calls": {"max_len": "max"}, "source_code": "def flip_bit_longest_seq(num):\n    curr_len = 0\n    prev_len = 0\n    max_len = 0\n    while num:\n        if num & 1 == 1:\n            curr_len += 1\n        elif num & 1 == 0:\n            if num & 2 == 0:\n                prev_len = 0\n            else:\n                prev_len = curr_len\n            curr_len = 0\n        max_len = max(max_len, prev_len + curr_len)\n        num = num >> 1\n    return max_len + 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/subsets.py", "fileNameBase": "subsets", "extension": "py", "doc": {"long_description": "return all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n{\n    (1, 2),\n    (1, 3),\n    (1,),\n    (2,),\n    (3,),\n    (1, 2, 3),\n    (),\n    (2, 3)\n}", "short_description": "Given a set of distinct integers, nums,", "full": "Given a set of distinct integers, nums,\nreturn all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n{\n    (1, 2),\n    (1, 3),\n    (1,),\n    (2,),\n    (3,),\n    (1, 2, 3),\n    (),\n    (2, 3)\n}"}}, "functions": {"subsets": {"doc": {"args": {"nums": {"description": "List[int]"}}, "returns": {"description": "Set[tuple]", "is_generator": false}}, "args": ["nums"], "returns": ["res"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 35}, "calls": ["len", "set", "range", "tuple", "set.add", "enumerate"], "store_vars_calls": {"n": "len", "res": "set", "subset": "tuple"}, "source_code": "def subsets(nums):\n    \"\"\"\n    :param nums: List[int]\n    :return: Set[tuple]\n    \"\"\"\n    n = len(nums)\n    total = 1 << n\n    res = set()\n    for i in range(total):\n        subset = tuple((num for (j, num) in enumerate(nums) if i & 1 << j))\n        res.add(subset)\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/find_difference.py", "fileNameBase": "find_difference", "extension": "py", "doc": {"long_description": "String t is generated by random shuffling string s and then add one more letter\nat a random position. Find the letter that was added in t.\n\nFor example:\nInput:\ns = \"abcd\"\nt = \"abecd\"\nOutput: 'e'\n\nExplanation:\n'e' is the letter that was added.", "short_description": "Given two strings s and t which consist of only lowercase letters.", "full": "Given two strings s and t which consist of only lowercase letters.\nString t is generated by random shuffling string s and then add one more letter\nat a random position. Find the letter that was added in t.\n\nFor example:\nInput:\ns = \"abcd\"\nt = \"abecd\"\nOutput: 'e'\n\nExplanation:\n'e' is the letter that was added."}}, "functions": {"find_difference": {"args": ["s", "t"], "returns": ["chr(ret)"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 29}, "calls": ["chr", "ord"], "source_code": "def find_difference(s, t):\n    ret = 0\n    for ch in s + t:\n        ret = ret ^ ord(ch)\n    return chr(ret)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/count_flips_to_convert.py", "fileNameBase": "count_flips_to_convert", "extension": "py", "doc": {"long_description": "flip to convert integer A to integer B.\nFor example:\nInput: 29 (or: 11101), 15 (or: 01111)\nOutput: 2", "short_description": "Write a function to determine the minimal number of bits you would need to", "full": "Write a function to determine the minimal number of bits you would need to\nflip to convert integer A to integer B.\nFor example:\nInput: 29 (or: 11101), 15 (or: 01111)\nOutput: 2"}}, "functions": {"count_flips_to_convert": {"args": ["a", "b"], "returns": ["count"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 20}, "source_code": "def count_flips_to_convert(a, b):\n    diff = a ^ b\n    count = 0\n    while diff:\n        diff &= diff - 1\n        count += 1\n    return count"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/reverse_bits.py", "fileNameBase": "reverse_bits", "extension": "py", "doc": {"long_description": "For example, given input 43261596\n(represented in binary as 00000010100101000001111010011100),\nreturn 964176192\n(represented in binary as 00111001011110000010100101000000).", "short_description": "Reverse bits of a given 32 bits unsigned integer.", "full": "Reverse bits of a given 32 bits unsigned integer.\n\nFor example, given input 43261596\n(represented in binary as 00000010100101000001111010011100),\nreturn 964176192\n(represented in binary as 00111001011110000010100101000000)."}}, "functions": {"reverse_bits": {"args": ["n"], "returns": ["m"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 17}, "source_code": "def reverse_bits(n):\n    m = 0\n    i = 0\n    while i < 32:\n        m = (m << 1) + (n & 1)\n        n >>= 1\n        i += 1\n    return m"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/bytes_int_conversion.py", "fileNameBase": "bytes_int_conversion", "extension": "py"}, "dependencies": [{"from_module": "collections", "import": "deque", "type": "external", "type_element": "module"}], "functions": {"int_to_bytes_big_endian": {"args": ["num"], "returns": ["bytes(bytestr)"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 11}, "calls": ["collections.deque", "bytes", "collections.deque.appendleft"], "store_vars_calls": {"bytestr": "deque"}, "source_code": "def int_to_bytes_big_endian(num):\n    bytestr = deque()\n    while num > 0:\n        bytestr.appendleft(num & 255)\n        num >>= 8\n    return bytes(bytestr)"}, "int_to_bytes_little_endian": {"args": ["num"], "returns": ["bytes(bytestr)"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 19}, "calls": ["bytes", "bytestr.append"], "source_code": "def int_to_bytes_little_endian(num):\n    bytestr = []\n    while num > 0:\n        bytestr.append(num & 255)\n        num >>= 8\n    return bytes(bytestr)"}, "bytes_big_endian_to_int": {"args": ["bytestr"], "returns": ["num"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 27}, "source_code": "def bytes_big_endian_to_int(bytestr):\n    num = 0\n    for b in bytestr:\n        num <<= 8\n        num += b\n    return num"}, "bytes_little_endian_to_int": {"args": ["bytestr"], "returns": ["num"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 36}, "source_code": "def bytes_little_endian_to_int(bytestr):\n    num = 0\n    e = 0\n    for b in bytestr:\n        num += b << e\n        e += 8\n    return num"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "add_bitwise_operator", "import": "add_bitwise_operator", "type": "internal", "type_element": "function"}, {"from_module": "count_ones", "import": "count_ones_recur", "type": "internal", "type_element": "function"}, {"from_module": "count_ones", "import": "count_ones_iter", "type": "internal", "type_element": "function"}, {"from_module": "find_missing_number", "import": "find_missing_number", "type": "internal", "type_element": "function"}, {"from_module": "find_missing_number", "import": "find_missing_number2", "type": "internal", "type_element": "function"}, {"from_module": "power_of_two", "import": "is_power_of_two", "type": "internal", "type_element": "function"}, {"from_module": "reverse_bits", "import": "reverse_bits", "type": "internal", "type_element": "function"}, {"from_module": "single_number", "import": "single_number", "type": "internal", "type_element": "function"}, {"from_module": "single_number2", "import": "single_number2", "type": "internal", "type_element": "function"}, {"from_module": "single_number3", "import": "single_number3", "type": "internal", "type_element": "function"}, {"from_module": "subsets", "import": "subsets", "type": "internal", "type_element": "function"}, {"from_module": "bit_operation", "import": "get_bit", "type": "internal", "type_element": "function"}, {"from_module": "bit_operation", "import": "set_bit", "type": "internal", "type_element": "function"}, {"from_module": "bit_operation", "import": "clear_bit", "type": "internal", "type_element": "function"}, {"from_module": "bit_operation", "import": "update_bit", "type": "internal", "type_element": "function"}, {"from_module": "swap_pair", "import": "swap_pair", "type": "internal", "type_element": "function"}, {"from_module": "find_difference", "import": "find_difference", "type": "internal", "type_element": "function"}, {"from_module": "has_alternative_bit", "import": "has_alternative_bit", "type": "internal", "type_element": "function"}, {"from_module": "has_alternative_bit", "import": "has_alternative_bit_fast", "type": "internal", "type_element": "function"}, {"from_module": "insert_bit", "import": "insert_one_bit", "type": "internal", "type_element": "function"}, {"from_module": "insert_bit", "import": "insert_mult_bits", "type": "internal", "type_element": "function"}, {"from_module": "remove_bit", "import": "remove_bit", "type": "internal", "type_element": "function"}, {"from_module": "count_flips_to_convert", "import": "count_flips_to_convert", "type": "internal", "type_element": "function"}, {"from_module": "flip_bit_longest_sequence", "import": "flip_bit_longest_seq", "type": "internal", "type_element": "function"}, {"from_module": "binary_gap", "import": "binary_gap", "type": "internal", "type_element": "function"}, {"from_module": "binary_gap", "import": "binary_gap_improved", "type": "internal", "type_element": "function"}, {"from_module": "bytes_int_conversion", "import": "int_to_bytes_big_endian", "type": "internal", "type_element": "function"}, {"from_module": "bytes_int_conversion", "import": "int_to_bytes_little_endian", "type": "internal", "type_element": "function"}, {"from_module": "bytes_int_conversion", "import": "bytes_big_endian_to_int", "type": "internal", "type_element": "function"}, {"from_module": "bytes_int_conversion", "import": "bytes_little_endian_to_int", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/add_bitwise_operator.py", "fileNameBase": "add_bitwise_operator", "extension": "py", "doc": {"long_description": "The code uses bitwise operations to add two numbers.\n\nInput: 2 3\nOutput: 5", "short_description": "The following code adds two positive integers without using the '+' operator.", "full": "The following code adds two positive integers without using the '+' operator.\nThe code uses bitwise operations to add two numbers.\n\nInput: 2 3\nOutput: 5"}}, "functions": {"add_bitwise_operator": {"args": ["x", "y"], "returns": ["x"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 15}, "source_code": "def add_bitwise_operator(x, y):\n    while y:\n        carry = x & y\n        x = x ^ y\n        y = carry << 1\n    return x"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/power_of_two.py", "fileNameBase": "power_of_two", "extension": "py", "doc": {"short_description": "given an integer, write a function to determine if it is a power of two", "full": "given an integer, write a function to determine if it is a power of two"}}, "functions": {"is_power_of_two": {"args": ["n"], "returns": ["n > 0 and (not n & n - 1)"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 10}, "source_code": "def is_power_of_two(n):\n    \"\"\"\n    :type n: int\n    :rtype: bool\n    \"\"\"\n    return n > 0 and (not n & n - 1)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/insert_bit.py", "fileNameBase": "insert_bit", "extension": "py", "doc": {"long_description": "insert_one_bit(num, bit, i): insert exact one bit at specific position\nFor example:\n\nInput: num = 10101 (21)\ninsert_one_bit(num, 1, 2): 101101 (45)\ninsert_one_bit(num, 0, 2): 101001 (41)\ninsert_one_bit(num, 1, 5): 110101 (53)\ninsert_one_bit(num, 1, 0): 101011 (43)\n\ninsert_mult_bits(num, bits, len, i): insert multiple bits with len at specific position\nFor example:\n\nInput: num = 101 (5)\ninsert_mult_bits(num, 7, 3, 1): 101111 (47)\ninsert_mult_bits(num, 7, 3, 0): 101111 (47)\ninsert_mult_bits(num, 7, 3, 3): 111101 (61)", "short_description": "Insertion:", "full": "Insertion:\n\ninsert_one_bit(num, bit, i): insert exact one bit at specific position\nFor example:\n\nInput: num = 10101 (21)\ninsert_one_bit(num, 1, 2): 101101 (45)\ninsert_one_bit(num, 0, 2): 101001 (41)\ninsert_one_bit(num, 1, 5): 110101 (53)\ninsert_one_bit(num, 1, 0): 101011 (43)\n\ninsert_mult_bits(num, bits, len, i): insert multiple bits with len at specific position\nFor example:\n\nInput: num = 101 (5)\ninsert_mult_bits(num, 7, 3, 1): 101111 (47)\ninsert_mult_bits(num, 7, 3, 0): 101111 (47)\ninsert_mult_bits(num, 7, 3, 3): 111101 (61)"}}, "functions": {"insert_one_bit": {"args": ["num", "bit", "i"], "returns": ["right | mask"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 38}, "source_code": "def insert_one_bit(num, bit, i):\n    mask = num >> i\n    mask = mask << 1 | bit\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return right | mask"}, "insert_mult_bits": {"args": ["num", "bits", "len", "i"], "returns": ["right | mask"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 45}, "source_code": "def insert_mult_bits(num, bits, len, i):\n    mask = num >> i\n    mask = mask << len | bits\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return right | mask"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/single_number2.py", "fileNameBase": "single_number2", "extension": "py", "doc": {"long_description": "three times except for one, which appears exactly once.\nFind that single one.\n\nNote:\nYour algorithm should have a linear runtime complexity.\nCould you implement it without using extra memory?\n\n\nSolution:\n32 bits for each integer.\nConsider 1 bit in it, the sum of each integer's corresponding bit\n(except for the single number)\nshould be 0 if mod by 3. Hence, we sum the bits of all\nintegers and mod by 3,\nthe remaining should be the exact bit of the single number.\nIn this way, you get the 32 bits of the single number.", "short_description": "Given an array of integers, every element appears", "full": "Given an array of integers, every element appears\nthree times except for one, which appears exactly once.\nFind that single one.\n\nNote:\nYour algorithm should have a linear runtime complexity.\nCould you implement it without using extra memory?\n\n\nSolution:\n32 bits for each integer.\nConsider 1 bit in it, the sum of each integer's corresponding bit\n(except for the single number)\nshould be 0 if mod by 3. Hence, we sum the bits of all\nintegers and mod by 3,\nthe remaining should be the exact bit of the single number.\nIn this way, you get the 32 bits of the single number."}}, "functions": {"single_number2": {"args": ["nums"], "returns": ["ones"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 28}, "calls": ["range", "len"], "source_code": "def single_number2(nums):\n    (ones, twos) = (0, 0)\n    for i in range(len(nums)):\n        ones = (ones ^ nums[i]) & ~twos\n        twos = (twos ^ nums[i]) & ~ones\n    return ones"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/count_ones.py", "fileNameBase": "count_ones", "extension": "py", "doc": {"long_description": "returns the number of '1' bits it has\n(also known as the Hamming weight).\n\nFor example, the 32-bit integer '11' has binary\nrepresentation 00000000000000000000000000001011,\nso the function should return 3.\n\nT(n)- O(k)   : k is the number of 1s present in binary representation.\nNOTE: this complexity is better than O(log n).\ne.g. for n = 00010100000000000000000000000000\nonly 2 iterations are required.\n\nNumber of loops is\nequal to the number of 1s in the binary representation.", "short_description": "Write a function that takes an unsigned integer and", "full": "Write a function that takes an unsigned integer and\nreturns the number of '1' bits it has\n(also known as the Hamming weight).\n\nFor example, the 32-bit integer '11' has binary\nrepresentation 00000000000000000000000000001011,\nso the function should return 3.\n\nT(n)- O(k)   : k is the number of 1s present in binary representation.\nNOTE: this complexity is better than O(log n).\ne.g. for n = 00010100000000000000000000000000\nonly 2 iterations are required.\n\nNumber of loops is\nequal to the number of 1s in the binary representation."}}, "functions": {"count_ones_recur": {"doc": {"short_description": "Using Brian Kernighan's Algorithm. (Recursive Approach)"}, "args": ["n"], "returns": ["1 + count_ones_recur(n & n - 1)", "0"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 23}, "calls": ["count_ones.count_ones_recur"], "source_code": "def count_ones_recur(n):\n    \"\"\"Using Brian Kernighan's Algorithm. (Recursive Approach)\"\"\"\n    if not n:\n        return 0\n    return 1 + count_ones_recur(n & n - 1)"}, "count_ones_iter": {"doc": {"short_description": "Using Brian Kernighan's Algorithm. (Iterative Approach)"}, "args": ["n"], "returns": ["count"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 33}, "source_code": "def count_ones_iter(n):\n    \"\"\"Using Brian Kernighan's Algorithm. (Iterative Approach)\"\"\"\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/swap_pair.py", "fileNameBase": "swap_pair", "extension": "py", "doc": {"long_description": "as possible (Ex bit and bit 1 are swapped, bit 2 and bit 3 are swapped)\n\nFor example:\n22: 010110  --> 41: 101001\n10: 1010    --> 5 : 0101", "short_description": "Swap_pair: A function swap odd and even bits in an integer with as few instructions", "full": "Swap_pair: A function swap odd and even bits in an integer with as few instructions\nas possible (Ex bit and bit 1 are swapped, bit 2 and bit 3 are swapped)\n\nFor example:\n22: 010110  --> 41: 101001\n10: 1010    --> 5 : 0101"}}, "functions": {"swap_pair": {"args": ["num"], "returns": ["odd | even"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 22}, "calls": ["int"], "source_code": "def swap_pair(num):\n    odd = (num & int('AAAAAAAA', 16)) >> 1\n    even = (num & int('55555555', 16)) << 1\n    return odd | even"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/find_missing_number.py", "fileNameBase": "find_missing_number", "extension": "py", "doc": {"long_description": "in range [0..n] in O(n) time and space. The difference between\nconsecutive integers cannot be more than 1. If the sequence is\nalready complete, the next integer in the sequence will be returned.\n\nFor example:\nInput: nums = [4, 1, 3, 0, 6, 5, 2]\nOutput: 7", "short_description": "Returns the missing number from a sequence of unique integers", "full": "Returns the missing number from a sequence of unique integers\nin range [0..n] in O(n) time and space. The difference between\nconsecutive integers cannot be more than 1. If the sequence is\nalready complete, the next integer in the sequence will be returned.\n\nFor example:\nInput: nums = [4, 1, 3, 0, 6, 5, 2]\nOutput: 7"}}, "functions": {"find_missing_number": {"args": ["nums"], "returns": ["missing"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 19}, "calls": ["enumerate"], "source_code": "def find_missing_number(nums):\n    missing = 0\n    for (i, num) in enumerate(nums):\n        missing ^= num\n        missing ^= i + 1\n    return missing"}, "find_missing_number2": {"args": ["nums"], "returns": ["missing"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 28}, "calls": ["sum", "len"], "store_vars_calls": {"num_sum": "sum", "n": "len"}, "source_code": "def find_missing_number2(nums):\n    num_sum = sum(nums)\n    n = len(nums)\n    total_sum = n * (n + 1) // 2\n    missing = total_sum - num_sum\n    return missing"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/binary_gap.py", "fileNameBase": "binary_gap", "extension": "py", "doc": {"long_description": "consecutive 1' in the binary representation of N.\nIf there are not two consecutive 1's, return 0\n\nFor example:\nInput: 22\nOutput: 2\nExplanation:\n22 in binary is 10110\nIn the binary representation of 22, there are three ones, and two consecutive pairs of 1's.\nThe first consecutive pair of 1's have distance 2.\nThe second consecutive pair of 1's have distance 1.\nThe answer is the largest of these two distances, which is 2", "short_description": "Given a positive integer N, find and return the longest distance between two", "full": "Given a positive integer N, find and return the longest distance between two\nconsecutive 1' in the binary representation of N.\nIf there are not two consecutive 1's, return 0\n\nFor example:\nInput: 22\nOutput: 2\nExplanation:\n22 in binary is 10110\nIn the binary representation of 22, there are three ones, and two consecutive pairs of 1's.\nThe first consecutive pair of 1's have distance 2.\nThe second consecutive pair of 1's have distance 1.\nThe answer is the largest of these two distances, which is 2"}}, "functions": {"binary_gap": {"args": ["N"], "returns": ["ans"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 36}, "calls": ["max"], "store_vars_calls": {"ans": "max"}, "source_code": "def binary_gap(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        if N & 1:\n            if last is not None:\n                ans = max(ans, index - last)\n            last = index\n        index = index + 1\n        N = N >> 1\n    return ans"}, "binary_gap_improved": {"args": ["N"], "returns": ["ans"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 54}, "calls": ["max"], "store_vars_calls": {"ans": "max"}, "source_code": "def binary_gap_improved(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        tes = N & 1\n        if tes:\n            if last is not None:\n                ans = max(ans, index - last + 1)\n            else:\n                last = index\n        else:\n            last = index + 1\n        index = index + 1\n        N = N >> 1\n    return ans"}}, "body": {"calls": ["print", "binary_gap.binary_gap", "binary_gap.binary_gap_improved"], "source_code": ["print(binary_gap(111))", "binary_gap(111)", "print(binary_gap_improved(111))", "binary_gap_improved(111)"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bit/single_number3.py", "fileNameBase": "single_number3", "extension": "py", "doc": {"long_description": "in which exactly two elements appear only once\nand all the other elements appear exactly twice.\nFind the two elements that appear only once.\nLimitation: Time Complexity: O(N) and Space Complexity O(1)\n\nFor example:\n\nGiven nums = [1, 2, 1, 3, 2, 5], return [3, 5].\n\nNote:\nThe order of the result is not important.\nSo in the above example, [5, 3] is also correct.\n\n\nSolution:\n1. Use XOR to cancel out the pairs and isolate A^B\n2. It is guaranteed that at least 1 bit exists in A^B since\n   A and B are different numbers. ex) 010 ^ 111 = 101\n3. Single out one bit R (right most bit in this solution) to use it as a pivot\n4. Divide all numbers into two groups.\n   One group with a bit in the position R\n   One group without a bit in the position R\n5. Use the same strategy we used in step 1 to isolate A and B from each group.", "short_description": "Given an array of numbers nums,", "full": "Given an array of numbers nums,\nin which exactly two elements appear only once\nand all the other elements appear exactly twice.\nFind the two elements that appear only once.\nLimitation: Time Complexity: O(N) and Space Complexity O(1)\n\nFor example:\n\nGiven nums = [1, 2, 1, 3, 2, 5], return [3, 5].\n\nNote:\nThe order of the result is not important.\nSo in the above example, [5, 3] is also correct.\n\n\nSolution:\n1. Use XOR to cancel out the pairs and isolate A^B\n2. It is guaranteed that at least 1 bit exists in A^B since\n   A and B are different numbers. ex) 010 ^ 111 = 101\n3. Single out one bit R (right most bit in this solution) to use it as a pivot\n4. Divide all numbers into two groups.\n   One group with a bit in the position R\n   One group without a bit in the position R\n5. Use the same strategy we used in step 1 to isolate A and B from each group."}}, "functions": {"single_number3": {"args": ["nums"], "returns": ["[a, b]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 50}, "source_code": "def single_number3(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    ab = 0\n    for n in nums:\n        ab ^= n\n    right_most = ab & -ab\n    (a, b) = (0, 0)\n    for n in nums:\n        if n & right_most:\n            a ^= n\n        else:\n            b ^= n\n    return [a, b]"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/arrays": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/flatten.py", "fileNameBase": "flatten", "extension": "py", "doc": {"long_description": "Given an array that may contain nested arrays,\nproduce a single resultant array.", "short_description": "Implement Flatten Arrays.", "full": "Implement Flatten Arrays.\nGiven an array that may contain nested arrays,\nproduce a single resultant array."}}, "dependencies": [{"from_module": "collections.abc", "import": "Iterable", "type": "external", "type_element": "module"}], "functions": {"flatten": {"args": ["input_arr", "output_arr"], "returns": ["output_arr"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 19}, "calls": ["isinstance", "flatten.flatten", "output_arr.append"], "source_code": "def flatten(input_arr, output_arr=None):\n    if output_arr is None:\n        output_arr = []\n    for ele in input_arr:\n        if not isinstance(ele, str) and isinstance(ele, Iterable):\n            flatten(ele, output_arr)\n        else:\n            output_arr.append(ele)\n    return output_arr"}, "flatten_iter": {"doc": {"long_description": "returns generator which produces one dimensional output.", "short_description": "Takes as input multi dimensional iterable and"}, "args": ["iterable"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 32}, "calls": ["isinstance", "flatten.flatten_iter"], "source_code": "def flatten_iter(iterable):\n    \"\"\"\n    Takes as input multi dimensional iterable and\n    returns generator which produces one dimensional output.\n    \"\"\"\n    for element in iterable:\n        if not isinstance(element, str) and isinstance(element, Iterable):\n            yield from flatten_iter(element)\n        else:\n            yield element"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/summarize_ranges.py", "fileNameBase": "summarize_ranges", "extension": "py", "doc": {"long_description": "return the summary of its ranges.\n\nFor example, given [0, 1, 2, 4, 5, 7], return [(0, 2), (4, 5), (7, 7)].", "short_description": "Given a sorted integer array without duplicates,", "full": "Given a sorted integer array without duplicates,\nreturn the summary of its ranges.\n\nFor example, given [0, 1, 2, 4, 5, 7], return [(0, 2), (4, 5), (7, 7)]."}}, "functions": {"summarize_ranges": {"args": ["array"], "returns": ["res", "[str(array[0])]"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 28}, "calls": ["len", "str", "res.append"], "source_code": "def summarize_ranges(array):\n    \"\"\"\n    :type array: List[int]\n    :rtype: List[]\n    \"\"\"\n    res = []\n    if len(array) == 1:\n        return [str(array[0])]\n    i = 0\n    while i < len(array):\n        num = array[i]\n        while i + 1 < len(array) and array[i + 1] - array[i] == 1:\n            i += 1\n        if array[i] != num:\n            res.append((num, array[i]))\n        else:\n            res.append((num, num))\n        i += 1\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/longest_non_repeat.py", "fileNameBase": "longest_non_repeat", "extension": "py", "doc": {"long_description": "without repeating characters.\n\nExamples:\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3.\nNote that the answer must be a substring,\n\"pwke\" is a subsequence and not a substring.", "short_description": "Given a string, find the length of the longest substring", "full": "Given a string, find the length of the longest substring\nwithout repeating characters.\n\nExamples:\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3.\nNote that the answer must be a substring,\n\"pwke\" is a subsequence and not a substring."}}, "functions": {"longest_non_repeat_v1": {"doc": {"long_description": "without repeating characters.", "short_description": "Find the length of the longest substring"}, "args": ["string"], "returns": ["max_length", "0"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 30}, "calls": ["range", "len", "max"], "store_vars_calls": {"max_length": "max", "j": "max"}, "source_code": "def longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    \"\"\"\n    if string is None:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        max_length = max(max_length, i - j + 1)\n    return max_length"}, "longest_non_repeat_v2": {"doc": {"long_description": "without repeating characters.\nUses alternative algorithm.", "short_description": "Find the length of the longest substring"}, "args": ["string"], "returns": ["max_len", "0"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 48}, "calls": ["enumerate", "max"], "store_vars_calls": {"max_len": "max"}, "source_code": "def longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    \"\"\"\n    if string is None:\n        return 0\n    (start, max_len) = (0, 0)\n    used_char = {}\n    for (index, char) in enumerate(string):\n        if char in used_char and start <= used_char[char]:\n            start = used_char[char] + 1\n        else:\n            max_len = max(max_len, index - start + 1)\n        used_char[char] = index\n    return max_len"}, "get_longest_non_repeat_v1": {"doc": {"long_description": "without repeating characters.\nReturn max_len and the substring as a tuple", "short_description": "Find the length of the longest substring"}, "args": ["string"], "returns": [["max_length", "sub_string"], ["0", "''"]], "min_max_lineno": {"min_lineno": 50, "max_lineno": 70}, "calls": ["range", "len", "max"], "store_vars_calls": {"j": "max"}, "source_code": "def get_longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Return max_len and the substring as a tuple\n    \"\"\"\n    if string is None:\n        return (0, '')\n    sub_string = ''\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        if i - j + 1 > max_length:\n            max_length = i - j + 1\n            sub_string = string[j:i + 1]\n    return (max_length, sub_string)"}, "get_longest_non_repeat_v2": {"doc": {"long_description": "without repeating characters.\nUses alternative algorithm.\nReturn max_len and the substring as a tuple", "short_description": "Find the length of the longest substring"}, "args": ["string"], "returns": [["max_len", "sub_string"], ["0", "''"]], "min_max_lineno": {"min_lineno": 71, "max_lineno": 92}, "calls": ["enumerate"], "source_code": "def get_longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    Return max_len and the substring as a tuple\n    \"\"\"\n    if string is None:\n        return (0, '')\n    sub_string = ''\n    (start, max_len) = (0, 0)\n    used_char = {}\n    for (index, char) in enumerate(string):\n        if char in used_char and start <= used_char[char]:\n            start = used_char[char] + 1\n        elif index - start + 1 > max_len:\n            max_len = index - start + 1\n            sub_string = string[start:index + 1]\n        used_char[char] = index\n    return (max_len, sub_string)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/garage.py", "fileNameBase": "garage", "extension": "py", "doc": {"long_description": "of the parking lot and the final state. Each step we are only allowed to\nmove a car\nout of its place and move it into the empty spot.\nThe goal is to find out the least movement needed to rearrange\nthe parking lot from the initial state to the final state.\n\nSay the initial state is an array:\n\n[1, 2, 3, 0, 4],\nwhere 1, 2, 3, 4 are different cars, and 0 is the empty spot.\n\nAnd the final state is\n\n[0, 3, 2, 1, 4].\nWe can swap 1 with 0 in the initial array to get [0, 2, 3, 1, 4] and so on.\nEach step swap with 0 only.\n\nEdit:\nNow also prints the sequence of changes in states.\nOutput of this example :-\n\ninitial: [1, 2, 3, 0, 4]\nfinal:   [0, 3, 2, 1, 4]\nSteps =  4\nSequence : \n0 2 3 1 4\n2 0 3 1 4\n2 3 0 1 4\n0 3 2 1 4", "short_description": "There is a parking lot with only one empty spot. Given the initial state", "full": "There is a parking lot with only one empty spot. Given the initial state\nof the parking lot and the final state. Each step we are only allowed to\nmove a car\nout of its place and move it into the empty spot.\nThe goal is to find out the least movement needed to rearrange\nthe parking lot from the initial state to the final state.\n\nSay the initial state is an array:\n\n[1, 2, 3, 0, 4],\nwhere 1, 2, 3, 4 are different cars, and 0 is the empty spot.\n\nAnd the final state is\n\n[0, 3, 2, 1, 4].\nWe can swap 1 with 0 in the initial array to get [0, 2, 3, 1, 4] and so on.\nEach step swap with 0 only.\n\nEdit:\nNow also prints the sequence of changes in states.\nOutput of this example :-\n\ninitial: [1, 2, 3, 0, 4]\nfinal:   [0, 3, 2, 1, 4]\nSteps =  4\nSequence : \n0 2 3 1 4\n2 0 3 1 4\n2 3 0 1 4\n0 3 2 1 4"}}, "functions": {"garage": {"args": ["initial", "final"], "returns": [["steps", "seq"]], "min_max_lineno": {"min_lineno": 35, "max_lineno": 55}, "calls": ["initial.index", "seq.append", "final.index", "range", "len"], "store_vars_calls": {"zero": "initial.index", "pos": "initial.index"}, "source_code": "def garage(initial, final):\n    initial = initial[:]\n    seq = []\n    steps = 0\n    while initial != final:\n        zero = initial.index(0)\n        if zero != final.index(0):\n            car_to_move = final[zero]\n            pos = initial.index(car_to_move)\n            (initial[zero], initial[pos]) = (initial[pos], initial[zero])\n        else:\n            for i in range(len(initial)):\n                if initial[i] != final[i]:\n                    (initial[zero], initial[i]) = (initial[i], initial[zero])\n                    break\n        seq.append(initial[:])\n        steps += 1\n    return (steps, seq)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/max_ones_index.py", "fileNameBase": "max_ones_index", "extension": "py", "doc": {"long_description": "longest continuous sequence\nof 1s in a binary array.\nReturns index of 0 to be\nreplaced with 1 to get longest\ncontinuous sequence of 1s.\nIf there is no 0 in array, then\nit returns -1.\n\ne.g.\nlet input array = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]\nIf we replace 0 at index 3 with 1, we get the longest continuous\nsequence of 1s in the array.\nSo the function return => 3", "short_description": "Find the index of 0 to be replaced with 1 to get", "full": "Find the index of 0 to be replaced with 1 to get\nlongest continuous sequence\nof 1s in a binary array.\nReturns index of 0 to be\nreplaced with 1 to get longest\ncontinuous sequence of 1s.\nIf there is no 0 in array, then\nit returns -1.\n\ne.g.\nlet input array = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]\nIf we replace 0 at index 3 with 1, we get the longest continuous\nsequence of 1s in the array.\nSo the function return => 3"}}, "functions": {"max_ones_index": {"args": ["arr"], "returns": ["max_index"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 44}, "calls": ["len", "range"], "store_vars_calls": {"n": "len"}, "source_code": "def max_ones_index(arr):\n    n = len(arr)\n    max_count = 0\n    max_index = 0\n    prev_zero = -1\n    prev_prev_zero = -1\n    for curr in range(n):\n        if arr[curr] == 0:\n            if curr - prev_prev_zero > max_count:\n                max_count = curr - prev_prev_zero\n                max_index = prev_zero\n            prev_prev_zero = prev_zero\n            prev_zero = curr\n    if n - prev_prev_zero > max_count:\n        max_index = prev_zero\n    return max_index"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/n_sum.py", "fileNameBase": "n_sum", "extension": "py", "doc": {"long_description": "such that a + b + .. + n = target?\n\nFind all unique n-tuplets in the array which gives the sum of target.", "short_description": "Given an array of n integers, are there elements a, b, .. , n in nums", "full": "Given an array of n integers, are there elements a, b, .. , n in nums\nsuch that a + b + .. + n = target?\n\nFind all unique n-tuplets in the array which gives the sum of target.\n\nExample:\n    basic:\n        Given:\n            n = 4\n            nums = [1, 0, -1, 0, -2, 2]\n            target = 0,\n        return [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n\n    advanced:\n        Given:\n            n = 2\n            nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]]\n            target = -5\n            def sum(a, b):\n                return [a[0] + b[1], a[1] + b[0]]\n            def compare(num, target):\n                if num[0] < target:\n                    return -1\n                elif if num[0] > target:\n                    return 1\n                else:\n                    return 0\n        return [[-9, 5], [8, 4]]\n(TL:DR) because -9 + 4 = -5"}}, "functions": {"n_sum": {"doc": {"long_description": "nums: list[object]\ntarget: object\nsum_closure: function, optional\n    Given two elements of nums, return sum of both.\ncompare_closure: function, optional\n    Given one object of nums and target, return -1, 1, or 0.\nsame_closure: function, optional\n    Given two object of nums, return bool.\nreturn: list[list[object]]\n\nNote:\n1. type of sum_closure's return should be same \n   as type of compare_closure's first param", "short_description": "n: int"}, "args": ["n", "nums", "target"], "returns": ["n_sum(n, nums, target)", "a + b", "a == b", "union(results)", "results", "results", "results", "-1", "1", "0"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 141}, "calls": ["kv.get", "nums.sort", "n_sum.n_sum", "n_sum.n_sum.union"], "store_vars_calls": {"sum_closure": "kv.get", "same_closure": "kv.get", "compare_closure": "kv.get", "results": "two_sum", "sum_": "sum_closure", "flag": "compare_closure", "n_minus1_results": "append_elem_to_each_list"}, "functions": {"sum_closure_default": {"args": ["a", "b"], "returns": ["a + b"], "min_max_lineno": {"min_lineno": 52, "max_lineno": 54}, "source_code": "def sum_closure_default(a, b):\n    return a + b"}, "compare_closure_default": {"doc": {"short_description": "above, below, or right on? "}, "args": ["num", "target"], "returns": ["-1", "1", "0"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 63}, "source_code": "def compare_closure_default(num, target):\n    \"\"\" above, below, or right on? \"\"\"\n    if num < target:\n        return -1\n    elif num > target:\n        return 1\n    else:\n        return 0"}, "same_closure_default": {"args": ["a", "b"], "returns": ["a == b"], "min_max_lineno": {"min_lineno": 64, "max_lineno": 66}, "source_code": "def same_closure_default(a, b):\n    return a == b"}, "two_sum": {"args": ["nums", "target"], "returns": ["results"], "min_max_lineno": {"min_lineno": 93, "max_lineno": 116}, "calls": ["nums.sort", "len", "sum_closure", "compare_closure", "results.append", "sorted", "same_closure"], "store_vars_calls": {"sum_": "sum_closure", "flag": "compare_closure"}, "source_code": "def two_sum(nums, target):\n    nums.sort()\n    lt = 0\n    rt = len(nums) - 1\n    results = []\n    while lt < rt:\n        sum_ = sum_closure(nums[lt], nums[rt])\n        flag = compare_closure(sum_, target)\n        if flag == -1:\n            lt += 1\n        elif flag == 1:\n            rt -= 1\n        else:\n            results.append(sorted([nums[lt], nums[rt]]))\n            lt += 1\n            rt -= 1\n            while lt < len(nums) and same_closure(nums[lt - 1], nums[lt]):\n                lt += 1\n            while 0 <= rt and same_closure(nums[rt], nums[rt + 1]):\n                rt -= 1\n    return results"}, "append_elem_to_each_list": {"args": ["elem", "container"], "returns": ["results"], "min_max_lineno": {"min_lineno": 117, "max_lineno": 123}, "calls": ["elems.append", "results.append", "sorted"], "source_code": "def append_elem_to_each_list(elem, container):\n    results = []\n    for elems in container:\n        elems.append(elem)\n        results.append(sorted(elems))\n    return results"}, "union": {"args": ["duplicate_results"], "returns": ["results"], "min_max_lineno": {"min_lineno": 124, "max_lineno": 135}, "calls": ["len", "duplicate_results.sort", "results.append"], "source_code": "def union(duplicate_results):\n    results = []\n    if len(duplicate_results) != 0:\n        duplicate_results.sort()\n        results.append(duplicate_results[0])\n        for result in duplicate_results[1:]:\n            if results[-1] != result:\n                results.append(result)\n    return results"}}, "source_code": "def n_sum(n, nums, target, **kv):\n    \"\"\"\n    n: int\n    nums: list[object]\n    target: object\n    sum_closure: function, optional\n        Given two elements of nums, return sum of both.\n    compare_closure: function, optional\n        Given one object of nums and target, return -1, 1, or 0.\n    same_closure: function, optional\n        Given two object of nums, return bool.\n    return: list[list[object]]\n\n    Note:\n    1. type of sum_closure's return should be same \n       as type of compare_closure's first param\n    \"\"\"\n\n    def sum_closure_default(a, b):\n        return a + b\n\n    def compare_closure_default(num, target):\n        \"\"\" above, below, or right on? \"\"\"\n        if num < target:\n            return -1\n        elif num > target:\n            return 1\n        else:\n            return 0\n\n    def same_closure_default(a, b):\n        return a == b\n\n    def n_sum(n, nums, target):\n        if n == 2:\n            results = two_sum(nums, target)\n        else:\n            results = []\n            prev_num = None\n            for (index, num) in enumerate(nums):\n                if prev_num is not None and same_closure(prev_num, num):\n                    continue\n                prev_num = num\n                n_minus1_results = n_sum(n - 1, nums[index + 1:], target - num)\n                n_minus1_results = append_elem_to_each_list(num, n_minus1_results)\n                results += n_minus1_results\n        return union(results)\n\n    def two_sum(nums, target):\n        nums.sort()\n        lt = 0\n        rt = len(nums) - 1\n        results = []\n        while lt < rt:\n            sum_ = sum_closure(nums[lt], nums[rt])\n            flag = compare_closure(sum_, target)\n            if flag == -1:\n                lt += 1\n            elif flag == 1:\n                rt -= 1\n            else:\n                results.append(sorted([nums[lt], nums[rt]]))\n                lt += 1\n                rt -= 1\n                while lt < len(nums) and same_closure(nums[lt - 1], nums[lt]):\n                    lt += 1\n                while 0 <= rt and same_closure(nums[rt], nums[rt + 1]):\n                    rt -= 1\n        return results\n\n    def append_elem_to_each_list(elem, container):\n        results = []\n        for elems in container:\n            elems.append(elem)\n            results.append(sorted(elems))\n        return results\n\n    def union(duplicate_results):\n        results = []\n        if len(duplicate_results) != 0:\n            duplicate_results.sort()\n            results.append(duplicate_results[0])\n            for result in duplicate_results[1:]:\n                if results[-1] != result:\n                    results.append(result)\n        return results\n    sum_closure = kv.get('sum_closure', sum_closure_default)\n    same_closure = kv.get('same_closure', same_closure_default)\n    compare_closure = kv.get('compare_closure', compare_closure_default)\n    nums.sort()\n    return n_sum(n, nums, target)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/rotate.py", "fileNameBase": "rotate", "extension": "py", "doc": {"long_description": "For example, with n = 7 and k = 3,\nthe array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].\n\nNote:\nTry to come up as many solutions as you can,\nthere are at least 3 different ways to solve this problem.", "short_description": "Rotate an array of n elements to the right by k steps.", "full": "Rotate an array of n elements to the right by k steps.\n\nFor example, with n = 7 and k = 3,\nthe array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].\n\nNote:\nTry to come up as many solutions as you can,\nthere are at least 3 different ways to solve this problem."}}, "functions": {"rotate_v1": {"doc": {"long_description": "T(n)- O(nk)", "short_description": "Rotate the entire array 'k' times"}, "args": ["array", "k"], "returns": ["array"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 30}, "calls": ["len", "range"], "store_vars_calls": {"n": "len"}, "source_code": "def rotate_v1(array, k):\n    \"\"\"\n    Rotate the entire array 'k' times\n    T(n)- O(nk)\n\n    :type array: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify array in-place instead.\n    \"\"\"\n    array = array[:]\n    n = len(array)\n    for i in range(k):\n        temp = array[n - 1]\n        for j in range(n - 1, 0, -1):\n            array[j] = array[j - 1]\n        array[0] = temp\n    return array"}, "rotate_v2": {"doc": {"long_description": "T(n)- O(n)", "short_description": "Reverse segments of the array, followed by the entire array"}, "args": ["array", "k"], "returns": ["array"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 54}, "calls": ["len", "rotate.rotate_v2.reverse"], "store_vars_calls": {"n": "len"}, "functions": {"reverse": {"args": ["arr", "a", "b"], "min_max_lineno": {"min_lineno": 42, "max_lineno": 47}, "source_code": "def reverse(arr, a, b):\n    while a < b:\n        (arr[a], arr[b]) = (arr[b], arr[a])\n        a += 1\n        b -= 1"}}, "source_code": "def rotate_v2(array, k):\n    \"\"\"\n    Reverse segments of the array, followed by the entire array\n    T(n)- O(n)\n    :type array: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    array = array[:]\n\n    def reverse(arr, a, b):\n        while a < b:\n            (arr[a], arr[b]) = (arr[b], arr[a])\n            a += 1\n            b -= 1\n    n = len(array)\n    k = k % n\n    reverse(array, 0, n - k - 1)\n    reverse(array, n - k, n - 1)\n    reverse(array, 0, n - 1)\n    return array"}, "rotate_v3": {"args": ["array", "k"], "returns": ["array[length - k:] + array[:length - k]", "None"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 62}, "calls": ["len"], "store_vars_calls": {"length": "len"}, "source_code": "def rotate_v3(array, k):\n    if array is None:\n        return None\n    length = len(array)\n    k = k % length\n    return array[length - k:] + array[:length - k]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/move_zeros.py", "fileNameBase": "move_zeros", "extension": "py", "doc": {"long_description": "preserving the order of the other elements.\n    move_zeros([false, 1, 0, 1, 2, 0, 1, 3, \"a\"])\n    returns => [false, 1, 1, 2, 1, 3, \"a\", 0, 0]\n\nThe time complexity of the below algorithm is O(n).", "short_description": "Write an algorithm that takes an array and moves all of the zeros to the end,", "full": "Write an algorithm that takes an array and moves all of the zeros to the end,\npreserving the order of the other elements.\n    move_zeros([false, 1, 0, 1, 2, 0, 1, 3, \"a\"])\n    returns => [false, 1, 1, 2, 1, 3, \"a\", 0, 0]\n\nThe time complexity of the below algorithm is O(n)."}}, "functions": {"move_zeros": {"args": ["array"], "returns": ["result"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 24}, "calls": ["result.extend", "result.append", "type"], "source_code": "def move_zeros(array):\n    result = []\n    zeros = 0\n    for i in array:\n        if i == 0 and type(i) != bool:\n            zeros += 1\n        else:\n            result.append(i)\n    result.extend([0] * zeros)\n    return result"}}, "body": {"calls": ["print", "move_zeros.move_zeros"], "source_code": ["print(move_zeros([False, 1, 0, 1, 2, 0, 1, 3, 'a']))", "move_zeros([False, 1, 0, 1, 2, 0, 1, 3, 'a'])"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "delete_nth", "import": "delete_nth_naive", "type": "internal", "type_element": "function"}, {"from_module": "delete_nth", "import": "delete_nth", "type": "internal", "type_element": "function"}, {"from_module": "flatten", "import": "flatten", "type": "internal", "type_element": "function"}, {"from_module": "flatten", "import": "flatten_iter", "type": "internal", "type_element": "function"}, {"from_module": "garage", "import": "garage", "type": "internal", "type_element": "function"}, {"from_module": "josephus", "import": "josephus", "type": "internal", "type_element": "function"}, {"from_module": "longest_non_repeat", "import": "longest_non_repeat_v1", "type": "internal", "type_element": "function"}, {"from_module": "longest_non_repeat", "import": "longest_non_repeat_v2", "type": "internal", "type_element": "function"}, {"from_module": "longest_non_repeat", "import": "get_longest_non_repeat_v1", "type": "internal", "type_element": "function"}, {"from_module": "longest_non_repeat", "import": "get_longest_non_repeat_v2", "type": "internal", "type_element": "function"}, {"from_module": "max_ones_index", "import": "max_ones_index", "type": "internal", "type_element": "function"}, {"from_module": "merge_intervals", "import": "merge_intervals", "type": "internal", "type_element": "function"}, {"from_module": "merge_intervals", "import": "Interval", "type": "internal", "type_element": "class"}, {"from_module": "missing_ranges", "import": "missing_ranges", "type": "internal", "type_element": "function"}, {"from_module": "move_zeros", "import": "move_zeros", "type": "internal", "type_element": "function"}, {"from_module": "plus_one", "import": "plus_one_v1", "type": "internal", "type_element": "function"}, {"from_module": "plus_one", "import": "plus_one_v2", "type": "internal", "type_element": "function"}, {"from_module": "plus_one", "import": "plus_one_v3", "type": "internal", "type_element": "function"}, {"from_module": "rotate", "import": "rotate_v1", "type": "internal", "type_element": "function"}, {"from_module": "rotate", "import": "rotate_v2", "type": "internal", "type_element": "function"}, {"from_module": "rotate", "import": "rotate_v3", "type": "internal", "type_element": "function"}, {"from_module": "summarize_ranges", "import": "summarize_ranges", "type": "internal", "type_element": "function"}, {"from_module": "three_sum", "import": "three_sum", "type": "internal", "type_element": "function"}, {"from_module": "trimmean", "import": "trimmean", "type": "internal", "type_element": "function"}, {"from_module": "top_1", "import": "top_1", "type": "internal", "type_element": "function"}, {"from_module": "two_sum", "import": "two_sum", "type": "internal", "type_element": "function"}, {"from_module": "limit", "import": "limit", "type": "internal", "type_element": "function"}, {"from_module": "n_sum", "import": "n_sum", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/trimmean.py", "fileNameBase": "trimmean", "extension": "py", "doc": {"long_description": "For example, when making average score on athletes we need this option.\nSo, this algorithm affixes some percentage to neglect when making mean.\nFor example, if you suggest 20%, it will neglect the best 10% of values\nand the worst 10% of values.\n\nThis algorithm takes an array and percentage to neglect. After sorted,\nif index of array is larger or smaller than desired ratio, we don't\ncompute it.\n\nCompleity: O(n)", "short_description": "When make reliable means, we need to neglect best and worst values.", "full": "When make reliable means, we need to neglect best and worst values.\nFor example, when making average score on athletes we need this option.\nSo, this algorithm affixes some percentage to neglect when making mean.\nFor example, if you suggest 20%, it will neglect the best 10% of values\nand the worst 10% of values.\n\nThis algorithm takes an array and percentage to neglect. After sorted,\nif index of array is larger or smaller than desired ratio, we don't\ncompute it.\n\nCompleity: O(n)"}}, "functions": {"trimmean": {"args": ["arr", "per"], "returns": ["cal_sum / len(arr)"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 25}, "calls": ["arr.sort", "int", "len"], "store_vars_calls": {"neg_val": "int"}, "source_code": "def trimmean(arr, per):\n    ratio = per / 200\n    cal_sum = 0\n    arr.sort()\n    neg_val = int(len(arr) * ratio)\n    arr = arr[neg_val:len(arr) - neg_val]\n    for i in arr:\n        cal_sum += i\n    return cal_sum / len(arr)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/limit.py", "fileNameBase": "limit", "extension": "py", "doc": {"long_description": "value over 10 or, you need value under than 100. By use this algorithms, you\n can limit your array to specific value\n\nIf array, Min, Max value was given, it returns array that contains values of \n given array which was larger than Min, and lower than Max. You need to give\n 'unlimit' to use only Min or Max.\n\nex) limit([1,2,3,4,5], None, 3) = [1,2,3]\n\nComplexity = O(n)", "short_description": "Sometimes you need to limit array result to use. Such as you only need the ", "full": "Sometimes you need to limit array result to use. Such as you only need the \n value over 10 or, you need value under than 100. By use this algorithms, you\n can limit your array to specific value\n\nIf array, Min, Max value was given, it returns array that contains values of \n given array which was larger than Min, and lower than Max. You need to give\n 'unlimit' to use only Min or Max.\n\nex) limit([1,2,3,4,5], None, 3) = [1,2,3]\n\nComplexity = O(n)"}}, "functions": {"limit": {"args": ["arr", "min_lim", "max_lim"], "returns": ["list(filter(lambda x: min_lim <= x <= max_lim, arr))", "arr"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 26}, "calls": ["list", "len", "min", "max", "filter"], "store_vars_calls": {"min_lim": "min", "max_lim": "max"}, "source_code": "def limit(arr, min_lim=None, max_lim=None):\n    if len(arr) == 0:\n        return arr\n    if min_lim is None:\n        min_lim = min(arr)\n    if max_lim is None:\n        max_lim = max(arr)\n    return list(filter(lambda x: min_lim <= x <= max_lim, arr))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/missing_ranges.py", "fileNameBase": "missing_ranges", "extension": "py", "doc": {"long_description": "Ex) [3, 5] lo=1 hi=10 => answer: [(1, 2), (4, 4), (6, 10)]", "short_description": "Find missing ranges between low and high in the given array.", "full": "Find missing ranges between low and high in the given array.\nEx) [3, 5] lo=1 hi=10 => answer: [(1, 2), (4, 4), (6, 10)]"}}, "functions": {"missing_ranges": {"args": ["arr", "lo", "hi"], "returns": ["res"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 23}, "calls": ["res.append"], "source_code": "def missing_ranges(arr, lo, hi):\n    res = []\n    start = lo\n    for n in arr:\n        if n == start:\n            start += 1\n        elif n > start:\n            res.append((start, n - 1))\n            start = n + 1\n    if start <= hi:\n        res.append((start, hi))\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/top_1.py", "fileNameBase": "top_1", "extension": "py", "doc": {"long_description": "Also, sometimes it is possible to have multiple 'most_frequent_value's,\nso this function returns a list. This result can be used to find a \nrepresentative value in an array.\n\nThis algorithm gets an array, makes a dictionary of it,\n finds the most frequent count, and makes the result list.\n\nFor example: top_1([1, 1, 2, 2, 3, 4]) will return [1, 2]\n\n(TL:DR) Get mathematical Mode\nComplexity: O(n)", "short_description": "This algorithm receives an array and returns most_frequent_value", "full": "This algorithm receives an array and returns most_frequent_value\nAlso, sometimes it is possible to have multiple 'most_frequent_value's,\nso this function returns a list. This result can be used to find a \nrepresentative value in an array.\n\nThis algorithm gets an array, makes a dictionary of it,\n finds the most frequent count, and makes the result list.\n\nFor example: top_1([1, 1, 2, 2, 3, 4]) will return [1, 2]\n\n(TL:DR) Get mathematical Mode\nComplexity: O(n)"}}, "functions": {"top_1": {"args": ["arr"], "returns": ["result"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 37}, "calls": ["max", "values.keys", "values.values", "result.append"], "store_vars_calls": {"f_val": "max"}, "source_code": "def top_1(arr):\n    values = {}\n    result = []\n    f_val = 0\n    for i in arr:\n        if i in values:\n            values[i] += 1\n        else:\n            values[i] = 1\n    f_val = max(values.values())\n    for i in values.keys():\n        if values[i] == f_val:\n            result.append(i)\n        else:\n            continue\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/merge_intervals.py", "fileNameBase": "merge_intervals", "extension": "py", "doc": {"long_description": "numbers with the property that any number that lies\nbetween two numbers in the set is also included in the set.", "short_description": "In mathematics, a (real) interval is a set of real", "full": "In mathematics, a (real) interval is a set of real\n numbers with the property that any number that lies\n between two numbers in the set is also included in the set."}}, "classes": {"Interval": {"doc": {"long_description": "numbers are included in the set.\nIncludes related methods to merge and print interval sets.", "short_description": "A set of real numbers with methods to determine if other", "full": "A set of real numbers with methods to determine if other\n numbers are included in the set.\nIncludes related methods to merge and print interval sets."}, "min_max_lineno": {"min_lineno": 8, "max_lineno": 64}, "methods": {"__init__": {"args": ["self", "start", "end"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 17}, "source_code": "def __init__(self, start=0, end=0):\n    self.start = start\n    self.end = end"}, "__repr__": {"args": ["self"], "returns": ["'Interval ({}, {})'.format(self.start, self.end)"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 20}, "source_code": "def __repr__(self):\n    return 'Interval ({}, {})'.format(self.start, self.end)"}, "__iter__": {"args": ["self"], "returns": ["iter(range(self.start, self.end))"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 23}, "calls": ["iter", "range"], "source_code": "def __iter__(self):\n    return iter(range(self.start, self.end))"}, "__getitem__": {"args": ["self", "index"], "returns": ["self.start + index", "self.end + index"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 28}, "source_code": "def __getitem__(self, index):\n    if index < 0:\n        return self.end + index\n    return self.start + index"}, "__len__": {"args": ["self"], "returns": ["self.end - self.start"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 31}, "source_code": "def __len__(self):\n    return self.end - self.start"}, "__contains__": {"args": ["self", "item"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 36}, "source_code": "def __contains__(self, item):\n    if self.start >= item >= self.end:\n        return True\n    return False"}, "__eq__": {"args": ["self", "other"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 41}, "source_code": "def __eq__(self, other):\n    if self.start == other.start and self.end == other.end:\n        return True\n    return False"}, "as_list": {"doc": {"short_description": "Return interval as list. "}, "args": ["self"], "returns": ["list(self)"], "min_max_lineno": {"min_lineno": 42, "max_lineno": 45}, "calls": ["list"], "source_code": "def as_list(self):\n    \"\"\" Return interval as list. \"\"\"\n    return list(self)"}, "merge": {"doc": {"short_description": "Merge two intervals into one. "}, "args": ["intervals"], "returns": ["out"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 56}, "calls": ["sorted", "max"], "store_vars_calls": {"out[].end": "max"}, "source_code": "@staticmethod\ndef merge(intervals):\n    \"\"\" Merge two intervals into one. \"\"\"\n    out = []\n    for i in sorted(intervals, key=lambda i: i.start):\n        if out and i.start <= out[-1].end:\n            out[-1].end = max(out[-1].end, i.end)\n        else:\n            out += (i,)\n    return out"}, "print_intervals": {"doc": {"short_description": "Print out the intervals. "}, "args": ["intervals"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 64}, "calls": ["print", "res.append", "repr"], "source_code": "@staticmethod\ndef print_intervals(intervals):\n    \"\"\" Print out the intervals. \"\"\"\n    res = []\n    for i in intervals:\n        res.append(repr(i))\n    print(''.join(res))"}}}}, "functions": {"merge_intervals": {"doc": {"short_description": "Merge intervals in the form of a list. "}, "args": ["intervals"], "returns": ["out", "None"], "min_max_lineno": {"min_lineno": 66, "max_lineno": 78}, "calls": ["intervals.sort", "intervals.pop", "max", "out.append"], "source_code": "def merge_intervals(intervals):\n    \"\"\" Merge intervals in the form of a list. \"\"\"\n    if intervals is None:\n        return None\n    intervals.sort(key=lambda i: i[0])\n    out = [intervals.pop(0)]\n    for i in intervals:\n        if out[-1][-1] >= i[0]:\n            out[-1][-1] = max(out[-1][-1], i[-1])\n        else:\n            out.append(i)\n    return out"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/josephus.py", "fileNameBase": "josephus", "extension": "py", "doc": {"long_description": "print every third member while removing them,\nthe next counter starts immediately after the member is removed.\nPrint till all the members are exhausted.\n\nFor example:\nInput: consider 123456789 members sitting in a circular fashion,\nOutput: 369485271", "short_description": "There are people sitting in a circular fashion,", "full": "There are people sitting in a circular fashion,\nprint every third member while removing them,\nthe next counter starts immediately after the member is removed.\nPrint till all the members are exhausted.\n\nFor example:\nInput: consider 123456789 members sitting in a circular fashion,\nOutput: 369485271"}}, "functions": {"josephus": {"args": ["int_list", "skip"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 20}, "calls": ["len", "int_list.pop"], "store_vars_calls": {"len_list": "len"}, "source_code": "def josephus(int_list, skip):\n    skip = skip - 1\n    idx = 0\n    len_list = len(int_list)\n    while len_list > 0:\n        idx = (skip + idx) % len_list\n        yield int_list.pop(idx)\n        len_list -= 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/plus_one.py", "fileNameBase": "plus_one", "extension": "py", "doc": {"long_description": "adding one to each numeral.\n\nThe digits are stored big-endian, such that the most significant\ndigit is at the head of the list.", "short_description": "Given a non-negative number represented as an array of digits,", "full": "Given a non-negative number represented as an array of digits,\nadding one to each numeral.\n\nThe digits are stored big-endian, such that the most significant\ndigit is at the head of the list."}}, "functions": {"plus_one_v1": {"args": ["digits"], "returns": ["res[::-1]"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 29}, "calls": ["len", "res.append"], "source_code": "def plus_one_v1(digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    digits[-1] = digits[-1] + 1\n    res = []\n    ten = 0\n    i = len(digits) - 1\n    while i >= 0 or ten == 1:\n        summ = 0\n        if i >= 0:\n            summ += digits[i]\n        if ten:\n            summ += 1\n        res.append(summ % 10)\n        ten = summ // 10\n        i -= 1\n    return res[::-1]"}, "plus_one_v2": {"args": ["digits"], "returns": ["digits", "digits"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 40}, "calls": ["len", "range", "digits.insert"], "store_vars_calls": {"n": "len"}, "source_code": "def plus_one_v2(digits):\n    n = len(digits)\n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    digits.insert(0, 1)\n    return digits"}, "plus_one_v3": {"args": ["num_arr"], "returns": ["[1] + num_arr", "num_arr"], "min_max_lineno": {"min_lineno": 42, "max_lineno": 49}, "calls": ["reversed", "list", "enumerate"], "source_code": "def plus_one_v3(num_arr):\n    for idx in reversed(list(enumerate(num_arr))):\n        num_arr[idx[0]] = (num_arr[idx[0]] + 1) % 10\n        if num_arr[idx[0]]:\n            return num_arr\n    return [1] + num_arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/three_sum.py", "fileNameBase": "three_sum", "extension": "py", "doc": {"long_description": "a, b, c in S such that a + b + c = 0?\nFind all unique triplets in the array which gives the sum of zero.\n\nNote: The solution set must not contain duplicate triplets.\n\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n{\n  (-1, 0, 1),\n  (-1, -1, 2)\n}", "short_description": "Given an array S of n integers, are there three distinct elements", "full": "Given an array S of n integers, are there three distinct elements\na, b, c in S such that a + b + c = 0?\nFind all unique triplets in the array which gives the sum of zero.\n\nNote: The solution set must not contain duplicate triplets.\n\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n{\n  (-1, 0, 1),\n  (-1, -1, 2)\n}"}}, "functions": {"three_sum": {"doc": {"args": {"array": {"description": "List[int]"}}, "returns": {"description": "Set[ Tuple[int, int, int] ]", "is_generator": false}}, "args": ["array"], "returns": ["res"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 49}, "calls": ["set", "array.sort", "range", "len", "set.add"], "store_vars_calls": {"res": "set"}, "source_code": "def three_sum(array):\n    \"\"\"\n    :param array: List[int]\n    :return: Set[ Tuple[int, int, int] ]\n    \"\"\"\n    res = set()\n    array.sort()\n    for i in range(len(array) - 2):\n        if i > 0 and array[i] == array[i - 1]:\n            continue\n        (l, r) = (i + 1, len(array) - 1)\n        while l < r:\n            s = array[i] + array[l] + array[r]\n            if s > 0:\n                r -= 1\n            elif s < 0:\n                l += 1\n            else:\n                res.add((array[i], array[l], array[r]))\n                while l < r and array[l] == array[l + 1]:\n                    l += 1\n                while l < r and array[r] == array[r - 1]:\n                    r -= 1\n                l += 1\n                r -= 1\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/two_sum.py", "fileNameBase": "two_sum", "extension": "py", "doc": {"long_description": "such that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.", "short_description": "Given an array of integers, return indices of the two numbers", "full": "Given an array of integers, return indices of the two numbers\nsuch that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\n\nExample:\n    Given nums = [2, 7, 11, 15], target = 9,\n\n    Because nums[0] + nums[1] = 2 + 7 = 9,\n    return (0, 1)"}}, "functions": {"two_sum": {"args": ["array", "target"], "returns": ["None", ["dic[num]", "i"]], "min_max_lineno": {"min_lineno": 16, "max_lineno": 24}, "calls": ["enumerate"], "source_code": "def two_sum(array, target):\n    dic = {}\n    for (i, num) in enumerate(array):\n        if num in dic:\n            return (dic[num], i)\n        else:\n            dic[target - num] = i\n    return None"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/arrays/delete_nth.py", "fileNameBase": "delete_nth", "extension": "py", "doc": {"long_description": "that contains each number of the list at most N times without reordering.\n\nFor example if N = 2, and the input is [1,2,3,1,2,1,2,3], you take [1,2,3,1,2], \ndrop the next [1,2] since this would lead to 1 and 2 being in the result 3 times, and then take 3, \nwhich leads to [1,2,3,1,2,3]", "short_description": "Given a list lst and a number N, create a new list", "full": "Given a list lst and a number N, create a new list\nthat contains each number of the list at most N times without reordering.\n\nFor example if N = 2, and the input is [1,2,3,1,2,1,2,3], you take [1,2,3,1,2], \ndrop the next [1,2] since this would lead to 1 and 2 being in the result 3 times, and then take 3, \nwhich leads to [1,2,3,1,2,3]"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"delete_nth_naive": {"args": ["array", "n"], "returns": ["ans"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 19}, "calls": ["ans.count", "ans.append"], "source_code": "def delete_nth_naive(array, n):\n    ans = []\n    for num in array:\n        if ans.count(num) < n:\n            ans.append(num)\n    return ans"}, "delete_nth": {"args": ["array", "n"], "returns": ["result"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 33}, "calls": ["collections.defaultdict", "result.append"], "store_vars_calls": {"counts": "collections.defaultdict"}, "source_code": "def delete_nth(array, n):\n    result = []\n    counts = collections.defaultdict(int)\n    for i in array:\n        if counts[i] < n:\n            result.append(i)\n            counts[i] += 1\n    return result"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/strings": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/rotate.py", "fileNameBase": "rotate", "extension": "py", "doc": {"long_description": "k can be any positive integer.\n\nFor example,\nrotate(\"hello\", 2) return \"llohe\"\nrotate(\"hello\", 5) return \"hello\"\nrotate(\"hello\", 6) return \"elloh\"\nrotate(\"hello\", 7) return \"llohe\"\nrotate(\"hello\", 102) return \"lohel\"", "short_description": "Given a strings s and int k, return a string that rotates k times", "full": "Given a strings s and int k, return a string that rotates k times\n\nk can be any positive integer.\n\nFor example,\nrotate(\"hello\", 2) return \"llohe\"\nrotate(\"hello\", 5) return \"hello\"\nrotate(\"hello\", 6) return \"elloh\"\nrotate(\"hello\", 7) return \"llohe\"\nrotate(\"hello\", 102) return \"lohel\""}}, "functions": {"rotate": {"args": ["s", "k"], "returns": ["long_string[k:k + len(s)]", "long_string[k - len(s):k]"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 20}, "calls": ["len"], "source_code": "def rotate(s, k):\n    long_string = s * (k // len(s) + 2)\n    if k <= len(s):\n        return long_string[k:k + len(s)]\n    else:\n        return long_string[k - len(s):k]"}, "rotate_alt": {"args": ["string", "k"], "returns": ["string[k:] + string[:k]"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 24}, "calls": ["len"], "source_code": "def rotate_alt(string, k):\n    k = k % len(string)\n    return string[k:] + string[:k]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "add_binary", "import": "add_binary", "type": "internal", "type_element": "function"}, {"from_module": "breaking_bad", "import": "match_symbol", "type": "internal", "type_element": "function"}, {"from_module": "breaking_bad", "import": "match_symbol_1", "type": "internal", "type_element": "function"}, {"from_module": "breaking_bad", "import": "bracket", "type": "internal", "type_element": "function"}, {"from_module": "breaking_bad", "import": "TreeNode", "type": "internal", "type_element": "class"}, {"from_module": "decode_string", "import": "decode_string", "type": "internal", "type_element": "function"}, {"from_module": "delete_reoccurring", "import": "delete_reoccurring_characters", "type": "internal", "type_element": "function"}, {"from_module": "domain_extractor", "import": "domain_name_1", "type": "internal", "type_element": "function"}, {"from_module": "domain_extractor", "import": "domain_name_2", "type": "internal", "type_element": "function"}, {"from_module": "encode_decode", "import": "encode", "type": "internal", "type_element": "function"}, {"from_module": "encode_decode", "import": "decode", "type": "internal", "type_element": "function"}, {"from_module": "group_anagrams", "import": "group_anagrams", "type": "internal", "type_element": "function"}, {"from_module": "int_to_roman", "import": "int_to_roman", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "remove_punctuation", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "string_reverse", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_reverse", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_two_pointer", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_stack", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_deque", "type": "internal", "type_element": "function"}, {"from_module": "is_rotated", "import": "is_rotated", "type": "internal", "type_element": "function"}, {"from_module": "is_rotated", "import": "is_rotated_v1", "type": "internal", "type_element": "function"}, {"from_module": "license_number", "import": "license_number", "type": "internal", "type_element": "function"}, {"from_module": "make_sentence", "import": "make_sentence", "type": "internal", "type_element": "function"}, {"from_module": "merge_string_checker", "import": "is_merge_recursive", "type": "internal", "type_element": "function"}, {"from_module": "merge_string_checker", "import": "is_merge_iterative", "type": "internal", "type_element": "function"}, {"from_module": "multiply_strings", "import": "multiply", "type": "internal", "type_element": "function"}, {"from_module": "one_edit_distance", "import": "is_one_edit", "type": "internal", "type_element": "function"}, {"from_module": "one_edit_distance", "import": "is_one_edit2", "type": "internal", "type_element": "function"}, {"from_module": "rabin_karp", "import": "rabin_karp", "type": "internal", "type_element": "function"}, {"from_module": "rabin_karp", "import": "RollingHash", "type": "internal", "type_element": "class"}, {"from_module": "reverse_string", "import": "recursive", "type": "internal", "type_element": "function"}, {"from_module": "reverse_string", "import": "iterative", "type": "internal", "type_element": "function"}, {"from_module": "reverse_string", "import": "pythonic", "type": "internal", "type_element": "function"}, {"from_module": "reverse_string", "import": "ultra_pythonic", "type": "internal", "type_element": "function"}, {"from_module": "reverse_vowel", "import": "reverse_vowel", "type": "internal", "type_element": "function"}, {"from_module": "reverse_words", "import": "reverse", "type": "internal", "type_element": "function"}, {"from_module": "reverse_words", "import": "reverse_words", "type": "internal", "type_element": "function"}, {"from_module": "roman_to_int", "import": "roman_to_int", "type": "internal", "type_element": "function"}, {"from_module": "strip_url_params", "import": "strip_url_params1", "type": "internal", "type_element": "function"}, {"from_module": "strip_url_params", "import": "strip_url_params2", "type": "internal", "type_element": "function"}, {"from_module": "strip_url_params", "import": "strip_url_params3", "type": "internal", "type_element": "function"}, {"from_module": "validate_coordinates", "import": "is_valid_coordinates_0", "type": "internal", "type_element": "function"}, {"from_module": "validate_coordinates", "import": "is_valid_coordinates_1", "type": "internal", "type_element": "function"}, {"from_module": "validate_coordinates", "import": "is_valid_coordinates_regular_expression", "type": "internal", "type_element": "function"}, {"from_module": "word_squares", "import": "word_squares", "type": "internal", "type_element": "function"}, {"from_module": "unique_morse", "import": "convert_morse_word", "type": "internal", "type_element": "function"}, {"from_module": "unique_morse", "import": "unique_morse", "type": "internal", "type_element": "function"}, {"from_module": "judge_circle", "import": "judge_circle", "type": "internal", "type_element": "function"}, {"from_module": "strong_password", "import": "strong_password", "type": "internal", "type_element": "function"}, {"from_module": "caesar_cipher", "import": "caesar_cipher", "type": "internal", "type_element": "function"}, {"from_module": "check_pangram", "import": "check_pangram", "type": "internal", "type_element": "function"}, {"from_module": "contain_string", "import": "contain_string", "type": "internal", "type_element": "function"}, {"from_module": "count_binary_substring", "import": "count_binary_substring", "type": "internal", "type_element": "function"}, {"from_module": "repeat_string", "import": "repeat_string", "type": "internal", "type_element": "function"}, {"from_module": "text_justification", "import": "text_justification", "type": "internal", "type_element": "function"}, {"from_module": "min_distance", "import": "min_distance", "type": "internal", "type_element": "function"}, {"from_module": "min_distance", "import": "lcs", "type": "internal", "type_element": "function"}, {"from_module": "min_distance", "import": "min_distance_dp", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "common_prefix", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "longest_common_prefix_v1", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "longest_common_prefix_v2", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "longest_common_prefix_v3", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "longest_common", "type": "internal", "type_element": "function"}, {"from_module": "rotate", "import": "rotate", "type": "internal", "type_element": "function"}, {"from_module": "rotate", "import": "rotate_alt", "type": "internal", "type_element": "function"}, {"from_module": "first_unique_char", "import": "first_unique_char", "type": "internal", "type_element": "function"}, {"from_module": "repeat_substring", "import": "repeat_substring", "type": "internal", "type_element": "function"}, {"from_module": "atbash_cipher", "import": "atbash", "type": "internal", "type_element": "function"}, {"from_module": "longest_palindromic_substring", "import": "longest_palindrome", "type": "internal", "type_element": "function"}, {"from_module": "knuth_morris_pratt", "import": "knuth_morris_pratt", "type": "internal", "type_element": "function"}, {"from_module": "panagram", "import": "panagram", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/validate_coordinates.py", "fileNameBase": "validate_coordinates", "extension": "py", "doc": {"long_description": "Create a function that will validate if given parameters are valid geographical coordinates.\nValid coordinates look like the following: \"23.32353342, -32.543534534\". The return value should be either true or false.\nLatitude (which is first float) can be between 0 and 90, positive or negative. Longitude (which is second float) can be between 0 and 180, positive or negative.\nCoordinates can only contain digits, or one of the following symbols (including space after comma) -, .\nThere should be no space between the minus \"-\" sign and the digit after it.\n\nHere are some valid coordinates:\n-23, 25\n43.91343345, 143\n4, -3\n\nAnd some invalid ones:\n23.234, - 23.4234\nN23.43345, E32.6457\n6.325624, 43.34345.345\n0, 1,2", "short_description": "\"", "full": "\"\nCreate a function that will validate if given parameters are valid geographical coordinates.\nValid coordinates look like the following: \"23.32353342, -32.543534534\". The return value should be either true or false.\nLatitude (which is first float) can be between 0 and 90, positive or negative. Longitude (which is second float) can be between 0 and 180, positive or negative.\nCoordinates can only contain digits, or one of the following symbols (including space after comma) -, .\nThere should be no space between the minus \"-\" sign and the digit after it.\n\nHere are some valid coordinates:\n-23, 25\n43.91343345, 143\n4, -3\n\nAnd some invalid ones:\n23.234, - 23.4234\nN23.43345, E32.6457\n6.325624, 43.34345.345\n0, 1,2"}}, "dependencies": [{"import": "re", "type": "external", "type_element": "module"}], "functions": {"is_valid_coordinates_0": {"args": ["coordinates"], "returns": ["-90 <= latitude <= 90 and -180 <= longitude <= 180", "False", "False", "False"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 37}, "calls": ["coordinates.split", "len", "float", "char.isdigit"], "store_vars_calls": {"l": "coordinates.split", "latitude": "float", "longitude": "float"}, "source_code": "def is_valid_coordinates_0(coordinates):\n    for char in coordinates:\n        if not (char.isdigit() or char in ['-', '.', ',', ' ']):\n            return False\n    l = coordinates.split(', ')\n    if len(l) != 2:\n        return False\n    try:\n        latitude = float(l[0])\n        longitude = float(l[1])\n    except:\n        return False\n    return -90 <= latitude <= 90 and -180 <= longitude <= 180"}, "is_valid_coordinates_1": {"args": ["coordinates"], "returns": ["lat <= 90 and lng <= 180", "False"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 46}, "calls": ["abs", "float", "coordinates.split"], "source_code": "def is_valid_coordinates_1(coordinates):\n    try:\n        (lat, lng) = [abs(float(c)) for c in coordinates.split(',') if 'e' not in c]\n    except ValueError:\n        return False\n    return lat <= 90 and lng <= 180"}, "is_valid_coordinates_regular_expression": {"args": ["coordinates"], "returns": ["bool(re.match('-?(\\\\d|[1-8]\\\\d|90)\\\\.?\\\\d*, -?(\\\\d|[1-9]\\\\d|1[0-7]\\\\d|180)\\\\.?\\\\d*$', coordinates))"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 50}, "calls": ["bool", "re.match"], "source_code": "def is_valid_coordinates_regular_expression(coordinates):\n    return bool(re.match('-?(\\\\d|[1-8]\\\\d|90)\\\\.?\\\\d*, -?(\\\\d|[1-9]\\\\d|1[0-7]\\\\d|180)\\\\.?\\\\d*$', coordinates))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/int_to_roman.py", "fileNameBase": "int_to_roman", "extension": "py", "doc": {"long_description": "Input is guaranteed to be within the range from 1 to 3999.", "short_description": "Given an integer, convert it to a roman numeral.", "full": "Given an integer, convert it to a roman numeral.\nInput is guaranteed to be within the range from 1 to 3999."}}, "functions": {"int_to_roman": {"args": ["num"], "returns": ["m[num // 1000] + c[num % 1000 // 100] + x[num % 100 // 10] + i[num % 10]"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 16}, "source_code": "def int_to_roman(num):\n    \"\"\"\n    :type num: int\n    :rtype: str\n    \"\"\"\n    m = ['', 'M', 'MM', 'MMM']\n    c = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']\n    x = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']\n    i = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']\n    return m[num // 1000] + c[num % 1000 // 100] + x[num % 100 // 10] + i[num % 10]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/longest_common_prefix.py", "fileNameBase": "longest_common_prefix", "extension": "py", "doc": {"long_description": "If there is no common prefix, return an empty string \"\".\n\nExample 1:\nInput: [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\nInput: [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\nReference: https://leetcode.com/problems/longest-common-prefix/description/", "short_description": "Write a function to find the longest common prefix string amongst an array of strings.", "full": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\nExample 1:\nInput: [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\nInput: [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\nReference: https://leetcode.com/problems/longest-common-prefix/description/"}}, "functions": {"common_prefix": {"doc": {"short_description": "Return prefix common of 2 strings"}, "args": ["s1", "s2"], "returns": ["s1[0:k]", "''", "s1[0:k]"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 31}, "calls": ["len"], "source_code": "def common_prefix(s1, s2):\n    \"\"\"Return prefix common of 2 strings\"\"\"\n    if not s1 or not s2:\n        return ''\n    k = 0\n    while s1[k] == s2[k]:\n        k = k + 1\n        if k >= len(s1) or k >= len(s2):\n            return s1[0:k]\n    return s1[0:k]"}, "longest_common_prefix_v1": {"args": ["strs"], "returns": ["result", "''"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 39}, "calls": ["range", "len", "longest_common_prefix.common_prefix"], "store_vars_calls": {"result": "common_prefix"}, "source_code": "def longest_common_prefix_v1(strs):\n    if not strs:\n        return ''\n    result = strs[0]\n    for i in range(len(strs)):\n        result = common_prefix(result, strs[i])\n    return result"}, "longest_common_prefix_v2": {"args": ["strs"], "returns": ["strs[0]", "''", "strs[0][0:i]"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 51}, "calls": ["range", "len"], "source_code": "def longest_common_prefix_v2(strs):\n    if not strs:\n        return ''\n    for i in range(len(strs[0])):\n        for string in strs[1:]:\n            if i == len(string) or string[i] != strs[0][i]:\n                return strs[0][0:i]\n    return strs[0]"}, "longest_common_prefix_v3": {"args": ["strs"], "returns": ["longest_common(strs, 0, len(strs) - 1)", "''"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 59}, "calls": ["longest_common_prefix.longest_common", "len"], "source_code": "def longest_common_prefix_v3(strs):\n    if not strs:\n        return ''\n    return longest_common(strs, 0, len(strs) - 1)"}, "longest_common": {"args": ["strs", "left", "right"], "returns": ["common_prefix(lcp_left, lcp_right)", "strs[left]"], "min_max_lineno": {"min_lineno": 60, "max_lineno": 67}, "calls": ["longest_common_prefix.longest_common", "longest_common_prefix.common_prefix"], "store_vars_calls": {"lcp_left": "longest_common", "lcp_right": "longest_common"}, "source_code": "def longest_common(strs, left, right):\n    if left == right:\n        return strs[left]\n    mid = (left + right) // 2\n    lcp_left = longest_common(strs, left, mid)\n    lcp_right = longest_common(strs, mid + 1, right)\n    return common_prefix(lcp_left, lcp_right)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/breaking_bad.py", "fileNameBase": "breaking_bad", "extension": "py", "doc": {"long_description": "the word with their matched symbol surrounded by square brackets.\n\nIf the word string matches more than one symbol, then choose the one with\nlongest length. (ex. 'Microsoft' matches 'i' and 'cro'):\n\nExample:\nWords array: ['Amazon', 'Microsoft', 'Google']\nSymbols: ['i', 'Am', 'cro', 'Na', 'le', 'abc']\n\nOutput:\n[Am]azon, Mi[cro]soft, Goog[le]\n\nMy solution(Wrong):\n(I sorted the symbols array in descending order of length and ran loop over\nwords array to find a symbol match(using indexOf in javascript) which\nworked. But I didn't make it through the interview, I am guessing my solution\nwas O(n^2) and they expected an efficient algorithm.\n\noutput:\n['[Am]azon', 'Mi[cro]soft', 'Goog[le]', 'Amaz[o]n', 'Micr[o]s[o]ft', 'G[o][o]gle']", "short_description": "Given an api which returns an array of words and an array of symbols, display", "full": "Given an api which returns an array of words and an array of symbols, display\nthe word with their matched symbol surrounded by square brackets.\n\nIf the word string matches more than one symbol, then choose the one with\nlongest length. (ex. 'Microsoft' matches 'i' and 'cro'):\n\nExample:\nWords array: ['Amazon', 'Microsoft', 'Google']\nSymbols: ['i', 'Am', 'cro', 'Na', 'le', 'abc']\n\nOutput:\n[Am]azon, Mi[cro]soft, Goog[le]\n\nMy solution(Wrong):\n(I sorted the symbols array in descending order of length and ran loop over\nwords array to find a symbol match(using indexOf in javascript) which\nworked. But I didn't make it through the interview, I am guessing my solution\nwas O(n^2) and they expected an efficient algorithm.\n\noutput:\n['[Am]azon', 'Mi[cro]soft', 'Goog[le]', 'Amaz[o]n', 'Micr[o]s[o]ft', 'G[o][o]gle']"}}, "dependencies": [{"from_module": "functools", "import": "reduce", "type": "external", "type_element": "module"}], "classes": {"TreeNode": {"min_max_lineno": {"min_lineno": 63, "max_lineno": 67}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 64, "max_lineno": 67}, "calls": ["dict"], "store_vars_calls": {"self.c": "dict"}, "source_code": "def __init__(self):\n    self.c = dict()\n    self.sym = None"}}}}, "functions": {"match_symbol": {"args": ["words", "symbols"], "returns": ["combined"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 37}, "calls": ["re.search", "combined.append", "re.sub"], "store_vars_calls": {"r": "re.search"}, "source_code": "def match_symbol(words, symbols):\n    import re\n    combined = []\n    for s in symbols:\n        for c in words:\n            r = re.search(s, c)\n            if r:\n                combined.append(re.sub(s, '[{}]'.format(s), c))\n    return combined"}, "match_symbol_1": {"args": ["words", "symbols"], "returns": ["res"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 54}, "calls": ["sorted", "res.append", "len", "word.find", "word.replace"], "store_vars_calls": {"symbols": "sorted", "word_replaced": "word.replace"}, "source_code": "def match_symbol_1(words, symbols):\n    res = []\n    symbols = sorted(symbols, key=lambda _: len(_), reverse=True)\n    for word in words:\n        for symbol in symbols:\n            word_replaced = ''\n            if word.find(symbol) != -1:\n                word_replaced = word.replace(symbol, '[' + symbol + ']')\n                res.append(word_replaced)\n                break\n        if word_replaced == '':\n            res.append(word)\n    return res"}, "bracket": {"args": ["words", "symbols"], "returns": ["tuple((word if word not in result else result[word] for word in words))"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 96}, "calls": ["dict", "tuple", "list", "len", "functools.reduce", "breaking_bad.TreeNode", "list.append"], "store_vars_calls": {"root": "TreeNode", "result": "dict", "symlist": "list", "sym": "reduce"}, "source_code": "def bracket(words, symbols):\n    root = TreeNode()\n    for s in symbols:\n        t = root\n        for char in s:\n            if char not in t.c:\n                t.c[char] = TreeNode()\n            t = t.c[char]\n        t.sym = s\n    result = dict()\n    for word in words:\n        i = 0\n        symlist = list()\n        while i < len(word):\n            (j, t) = (i, root)\n            while j < len(word) and word[j] in t.c:\n                t = t.c[word[j]]\n                if t.sym is not None:\n                    symlist.append((j + 1 - len(t.sym), j + 1, t.sym))\n                j += 1\n            i += 1\n        if len(symlist) > 0:\n            sym = reduce(lambda x, y: x if x[1] - x[0] >= y[1] - y[0] else y, symlist)\n            result[word] = '{}[{}]{}'.format(word[:sym[0]], sym[2], word[sym[1]:])\n    return tuple((word if word not in result else result[word] for word in words))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/judge_circle.py", "fileNameBase": "judge_circle", "extension": "py", "doc": {"long_description": "judge if this robot makes a circle, which means it moves back to the original place.\n\nThe move sequence is represented by a string. And each move is represent by a\ncharacter. The valid robot moves are R (Right), L (Left), U (Up) and D (down).\nThe output should be true or false representing whether the robot makes a circle.\n\nExample 1:\nInput: \"UD\"\nOutput: true\nExample 2:\nInput: \"LL\"\nOutput: false", "short_description": "Initially, there is a Robot at position (0, 0). Given a sequence of its moves,", "full": "Initially, there is a Robot at position (0, 0). Given a sequence of its moves,\njudge if this robot makes a circle, which means it moves back to the original place.\n\nThe move sequence is represented by a string. And each move is represent by a\ncharacter. The valid robot moves are R (Right), L (Left), U (Up) and D (down).\nThe output should be true or false representing whether the robot makes a circle.\n\nExample 1:\nInput: \"UD\"\nOutput: true\nExample 2:\nInput: \"LL\"\nOutput: false"}}, "functions": {"judge_circle": {"args": ["moves"], "returns": ["dict_moves['L'] == dict_moves['R'] and dict_moves['U'] == dict_moves['D']"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 26}, "source_code": "def judge_circle(moves):\n    dict_moves = {'U': 0, 'D': 0, 'R': 0, 'L': 0}\n    for char in moves:\n        dict_moves[char] = dict_moves[char] + 1\n    return dict_moves['L'] == dict_moves['R'] and dict_moves['U'] == dict_moves['D']"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/is_rotated.py", "fileNameBase": "is_rotated", "extension": "py", "doc": {"long_description": "For example,\nis_rotated(\"hello\", \"llohe\") returns True\nis_rotated(\"hello\", \"helol\") returns False\n\naccepts two strings\nreturns bool\nReference: https://leetcode.com/problems/rotate-string/description/", "short_description": "Given two strings s1 and s2, determine if s2 is a rotated version of s1.", "full": "Given two strings s1 and s2, determine if s2 is a rotated version of s1.\nFor example,\nis_rotated(\"hello\", \"llohe\") returns True\nis_rotated(\"hello\", \"helol\") returns False\n\naccepts two strings\nreturns bool\nReference: https://leetcode.com/problems/rotate-string/description/"}}, "functions": {"is_rotated": {"args": ["s1", "s2"], "returns": ["s2 in s1 + s1", "False"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 17}, "calls": ["len"], "source_code": "def is_rotated(s1, s2):\n    if len(s1) == len(s2):\n        return s2 in s1 + s1\n    else:\n        return False"}, "is_rotated_v1": {"args": ["s1", "s2"], "returns": ["False", "False", "True", "True"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 32}, "calls": ["range", "len", "all"], "source_code": "def is_rotated_v1(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    if len(s1) == 0:\n        return True\n    for c in range(len(s1)):\n        if all((s1[(c + i) % len(s1)] == s2[i] for i in range(len(s1)))):\n            return True\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/one_edit_distance.py", "fileNameBase": "one_edit_distance", "extension": "py", "doc": {"short_description": "Given two strings S and T, determine if they are both one edit distance apart.", "full": "Given two strings S and T, determine if they are both one edit distance apart."}}, "functions": {"is_one_edit": {"args": ["s", "t"], "returns": ["True", "is_one_edit(t, s)", "False", "s[i + 1:] == t[i + 1:] or s[i:] == t[i + 1:]"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 20}, "calls": ["range", "len", "one_edit_distance.is_one_edit"], "source_code": "def is_one_edit(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    if len(s) > len(t):\n        return is_one_edit(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            return s[i + 1:] == t[i + 1:] or s[i:] == t[i + 1:]\n    return True"}, "is_one_edit2": {"args": ["s", "t"], "returns": ["s == t or s == t[:-1]", "is_one_edit2(t, s)", "False"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 36}, "calls": ["range", "len", "one_edit_distance.is_one_edit2"], "source_code": "def is_one_edit2(s, t):\n    (l1, l2) = (len(s), len(t))\n    if l1 > l2:\n        return is_one_edit2(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if l1 == l2:\n                s = s[:i] + t[i] + s[i + 1:]\n            else:\n                s = s[:i] + t[i] + s[i:]\n            break\n    return s == t or s == t[:-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/strong_password.py", "fileNameBase": "strong_password", "extension": "py", "doc": {"long_description": "must be strong. The website considers a password to be strong if it satisfies the following criteria:\n\n1) Its length is at least 6.\n2) It contains at least one digit.\n3) It contains at least one lowercase English character.\n4) It contains at least one uppercase English character.\n5) It contains at least one special character. The special characters are: !@#$%^&*()-+\nShe typed a random string of length  in the password field but wasn't sure if it was strong.\nGiven the string she typed, can you find the minimum number of characters she must add to make her password strong?\n\nNote: Here's the set of types of characters in a form you can paste in your solution:\nnumbers = \"0123456789\"\nlower_case = \"abcdefghijklmnopqrstuvwxyz\"\nupper_case = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nspecial_characters = \"!@#$%^&*()-+\"\n\nInput Format\nThe first line contains an integer  denoting the length of the string.\nThe second line contains a string consisting of  characters, the password\ntyped by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character.\n\nSample Input 1: strong_password(3,\"Ab1\")\nOutput: 3 (Because She can make the password strong by adding  characters,for example, $hk, turning the password into Ab1$hk which is strong.\n2 characters aren't enough since the length must be at least 6.)\n\nSample Output 2: strong_password(11,\"#Algorithms\")\nOutput: 1 (Because the password isn't strong, but she can make it strong by adding a single digit.)", "short_description": "The signup page required her to input a name and a password. However, the password", "full": "The signup page required her to input a name and a password. However, the password\nmust be strong. The website considers a password to be strong if it satisfies the following criteria:\n\n1) Its length is at least 6.\n2) It contains at least one digit.\n3) It contains at least one lowercase English character.\n4) It contains at least one uppercase English character.\n5) It contains at least one special character. The special characters are: !@#$%^&*()-+\nShe typed a random string of length  in the password field but wasn't sure if it was strong.\nGiven the string she typed, can you find the minimum number of characters she must add to make her password strong?\n\nNote: Here's the set of types of characters in a form you can paste in your solution:\nnumbers = \"0123456789\"\nlower_case = \"abcdefghijklmnopqrstuvwxyz\"\nupper_case = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nspecial_characters = \"!@#$%^&*()-+\"\n\nInput Format\nThe first line contains an integer  denoting the length of the string.\nThe second line contains a string consisting of  characters, the password\ntyped by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character.\n\nSample Input 1: strong_password(3,\"Ab1\")\nOutput: 3 (Because She can make the password strong by adding  characters,for example, $hk, turning the password into Ab1$hk which is strong.\n2 characters aren't enough since the length must be at least 6.)\n\nSample Output 2: strong_password(11,\"#Algorithms\")\nOutput: 1 (Because the password isn't strong, but she can make it strong by adding a single digit.)"}}, "functions": {"strong_password": {"args": ["n", "password"], "returns": ["max(count_error, 6 - n)"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 44}, "calls": ["max", "any", "i.isdigit", "i.islower", "i.isupper"], "source_code": "def strong_password(n, password):\n    count_error = 0\n    if any((i.isdigit() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i.islower() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i.isupper() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i in '!@#$%^&*()-+' for i in password)) == False:\n        count_error = count_error + 1\n    return max(count_error, 6 - n)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/repeat_substring.py", "fileNameBase": "repeat_substring", "extension": "py", "doc": {"long_description": "a substring of it and appending multiple copies of the substring together.\n\nFor example:\nInput: \"abab\"\nOutput: True\nExplanation: It's the substring \"ab\" twice.\n\nInput: \"aba\"\nOutput: False\n\nInput: \"abcabcabcabc\"\nOutput: True\nExplanation: It's the substring \"abc\" four times.\n\nReference: https://leetcode.com/problems/repeated-substring-pattern/description/", "short_description": "Given a non-empty string check if it can be constructed by taking", "full": "Given a non-empty string check if it can be constructed by taking\na substring of it and appending multiple copies of the substring together.\n\nFor example:\nInput: \"abab\"\nOutput: True\nExplanation: It's the substring \"ab\" twice.\n\nInput: \"aba\"\nOutput: False\n\nInput: \"abcabcabcabc\"\nOutput: True\nExplanation: It's the substring \"abc\" four times.\n\nReference: https://leetcode.com/problems/repeated-substring-pattern/description/"}}, "functions": {"repeat_substring": {"args": ["s"], "returns": ["s in str"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 26}, "source_code": "def repeat_substring(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    str = (s + s)[1:-1]\n    return s in str"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/strip_url_params.py", "fileNameBase": "strip_url_params", "extension": "py", "doc": {"long_description": "Removes any duplicate query string parameters from the url\nRemoves any query string parameters specified within the 2nd argument (optional array)\n\nAn example:\nwww.saadbenn.com?a=1&b=2&a=2') // returns 'www.saadbenn.com?a=1&b=2'", "short_description": "Write a function that does the following:", "full": "Write a function that does the following:\nRemoves any duplicate query string parameters from the url\nRemoves any query string parameters specified within the 2nd argument (optional array)\n\nAn example:\nwww.saadbenn.com?a=1&b=2&a=2') // returns 'www.saadbenn.com?a=1&b=2'"}}, "dependencies": [{"from_module": "collections", "import": "defaultdict", "type": "external", "type_element": "module"}, {"import": "urllib", "type": "external", "type_element": "module"}, {"import": "urllib", "type": "external", "type_element": "module"}], "functions": {"strip_url_params1": {"args": ["url", "params_to_strip"], "returns": ["result", "url"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 69}, "calls": ["url.split", "len", "collections.defaultdict", "char.isdigit", "i.split", "key_value_string.append"], "store_vars_calls": {"tokens": "url.split", "dict": "defaultdict", "_token": "i.split", "length": "len"}, "source_code": "def strip_url_params1(url, params_to_strip=None):\n    if not params_to_strip:\n        params_to_strip = []\n    if url:\n        result = ''\n        tokens = url.split('?')\n        domain = tokens[0]\n        query_string = tokens[-1]\n        result += domain\n        if len(tokens) > 1:\n            result += '?'\n        if not query_string:\n            return url\n        else:\n            key_value_string = []\n            string = ''\n            for char in query_string:\n                if char.isdigit():\n                    key_value_string.append(string + char)\n                    string = ''\n                else:\n                    string += char\n            dict = defaultdict(int)\n            for i in key_value_string:\n                _token = i.split('=')\n                if _token[0]:\n                    length = len(_token[0])\n                    if length == 1:\n                        if _token and (not _token[0] in dict):\n                            if params_to_strip:\n                                if _token[0] != params_to_strip[0]:\n                                    dict[_token[0]] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            elif not _token[0] in dict:\n                                dict[_token[0]] = _token[1]\n                                result = result + _token[0] + '=' + _token[1]\n                    else:\n                        check = _token[0]\n                        letter = check[1]\n                        if _token and (not letter in dict):\n                            if params_to_strip:\n                                if letter != params_to_strip[0]:\n                                    dict[letter] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            elif not letter in dict:\n                                dict[letter] = _token[1]\n                                result = result + _token[0] + '=' + _token[1]\n    return result"}, "strip_url_params2": {"args": ["url", "param_to_strip"], "returns": ["url.split('?')[0] + '?' + '&'.join(queries)", "url"], "min_max_lineno": {"min_lineno": 71, "max_lineno": 82}, "calls": ["[].split", "range", "len", "[].split.pop", "url.split"], "store_vars_calls": {"queries": "[].split"}, "source_code": "def strip_url_params2(url, param_to_strip=[]):\n    if '?' not in url:\n        return url\n    queries = url.split('?')[1].split('&')\n    queries_obj = [query[0] for query in queries]\n    for i in range(len(queries_obj) - 1, 0, -1):\n        if queries_obj[i] in param_to_strip or queries_obj[i] in queries_obj[0:i]:\n            queries.pop(i)\n    return url.split('?')[0] + '?' + '&'.join(queries)"}, "strip_url_params3": {"args": ["url", "strip"], "returns": ["new.geturl()"], "min_max_lineno": {"min_lineno": 85, "max_lineno": 96}, "calls": ["urllib.parse.urlparse", "urllib.parse.urlparse", "urllib.parse.parse_qs", "urllib.parse.parse_qs", "urllib.parse.urlencode", "urllib.parse.urlencode", "urllib.parse.urlparse._replace", "parse._replace.geturl", "urllib.parse.urlencode.items"], "store_vars_calls": {"parse": "urllib.parse.urlparse", "query": "urllib.parse.urlencode", "new": "parse._replace"}, "source_code": "def strip_url_params3(url, strip=None):\n    if not strip:\n        strip = []\n    parse = urllib.parse.urlparse(url)\n    query = urllib.parse.parse_qs(parse.query)\n    query = {k: v[0] for (k, v) in query.items() if k not in strip}\n    query = urllib.parse.urlencode(query)\n    new = parse._replace(query=query)\n    return new.geturl()"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/count_binary_substring.py", "fileNameBase": "count_binary_substring", "extension": "py", "doc": {"long_description": "the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.\nExample 1:\nInput: \"00110011\"\nOutput: 6\nExplanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\n\nNotice that some of these substrings repeat and are counted the number of times they occur.\n\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\nExample 2:\nInput: \"10101\"\nOutput: 4\nExplanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\nReference: https://leetcode.com/problems/count-binary-substrings/description/", "short_description": "Give a string s, count the number of non-empty (contiguous) substrings that have", "full": "Give a string s, count the number of non-empty (contiguous) substrings that have\n the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.\nExample 1:\nInput: \"00110011\"\nOutput: 6\nExplanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\n\nNotice that some of these substrings repeat and are counted the number of times they occur.\n\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\nExample 2:\nInput: \"10101\"\nOutput: 4\nExplanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\nReference: https://leetcode.com/problems/count-binary-substrings/description/"}}, "functions": {"count_binary_substring": {"args": ["s"], "returns": ["count"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 34}, "calls": ["range", "len", "min"], "source_code": "def count_binary_substring(s):\n    cur = 1\n    pre = 0\n    count = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            count = count + min(pre, cur)\n            pre = cur\n            cur = 1\n        else:\n            cur = cur + 1\n    count = count + min(pre, cur)\n    return count"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/merge_string_checker.py", "fileNameBase": "merge_string_checker", "extension": "py", "doc": {"long_description": "given string, s, can be formed from two other strings, part1 and part2.\nThe restriction is that the characters in part1 and part2 are in the same \norder as in s. The interviewer gives you the following example and tells \nyou to figure out the rest from the given test cases.\n'codewars' is a merge from 'cdw' and 'oears':\ns:  c o d e w a r s   = codewars\npart1:  c   d   w         = cdw\npart2:    o   e   a r s   = oears", "short_description": "At a job interview, you are challenged to write an algorithm to check if a ", "full": "At a job interview, you are challenged to write an algorithm to check if a \ngiven string, s, can be formed from two other strings, part1 and part2.\nThe restriction is that the characters in part1 and part2 are in the same \norder as in s. The interviewer gives you the following example and tells \nyou to figure out the rest from the given test cases.\n'codewars' is a merge from 'cdw' and 'oears':\ns:  c o d e w a r s   = codewars\npart1:  c   d   w         = cdw\npart2:    o   e   a r s   = oears"}}, "functions": {"is_merge_recursive": {"args": ["s", "part1", "part2"], "returns": ["False", "s == part2", "s == part1", "part1 + part2 == ''", "True", "True"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 27}, "calls": ["merge_string_checker.is_merge_recursive"], "source_code": "def is_merge_recursive(s, part1, part2):\n    if not part1:\n        return s == part2\n    if not part2:\n        return s == part1\n    if not s:\n        return part1 + part2 == ''\n    if s[0] == part1[0] and is_merge_recursive(s[1:], part1[1:], part2):\n        return True\n    if s[0] == part2[0] and is_merge_recursive(s[1:], part1, part2[1:]):\n        return True\n    return False"}, "is_merge_iterative": {"args": ["s", "part1", "part2"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 43}, "calls": ["tuple_list.pop", "tuple_list.append"], "source_code": "def is_merge_iterative(s, part1, part2):\n    tuple_list = [(s, part1, part2)]\n    while tuple_list:\n        (string, p1, p2) = tuple_list.pop()\n        if string:\n            if p1 and string[0] == p1[0]:\n                tuple_list.append((string[1:], p1[1:], p2))\n            if p2 and string[0] == p2[0]:\n                tuple_list.append((string[1:], p1, p2[1:]))\n        elif not p1 and (not p2):\n            return True\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/reverse_string.py", "fileNameBase": "reverse_string", "extension": "py"}, "functions": {"recursive": {"args": ["s"], "returns": ["recursive(s[l // 2:]) + recursive(s[:l // 2])", "s"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 6}, "calls": ["len", "reverse_string.recursive"], "store_vars_calls": {"l": "len"}, "source_code": "def recursive(s):\n    l = len(s)\n    if l < 2:\n        return s\n    return recursive(s[l // 2:]) + recursive(s[:l // 2])"}, "iterative": {"args": ["s"], "returns": ["''.join(r)"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 15}, "calls": ["list", "len"], "store_vars_calls": {"r": "list"}, "source_code": "def iterative(s):\n    r = list(s)\n    (i, j) = (0, len(s) - 1)\n    while i < j:\n        (r[i], r[j]) = (r[j], r[i])\n        i += 1\n        j -= 1\n    return ''.join(r)"}, "pythonic": {"args": ["s"], "returns": ["''.join(r)"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 19}, "calls": ["list", "reversed"], "store_vars_calls": {"r": "list"}, "source_code": "def pythonic(s):\n    r = list(reversed(s))\n    return ''.join(r)"}, "ultra_pythonic": {"args": ["s"], "returns": ["s[::-1]"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 22}, "source_code": "def ultra_pythonic(s):\n    return s[::-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/is_palindrome.py", "fileNameBase": "is_palindrome", "extension": "py", "doc": {"long_description": "considering only alphanumeric characters and ignoring cases.\nFor example,\n\"A man, a plan, a canal: Panama\" is a palindrome.\n\"race a car\" is not a palindrome.\nNote:\nHave you consider that the string might be empty?\nThis is a good question to ask during an interview.\nFor the purpose of this problem,\nwe define empty string as valid palindrome.", "short_description": "Given a string, determine if it is a palindrome,", "full": "Given a string, determine if it is a palindrome,\nconsidering only alphanumeric characters and ignoring cases.\nFor example,\n\"A man, a plan, a canal: Panama\" is a palindrome.\n\"race a car\" is not a palindrome.\nNote:\nHave you consider that the string might be empty?\nThis is a good question to ask during an interview.\nFor the purpose of this problem,\nwe define empty string as valid palindrome."}}, "dependencies": [{"from_module": "string", "import": "ascii_letters", "type": "external", "type_element": "module"}, {"from_module": "collections", "import": "deque", "type": "external", "type_element": "module"}], "functions": {"is_palindrome": {"args": ["s"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 33}, "calls": ["len", "s[].isalnum", "s[].lower"], "source_code": "def is_palindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        while not s[i].isalnum():\n            i += 1\n        while not s[j].isalnum():\n            j -= 1\n        if s[i].lower() != s[j].lower():\n            return False\n        (i, j) = (i + 1, j - 1)\n    return True"}, "remove_punctuation": {"doc": {"short_description": "Remove punctuation, case sensitivity and spaces"}, "args": ["s"], "returns": ["''.join((i.lower() for i in s if i in ascii_letters))"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 54}, "calls": ["i.lower"], "source_code": "def remove_punctuation(s):\n    \"\"\"\n    Remove punctuation, case sensitivity and spaces\n    \"\"\"\n    return ''.join((i.lower() for i in s if i in ascii_letters))"}, "string_reverse": {"args": ["s"], "returns": ["s[::-1]"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 58}, "source_code": "def string_reverse(s):\n    return s[::-1]"}, "is_palindrome_reverse": {"args": ["s"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 66}, "calls": ["is_palindrome.remove_punctuation", "is_palindrome.string_reverse"], "store_vars_calls": {"s": "remove_punctuation"}, "source_code": "def is_palindrome_reverse(s):\n    s = remove_punctuation(s)\n    if s == string_reverse(s):\n        return True\n    return False"}, "is_palindrome_two_pointer": {"args": ["s"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 76}, "calls": ["is_palindrome.remove_punctuation", "range", "len"], "store_vars_calls": {"s": "remove_punctuation"}, "source_code": "def is_palindrome_two_pointer(s):\n    s = remove_punctuation(s)\n    for i in range(0, len(s) // 2):\n        if s[i] != s[len(s) - i - 1]:\n            return False\n    return True"}, "is_palindrome_stack": {"args": ["s"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 79, "max_lineno": 89}, "calls": ["is_palindrome.remove_punctuation", "range", "len", "stack.append", "stack.pop"], "store_vars_calls": {"s": "remove_punctuation"}, "source_code": "def is_palindrome_stack(s):\n    stack = []\n    s = remove_punctuation(s)\n    for i in range(len(s) // 2, len(s)):\n        stack.append(s[i])\n    for i in range(0, len(s) // 2):\n        if s[i] != stack.pop():\n            return False\n    return True"}, "is_palindrome_deque": {"args": ["s"], "returns": ["equal"], "min_max_lineno": {"min_lineno": 91, "max_lineno": 106}, "calls": ["is_palindrome.remove_punctuation", "collections.deque", "collections.deque.appendleft", "collections.deque.pop", "collections.deque.popleft", "len"], "store_vars_calls": {"s": "remove_punctuation", "deq": "deque", "first": "deq.pop", "last": "deq.popleft"}, "source_code": "def is_palindrome_deque(s):\n    s = remove_punctuation(s)\n    deq = deque()\n    for char in s:\n        deq.appendleft(char)\n    equal = True\n    while len(deq) > 1 and equal:\n        first = deq.pop()\n        last = deq.popleft()\n        if first != last:\n            equal = False\n    return equal"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/rabin_karp.py", "fileNameBase": "rabin_karp", "extension": "py"}, "classes": {"RollingHash": {"min_max_lineno": {"min_lineno": 4, "max_lineno": 31}, "methods": {"__init__": {"args": ["self", "text", "size_word"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 19}, "calls": ["range", "ord"], "source_code": "def __init__(self, text, size_word):\n    self.text = text\n    self.hash = 0\n    self.size_word = size_word\n    for i in range(0, size_word):\n        self.hash += (ord(self.text[i]) - ord('a') + 1) * 26 ** (size_word - i - 1)\n    self.window_start = 0\n    self.window_end = size_word"}, "move_window": {"args": ["self"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 28}, "calls": ["len", "ord"], "source_code": "def move_window(self):\n    if self.window_end <= len(self.text) - 1:\n        self.hash -= (ord(self.text[self.window_start]) - ord('a') + 1) * 26 ** (self.size_word - 1)\n        self.hash *= 26\n        self.hash += ord(self.text[self.window_end]) - ord('a') + 1\n        self.window_start += 1\n        self.window_end += 1"}, "window_text": {"args": ["self"], "returns": ["self.text[self.window_start:self.window_end]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 31}, "source_code": "def window_text(self):\n    return self.text[self.window_start:self.window_end]"}}}}, "functions": {"rabin_karp": {"args": ["word", "text"], "returns": ["None", "None", "None", "i"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 48}, "calls": ["rabin_karp.RollingHash", "range", "len", "rabin_karp.RollingHash.move_window", "rabin_karp.RollingHash.window_text"], "store_vars_calls": {"rolling_hash": "RollingHash", "word_hash": "RollingHash"}, "source_code": "def rabin_karp(word, text):\n    if word == '' or text == '':\n        return None\n    if len(word) > len(text):\n        return None\n    rolling_hash = RollingHash(text, len(word))\n    word_hash = RollingHash(word, len(word))\n    for i in range(len(text) - len(word) + 1):\n        if rolling_hash.hash == word_hash.hash:\n            if rolling_hash.window_text() == word:\n                return i\n        rolling_hash.move_window()\n    return None"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/domain_extractor.py", "fileNameBase": "domain_extractor", "extension": "py", "doc": {"long_description": "Examples:\ndomain_name(\"http://github.com/SaadBenn\") == \"github\" \ndomain_name(\"http://www.zombie-bites.com\") == \"zombie-bites\"\ndomain_name(\"https://www.cnet.com\") == \"cnet\"\n\nNote: The idea is not to use any built-in libraries such as re (regular expression) or urlparse except .split() built-in function", "short_description": "Write a function that when given a URL as a string, parses out just the domain name and returns it as a string. ", "full": "Write a function that when given a URL as a string, parses out just the domain name and returns it as a string. \n\nExamples:\ndomain_name(\"http://github.com/SaadBenn\") == \"github\" \ndomain_name(\"http://www.zombie-bites.com\") == \"zombie-bites\"\ndomain_name(\"https://www.cnet.com\") == \"cnet\"\n\nNote: The idea is not to use any built-in libraries such as re (regular expression) or urlparse except .split() built-in function"}}, "functions": {"domain_name_1": {"args": ["url"], "returns": ["actual_domain[0]", "actual_domain[1]"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 24}, "calls": ["full_domain_name.split", "url.split", "len"], "store_vars_calls": {"actual_domain": "full_domain_name.split"}, "source_code": "def domain_name_1(url):\n    full_domain_name = url.split('//')[-1]\n    actual_domain = full_domain_name.split('.')\n    if len(actual_domain) > 2:\n        return actual_domain[1]\n    return actual_domain[0]"}, "domain_name_2": {"args": ["url"], "returns": ["url.split('//')[-1].split('www.')[-1].split('.')[0]"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 29}, "calls": ["[].split", "url.split"], "source_code": "def domain_name_2(url):\n    return url.split('//')[-1].split('www.')[-1].split('.')[0]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/min_distance.py", "fileNameBase": "min_distance", "extension": "py", "doc": {"long_description": "make word1 and word2 the same, where in each step you can delete one character\nin either string.\n\nFor example:\nInput: \"sea\", \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\n\nReference: https://leetcode.com/problems/delete-operation-for-two-strings/description/", "short_description": "Given two words word1 and word2, find the minimum number of steps required to", "full": "Given two words word1 and word2, find the minimum number of steps required to\nmake word1 and word2 the same, where in each step you can delete one character\nin either string.\n\nFor example:\nInput: \"sea\", \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\n\nReference: https://leetcode.com/problems/delete-operation-for-two-strings/description/"}}, "functions": {"min_distance": {"doc": {"short_description": "Finds minimum distance by getting longest common subsequence"}, "args": ["word1", "word2"], "returns": ["len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 23}, "calls": ["len", "min_distance.lcs"], "source_code": "def min_distance(word1, word2):\n    \"\"\"\n    Finds minimum distance by getting longest common subsequence\n\n    :type word1: str\n    :type word2: str\n    :rtype: int\n    \"\"\"\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))"}, "lcs": {"doc": {"short_description": "The length of longest common subsequence among the two given strings word1 and word2"}, "args": ["word1", "word2", "i", "j"], "returns": ["max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))", "0", "1 + lcs(word1, word2, i - 1, j - 1)"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 33}, "calls": ["max", "min_distance.lcs"], "source_code": "def lcs(word1, word2, i, j):\n    \"\"\"\n    The length of longest common subsequence among the two given strings word1 and word2\n    \"\"\"\n    if i == 0 or j == 0:\n        return 0\n    if word1[i - 1] == word2[j - 1]:\n        return 1 + lcs(word1, word2, i - 1, j - 1)\n    return max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))"}, "min_distance_dp": {"doc": {"long_description": "TC: O(length1*length2), SC: O(length1*length2)", "short_description": "Finds minimum distance in a dynamic programming manner"}, "args": ["word1", "word2"], "returns": ["res[len(word1)][len(word2)]"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 63}, "calls": ["range", "len", "min"], "source_code": "def min_distance_dp(word1, word2):\n    \"\"\"\n    Finds minimum distance in a dynamic programming manner\n    TC: O(length1*length2), SC: O(length1*length2)\n\n    :type word1: str\n    :type word2: str\n    :rtype: int\n    \"\"\"\n    (length1, length2) = (len(word1) + 1, len(word2) + 1)\n    res = [[0 for _ in range(length2)] for _ in range(length1)]\n    if length1 == length2:\n        for i in range(1, length1):\n            (res[i][0], res[0][i]) = (i, i)\n    else:\n        for i in range(length1):\n            res[i][0] = i\n        for i in range(length2):\n            res[0][i] = i\n    for i in range(1, length1):\n        for j in range(1, length2):\n            if word1[i - 1] == word2[j - 1]:\n                res[i][j] = res[i - 1][j - 1]\n            else:\n                res[i][j] = min(res[i - 1][j], res[i][j - 1]) + 1\n    return res[len(word1)][len(word2)]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/encode_decode.py", "fileNameBase": "encode_decode", "extension": "py", "doc": {"long_description": "The encoded mystring is then sent over the network and is decoded\nback to the original list of strings.", "short_description": "Design an algorithm to encode a list of strings to a string.", "full": "Design an algorithm to encode a list of strings to a string.\nThe encoded mystring is then sent over the network and is decoded\nback to the original list of strings."}}, "functions": {"encode": {"doc": {"short_description": "Encodes a list of strings to a single string."}, "args": ["strs"], "returns": ["res"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 17}, "calls": ["strs.split", "str", "len"], "source_code": "def encode(strs):\n    \"\"\"Encodes a list of strings to a single string.\n    :type strs: List[str]\n    :rtype: str\n    \"\"\"\n    res = ''\n    for string in strs.split():\n        res += str(len(string)) + ':' + string\n    return res"}, "decode": {"doc": {"short_description": "Decodes a single string to a list of strings."}, "args": ["s"], "returns": ["strs"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 31}, "calls": ["len", "s.find", "int", "strs.append"], "store_vars_calls": {"index": "s.find", "size": "int"}, "source_code": "def decode(s):\n    \"\"\"Decodes a single string to a list of strings.\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    strs = []\n    i = 0\n    while i < len(s):\n        index = s.find(':', i)\n        size = int(s[i:index])\n        strs.append(s[index + 1:index + 1 + size])\n        i = index + 1 + size\n    return strs"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/license_number.py", "fileNameBase": "license_number", "extension": "py"}, "functions": {"license_number": {"args": ["key", "k"], "returns": ["''.join(res[::-1])"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 12}, "calls": ["enumerate", "reversed", "res.append", "alnum.append", "len"], "source_code": "def license_number(key, k):\n    (res, alnum) = ([], [])\n    for char in key:\n        if char != '-':\n            alnum.append(char)\n    for (i, char) in enumerate(reversed(alnum)):\n        res.append(char)\n        if (i + 1) % k == 0 and i != len(alnum) - 1:\n            res.append('-')\n    return ''.join(res[::-1])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/knuth_morris_pratt.py", "fileNameBase": "knuth_morris_pratt", "extension": "py"}, "dependencies": [{"from_module": "typing", "import": "Sequence", "type": "external", "type_element": "module"}, {"from_module": "typing", "import": "List", "type": "external", "type_element": "module"}], "functions": {"knuth_morris_pratt": {"doc": {"long_description": "using knuth_morris_pratt algorithm.", "short_description": "Given two strings text and pattern, return the list of start indexes in text that matches with the pattern", "args": {"text": {"description": "Text to search"}, "pattern": {"description": "Pattern to search in the text"}}, "returns": {"description": "List of indices of patterns found", "is_generator": false}}, "args": ["text", "pattern"], "annotated_arg_types": {"text": "Sequence", "pattern": "Sequence"}, "annotated_return_type": "List[int]", "returns": ["ret"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 45}, "calls": ["len", "range", "ret.append"], "store_vars_calls": {"n": "len", "m": "len"}, "source_code": "def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]:\n    \"\"\"\n    Given two strings text and pattern, return the list of start indexes in text that matches with the pattern\n    using knuth_morris_pratt algorithm.\n\n    Args:\n        text: Text to search\n        pattern: Pattern to search in the text\n    Returns:\n        List of indices of patterns found\n\n    Example:\n        >>> knuth_morris_pratt('hello there hero!', 'he')\n        [0, 7, 12]\n\n    If idx is in the list, text[idx : idx + M] matches with pattern.\n    Time complexity of the algorithm is O(N+M), with N and M the length of text and pattern, respectively.\n    \"\"\"\n    n = len(text)\n    m = len(pattern)\n    pi = [0 for i in range(m)]\n    i = 0\n    j = 0\n    for i in range(1, m):\n        while j and pattern[i] != pattern[j]:\n            j = pi[j - 1]\n        if pattern[i] == pattern[j]:\n            j += 1\n            pi[i] = j\n    j = 0\n    ret = []\n    for i in range(n):\n        while j and text[i] != pattern[j]:\n            j = pi[j - 1]\n        if text[i] == pattern[j]:\n            j += 1\n            if j == m:\n                ret.append(i - m + 1)\n                j = pi[j - 1]\n    return ret"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/fizzbuzz.py", "fileNameBase": "fizzbuzz", "extension": "py", "doc": {"long_description": "where N is the parametered value. N will never be less than 1.\n\nReplace certain values however if any of the following conditions are met:\n\nIf the value is a multiple of 3: use the value 'Fizz' instead\nIf the value is a multiple of 5: use the value 'Buzz' instead\nIf the value is a multiple of 3 & 5: use the value 'FizzBuzz' instead", "short_description": "Write a function that returns an array containing the numbers from 1 to N, ", "full": "Write a function that returns an array containing the numbers from 1 to N, \nwhere N is the parametered value. N will never be less than 1.\n\nReplace certain values however if any of the following conditions are met:\n\nIf the value is a multiple of 3: use the value 'Fizz' instead\nIf the value is a multiple of 5: use the value 'Buzz' instead\nIf the value is a multiple of 3 & 5: use the value 'FizzBuzz' instead"}}, "functions": {"fizzbuzz": {"args": ["n"], "returns": ["result"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 48}, "calls": ["range", "ValueError", "TypeError", "result.append"], "source_code": "def fizzbuzz(n):\n    if n < 1:\n        raise ValueError('n cannot be less than one')\n    if n is None:\n        raise TypeError('n cannot be None')\n    result = []\n    for i in range(1, n + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            result.append('FizzBuzz')\n        elif i % 3 == 0:\n            result.append('Fizz')\n        elif i % 5 == 0:\n            result.append('Buzz')\n        else:\n            result.append(i)\n    return result"}, "fizzbuzz_with_helper_func": {"args": ["n"], "returns": ["[fb(m) for m in range(1, n + 1)]"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 52}, "calls": ["fizzbuzz.fb", "range"], "source_code": "def fizzbuzz_with_helper_func(n):\n    return [fb(m) for m in range(1, n + 1)]"}, "fb": {"args": ["m"], "returns": ["r if r != '' else m"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 56}, "source_code": "def fb(m):\n    r = (m % 3 == 0) * 'Fizz' + (m % 5 == 0) * 'Buzz'\n    return r if r != '' else m"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/multiply_strings.py", "fileNameBase": "multiply_strings", "extension": "py", "doc": {"long_description": "return the product of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 110.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert\nthe inputs to integer directly.", "short_description": "Given two non-negative integers num1 and num2 represented as strings,", "full": "Given two non-negative integers num1 and num2 represented as strings,\nreturn the product of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 110.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert\nthe inputs to integer directly."}}, "functions": {"multiply": {"args": ["num1", "num2"], "annotated_arg_types": {"num1": "'str'", "num2": "'str'"}, "annotated_return_type": "'str'", "returns": ["str(sum(interm))"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 29}, "calls": ["ord", "reversed", "str", "interm.append", "sum"], "store_vars_calls": {"zero": "ord"}, "source_code": "def multiply(num1: 'str', num2: 'str') -> 'str':\n    interm = []\n    zero = ord('0')\n    i_pos = 1\n    for i in reversed(num1):\n        j_pos = 1\n        add = 0\n        for j in reversed(num2):\n            mult = (ord(i) - zero) * (ord(j) - zero) * j_pos * i_pos\n            j_pos *= 10\n            add += mult\n        i_pos *= 10\n        interm.append(add)\n    return str(sum(interm))"}}, "body": {"calls": ["print", "multiply_strings.multiply"], "source_code": ["print(multiply('1', '23'))", "multiply('1', '23')", "print(multiply('23', '23'))", "multiply('23', '23')", "print(multiply('100', '23'))", "multiply('100', '23')", "print(multiply('100', '10000'))", "multiply('100', '10000')"]}, "main_info": {"main_flag": 1, "main_function": "multiply_strings.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/check_pangram.py", "fileNameBase": "check_pangram", "extension": "py", "doc": {"short_description": "Algorithm that checks if a given string is a pangram or not", "full": "Algorithm that checks if a given string is a pangram or not"}}, "functions": {"check_pangram": {"args": ["input_string"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 11}, "calls": ["input_string.lower"], "source_code": "def check_pangram(input_string):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for ch in alphabet:\n        if ch not in input_string.lower():\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/atbash_cipher.py", "fileNameBase": "atbash_cipher", "extension": "py", "doc": {"long_description": "So if we take \"a\" as it is the first letter, we change it to the last - z.\n\nExample:\nAttack at dawn --> Zggzxp zg wzdm\n\nComplexity: O(n)", "short_description": "Atbash cipher is mapping the alphabet to it's reverse.", "full": "Atbash cipher is mapping the alphabet to it's reverse.\nSo if we take \"a\" as it is the first letter, we change it to the last - z.\n\nExample:\nAttack at dawn --> Zggzxp zg wzdm\n\nComplexity: O(n)"}}, "functions": {"atbash": {"args": ["s"], "returns": ["translated"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 28}, "calls": ["range", "len", "ord", "s[].isalpha", "s[].isupper", "s[].islower", "chr"], "store_vars_calls": {"n": "ord"}, "source_code": "def atbash(s):\n    translated = ''\n    for i in range(len(s)):\n        n = ord(s[i])\n        if s[i].isalpha():\n            if s[i].isupper():\n                x = n - ord('A')\n                translated += chr(ord('Z') - x)\n            if s[i].islower():\n                x = n - ord('a')\n                translated += chr(ord('z') - x)\n        else:\n            translated += s[i]\n    return translated"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/repeat_string.py", "fileNameBase": "repeat_string", "extension": "py", "doc": {"long_description": "For example, with A = \"abcd\" and B = \"cdabcdab\".\n\nReturn 3, because by repeating A three times (\u201cabcdabcdabcd\u201d), B is a substring of it; and B is not a substring of A repeated two times (\"abcdabcd\").\n\nNote:\nThe length of A and B will be between 1 and 10000.\n\nReference: https://leetcode.com/problems/repeated-string-match/description/", "short_description": "Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.", "full": "Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.\n\nFor example, with A = \"abcd\" and B = \"cdabcdab\".\n\nReturn 3, because by repeating A three times (\u201cabcdabcdabcd\u201d), B is a substring of it; and B is not a substring of A repeated two times (\"abcdabcd\").\n\nNote:\nThe length of A and B will be between 1 and 10000.\n\nReference: https://leetcode.com/problems/repeated-string-match/description/"}}, "functions": {"repeat_string": {"args": ["A", "B"], "returns": ["count"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 25}, "calls": ["len"], "source_code": "def repeat_string(A, B):\n    count = 1\n    tmp = A\n    max_count = len(B) / len(A) + 1\n    while not B in tmp:\n        tmp = tmp + A\n        if count > max_count:\n            count = -1\n            break\n        count = count + 1\n    return count"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/delete_reoccurring.py", "fileNameBase": "delete_reoccurring", "extension": "py", "doc": {"long_description": "character, and return the new string.\n\nThis is a Google warmup interview question that was asked duirng phone screening\nat my university.", "short_description": "QUESTION: Given a string as your input, delete any reoccurring ", "full": "QUESTION: Given a string as your input, delete any reoccurring \ncharacter, and return the new string.\n\nThis is a Google warmup interview question that was asked duirng phone screening\nat my university. "}}, "functions": {"delete_reoccurring_characters": {"args": ["string"], "returns": ["output_string"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 18}, "calls": ["set", "set.add"], "store_vars_calls": {"seen_characters": "set"}, "source_code": "def delete_reoccurring_characters(string):\n    seen_characters = set()\n    output_string = ''\n    for char in string:\n        if char not in seen_characters:\n            seen_characters.add(char)\n            output_string += char\n    return output_string"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/longest_palindromic_substring.py", "fileNameBase": "longest_palindromic_substring", "extension": "py", "doc": {"long_description": "Example1:\n\n* input: \"dasdasdasdasdasdadsa\"\n* output: \"asdadsa\"\n\nExample2:\n\n* input: \"acdbbdaa\"\n* output: \"dbbd\"\n\nManacher's algorithm", "short_description": "Given string s, find the longest palindromic substring.", "full": "Given string s, find the longest palindromic substring.\n\nExample1:\n\n* input: \"dasdasdasdasdasdadsa\"\n* output: \"asdadsa\"\n\nExample2:\n\n* input: \"acdbbdaa\"\n* output: \"dbbd\"\n\nManacher's algorithm"}}, "functions": {"longest_palindrome": {"args": ["s"], "returns": ["s.replace('#', '')", "s"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 45}, "calls": ["range", "s.replace", "len", "min"], "source_code": "def longest_palindrome(s):\n    if len(s) < 2:\n        return s\n    n_str = '#' + '#'.join(s) + '#'\n    p = [0] * len(n_str)\n    (mx, loc) = (0, 0)\n    (index, maxlen) = (0, 0)\n    for i in range(len(n_str)):\n        if i < mx and 2 * loc - i < len(n_str):\n            p[i] = min(mx - i, p[2 * loc - i])\n        else:\n            p[i] = 1\n        while p[i] + i < len(n_str) and i - p[i] >= 0 and (n_str[i - p[i]] == n_str[i + p[i]]):\n            p[i] += 1\n        if i + p[i] > mx:\n            mx = i + p[i]\n            loc = i\n        if p[i] > maxlen:\n            index = i\n            maxlen = p[i]\n    s = n_str[index - p[index] + 1:index + p[index]]\n    return s.replace('#', '')"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/unique_morse.py", "fileNameBase": "unique_morse", "extension": "py", "doc": {"long_description": "a series of dots and dashes, as follows: \"a\" maps to \".-\", \"b\" maps to \"-...\", \"c\"\nmaps to \"-.-.\", and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n        'a':\".-\",\n        'b':\"-...\",\n        'c':\"-.-.\",\n        'd': \"-..\",\n        'e':\".\",\n        'f':\"..-.\",\n        'g':\"--.\",\n        'h':\"....\",\n        'i':\"..\",\n        'j':\".---\",\n        'k':\"-.-\",\n        'l':\".-..\",\n        'm':\"--\",\n        'n':\"-.\",\n        'o':\"---\",\n        'p':\".--.\",\n        'q':\"--.-\",\n        'r':\".-.\",\n        's':\"...\",\n        't':\"-\",\n        'u':\"..-\",\n        'v':\"...-\",\n        'w':\".--\",\n        'x':\"-..-\",\n        'y':\"-.--\",\n        'z':\"--..\"\n\nNow, given a list of words, each word can be written as a concatenation of the\nMorse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\",\n(which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a\nconcatenation, the transformation of a word.\n\nReturn the number of different transformations among all words we have.\nExample:\nInput: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\nOutput: 2\nExplanation:\nThe transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\".", "short_description": "International Morse Code defines a standard encoding where each letter is mapped to", "full": "International Morse Code defines a standard encoding where each letter is mapped to\na series of dots and dashes, as follows: \"a\" maps to \".-\", \"b\" maps to \"-...\", \"c\"\nmaps to \"-.-.\", and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n        'a':\".-\",\n        'b':\"-...\",\n        'c':\"-.-.\",\n        'd': \"-..\",\n        'e':\".\",\n        'f':\"..-.\",\n        'g':\"--.\",\n        'h':\"....\",\n        'i':\"..\",\n        'j':\".---\",\n        'k':\"-.-\",\n        'l':\".-..\",\n        'm':\"--\",\n        'n':\"-.\",\n        'o':\"---\",\n        'p':\".--.\",\n        'q':\"--.-\",\n        'r':\".-.\",\n        's':\"...\",\n        't':\"-\",\n        'u':\"..-\",\n        'v':\"...-\",\n        'w':\".--\",\n        'x':\"-..-\",\n        'y':\"-.--\",\n        'z':\"--..\"\n\nNow, given a list of words, each word can be written as a concatenation of the\nMorse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\",\n(which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a\nconcatenation, the transformation of a word.\n\nReturn the number of different transformations among all words we have.\nExample:\nInput: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\nOutput: 2\nExplanation:\nThe transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\"."}}, "functions": {"convert_morse_word": {"args": ["word"], "returns": ["morse_word"], "min_max_lineno": {"min_lineno": 81, "max_lineno": 87}, "calls": ["word.lower.lower"], "store_vars_calls": {"word": "word.lower"}, "source_code": "def convert_morse_word(word):\n    morse_word = ''\n    word = word.lower()\n    for char in word:\n        morse_word = morse_word + morse_code[char]\n    return morse_word"}, "unique_morse": {"args": ["words"], "returns": ["len(unique_morse_word)"], "min_max_lineno": {"min_lineno": 88, "max_lineno": 95}, "calls": ["len", "unique_morse.convert_morse_word", "unique_morse_word.append"], "store_vars_calls": {"morse_word": "convert_morse_word"}, "source_code": "def unique_morse(words):\n    unique_morse_word = []\n    for word in words:\n        morse_word = convert_morse_word(word)\n        if morse_word not in unique_morse_word:\n            unique_morse_word.append(morse_word)\n    return len(unique_morse_word)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/contain_string.py", "fileNameBase": "contain_string", "extension": "py", "doc": {"long_description": "Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\nExample 1:\nInput: haystack = \"hello\", needle = \"ll\"\nOutput: 2\n\nExample 2:\nInput: haystack = \"aaaaa\", needle = \"bba\"\nOutput: -1\nReference: https://leetcode.com/problems/implement-strstr/description/", "short_description": "Implement strStr().", "full": "Implement strStr().\n\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\nExample 1:\nInput: haystack = \"hello\", needle = \"ll\"\nOutput: 2\n\nExample 2:\nInput: haystack = \"aaaaa\", needle = \"bba\"\nOutput: -1\nReference: https://leetcode.com/problems/implement-strstr/description/"}}, "functions": {"contain_string": {"args": ["haystack", "needle"], "returns": ["-1", "0", "-1", "-1", "i"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 26}, "calls": ["range", "len"], "source_code": "def contain_string(haystack, needle):\n    if len(needle) == 0:\n        return 0\n    if len(needle) > len(haystack):\n        return -1\n    for i in range(len(haystack)):\n        if len(haystack) - i < len(needle):\n            return -1\n        if haystack[i:i + len(needle)] == needle:\n            return i\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/add_binary.py", "fileNameBase": "add_binary", "extension": "py", "doc": {"long_description": "return their sum (also a binary string).\n\nFor example,\na = \"11\"\nb = \"1\"\nReturn \"100\".", "short_description": "Given two binary strings,", "full": "Given two binary strings,\nreturn their sum (also a binary string).\n\nFor example,\na = \"11\"\nb = \"1\"\nReturn \"100\"."}}, "functions": {"add_binary": {"args": ["a", "b"], "returns": ["s"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 27}, "calls": ["ord", "len", "chr"], "store_vars_calls": {"zero": "ord"}, "source_code": "def add_binary(a, b):\n    s = ''\n    (c, i, j) = (0, len(a) - 1, len(b) - 1)\n    zero = ord('0')\n    while i >= 0 or j >= 0 or c == 1:\n        if i >= 0:\n            c += ord(a[i]) - zero\n            i -= 1\n        if j >= 0:\n            c += ord(b[j]) - zero\n            j -= 1\n        s = chr(c % 2 + zero) + s\n        c //= 2\n    return s"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/roman_to_int.py", "fileNameBase": "roman_to_int", "extension": "py", "doc": {"long_description": "Input is guaranteed to be within the range from 1 to 3999.", "short_description": "Given a roman numeral, convert it to an integer.", "full": "Given a roman numeral, convert it to an integer.\nInput is guaranteed to be within the range from 1 to 3999."}}, "functions": {"roman_to_int": {"args": ["s"], "annotated_arg_types": {"s": "'str'"}, "annotated_return_type": "'int'", "returns": ["number + roman[s[-1]]"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 16}, "calls": ["range", "len"], "source_code": "def roman_to_int(s: 'str') -> 'int':\n    number = 0\n    roman = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}\n    for i in range(len(s) - 1):\n        if roman[s[i]] < roman[s[i + 1]]:\n            number -= roman[s[i]]\n        else:\n            number += roman[s[i]]\n    return number + roman[s[-1]]"}}, "body": {"calls": ["print", "roman_to_int.roman_to_int"], "source_code": ["print(roman_to_int(roman))", "roman_to_int(roman)"]}, "main_info": {"main_flag": 1, "main_function": "roman_to_int.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/first_unique_char.py", "fileNameBase": "first_unique_char", "extension": "py", "doc": {"long_description": "index. If it doesn't exist, return -1.\n\nFor example:\ns = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\n\nReference: https://leetcode.com/problems/first-unique-character-in-a-string/description/", "short_description": "Given a string, find the first non-repeating character in it and return it's", "full": "Given a string, find the first non-repeating character in it and return it's\nindex. If it doesn't exist, return -1.\n\nFor example:\ns = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\n\nReference: https://leetcode.com/problems/first-unique-character-in-a-string/description/"}}, "functions": {"first_unique_char": {"args": ["s"], "returns": ["-1", "0", "i"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 28}, "calls": ["range", "len", "ban.append", "all"], "source_code": "def first_unique_char(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 1:\n        return 0\n    ban = []\n    for i in range(len(s)):\n        if all((s[i] != s[k] for k in range(i + 1, len(s)))) == True and s[i] not in ban:\n            return i\n        else:\n            ban.append(s[i])\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/decode_string.py", "fileNameBase": "decode_string", "extension": "py"}, "functions": {"decode_string": {"args": ["s"], "returns": ["cur_string"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 39}, "calls": ["stack.append", "stack.pop", "c.isdigit", "int"], "source_code": "def decode_string(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    stack = []\n    cur_num = 0\n    cur_string = ''\n    for c in s:\n        if c == '[':\n            stack.append((cur_string, cur_num))\n            cur_string = ''\n            cur_num = 0\n        elif c == ']':\n            (prev_string, num) = stack.pop()\n            cur_string = prev_string + num * cur_string\n        elif c.isdigit():\n            cur_num = cur_num * 10 + int(c)\n        else:\n            cur_string += c\n    return cur_string"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/reverse_words.py", "fileNameBase": "reverse_words", "extension": "py"}, "functions": {"reverse": {"args": ["array", "i", "j"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 7}, "source_code": "def reverse(array, i, j):\n    while i < j:\n        (array[i], array[j]) = (array[j], array[i])\n        i += 1\n        j -= 1"}, "reverse_words": {"args": ["string"], "returns": ["' '.join(arr)"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 15}, "calls": ["string.strip().split", "len", "reverse_words.reverse", "string.strip"], "store_vars_calls": {"arr": "string.strip().split", "n": "len"}, "source_code": "def reverse_words(string):\n    arr = string.strip().split()\n    n = len(arr)\n    reverse(arr, 0, n - 1)\n    return ' '.join(arr)"}}, "body": {"calls": ["print", "reverse_words.reverse_words"], "source_code": ["print(test)", "print(reverse_words(test))", "reverse_words(test)"]}, "main_info": {"main_flag": 1, "main_function": "reverse_words.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/reverse_vowel.py", "fileNameBase": "reverse_vowel", "extension": "py"}, "functions": {"reverse_vowel": {"args": ["s"], "returns": ["''.join(s)"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 14}, "calls": ["list", "len"], "store_vars_calls": {"s": "list"}, "source_code": "def reverse_vowel(s):\n    vowels = 'AEIOUaeiou'\n    (i, j) = (0, len(s) - 1)\n    s = list(s)\n    while i < j:\n        while i < j and s[i] not in vowels:\n            i += 1\n        while i < j and s[j] not in vowels:\n            j -= 1\n        (s[i], s[j]) = (s[j], s[i])\n        (i, j) = (i + 1, j - 1)\n    return ''.join(s)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/caesar_cipher.py", "fileNameBase": "caesar_cipher", "extension": "py", "doc": {"long_description": "Caesar's cipher shifts each letter by a number of letters. If the shift takes you\npast the end of the alphabet, just rotate back to the front of the alphabet.\nIn the case of a rotation by 3, w, x, y and z would map to z, a, b and c.\nOriginal alphabet:      abcdefghijklmnopqrstuvwxyz\nAlphabet rotated +3:    defghijklmnopqrstuvwxyzabc", "short_description": "Julius Caesar protected his confidential information by encrypting it using a cipher.", "full": "Julius Caesar protected his confidential information by encrypting it using a cipher.\nCaesar's cipher shifts each letter by a number of letters. If the shift takes you\npast the end of the alphabet, just rotate back to the front of the alphabet.\nIn the case of a rotation by 3, w, x, y and z would map to z, a, b and c.\nOriginal alphabet:      abcdefghijklmnopqrstuvwxyz\nAlphabet rotated +3:    defghijklmnopqrstuvwxyzabc"}}, "functions": {"caesar_cipher": {"args": ["s", "k"], "returns": ["result"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 20}, "calls": ["ord", "chr"], "store_vars_calls": {"n": "ord"}, "source_code": "def caesar_cipher(s, k):\n    result = ''\n    for char in s:\n        n = ord(char)\n        if 64 < n < 91:\n            n = (n - 65 + k) % 26 + 65\n        if 96 < n < 123:\n            n = (n - 97 + k) % 26 + 97\n        result = result + chr(n)\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/make_sentence.py", "fileNameBase": "make_sentence", "extension": "py", "doc": {"long_description": "string, such that all the words are contained in the dictionary.\n\neg: for given string -> \"appletablet\"\n\"apple\", \"tablet\"\n\"applet\", \"able\", \"t\"\n\"apple\", \"table\", \"t\"\n\"app\", \"let\", \"able\", \"t\"\n\n\"applet\", {app, let, apple, t, applet} => 3\n\"thing\", {\"thing\"} -> 1", "short_description": "For a given string and dictionary, how many sentences can you make from the", "full": "For a given string and dictionary, how many sentences can you make from the\nstring, such that all the words are contained in the dictionary.\n\neg: for given string -> \"appletablet\"\n\"apple\", \"tablet\"\n\"applet\", \"able\", \"t\"\n\"apple\", \"table\", \"t\"\n\"app\", \"let\", \"able\", \"t\"\n\n\"applet\", {app, let, apple, t, applet} => 3\n\"thing\", {\"thing\"} -> 1"}}, "functions": {"make_sentence": {"args": ["str_piece", "dictionaries"], "returns": ["True", "True"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 28}, "calls": ["range", "len", "make_sentence.make_sentence"], "source_code": "def make_sentence(str_piece, dictionaries):\n    global count\n    if len(str_piece) == 0:\n        return True\n    for i in range(0, len(str_piece)):\n        (prefix, suffix) = (str_piece[0:i], str_piece[i:])\n        if prefix in dictionaries:\n            if suffix in dictionaries or make_sentence(suffix, dictionaries):\n                count += 1\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/group_anagrams.py", "fileNameBase": "group_anagrams", "extension": "py", "doc": {"long_description": "For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\nReturn:\n\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]", "short_description": "Given an array of strings, group anagrams together.", "full": "Given an array of strings, group anagrams together.\n\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\nReturn:\n\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]"}}, "functions": {"group_anagrams": {"args": ["strs"], "returns": ["ans"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 29}, "calls": ["sorted", "ans.append", "ans[].append"], "source_code": "def group_anagrams(strs):\n    d = {}\n    ans = []\n    k = 0\n    for str in strs:\n        sstr = ''.join(sorted(str))\n        if sstr not in d:\n            d[sstr] = k\n            k += 1\n            ans.append([])\n            ans[-1].append(str)\n        else:\n            ans[d[sstr]].append(str)\n    return ans"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/text_justification.py", "fileNameBase": "text_justification", "extension": "py", "doc": {"long_description": "has exactly maxWidth characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as\nyou can in each line. Pad extra spaces ' ' when necessary so that each line has\nexactly maxWidth characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the\nnumber of spaces on a line do not divide evenly between words, the empty slots\non the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left justified and no extra space is\ninserted between words.\n\nNote:\nA word is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\nThe input array words contains at least one word.\n\nExample:\nInput:\nwords = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\nmaxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]", "short_description": "Given an array of words and a width maxWidth, format the text such that each line", "full": "Given an array of words and a width maxWidth, format the text such that each line\nhas exactly maxWidth characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as\nyou can in each line. Pad extra spaces ' ' when necessary so that each line has\nexactly maxWidth characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the\nnumber of spaces on a line do not divide evenly between words, the empty slots\non the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left justified and no extra space is\ninserted between words.\n\nNote:\nA word is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\nThe input array words contains at least one word.\n\nExample:\nInput:\nwords = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\nmaxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]"}}, "functions": {"text_justification": {"args": ["words", "max_width"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 90}, "calls": ["len", "ret.append", "row_words.append", "ValueError", "row_words.pop", "range"], "source_code": "def text_justification(words, max_width):\n    \"\"\"\n    :type words: list\n    :type max_width: int\n    :rtype: list\n    \"\"\"\n    ret = []\n    row_len = 0\n    row_words = []\n    index = 0\n    is_first_word = True\n    while index < len(words):\n        while row_len <= max_width and index < len(words):\n            if len(words[index]) > max_width:\n                raise ValueError('there exists word whose length is larger than max_width')\n            tmp = row_len\n            row_words.append(words[index])\n            tmp += len(words[index])\n            if not is_first_word:\n                tmp += 1\n            if tmp > max_width:\n                row_words.pop()\n                break\n            row_len = tmp\n            index += 1\n            is_first_word = False\n        row = ''\n        if index == len(words):\n            for word in row_words:\n                row += word + ' '\n            row = row[:-1]\n            row += ' ' * (max_width - len(row))\n        elif len(row_words) != 1:\n            space_num = max_width - row_len\n            space_num_of_each_interval = space_num // (len(row_words) - 1)\n            space_num_rest = space_num - space_num_of_each_interval * (len(row_words) - 1)\n            for j in range(len(row_words)):\n                row += row_words[j]\n                if j != len(row_words) - 1:\n                    row += ' ' * (1 + space_num_of_each_interval)\n                if space_num_rest > 0:\n                    row += ' '\n                    space_num_rest -= 1\n        else:\n            row += row_words[0]\n            row += ' ' * (max_width - len(row))\n        ret.append(row)\n        row_len = 0\n        row_words = []\n        is_first_word = True\n    return ret"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/strings/panagram.py", "fileNameBase": "panagram", "extension": "py", "doc": {"long_description": "A panagram is a sentence that uses every letter at least once.\n\nThe most famous example is: \"he quick brown fox jumps over the lazy dog.\n\nNote:\nA panagram in one language isn't necessarily a panagram in another. This\nmodule assumes the english language. Hence, the Finnish panagram\n'T\u00f6rkylempij\u00e4vongahdus' won't pass for a panagram despite being considered\na perfect panagram in its language. However, the Swedish panagram\n'Yxm\u00f6rdaren Julia Blomqvist p\u00e5 f\u00e4ktning i Schweiz' will pass despite\nincluding letters not used in the english alphabet. This is because the\nSwedish alphabet only extends the Latin one.", "short_description": "Given a string, check whether it is a panagram or not.", "full": "Given a string, check whether it is a panagram or not.\n\nA panagram is a sentence that uses every letter at least once.\n\nThe most famous example is: \"he quick brown fox jumps over the lazy dog.\n\nNote:\nA panagram in one language isn't necessarily a panagram in another. This\nmodule assumes the english language. Hence, the Finnish panagram\n'T\u00f6rkylempij\u00e4vongahdus' won't pass for a panagram despite being considered\na perfect panagram in its language. However, the Swedish panagram\n'Yxm\u00f6rdaren Julia Blomqvist p\u00e5 f\u00e4ktning i Schweiz' will pass despite\nincluding letters not used in the english alphabet. This is because the\nSwedish alphabet only extends the Latin one."}}, "dependencies": [{"from_module": "string", "import": "ascii_lowercase", "type": "external", "type_element": "module"}], "functions": {"panagram": {"doc": {"short_description": "Returns whether the input string is an English panagram or not.", "args": {"string": {"description": "A sentence in the form of a string.", "type_name": "str", "is_optional": false}}, "returns": {"description": "A boolean with the result.", "is_generator": false}}, "args": ["string"], "returns": ["len(letters) == 0"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 37}, "calls": ["set", "len", "set.remove", "c.lower"], "store_vars_calls": {"letters": "set"}, "source_code": "def panagram(string):\n    \"\"\"\n    Returns whether the input string is an English panagram or not.\n\n        Parameters:\n            string (str): A sentence in the form of a string.\n\n        Returns:\n            A boolean with the result.\n    \"\"\"\n    letters = set(ascii_lowercase)\n    for c in string:\n        try:\n            letters.remove(c.lower())\n        except:\n            pass\n    return len(letters) == 0"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/automata": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/automata/dfa.py", "fileNameBase": "dfa", "extension": "py"}, "functions": {"DFA": {"args": ["transitions", "start", "final", "string"], "returns": ["False", "False", "True"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 18}, "calls": ["len", "range"], "store_vars_calls": {"num": "len", "num_final": "len"}, "source_code": "def DFA(transitions, start, final, string):\n    num = len(string)\n    num_final = len(final)\n    cur = start\n    for i in range(num):\n        if transitions[cur][string[i]] is None:\n            return False\n        else:\n            cur = transitions[cur][string[i]]\n    for i in range(num_final):\n        if cur == final[i]:\n            return True\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/automata/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "dfa", "import": "DFA", "type": "internal", "type_element": "function"}], "is_test": false}], "output/keon/algorithms/algorithms/algorithms/bfs": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bfs/maze_search.py", "fileNameBase": "maze_search", "extension": "py"}, "dependencies": [{"from_module": "collections", "import": "deque", "type": "external", "type_element": "module"}], "functions": {"maze_search": {"args": ["maze"], "returns": ["-1", "-1", "steps"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 67}, "calls": ["collections.deque", "len", "collections.deque.popleft", "range", "collections.deque.append"], "store_vars_calls": {"queue": "deque"}, "source_code": "def maze_search(maze):\n    (BLOCKED, ALLOWED) = (0, 1)\n    (UNVISITED, VISITED) = (0, 1)\n    (initial_x, initial_y) = (0, 0)\n    if maze[initial_x][initial_y] == BLOCKED:\n        return -1\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    (height, width) = (len(maze), len(maze[0]))\n    (target_x, target_y) = (height - 1, width - 1)\n    queue = deque([(initial_x, initial_y, 0)])\n    is_visited = [[UNVISITED for w in range(width)] for h in range(height)]\n    is_visited[initial_x][initial_y] = VISITED\n    while queue:\n        (x, y, steps) = queue.popleft()\n        if x == target_x and y == target_y:\n            return steps\n        for (dx, dy) in directions:\n            new_x = x + dx\n            new_y = y + dy\n            if not (0 <= new_x < height and 0 <= new_y < width):\n                continue\n            if maze[new_x][new_y] == ALLOWED and is_visited[new_x][new_y] == UNVISITED:\n                queue.append((new_x, new_y, steps + 1))\n                is_visited[new_x][new_y] = VISITED\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bfs/shortest_distance_from_all_buildings.py", "fileNameBase": "shortest_distance_from_all_buildings", "extension": "py"}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"shortest_distance": {"args": ["grid"], "returns": ["res if res != float('inf') else -1", "-1"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 29}, "calls": ["range", "float", "len", "shortest_distance_from_all_buildings.bfs", "min"], "store_vars_calls": {"res": "min"}, "source_code": "def shortest_distance(grid):\n    if not grid or not grid[0]:\n        return -1\n    matrix = [[[0, 0] for i in range(len(grid[0]))] for j in range(len(grid))]\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                bfs(grid, matrix, i, j, count)\n                count += 1\n    res = float('inf')\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j][1] == count:\n                res = min(res, matrix[i][j][0])\n    return res if res != float('inf') else -1"}, "bfs": {"args": ["grid", "matrix", "i", "j", "count"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 41}, "calls": ["q.pop", "q.append", "len"], "source_code": "def bfs(grid, matrix, i, j, count):\n    q = [(i, j, 0)]\n    while q:\n        (i, j, step) = q.pop(0)\n        for (k, l) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= k < len(grid) and 0 <= l < len(grid[0]) and (matrix[k][l][1] == count) and (grid[k][l] == 0):\n                matrix[k][l][0] += step + 1\n                matrix[k][l][1] = count + 1\n                q.append((k, l, step + 1))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bfs/word_ladder.py", "fileNameBase": "word_ladder", "extension": "py", "doc": {"long_description": "find the length of shortest transformation sequence\nfrom beginWord to endWord, such that:\n\nOnly one letter can be changed at a time\nEach intermediate word must exist in the word list\nFor example,\n\nGiven:\nbegin_word = \"hit\"\nend_word = \"cog\"\nword_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n\nNote:\nReturn -1 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.", "short_description": "Given two words (begin_word and end_word), and a dictionary's word list,", "full": "Given two words (begin_word and end_word), and a dictionary's word list,\nfind the length of shortest transformation sequence\nfrom beginWord to endWord, such that:\n\nOnly one letter can be changed at a time\nEach intermediate word must exist in the word list\nFor example,\n\nGiven:\nbegin_word = \"hit\"\nend_word = \"cog\"\nword_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n\nNote:\nReturn -1 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters."}}, "functions": {"ladder_length": {"doc": {"short_description": "Bidirectional BFS!!!"}, "args": ["begin_word", "end_word", "word_list"], "returns": ["-1", "-1", "0", "1", "result"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 65}, "calls": ["set", "set.add", "set.add", "len", "sum", "word_ladder.word_range", "zip", "set.add", "word_list.remove"], "store_vars_calls": {"begin_set": "set", "end_set": "set", "next_begin_set": "set"}, "source_code": "def ladder_length(begin_word, end_word, word_list):\n    \"\"\"\n    Bidirectional BFS!!!\n    :type begin_word: str\n    :type end_word: str\n    :type word_list: Set[str]\n    :rtype: int\n    \"\"\"\n    if len(begin_word) != len(end_word):\n        return -1\n    if begin_word == end_word:\n        return 0\n    if sum((c1 != c2 for (c1, c2) in zip(begin_word, end_word))) == 1:\n        return 1\n    begin_set = set()\n    end_set = set()\n    begin_set.add(begin_word)\n    end_set.add(end_word)\n    result = 2\n    while begin_set and end_set:\n        if len(begin_set) > len(end_set):\n            (begin_set, end_set) = (end_set, begin_set)\n        next_begin_set = set()\n        for word in begin_set:\n            for ladder_word in word_range(word):\n                if ladder_word in end_set:\n                    return result\n                if ladder_word in word_list:\n                    next_begin_set.add(ladder_word)\n                    word_list.remove(ladder_word)\n        begin_set = next_begin_set\n        result += 1\n    return -1"}, "word_range": {"args": ["word"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 73}, "calls": ["range", "len", "chr", "ord"], "source_code": "def word_range(word):\n    for ind in range(len(word)):\n        temp = word[ind]\n        for c in [chr(x) for x in range(ord('a'), ord('z') + 1)]:\n            if c != temp:\n                yield (word[:ind] + c + word[ind + 1:])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bfs/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "count_islands", "import": "count_islands", "type": "internal", "type_element": "function"}, {"from_module": "maze_search", "import": "maze_search", "type": "internal", "type_element": "function"}, {"from_module": "shortest_distance_from_all_buildings", "import": "shortest_distance", "type": "internal", "type_element": "function"}, {"from_module": "shortest_distance_from_all_buildings", "import": "bfs", "type": "internal", "type_element": "function"}, {"from_module": "word_ladder", "import": "ladder_length", "type": "internal", "type_element": "function"}, {"from_module": "word_ladder", "import": "word_range", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/bfs/count_islands.py", "fileNameBase": "count_islands", "extension": "py", "doc": {"long_description": "Given a 2d grid map of '1's (land) and '0's (water),\ncount the number of islands.\nAn island is surrounded by water and is formed by\nconnecting adjacent lands horizontally or vertically.\nYou may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\n11110\n11010\n11000\n00000\nAnswer: 1\n\nExample 2:\n11000\n11000\n00100\n00011\nAnswer: 3\n\nExample 3:\n111000\n110000\n100001\n001101\n001100\nAnswer: 3\n\nExample 4:\n110011\n001100\n000001\n111100\nAnswer: 5", "short_description": "This is a bfs-version of counting-islands problem in dfs section.", "full": "This is a bfs-version of counting-islands problem in dfs section.\nGiven a 2d grid map of '1's (land) and '0's (water),\ncount the number of islands.\nAn island is surrounded by water and is formed by\nconnecting adjacent lands horizontally or vertically.\nYou may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\n11110\n11010\n11000\n00000\nAnswer: 1\n\nExample 2:\n11000\n11000\n00100\n00011\nAnswer: 3\n\nExample 3:\n111000\n110000\n100001\n001101\n001100\nAnswer: 3\n\nExample 4:\n110011\n001100\n000001\n111100\nAnswer: 5"}}, "functions": {"count_islands": {"args": ["grid"], "returns": ["num_islands"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 66}, "calls": ["len", "range", "enumerate", "queue.append", "queue.pop"], "store_vars_calls": {"row": "len", "col": "len"}, "source_code": "def count_islands(grid):\n    row = len(grid)\n    col = len(grid[0])\n    num_islands = 0\n    visited = [[0] * col for i in range(row)]\n    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    queue = []\n    for i in range(row):\n        for (j, num) in enumerate(grid[i]):\n            if num == 1 and visited[i][j] != 1:\n                visited[i][j] = 1\n                queue.append((i, j))\n                while queue:\n                    (x, y) = queue.pop(0)\n                    for k in range(len(directions)):\n                        nx_x = x + directions[k][0]\n                        nx_y = y + directions[k][1]\n                        if nx_x >= 0 and nx_y >= 0 and (nx_x < row) and (nx_y < col):\n                            if visited[nx_x][nx_y] != 1 and grid[nx_x][nx_y] == 1:\n                                queue.append((nx_x, nx_y))\n                                visited[nx_x][nx_y] = 1\n                num_islands += 1\n    return num_islands"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/maths": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/prime_check.py", "fileNameBase": "prime_check", "extension": "py"}, "functions": {"prime_check": {"doc": {"long_description": "Else return False.", "short_description": "Return True if n is a prime number"}, "args": ["n"], "returns": ["True", "False", "True", "False", "False"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 18}, "source_code": "def prime_check(n):\n    \"\"\"Return True if n is a prime number\n    Else return False.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    j = 5\n    while j * j <= n:\n        if n % j == 0 or n % (j + 2) == 0:\n            return False\n        j += 6\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/num_perfect_squares.py", "fileNameBase": "num_perfect_squares", "extension": "py", "doc": {"long_description": "to sum to the specified number. Lagrange's four-square theorem gives us that the answer will always\nbe between 1 and 4 (https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem).\n\nSome examples:\nNumber | Perfect Squares representation | Answer\n-------|--------------------------------|--------\n9      | 3^2                            | 1\n10     | 3^2 + 1^2                      | 2\n12     | 2^2 + 2^2 + 2^2                | 3\n31     | 5^2 + 2^2 + 1^2 + 1^2          | 4", "short_description": "Given an integer num_perfect_squares will return the minimum amount of perfect squares are required", "full": "Given an integer num_perfect_squares will return the minimum amount of perfect squares are required\nto sum to the specified number. Lagrange's four-square theorem gives us that the answer will always\nbe between 1 and 4 (https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem).\n\nSome examples:\nNumber | Perfect Squares representation | Answer\n-------|--------------------------------|--------\n9      | 3^2                            | 1\n10     | 3^2 + 1^2                      | 2\n12     | 2^2 + 2^2 + 2^2                | 3\n31     | 5^2 + 2^2 + 1^2 + 1^2          | 4"}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"num_perfect_squares": {"doc": {"short_description": "Returns the smallest number of perfect squares that sum to the specified number.", "returns": {"description": "int between 1 - 4", "is_generator": false}}, "args": ["number"], "returns": ["3", "1", "4", "2"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 48}, "calls": ["range", "int", "math.sqrt"], "source_code": "def num_perfect_squares(number):\n    \"\"\"\n    Returns the smallest number of perfect squares that sum to the specified number.\n    :return: int between 1 - 4\n    \"\"\"\n    if int(math.sqrt(number)) ** 2 == number:\n        return 1\n    while number > 0 and number % 4 == 0:\n        number /= 4\n    if number % 8 == 7:\n        return 4\n    for i in range(1, int(math.sqrt(number)) + 1):\n        if int(math.sqrt(number - i ** 2)) ** 2 == number - i ** 2:\n            return 2\n    return 3"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/cosine_similarity.py", "fileNameBase": "cosine_similarity", "extension": "py", "doc": {"long_description": "Two list must have the same length.\n\nExample:\ncosine_similarity([1, 1, 1], [1, 2, -1])  # output : 0.47140452079103173", "short_description": "Calculate cosine similarity between given two 1d list.", "full": "Calculate cosine similarity between given two 1d list.\nTwo list must have the same length.\n\nExample:\ncosine_similarity([1, 1, 1], [1, 2, -1])  # output : 0.47140452079103173"}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"_l2_distance": {"doc": {"short_description": "Calculate l2 distance from two given vectors."}, "args": ["vec"], "returns": ["norm"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 20}, "calls": ["math.sqrt"], "store_vars_calls": {"norm": "math.sqrt"}, "source_code": "def _l2_distance(vec):\n    \"\"\"\n    Calculate l2 distance from two given vectors.\n    \"\"\"\n    norm = 0.0\n    for element in vec:\n        norm += element * element\n    norm = math.sqrt(norm)\n    return norm"}, "cosine_similarity": {"doc": {"short_description": "Calculate cosine similarity between given two vectors"}, "args": ["vec1", "vec2"], "returns": ["similarity"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 44}, "calls": ["cosine_similarity._l2_distance", "zip", "len", "ValueError", "str"], "store_vars_calls": {"norm_a": "_l2_distance", "norm_b": "_l2_distance"}, "source_code": "def cosine_similarity(vec1, vec2):\n    \"\"\"\n    Calculate cosine similarity between given two vectors\n    :type vec1: list\n    :type vec2: list\n    \"\"\"\n    if len(vec1) != len(vec2):\n        raise ValueError('The two vectors must be the same length. Got shape ' + str(len(vec1)) + ' and ' + str(len(vec2)))\n    norm_a = _l2_distance(vec1)\n    norm_b = _l2_distance(vec2)\n    similarity = 0.0\n    for (vec1_element, vec2_element) in zip(vec1, vec2):\n        similarity += vec1_element * vec2_element\n    similarity /= norm_a * norm_b\n    return similarity"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/find_order_simple.py", "fileNameBase": "find_order_simple", "extension": "py", "doc": {"long_description": "the order of a modulo n is the smallest positive integer k that satisfies\npow (a, k) % n = 1. In other words, (a^k) \u2261 1 (mod n).\nOrder of a certain number may or may not be exist. If not, return -1.\n\nTotal time complexity O(nlog(n)):\nO(n) for iteration loop, \nO(log(n)) for built-in power function", "short_description": "For positive integer n and given integer a that satisfies gcd(a, n) = 1,", "full": "For positive integer n and given integer a that satisfies gcd(a, n) = 1,\nthe order of a modulo n is the smallest positive integer k that satisfies\npow (a, k) % n = 1. In other words, (a^k) \u2261 1 (mod n).\nOrder of a certain number may or may not be exist. If not, return -1.\n\nTotal time complexity O(nlog(n)):\nO(n) for iteration loop, \nO(log(n)) for built-in power function"}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"find_order": {"doc": {"short_description": "Find order for positive integer n and given integer a that satisfies gcd(a, n) = 1."}, "args": ["a", "n"], "returns": ["-1", "1", "-1", "i"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 28}, "calls": ["range", "math.gcd", "print", "pow"], "source_code": "def find_order(a, n):\n    \"\"\"\n    Find order for positive integer n and given integer a that satisfies gcd(a, n) = 1.\n    \"\"\"\n    if (a == 1) & (n == 1):\n        return 1\n    if math.gcd(a, n) != 1:\n        print('a and n should be relative prime!')\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/combination.py", "fileNameBase": "combination", "extension": "py", "doc": {"short_description": "Functions to calculate nCr (ie how many ways to choose r items from n items)", "full": "Functions to calculate nCr (ie how many ways to choose r items from n items)"}}, "functions": {"combination": {"doc": {"short_description": "This function calculates nCr."}, "args": ["n", "r"], "returns": ["combination(n - 1, r - 1) + combination(n - 1, r)", "1"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 9}, "calls": ["combination.combination"], "source_code": "def combination(n, r):\n    \"\"\"This function calculates nCr.\"\"\"\n    if n == r or r == 0:\n        return 1\n    return combination(n - 1, r - 1) + combination(n - 1, r)"}, "combination_memo": {"doc": {"short_description": "This function calculates nCr using memoization method."}, "args": ["n", "r"], "returns": ["recur(n, r)", "memo[n, r]", "1"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 20}, "calls": ["combination.combination_memo.recur"], "functions": {"recur": {"args": ["n", "r"], "returns": ["memo[n, r]", "1"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 19}, "calls": ["recur"], "source_code": "def recur(n, r):\n    if n == r or r == 0:\n        return 1\n    if (n, r) not in memo:\n        memo[n, r] = recur(n - 1, r - 1) + recur(n - 1, r)\n    return memo[n, r]"}}, "source_code": "def combination_memo(n, r):\n    \"\"\"This function calculates nCr using memoization method.\"\"\"\n    memo = {}\n\n    def recur(n, r):\n        if n == r or r == 0:\n            return 1\n        if (n, r) not in memo:\n            memo[n, r] = recur(n - 1, r - 1) + recur(n - 1, r)\n        return memo[n, r]\n    return recur(n, r)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/hailstone.py", "fileNameBase": "hailstone", "extension": "py", "doc": {"long_description": "* n == 1    : done\n* n is even : the next n = n/2\n* n is odd  : the next n = 3n + 1", "short_description": "Implementation of hailstone function which generates a sequence for some n by following these rules:", "full": "Implementation of hailstone function which generates a sequence for some n by following these rules:\n* n == 1    : done\n* n is even : the next n = n/2\n* n is odd  : the next n = 3n + 1"}}, "functions": {"hailstone": {"doc": {"long_description": "n: The starting point of the hailstone sequence", "short_description": "Return the 'hailstone sequence' from n to 1"}, "args": ["n"], "returns": ["sequence"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 22}, "calls": ["sequence.append", "int"], "store_vars_calls": {"n": "int"}, "source_code": "def hailstone(n):\n    \"\"\"\n    Return the 'hailstone sequence' from n to 1\n    n: The starting point of the hailstone sequence\n    \"\"\"\n    sequence = [n]\n    while n > 1:\n        if n % 2 != 0:\n            n = 3 * n + 1\n        else:\n            n = int(n / 2)\n        sequence.append(n)\n    return sequence"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/pythagoras.py", "fileNameBase": "pythagoras", "extension": "py", "doc": {"long_description": "length of the third side.", "short_description": "Given the lengths of two of the three sides of a right angled triangle, this function returns the", "full": "Given the lengths of two of the three sides of a right angled triangle, this function returns the\nlength of the third side."}}, "functions": {"pythagoras": {"doc": {"long_description": "Passing \"?\" will indicate the unknown side.", "short_description": "Returns length of a third side of a right angled triangle."}, "args": ["opposite", "adjacent", "hypotenuse"], "returns": ["'You already know the answer!'", "'Opposite = ' + str((hypotenuse ** 2 - adjacent ** 2) ** 0.5)", "'Adjacent = ' + str((hypotenuse ** 2 - opposite ** 2) ** 0.5)", "'Hypotenuse = ' + str((opposite ** 2 + adjacent ** 2) ** 0.5)"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 21}, "calls": ["str", "ValueError"], "source_code": "def pythagoras(opposite, adjacent, hypotenuse):\n    \"\"\"\n    Returns length of a third side of a right angled triangle.\n    Passing \"?\" will indicate the unknown side.\n    \"\"\"\n    try:\n        if opposite == str('?'):\n            return 'Opposite = ' + str((hypotenuse ** 2 - adjacent ** 2) ** 0.5)\n        if adjacent == str('?'):\n            return 'Adjacent = ' + str((hypotenuse ** 2 - opposite ** 2) ** 0.5)\n        if hypotenuse == str('?'):\n            return 'Hypotenuse = ' + str((opposite ** 2 + adjacent ** 2) ** 0.5)\n        return 'You already know the answer!'\n    except:\n        raise ValueError('invalid argument(s) were given.')"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/gcd.py", "fileNameBase": "gcd", "extension": "py", "doc": {"long_description": "their least common multiple.", "short_description": "Functions for calculating the greatest common divisor of two integers or", "full": "Functions for calculating the greatest common divisor of two integers or\ntheir least common multiple."}}, "functions": {"gcd": {"doc": {"long_description": "Euclid's Algorithm.\ngcd{\ud835\udc4e,\ud835\udc4f}=gcd{\u2212\ud835\udc4e,\ud835\udc4f}=gcd{\ud835\udc4e,\u2212\ud835\udc4f}=gcd{\u2212\ud835\udc4e,\u2212\ud835\udc4f}\nSee proof: https://proofwiki.org/wiki/GCD_for_Negative_Integers", "short_description": "Computes the greatest common divisor of integers a and b using"}, "args": ["a", "b"], "returns": ["a"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 25}, "calls": ["isinstance", "abs", "ValueError"], "store_vars_calls": {"a_int": "isinstance", "b_int": "isinstance", "a": "abs", "b": "abs"}, "source_code": "def gcd(a, b):\n    \"\"\"Computes the greatest common divisor of integers a and b using\n    Euclid's Algorithm.\n    gcd{\ud835\udc4e,\ud835\udc4f}=gcd{\u2212\ud835\udc4e,\ud835\udc4f}=gcd{\ud835\udc4e,\u2212\ud835\udc4f}=gcd{\u2212\ud835\udc4e,\u2212\ud835\udc4f}\n    See proof: https://proofwiki.org/wiki/GCD_for_Negative_Integers\n    \"\"\"\n    a_int = isinstance(a, int)\n    b_int = isinstance(b, int)\n    a = abs(a)\n    b = abs(b)\n    if not (a_int or b_int):\n        raise ValueError('Input arguments are not integers')\n    if a == 0 or b == 0:\n        raise ValueError('One or more input arguments equals zero')\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a"}, "lcm": {"doc": {"short_description": "Computes the lowest common multiple of integers a and b."}, "args": ["a", "b"], "returns": ["abs(a) * abs(b) / gcd(a, b)"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 29}, "calls": ["gcd.gcd", "abs"], "source_code": "def lcm(a, b):\n    \"\"\"Computes the lowest common multiple of integers a and b.\"\"\"\n    return abs(a) * abs(b) / gcd(a, b)"}, "trailing_zero": {"args": ["x"], "returns": ["count"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 47}, "source_code": "def trailing_zero(x):\n    count = 0\n    while x and (not x & 1):\n        count += 1\n        x >>= 1\n    return count"}, "gcd_bit": {"doc": {"short_description": "Similar to gcd but uses bitwise operators and less error handling."}, "args": ["a", "b"], "returns": ["a << min(tza, tzb)"], "min_max_lineno": {"min_lineno": 52, "max_lineno": 64}, "calls": ["gcd.trailing_zero", "min"], "store_vars_calls": {"tza": "trailing_zero", "tzb": "trailing_zero"}, "source_code": "def gcd_bit(a, b):\n    \"\"\" Similar to gcd but uses bitwise operators and less error handling.\"\"\"\n    tza = trailing_zero(a)\n    tzb = trailing_zero(b)\n    a >>= tza\n    b >>= tzb\n    while b:\n        if a < b:\n            (a, b) = (b, a)\n        a -= b\n        a >>= trailing_zero(a)\n    return a << min(tza, tzb)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/base_conversion.py", "fileNameBase": "base_conversion", "extension": "py", "doc": {"long_description": "int_to_base(5, 2) return '101'.\nbase_to_int('F', 16) return 15.", "short_description": "Integer base conversion algorithm", "full": "Integer base conversion algorithm\n\nint_to_base(5, 2) return '101'.\nbase_to_int('F', 16) return 15."}}, "dependencies": [{"import": "string", "type": "external", "type_element": "module"}], "functions": {"int_to_base": {"args": ["num", "base"], "returns": ["res[::-1]", "'0'", "'-' + res[::-1]"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 31}, "source_code": "def int_to_base(num, base):\n    \"\"\"\n        :type num: int\n        :type base: int\n        :rtype: str\n    \"\"\"\n    is_negative = False\n    if num == 0:\n        return '0'\n    if num < 0:\n        is_negative = True\n        num *= -1\n    digit = string.digits + string.ascii_uppercase\n    res = ''\n    while num > 0:\n        res += digit[num % base]\n        num //= base\n    if is_negative:\n        return '-' + res[::-1]\n    return res[::-1]"}, "base_to_int": {"doc": {"short_description": "Note : You can use int() built-in function instead of this."}, "args": ["str_to_convert", "base"], "returns": ["res"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 50}, "calls": ["enumerate"], "source_code": "def base_to_int(str_to_convert, base):\n    \"\"\"\n        Note : You can use int() built-in function instead of this.\n        :type str_to_convert: str\n        :type base: int\n        :rtype: int\n    \"\"\"\n    digit = {}\n    for (ind, char) in enumerate(string.digits + string.ascii_uppercase):\n        digit[char] = ind\n    multiplier = 1\n    res = 0\n    for char in str_to_convert[::-1]:\n        res += digit[char] * multiplier\n        multiplier *= base\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/power.py", "fileNameBase": "power", "extension": "py", "doc": {"long_description": "Allows also for calculating the exponentiation modulo.", "short_description": "Performs exponentiation, similarly to the built-in pow() or ** functions.", "full": "Performs exponentiation, similarly to the built-in pow() or ** functions.\nAllows also for calculating the exponentiation modulo."}}, "functions": {"power": {"doc": {"long_description": "Calculate a ^ n\nif mod is specified, return the result modulo mod\n\nTime Complexity :  O(log(n))\nSpace Complexity : O(1)", "short_description": "Iterative version of binary exponentiation"}, "args": ["a", "n", "mod"], "annotated_arg_types": {"a": "int", "n": "int", "mod": "int"}, "returns": ["ans"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 25}, "source_code": "def power(a: int, n: int, mod: int=None):\n    \"\"\"\n    Iterative version of binary exponentiation\n\n    Calculate a ^ n\n    if mod is specified, return the result modulo mod\n\n    Time Complexity :  O(log(n))\n    Space Complexity : O(1)\n    \"\"\"\n    ans = 1\n    while n:\n        if n & 1:\n            ans = ans * a\n        a = a * a\n        if mod:\n            ans %= mod\n            a %= mod\n        n >>= 1\n    return ans"}, "power_recur": {"doc": {"long_description": "Calculate a ^ n\nif mod is specified, return the result modulo mod\n\nTime Complexity :  O(log(n))\nSpace Complexity : O(log(n))", "short_description": "Recursive version of binary exponentiation"}, "args": ["a", "n", "mod"], "annotated_arg_types": {"a": "int", "n": "int", "mod": "int"}, "returns": ["ans"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 49}, "calls": ["power.power_recur"], "store_vars_calls": {"ans": "power_recur"}, "source_code": "def power_recur(a: int, n: int, mod: int=None):\n    \"\"\"\n    Recursive version of binary exponentiation\n\n    Calculate a ^ n\n    if mod is specified, return the result modulo mod\n\n    Time Complexity :  O(log(n))\n    Space Complexity : O(log(n))\n    \"\"\"\n    if n == 0:\n        ans = 1\n    elif n == 1:\n        ans = a\n    else:\n        ans = power_recur(a, n // 2, mod)\n        ans = ans * ans\n        if n % 2:\n            ans = ans * a\n    if mod:\n        ans %= mod\n    return ans"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/factorial.py", "fileNameBase": "factorial", "extension": "py", "doc": {"short_description": "Calculates the factorial with the added functionality of calculating it modulo mod.", "full": "Calculates the factorial with the added functionality of calculating it modulo mod."}}, "functions": {"factorial": {"doc": {"long_description": "If mod is not None, then return (n! % mod)\nTime Complexity - O(n)", "short_description": "Calculates factorial iteratively."}, "args": ["n", "mod"], "returns": ["result", "1"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 20}, "calls": ["range", "ValueError", "isinstance"], "source_code": "def factorial(n, mod=None):\n    \"\"\"Calculates factorial iteratively.\n    If mod is not None, then return (n! % mod)\n    Time Complexity - O(n)\"\"\"\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and (not (isinstance(mod, int) and mod > 0)):\n        raise ValueError(\"'mod' must be a positive integer\")\n    result = 1\n    if n == 0:\n        return 1\n    for i in range(2, n + 1):\n        result *= i\n        if mod:\n            result %= mod\n    return result"}, "factorial_recur": {"doc": {"long_description": "If mod is not None, then return (n! % mod)\nTime Complexity - O(n)", "short_description": "Calculates factorial recursively."}, "args": ["n", "mod"], "returns": ["result", "1"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 36}, "calls": ["ValueError", "factorial.factorial", "isinstance"], "source_code": "def factorial_recur(n, mod=None):\n    \"\"\"Calculates factorial recursively.\n    If mod is not None, then return (n! % mod)\n    Time Complexity - O(n)\"\"\"\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and (not (isinstance(mod, int) and mod > 0)):\n        raise ValueError(\"'mod' must be a positive integer\")\n    if n == 0:\n        return 1\n    result = n * factorial(n - 1, mod)\n    if mod:\n        result %= mod\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/nth_digit.py", "fileNameBase": "nth_digit", "extension": "py"}, "functions": {"find_nth_digit": {"doc": {"long_description": "1. find the length of the number where the nth digit is from.\n2. find the actual number where the nth digit is from\n3. find the nth digit and return", "short_description": "find the nth digit of given number."}, "args": ["n"], "returns": ["int(s[(n - 1) % length])"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 18}, "calls": ["str", "int"], "store_vars_calls": {"s": "str"}, "source_code": "def find_nth_digit(n):\n    \"\"\"find the nth digit of given number.\n    1. find the length of the number where the nth digit is from.\n    2. find the actual number where the nth digit is from\n    3. find the nth digit and return\n    \"\"\"\n    length = 1\n    count = 9\n    start = 1\n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    start += (n - 1) / length\n    s = str(start)\n    return int(s[(n - 1) % length])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/__init__.py", "fileNameBase": "__init__", "extension": "py", "doc": {"short_description": "Collection of mathematical algorithms and functions.", "full": "Collection of mathematical algorithms and functions."}}, "dependencies": [{"from_module": "base_conversion", "import": "int_to_base", "type": "internal", "type_element": "function"}, {"from_module": "base_conversion", "import": "base_to_int", "type": "internal", "type_element": "function"}, {"from_module": "decimal_to_binary_ip", "import": "decimal_to_binary_util", "type": "internal", "type_element": "function"}, {"from_module": "decimal_to_binary_ip", "import": "decimal_to_binary_ip", "type": "internal", "type_element": "function"}, {"from_module": "euler_totient", "import": "euler_totient", "type": "internal", "type_element": "function"}, {"from_module": "extended_gcd", "import": "extended_gcd", "type": "internal", "type_element": "function"}, {"from_module": "factorial", "import": "factorial", "type": "internal", "type_element": "function"}, {"from_module": "factorial", "import": "factorial_recur", "type": "internal", "type_element": "function"}, {"from_module": "gcd", "import": "gcd", "type": "internal", "type_element": "function"}, {"from_module": "gcd", "import": "lcm", "type": "internal", "type_element": "function"}, {"from_module": "gcd", "import": "trailing_zero", "type": "internal", "type_element": "function"}, {"from_module": "gcd", "import": "gcd_bit", "type": "internal", "type_element": "function"}, {"from_module": "generate_strobogrammtic", "import": "gen_strobogrammatic", "type": "internal", "type_element": "function"}, {"from_module": "generate_strobogrammtic", "import": "helper", "type": "internal", "type_element": "function"}, {"from_module": "generate_strobogrammtic", "import": "strobogrammatic_in_range", "type": "internal", "type_element": "function"}, {"from_module": "generate_strobogrammtic", "import": "helper2", "type": "internal", "type_element": "function"}, {"from_module": "is_strobogrammatic", "import": "is_strobogrammatic", "type": "internal", "type_element": "function"}, {"from_module": "is_strobogrammatic", "import": "is_strobogrammatic2", "type": "internal", "type_element": "function"}, {"from_module": "modular_exponential", "import": "modular_exponential", "type": "internal", "type_element": "function"}, {"from_module": "next_perfect_square", "import": "find_next_square", "type": "internal", "type_element": "function"}, {"from_module": "next_perfect_square", "import": "find_next_square2", "type": "internal", "type_element": "function"}, {"from_module": "prime_check", "import": "prime_check", "type": "internal", "type_element": "function"}, {"from_module": "primes_sieve_of_eratosthenes", "import": "get_primes", "type": "internal", "type_element": "function"}, {"from_module": "pythagoras", "import": "pythagoras", "type": "internal", "type_element": "function"}, {"from_module": "rabin_miller", "import": "is_prime", "type": "internal", "type_element": "function"}, {"from_module": "rsa", "import": "generate_key", "type": "internal", "type_element": "function"}, {"from_module": "rsa", "import": "encrypt", "type": "internal", "type_element": "function"}, {"from_module": "rsa", "import": "decrypt", "type": "internal", "type_element": "function"}, {"from_module": "combination", "import": "combination", "type": "internal", "type_element": "function"}, {"from_module": "combination", "import": "combination_memo", "type": "internal", "type_element": "function"}, {"from_module": "cosine_similarity", "import": "_l2_distance", "type": "internal", "type_element": "function"}, {"from_module": "cosine_similarity", "import": "cosine_similarity", "type": "internal", "type_element": "function"}, {"from_module": "find_order_simple", "import": "find_order", "type": "internal", "type_element": "function"}, {"from_module": "find_primitive_root_simple", "import": "find_order", "type": "internal", "type_element": "function"}, {"from_module": "find_primitive_root_simple", "import": "euler_totient", "type": "internal", "type_element": "function"}, {"from_module": "find_primitive_root_simple", "import": "find_primitive_root", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "prime_check", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "find_order", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "euler_totient", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "find_primitive_root", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "alice_private_key", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "alice_public_key", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "bob_private_key", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "bob_public_key", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "alice_shared_key", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "bob_shared_key", "type": "internal", "type_element": "function"}, {"from_module": "diffie_hellman_key_exchange", "import": "diffie_hellman_key_exchange", "type": "internal", "type_element": "function"}, {"from_module": "num_digits", "import": "num_digits", "type": "internal", "type_element": "function"}, {"from_module": "power", "import": "power", "type": "internal", "type_element": "function"}, {"from_module": "power", "import": "power_recur", "type": "internal", "type_element": "function"}, {"from_module": "magic_number", "import": "magic_number", "type": "internal", "type_element": "function"}, {"from_module": "krishnamurthy_number", "import": "find_factorial", "type": "internal", "type_element": "function"}, {"from_module": "krishnamurthy_number", "import": "krishnamurthy_number", "type": "internal", "type_element": "function"}, {"from_module": "num_perfect_squares", "import": "num_perfect_squares", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/symmetry_group_cycle_index.py", "fileNameBase": "symmetry_group_cycle_index", "extension": "py", "doc": {"long_description": "is deeply rooted in counting the number of configurations\nof an object excluding those that are symmetric (in terms of permutations).\n\nFor example, the following problem can be solved as a direct\napplication of the cycle index polynomial of the symmetry\ngroup.\n\nNote: I came across this problem as a Google's foo.bar challenge at Level 5\nand solved it using a purely Group Theoretic approach. :)\n-----\n\nProblem:\n\nGiven positive integers\nw, h, and s,\ncompute the number of distinct 2D\ngrids of dimensions w x h that contain\nentries from {0, 1, ..., s-1}.\nNote that two grids are defined\nto be equivalent if one can be\nobtained from the other by\nswitching rows and columns\nsome number of times.\n\n-----\n\nApproach:\n\nCompute the cycle index (polynomials)\nof S_w, and S_h, i.e. the Symmetry\ngroup on w and h symbols respectively.\n\nCompute the product of the two\ncycle indices while combining two\nmonomials in such a way that\nfor any pair of cycles c1, and c2\nin the elements of S_w X S_h,\nthe resultant monomial contains\nterms of the form:\n$$ x_{lcm(|c1|, |c2|)}^{gcd(|c1|, |c2|)} $$\n\nReturn the specialization of\nthe product of cycle indices\nat x_i = s (for all the valid i).\n\n-----\n\nCode:\n\ndef solve(w, h, s):\n    s1 = get_cycle_index_sym(w)\n    s2 = get_cycle_index_sym(h)\n\n    result = cycle_product_for_two_polynomials(s1, s2, s)\n\n    return str(result)", "short_description": "The significance of the cycle index (polynomial) of symmetry group", "full": "The significance of the cycle index (polynomial) of symmetry group\nis deeply rooted in counting the number of configurations\nof an object excluding those that are symmetric (in terms of permutations).\n\nFor example, the following problem can be solved as a direct\napplication of the cycle index polynomial of the symmetry\ngroup.\n\nNote: I came across this problem as a Google's foo.bar challenge at Level 5\nand solved it using a purely Group Theoretic approach. :)\n-----\n\nProblem:\n\nGiven positive integers\nw, h, and s,\ncompute the number of distinct 2D\ngrids of dimensions w x h that contain\nentries from {0, 1, ..., s-1}.\nNote that two grids are defined\nto be equivalent if one can be\nobtained from the other by\nswitching rows and columns\nsome number of times.\n\n-----\n\nApproach:\n\nCompute the cycle index (polynomials)\nof S_w, and S_h, i.e. the Symmetry\ngroup on w and h symbols respectively.\n\nCompute the product of the two\ncycle indices while combining two\nmonomials in such a way that\nfor any pair of cycles c1, and c2\nin the elements of S_w X S_h,\nthe resultant monomial contains\nterms of the form:\n$$ x_{lcm(|c1|, |c2|)}^{gcd(|c1|, |c2|)} $$\n\nReturn the specialization of\nthe product of cycle indices\nat x_i = s (for all the valid i).\n\n-----\n\nCode:\n\ndef solve(w, h, s):\n    s1 = get_cycle_index_sym(w)\n    s2 = get_cycle_index_sym(h)\n\n    result = cycle_product_for_two_polynomials(s1, s2, s)\n\n    return str(result)"}}, "dependencies": [{"from_module": "fractions", "import": "Fraction", "type": "external", "type_element": "module"}, {"from_module": "typing", "import": "Dict", "type": "external", "type_element": "module"}, {"from_module": "typing", "import": "Union", "type": "external", "type_element": "module"}, {"from_module": "polynomial", "import": "Monomial", "type": "internal", "type_element": "module"}, {"from_module": "polynomial", "import": "Polynomial", "type": "internal", "type_element": "module"}, {"from_module": "gcd", "import": "lcm", "type": "internal", "type_element": "module"}], "functions": {"cycle_product": {"doc": {"long_description": "cycle index of a symmetry group),\ncompute the resultant monomial\nin the cartesian product\ncorresponding to their merging.", "short_description": "Given two monomials (from the"}, "args": ["m1", "m2"], "annotated_arg_types": {"m1": "Monomial", "m2": "Monomial"}, "annotated_return_type": "Monomial", "returns": ["Monomial(result_variables, Fraction(m1.coeff * m2.coeff, 1))"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 89}, "calls": ["dict", "polynomial.Monomial", "isinstance", "fractions.Fraction", "gcd.lcm"], "store_vars_calls": {"result_variables": "dict", "k": "lcm"}, "source_code": "def cycle_product(m1: Monomial, m2: Monomial) -> Monomial:\n    \"\"\"\n    Given two monomials (from the\n    cycle index of a symmetry group),\n    compute the resultant monomial\n    in the cartesian product\n    corresponding to their merging.\n    \"\"\"\n    assert isinstance(m1, Monomial) and isinstance(m2, Monomial)\n    A = m1.variables\n    B = m2.variables\n    result_variables = dict()\n    for i in A:\n        for j in B:\n            k = lcm(i, j)\n            g = i * j // k\n            if k in result_variables:\n                result_variables[k] += A[i] * B[j] * g\n            else:\n                result_variables[k] = A[i] * B[j] * g\n    return Monomial(result_variables, Fraction(m1.coeff * m2.coeff, 1))"}, "cycle_product_for_two_polynomials": {"doc": {"long_description": "given cycle indices p1,\nand p2 and evaluate it at q.", "short_description": "Compute the product of"}, "args": ["p1", "p2", "q"], "annotated_arg_types": {"p1": "Polynomial", "p2": "Polynomial", "q": "Union[float, int, Fraction]"}, "annotated_return_type": "Union[float, int, Fraction]", "returns": ["ans"], "min_max_lineno": {"min_lineno": 91, "max_lineno": 103}, "calls": ["fractions.Fraction", "cycle_product().substitute", "symmetry_group_cycle_index.cycle_product"], "store_vars_calls": {"ans": "Fraction"}, "source_code": "def cycle_product_for_two_polynomials(p1: Polynomial, p2: Polynomial, q: Union[float, int, Fraction]) -> Union[float, int, Fraction]:\n    \"\"\"\n    Compute the product of\n    given cycle indices p1,\n    and p2 and evaluate it at q.\n    \"\"\"\n    ans = Fraction(0, 1)\n    for m1 in p1.monomials:\n        for m2 in p2.monomials:\n            ans += cycle_product(m1, m2).substitute(q)\n    return ans"}, "cycle_index_sym_helper": {"doc": {"long_description": "of the cycle index.\n\nThe recurrence is given in:\nhttps://en.wikipedia.org/wiki/Cycle_index#Symmetric_group_Sn", "short_description": "A helper for the dp-style evaluation"}, "args": ["n", "memo"], "annotated_arg_types": {"n": "int", "memo": "Dict[int, Polynomial]"}, "annotated_return_type": "Polynomial", "returns": ["memo[n]", "memo[n]"], "min_max_lineno": {"min_lineno": 105, "max_lineno": 122}, "calls": ["polynomial.Polynomial", "range", "fractions.Fraction", "ans.__add__.__add__", "polynomial.Monomial", "symmetry_group_cycle_index.cycle_index_sym_helper"], "store_vars_calls": {"ans": "ans.__add__"}, "source_code": "def cycle_index_sym_helper(n: int, memo: Dict[int, Polynomial]) -> Polynomial:\n    \"\"\"\n    A helper for the dp-style evaluation\n    of the cycle index.\n\n    The recurrence is given in:\n    https://en.wikipedia.org/wiki/Cycle_index#Symmetric_group_Sn\n\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    ans = Polynomial([Monomial({}, Fraction(0, 1))])\n    for t in range(1, n + 1):\n        ans = ans.__add__(Polynomial([Monomial({t: 1}, Fraction(1, 1))]) * cycle_index_sym_helper(n - t, memo))\n    ans *= Fraction(1, n)\n    memo[n] = ans\n    return memo[n]"}, "get_cycle_index_sym": {"doc": {"long_description": "of S_n, i.e. the symmetry\ngroup of n symbols.", "short_description": "Compute the cycle index"}, "args": ["n"], "annotated_arg_types": {"n": "int"}, "annotated_return_type": "Polynomial", "returns": ["result"], "min_max_lineno": {"min_lineno": 124, "max_lineno": 160}, "calls": ["symmetry_group_cycle_index.cycle_index_sym_helper", "ValueError", "polynomial.Polynomial", "polynomial.Monomial", "fractions.Fraction"], "store_vars_calls": {"result": "cycle_index_sym_helper"}, "source_code": "def get_cycle_index_sym(n: int) -> Polynomial:\n    \"\"\"\n    Compute the cycle index\n    of S_n, i.e. the symmetry\n    group of n symbols.\n\n    \"\"\"\n    if n < 0:\n        raise ValueError('n should be a non-negative integer.')\n    memo = {0: Polynomial([Monomial({}, Fraction(1, 1))]), 1: Polynomial([Monomial({1: 1}, Fraction(1, 1))]), 2: Polynomial([Monomial({1: 2}, Fraction(1, 2)), Monomial({2: 1}, Fraction(1, 2))]), 3: Polynomial([Monomial({1: 3}, Fraction(1, 6)), Monomial({1: 1, 2: 1}, Fraction(1, 2)), Monomial({3: 1}, Fraction(1, 3))]), 4: Polynomial([Monomial({1: 4}, Fraction(1, 24)), Monomial({2: 1, 1: 2}, Fraction(1, 4)), Monomial({3: 1, 1: 1}, Fraction(1, 3)), Monomial({2: 2}, Fraction(1, 8)), Monomial({4: 1}, Fraction(1, 4))])}\n    result = cycle_index_sym_helper(n, memo)\n    return result"}}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/find_primitive_root_simple.py", "fileNameBase": "find_primitive_root_simple", "extension": "py", "doc": {"short_description": "Function to find the primitive root of a number.", "full": "Function to find the primitive root of a number."}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"find_order": {"doc": {"long_description": "Time complexity O(nlog(n))", "short_description": "Find order for positive integer n and given integer a that satisfies gcd(a, n) = 1."}, "args": ["a", "n"], "returns": ["-1", "1", "-1", "i"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 27}, "calls": ["range", "math.gcd", "print", "pow"], "source_code": "def find_order(a, n):\n    \"\"\"\n    Find order for positive integer n and given integer a that satisfies gcd(a, n) = 1.\n    Time complexity O(nlog(n))\n    \"\"\"\n    if (a == 1) & (n == 1):\n        return 1\n    if math.gcd(a, n) != 1:\n        print('a and n should be relative prime!')\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1"}, "euler_totient": {"doc": {"long_description": "Time Complexity: O(sqrt(n)).", "short_description": "Euler's totient function or Phi function."}, "args": ["n"], "returns": ["result"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 47}, "calls": ["range", "int"], "source_code": "def euler_totient(n):\n    \"\"\"Euler's totient function or Phi function.\n    Time Complexity: O(sqrt(n)).\"\"\"\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result"}, "find_primitive_root": {"args": ["n"], "returns": ["p_root_list", "[0]"], "min_max_lineno": {"min_lineno": 54, "max_lineno": 68}, "calls": ["find_primitive_root_simple.euler_totient", "range", "math.gcd", "find_primitive_root_simple.find_order", "p_root_list.append"], "store_vars_calls": {"phi": "euler_totient", "order": "find_order"}, "source_code": "def find_primitive_root(n):\n    if n == 1:\n        return [0]\n    phi = euler_totient(n)\n    p_root_list = []\n    ' It will return every primitive roots of n. '\n    for i in range(1, n):\n        if math.gcd(i, n) == 1:\n            order = find_order(i, n)\n            if order == phi:\n                p_root_list.append(i)\n    return p_root_list"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/diffie_hellman_key_exchange.py", "fileNameBase": "diffie_hellman_key_exchange", "extension": "py", "doc": {"short_description": "Algorithms for performing diffie-hellman key exchange.", "full": "Algorithms for performing diffie-hellman key exchange."}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}, {"from_module": "random", "import": "randint", "type": "external", "type_element": "module"}], "functions": {"prime_check": {"doc": {"long_description": "Else return False.", "short_description": "Return True if num is a prime number"}, "args": ["num"], "returns": ["True", "False", "True", "False", "False"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 29}, "source_code": "def prime_check(num):\n    \"\"\"Return True if num is a prime number\n    Else return False.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num == 2 or num == 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    j = 5\n    while j * j <= num:\n        if num % j == 0 or num % (j + 2) == 0:\n            return False\n        j += 6\n    return True"}, "find_order": {"args": ["a", "n"], "returns": ["-1", "1", "-1", "i"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 48}, "calls": ["range", "math.gcd", "print", "pow"], "source_code": "def find_order(a, n):\n    if (a == 1) & (n == 1):\n        return 1\n    if math.gcd(a, n) != 1:\n        print('a and n should be relative prime!')\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1"}, "euler_totient": {"doc": {"long_description": "Time Complexity: O(sqrt(n)).", "short_description": "Euler's totient function or Phi function."}, "args": ["n"], "returns": ["result"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 69}, "calls": ["range", "int"], "source_code": "def euler_totient(n):\n    \"\"\"Euler's totient function or Phi function.\n    Time Complexity: O(sqrt(n)).\"\"\"\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result"}, "find_primitive_root": {"doc": {"short_description": "Returns all primitive roots of n. "}, "args": ["n"], "returns": ["p_root_list", "[0]"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 92}, "calls": ["diffie_hellman_key_exchange.euler_totient", "range", "diffie_hellman_key_exchange.find_order", "math.gcd", "p_root_list.append"], "store_vars_calls": {"phi": "euler_totient", "order": "find_order"}, "source_code": "def find_primitive_root(n):\n    \"\"\" Returns all primitive roots of n. \"\"\"\n    if n == 1:\n        return [0]\n    phi = euler_totient(n)\n    p_root_list = []\n    for i in range(1, n):\n        if math.gcd(i, n) != 1:\n            continue\n        order = find_order(i, n)\n        if order == phi:\n            p_root_list.append(i)\n    return p_root_list"}, "alice_private_key": {"doc": {"long_description": "in the range of 1 ~ p-1.\nThis must be kept in secret", "short_description": "Alice determine her private key"}, "args": ["p"], "returns": ["randint(1, p - 1)"], "min_max_lineno": {"min_lineno": 106, "max_lineno": 111}, "calls": ["random.randint"], "source_code": "def alice_private_key(p):\n    \"\"\"Alice determine her private key\n    in the range of 1 ~ p-1.\n    This must be kept in secret\"\"\"\n    return randint(1, p - 1)"}, "alice_public_key": {"doc": {"long_description": "with her private key.\nThis is open to public", "short_description": "Alice calculate her public key"}, "args": ["a_pr_k", "a", "p"], "returns": ["pow(a, a_pr_k) % p"], "min_max_lineno": {"min_lineno": 113, "max_lineno": 118}, "calls": ["pow"], "source_code": "def alice_public_key(a_pr_k, a, p):\n    \"\"\"Alice calculate her public key\n    with her private key.\n    This is open to public\"\"\"\n    return pow(a, a_pr_k) % p"}, "bob_private_key": {"doc": {"long_description": "in the range of 1 ~ p-1.\nThis must be kept in secret", "short_description": "Bob determine his private key"}, "args": ["p"], "returns": ["randint(1, p - 1)"], "min_max_lineno": {"min_lineno": 120, "max_lineno": 125}, "calls": ["random.randint"], "source_code": "def bob_private_key(p):\n    \"\"\"Bob determine his private key\n    in the range of 1 ~ p-1.\n    This must be kept in secret\"\"\"\n    return randint(1, p - 1)"}, "bob_public_key": {"doc": {"long_description": "with his private key.\nThis is open to public", "short_description": "Bob calculate his public key"}, "args": ["b_pr_k", "a", "p"], "returns": ["pow(a, b_pr_k) % p"], "min_max_lineno": {"min_lineno": 127, "max_lineno": 132}, "calls": ["pow"], "source_code": "def bob_public_key(b_pr_k, a, p):\n    \"\"\"Bob calculate his public key\n    with his private key.\n    This is open to public\"\"\"\n    return pow(a, b_pr_k) % p"}, "alice_shared_key": {"doc": {"long_description": "with her private key and Bob's public key.\nThis must be kept in secret", "short_description": "Alice calculate secret key shared with Bob,"}, "args": ["b_pu_k", "a_pr_k", "p"], "returns": ["pow(b_pu_k, a_pr_k) % p"], "min_max_lineno": {"min_lineno": 134, "max_lineno": 139}, "calls": ["pow"], "source_code": "def alice_shared_key(b_pu_k, a_pr_k, p):\n    \"\"\" Alice calculate secret key shared with Bob,\n    with her private key and Bob's public key.\n    This must be kept in secret\"\"\"\n    return pow(b_pu_k, a_pr_k) % p"}, "bob_shared_key": {"doc": {"long_description": "with his private key and Alice's public key.\nThis must be kept in secret", "short_description": "Bob calculate secret key shared with Alice,"}, "args": ["a_pu_k", "b_pr_k", "p"], "returns": ["pow(a_pu_k, b_pr_k) % p"], "min_max_lineno": {"min_lineno": 141, "max_lineno": 146}, "calls": ["pow"], "source_code": "def bob_shared_key(a_pu_k, b_pr_k, p):\n    \"\"\" Bob calculate secret key shared with Alice,\n    with his private key and Alice's public key.\n    This must be kept in secret\"\"\"\n    return pow(a_pu_k, b_pr_k) % p"}, "diffie_hellman_key_exchange": {"doc": {"short_description": "Perform diffie-helmman key exchange. "}, "args": ["a", "p", "option"], "returns": ["a_sh_k == b_sh_k", "False", "False"], "min_max_lineno": {"min_lineno": 148, "max_lineno": 185}, "calls": ["diffie_hellman_key_exchange.alice_private_key", "diffie_hellman_key_exchange.alice_public_key", "diffie_hellman_key_exchange.bob_private_key", "diffie_hellman_key_exchange.bob_public_key", "diffie_hellman_key_exchange.alice_shared_key", "diffie_hellman_key_exchange.bob_shared_key", "print", "diffie_hellman_key_exchange.prime_check", "diffie_hellman_key_exchange.find_primitive_root", "find_primitive_root.index"], "store_vars_calls": {"a_pr_k": "alice_private_key", "a_pu_k": "alice_public_key", "b_pr_k": "bob_private_key", "b_pu_k": "bob_public_key", "a_sh_k": "alice_shared_key", "b_sh_k": "bob_shared_key", "p_root_list": "find_primitive_root"}, "source_code": "def diffie_hellman_key_exchange(a, p, option=None):\n    \"\"\" Perform diffie-helmman key exchange. \"\"\"\n    if option is not None:\n        option = 1\n    if prime_check(p) is False:\n        print(f'{p} is not a prime number')\n        return False\n    try:\n        p_root_list = find_primitive_root(p)\n        p_root_list.index(a)\n    except ValueError:\n        print(f'{a} is not a primitive root of {p}')\n        return False\n    a_pr_k = alice_private_key(p)\n    a_pu_k = alice_public_key(a_pr_k, a, p)\n    b_pr_k = bob_private_key(p)\n    b_pu_k = bob_public_key(b_pr_k, a, p)\n    if option == 1:\n        print(f\"Alice's private key: {a_pr_k}\")\n        print(f\"Alice's public key: {a_pu_k}\")\n        print(f\"Bob's private key: {b_pr_k}\")\n        print(f\"Bob's public key: {b_pu_k}\")\n    a_sh_k = alice_shared_key(b_pu_k, a_pr_k, p)\n    b_sh_k = bob_shared_key(a_pu_k, b_pr_k, p)\n    print(f'Shared key calculated by Alice = {a_sh_k}')\n    print(f'Shared key calculated by Bob = {b_sh_k}')\n    return a_sh_k == b_sh_k"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/modular_inverse.py", "fileNameBase": "modular_inverse", "extension": "py"}, "functions": {"extended_gcd": {"doc": {"long_description": "Return s, t, g\nsuch that a * s + b * t = GCD(a, b)\nand s and t are co-prime.", "short_description": "Extended GCD algorithm."}, "args": ["a", "b"], "annotated_arg_types": {"a": "int", "b": "int"}, "annotated_return_type": "[int, int, int]", "returns": [["old_s", "old_t", "old_r"]], "min_max_lineno": {"min_lineno": 4, "max_lineno": 23}, "source_code": "def extended_gcd(a: int, b: int) -> [int, int, int]:\n    \"\"\"Extended GCD algorithm.\n    Return s, t, g\n    such that a * s + b * t = GCD(a, b)\n    and s and t are co-prime.\n    \"\"\"\n    (old_s, s) = (1, 0)\n    (old_t, t) = (0, 1)\n    (old_r, r) = (a, b)\n    while r != 0:\n        quotient = old_r // r\n        (old_r, r) = (r, old_r - quotient * r)\n        (old_s, s) = (s, old_s - quotient * s)\n        (old_t, t) = (t, old_t - quotient * t)\n    return (old_s, old_t, old_r)"}, "modular_inverse": {"doc": {"long_description": "a and m must be coprime", "short_description": "Returns x such that a * x = 1 (mod m)"}, "args": ["a", "m"], "annotated_arg_types": {"a": "int", "m": "int"}, "annotated_return_type": "int", "returns": ["s % m"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 35}, "calls": ["modular_inverse.extended_gcd", "ValueError"], "source_code": "def modular_inverse(a: int, m: int) -> int:\n    \"\"\"\n    Returns x such that a * x = 1 (mod m)\n    a and m must be coprime\n    \"\"\"\n    (s, _, g) = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError('a and m must be coprime')\n    return s % m"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/sqrt_precision_factor.py", "fileNameBase": "sqrt_precision_factor", "extension": "py", "doc": {"long_description": "it produces an output\nwith a maximum error P from the actual square root of N.\n\nExample:\nGiven N = 5 and P = 0.001, can produce output x such that\n2.235 < x < 2.237. Actual square root of 5 being 2.236.", "short_description": "Given a positive integer N and a precision factor P,", "full": "Given a positive integer N and a precision factor P,\nit produces an output\nwith a maximum error P from the actual square root of N.\n\nExample:\nGiven N = 5 and P = 0.001, can produce output x such that\n2.235 < x < 2.237. Actual square root of 5 being 2.236."}}, "functions": {"square_root": {"doc": {"short_description": "Return square root of n, with maximum absolute error epsilon"}, "args": ["n", "epsilon"], "returns": ["guess"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 20}, "calls": ["abs"], "source_code": "def square_root(n, epsilon=0.001):\n    \"\"\"Return square root of n, with maximum absolute error epsilon\"\"\"\n    guess = n / 2\n    while abs(guess * guess - n) > epsilon:\n        guess = (guess + n / guess) / 2\n    return guess"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/krishnamurthy_number.py", "fileNameBase": "krishnamurthy_number", "extension": "py", "doc": {"long_description": "number itself.\n\nThe following are some examples of Krishnamurthy numbers:\n\n\"145\" is a Krishnamurthy Number because,\n1! + 4! + 5! = 1 + 24 + 120 = 145\n\n\"40585\" is also a Krishnamurthy Number.\n4! + 0! + 5! + 8! + 5! = 40585\n\n\"357\" or \"25965\" is NOT a Krishnamurthy Number\n3! + 5! + 7! = 6 + 120 + 5040 != 357\n\nThe following function will check if a number is a Krishnamurthy Number or not and return a\nboolean value.", "short_description": "A Krishnamurthy number is a number whose sum total of the factorials of each digit is equal to the", "full": "A Krishnamurthy number is a number whose sum total of the factorials of each digit is equal to the\nnumber itself.\n\nThe following are some examples of Krishnamurthy numbers:\n\n\"145\" is a Krishnamurthy Number because,\n1! + 4! + 5! = 1 + 24 + 120 = 145\n\n\"40585\" is also a Krishnamurthy Number.\n4! + 0! + 5! + 8! + 5! = 40585\n\n\"357\" or \"25965\" is NOT a Krishnamurthy Number\n3! + 5! + 7! = 6 + 120 + 5040 != 357\n\nThe following function will check if a number is a Krishnamurthy Number or not and return a\nboolean value."}}, "functions": {"find_factorial": {"doc": {"short_description": "Calculates the factorial of a given number n "}, "args": ["n"], "returns": ["fact"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 28}, "source_code": "def find_factorial(n):\n    \"\"\" Calculates the factorial of a given number n \"\"\"\n    fact = 1\n    while n != 0:\n        fact *= n\n        n -= 1\n    return fact"}, "krishnamurthy_number": {"args": ["n"], "returns": ["sum_of_digits == n", "False"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 47}, "calls": ["krishnamurthy_number.find_factorial"], "source_code": "def krishnamurthy_number(n):\n    if n == 0:\n        return False\n    sum_of_digits = 0\n    temp = n\n    while temp != 0:\n        sum_of_digits += find_factorial(temp % 10)\n        temp //= 10\n    return sum_of_digits == n"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/fft.py", "fileNameBase": "fft", "extension": "py", "doc": {"long_description": "Input: an array of complex values which has a size of N, where N is an integer power of 2\nOutput: an array of complex values which is the discrete fourier transform of the input\n\nExample 1\nInput: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j]\nOutput: [8+8j, 2j, 2-2j, -2+0j]\n\n\nPseudocode: https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm", "short_description": "Implementation of the Cooley-Tukey, which is the most common FFT algorithm.", "full": "Implementation of the Cooley-Tukey, which is the most common FFT algorithm.\n\nInput: an array of complex values which has a size of N, where N is an integer power of 2\nOutput: an array of complex values which is the discrete fourier transform of the input\n\nExample 1\nInput: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j]\nOutput: [8+8j, 2j, 2-2j, -2+0j]\n\n\nPseudocode: https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm"}}, "dependencies": [{"from_module": "cmath", "import": "exp", "type": "external", "type_element": "module"}, {"from_module": "cmath", "import": "pi", "type": "external", "type_element": "module"}], "functions": {"fft": {"doc": {"short_description": "Recursive implementation of the Cooley-Tukey"}, "args": ["x"], "returns": ["y", "x"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 33}, "calls": ["len", "fft.fft", "range", "cmath.exp"], "store_vars_calls": {"N": "len", "even": "fft", "odd": "fft"}, "source_code": "def fft(x):\n    \"\"\" Recursive implementation of the Cooley-Tukey\"\"\"\n    N = len(x)\n    if N == 1:\n        return x\n    even = fft(x[0::2])\n    odd = fft(x[1::2])\n    y = [0 for i in range(N)]\n    for k in range(N // 2):\n        q = exp(-2j * pi * k / N) * odd[k]\n        y[k] = even[k] + q\n        y[k + N // 2] = even[k] - q\n    return y"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/is_strobogrammatic.py", "fileNameBase": "is_strobogrammatic", "extension": "py", "doc": {"long_description": "the same when rotated 180 degrees (looked at upside down).\n\nWrite a function to determine if a number is strobogrammatic.\nThe number is represented as a string.\n\nFor example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic.", "short_description": "A strobogrammatic number is a number that looks", "full": "A strobogrammatic number is a number that looks\nthe same when rotated 180 degrees (looked at upside down).\n\nWrite a function to determine if a number is strobogrammatic.\nThe number is represented as a string.\n\nFor example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic."}}, "functions": {"is_strobogrammatic": {"args": ["num"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 26}, "calls": ["len", "comb.find"], "source_code": "def is_strobogrammatic(num):\n    \"\"\"\n    :type num: str\n    :rtype: bool\n    \"\"\"\n    comb = '00 11 88 69 96'\n    i = 0\n    j = len(num) - 1\n    while i <= j:\n        if comb.find(num[i] + num[j]) == -1:\n            return False\n        i += 1\n        j -= 1\n    return True"}, "is_strobogrammatic2": {"doc": {"short_description": "Another implementation."}, "args": ["num"], "annotated_arg_types": {"num": "str"}, "returns": ["num == num[::-1].replace('6', '#').replace('9', '6').replace('#', '9')"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 31}, "calls": ["num[].replace().replace().replace", "num[].replace().replace", "num[].replace"], "source_code": "def is_strobogrammatic2(num: str):\n    \"\"\"Another implementation.\"\"\"\n    return num == num[::-1].replace('6', '#').replace('9', '6').replace('#', '9')"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/chinese_remainder_theorem.py", "fileNameBase": "chinese_remainder_theorem", "extension": "py", "doc": {"short_description": "Solves system of equations using the chinese remainder theorem if possible.", "full": "Solves system of equations using the chinese remainder theorem if possible."}}, "dependencies": [{"from_module": "typing", "import": "List", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths.gcd", "import": "gcd", "type": "external", "type_element": "module"}], "functions": {"solve_chinese_remainder": {"doc": {"long_description": "for a system of equations.\nThe system of equations has the form:\nx % nums[0] = rems[0]\nx % nums[1] = rems[1]\n...\nx % nums[k - 1] = rems[k - 1]\nWhere k is the number of elements in nums and rems, k > 0.\nAll numbers in nums needs to be pariwise coprime otherwise an exception is raised\nreturns x: the smallest value for x that satisfies the system of equations", "short_description": "Computes the smallest x that satisfies the chinese remainder theorem"}, "args": ["nums", "rems"], "annotated_arg_types": {"nums": "List[int]", "rems": "List[int]"}, "returns": ["x"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 40}, "calls": ["len", "Exception", "chinese_remainder_theorem._check_coprime"], "store_vars_calls": {"k": "len"}, "source_code": "def solve_chinese_remainder(nums: List[int], rems: List[int]):\n    \"\"\"\n    Computes the smallest x that satisfies the chinese remainder theorem\n    for a system of equations.\n    The system of equations has the form:\n    x % nums[0] = rems[0]\n    x % nums[1] = rems[1]\n    ...\n    x % nums[k - 1] = rems[k - 1]\n    Where k is the number of elements in nums and rems, k > 0.\n    All numbers in nums needs to be pariwise coprime otherwise an exception is raised\n    returns x: the smallest value for x that satisfies the system of equations\n    \"\"\"\n    if not len(nums) == len(rems):\n        raise Exception('nums and rems should have equal length')\n    if not len(nums) > 0:\n        raise Exception('Lists nums and rems need to contain at least one element')\n    for num in nums:\n        if not num > 1:\n            raise Exception('All numbers in nums needs to be > 1')\n    if not _check_coprime(nums):\n        raise Exception('All pairs of numbers in nums are not coprime')\n    k = len(nums)\n    x = 1\n    while True:\n        i = 0\n        while i < k:\n            if x % nums[i] != rems[i]:\n                break\n            i += 1\n        if i == k:\n            return x\n        x += 1"}, "_check_coprime": {"args": ["list_to_check"], "annotated_arg_types": {"list_to_check": "List[int]"}, "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 47}, "calls": ["enumerate", "algorithms.maths.gcd.gcd"], "source_code": "def _check_coprime(list_to_check: List[int]):\n    for (ind, num) in enumerate(list_to_check):\n        for num2 in list_to_check[ind + 1:]:\n            if gcd(num, num2) != 1:\n                return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/decimal_to_binary_ip.py", "fileNameBase": "decimal_to_binary_ip", "extension": "py", "doc": {"long_description": "binary representation. For example,\ndecimal_to_binary(255.0.0.5) returns 11111111.00000000.00000000.00000101\naccepts string\nreturns string", "short_description": "Given an ip address in dotted-decimal representation, determine the", "full": "Given an ip address in dotted-decimal representation, determine the\nbinary representation. For example,\ndecimal_to_binary(255.0.0.5) returns 11111111.00000000.00000000.00000101\naccepts string\nreturns string"}}, "functions": {"decimal_to_binary_util": {"doc": {"short_description": "Convert 8-bit decimal number to binary representation"}, "args": ["val"], "returns": ["binary_rep"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 26}, "calls": ["int", "str"], "store_vars_calls": {"val": "int"}, "source_code": "def decimal_to_binary_util(val):\n    \"\"\"\n    Convert 8-bit decimal number to binary representation\n    :type val: str\n    :rtype: str\n    \"\"\"\n    bits = [128, 64, 32, 16, 8, 4, 2, 1]\n    val = int(val)\n    binary_rep = ''\n    for bit in bits:\n        if val >= bit:\n            binary_rep += str(1)\n            val -= bit\n        else:\n            binary_rep += str(0)\n    return binary_rep"}, "decimal_to_binary_ip": {"doc": {"short_description": "Convert dotted-decimal ip address to binary representation with help of decimal_to_binary_util"}, "args": ["ip"], "returns": ["'.'.join(binary_list)"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 36}, "calls": ["ip.split", "binary_list.append", "decimal_to_binary_ip.decimal_to_binary_util"], "store_vars_calls": {"values": "ip.split"}, "source_code": "def decimal_to_binary_ip(ip):\n    \"\"\"\n    Convert dotted-decimal ip address to binary representation with help of decimal_to_binary_util\n    \"\"\"\n    values = ip.split('.')\n    binary_list = []\n    for val in values:\n        binary_list.append(decimal_to_binary_util(val))\n    return '.'.join(binary_list)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/euler_totient.py", "fileNameBase": "euler_totient", "extension": "py", "doc": {"long_description": "counts the number of integers between 1 and n inclusive,\nwhich are coprime to n.\n(Two numbers are coprime if their greatest common divisor (GCD) equals 1).", "short_description": "Euler's totient function, also known as phi-function \u03d5(n),", "full": "Euler's totient function, also known as phi-function \u03d5(n),\ncounts the number of integers between 1 and n inclusive,\nwhich are coprime to n.\n(Two numbers are coprime if their greatest common divisor (GCD) equals 1)."}}, "functions": {"euler_totient": {"doc": {"long_description": "Time Complexity: O(sqrt(n)).", "short_description": "Euler's totient function or Phi function."}, "args": ["n"], "returns": ["result"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 19}, "calls": ["range", "int"], "source_code": "def euler_totient(n):\n    \"\"\"Euler's totient function or Phi function.\n    Time Complexity: O(sqrt(n)).\"\"\"\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/modular_exponential.py", "fileNameBase": "modular_exponential", "extension": "py"}, "functions": {"modular_exponential": {"doc": {"long_description": "Time complexity - O(log n)\nUse similar to Python in-built function pow.", "short_description": "Computes (base ^ exponent) % mod."}, "args": ["base", "exponent", "mod"], "returns": ["result"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 19}, "calls": ["ValueError"], "source_code": "def modular_exponential(base, exponent, mod):\n    \"\"\"Computes (base ^ exponent) % mod.\n    Time complexity - O(log n)\n    Use similar to Python in-built function pow.\"\"\"\n    if exponent < 0:\n        raise ValueError('Exponent must be positive.')\n    base %= mod\n    result = 1\n    while exponent > 0:\n        if exponent & 1:\n            result = result * base % mod\n        exponent = exponent >> 1\n        base = base * base % mod\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/generate_strobogrammtic.py", "fileNameBase": "generate_strobogrammtic", "extension": "py", "doc": {"long_description": "the same when rotated 180 degrees (looked at upside down).\n\nFind all strobogrammatic numbers that are of length = n.\n\nFor example,\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].", "short_description": "A strobogrammatic number is a number that looks", "full": "A strobogrammatic number is a number that looks\nthe same when rotated 180 degrees (looked at upside down).\n\nFind all strobogrammatic numbers that are of length = n.\n\nFor example,\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"]."}}, "functions": {"gen_strobogrammatic": {"doc": {"short_description": "Given n, generate all strobogrammatic numbers of length n."}, "args": ["n"], "returns": ["helper(n, n)"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 18}, "calls": ["generate_strobogrammtic.helper"], "source_code": "def gen_strobogrammatic(n):\n    \"\"\"\n    Given n, generate all strobogrammatic numbers of length n.\n    :type n: int\n    :rtype: List[str]\n    \"\"\"\n    return helper(n, n)"}, "helper": {"args": ["n", "length"], "returns": ["result", "['']", "['1', '0', '8']"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 34}, "calls": ["generate_strobogrammtic.helper", "result.append"], "store_vars_calls": {"middles": "helper"}, "source_code": "def helper(n, length):\n    if n == 0:\n        return ['']\n    if n == 1:\n        return ['1', '0', '8']\n    middles = helper(n - 2, length)\n    result = []\n    for middle in middles:\n        if n != length:\n            result.append('0' + middle + '0')\n        result.append('8' + middle + '8')\n        result.append('1' + middle + '1')\n        result.append('9' + middle + '6')\n        result.append('6' + middle + '9')\n    return result"}, "strobogrammatic_in_range": {"args": ["low", "high"], "returns": ["count"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 54}, "calls": ["len", "range", "res.extend", "generate_strobogrammtic.helper2", "int"], "store_vars_calls": {"low_len": "len", "high_len": "len"}, "source_code": "def strobogrammatic_in_range(low, high):\n    \"\"\"\n    :type low: str\n    :type high: str\n    :rtype: int\n    \"\"\"\n    res = []\n    count = 0\n    low_len = len(low)\n    high_len = len(high)\n    for i in range(low_len, high_len + 1):\n        res.extend(helper2(i, i))\n    for perm in res:\n        if len(perm) == low_len and int(perm) < int(low):\n            continue\n        if len(perm) == high_len and int(perm) > int(high):\n            continue\n        count += 1\n    return count"}, "helper2": {"args": ["n", "length"], "returns": ["res", "['']", "['0', '8', '1']"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 70}, "calls": ["generate_strobogrammtic.helper", "res.append"], "store_vars_calls": {"mids": "helper"}, "source_code": "def helper2(n, length):\n    if n == 0:\n        return ['']\n    if n == 1:\n        return ['0', '8', '1']\n    mids = helper(n - 2, length)\n    res = []\n    for mid in mids:\n        if n != length:\n            res.append('0' + mid + '0')\n        res.append('1' + mid + '1')\n        res.append('6' + mid + '9')\n        res.append('9' + mid + '6')\n        res.append('8' + mid + '8')\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/summing_digits.py", "fileNameBase": "summing_digits", "extension": "py", "doc": {"long_description": "The number 89 is the first integer with more than one digit whose digits when raised up to\nconsecutive powers give the same number. For example, 89 = 8**1 + 9**2 gives the number 89.\n\nThe next number after 89 with this property is 135 = 1**1 + 3**2 + 5**3 = 135.\n\nWrite a function that returns a list of numbers with the above property. The function will\nreceive range as parameter.", "short_description": "Recently, I encountered an interview question whose description was as below:", "full": "Recently, I encountered an interview question whose description was as below:\n\nThe number 89 is the first integer with more than one digit whose digits when raised up to\nconsecutive powers give the same number. For example, 89 = 8**1 + 9**2 gives the number 89.\n\nThe next number after 89 with this property is 135 = 1**1 + 3**2 + 5**3 = 135.\n\nWrite a function that returns a list of numbers with the above property. The function will\nreceive range as parameter."}}, "functions": {"sum_dig_pow": {"args": ["low", "high"], "returns": ["result"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 30}, "calls": ["range", "str", "list", "map", "result.append"], "store_vars_calls": {"number_as_string": "str", "tokens": "list"}, "source_code": "def sum_dig_pow(low, high):\n    result = []\n    for number in range(low, high + 1):\n        exponent = 1\n        summation = 0\n        number_as_string = str(number)\n        tokens = list(map(int, number_as_string))\n        for k in tokens:\n            summation = summation + k ** exponent\n            exponent += 1\n        if summation == number:\n            result.append(number)\n    return result"}}, "body": {"calls": ["summing_digits.sum_dig_pow"], "source_code": ["sum_dig_pow(1, 10)", "sum_dig_pow(1, 100)"]}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/recursive_binomial_coefficient.py", "fileNameBase": "recursive_binomial_coefficient", "extension": "py"}, "functions": {"recursive_binomial_coefficient": {"doc": {"long_description": "Time complexity is O(k), so can calculate fairly quickly for large values of k.\n\n>>> recursive_binomial_coefficient(5,0)\n1\n\n>>> recursive_binomial_coefficient(8,2)\n28\n\n>>> recursive_binomial_coefficient(500,300)\n5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640", "short_description": "Calculates the binomial coefficient, C(n,k), with n>=k using recursion"}, "args": ["n", "k"], "returns": ["int(n / k * recursive_binomial_coefficient(n - 1, k - 1))", "1", "recursive_binomial_coefficient(n, n - k)"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 27}, "calls": ["int", "ValueError", "recursive_binomial_coefficient.recursive_binomial_coefficient"], "source_code": "def recursive_binomial_coefficient(n, k):\n    \"\"\"Calculates the binomial coefficient, C(n,k), with n>=k using recursion\n    Time complexity is O(k), so can calculate fairly quickly for large values of k.\n\n    >>> recursive_binomial_coefficient(5,0)\n    1\n\n    >>> recursive_binomial_coefficient(8,2)\n    28\n\n    >>> recursive_binomial_coefficient(500,300)\n    5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640\n\n    \"\"\"\n    if k > n:\n        raise ValueError('Invalid Inputs, ensure that n >= k')\n    if k == 0 or n == k:\n        return 1\n    if k > n / 2:\n        return recursive_binomial_coefficient(n, n - k)\n    return int(n / k * recursive_binomial_coefficient(n - 1, k - 1))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/rabin_miller.py", "fileNameBase": "rabin_miller", "extension": "py", "doc": {"long_description": "returning False implies that n is guaranteed composite\nreturning True means that n is probably prime\nwith a 4 ** -k chance of being wrong", "short_description": "Rabin-Miller primality test", "full": "Rabin-Miller primality test\nreturning False implies that n is guaranteed composite\nreturning True means that n is probably prime\nwith a 4 ** -k chance of being wrong"}}, "dependencies": [{"import": "random", "type": "external", "type_element": "module"}], "functions": {"is_prime": {"args": ["n", "k"], "returns": ["True", ["power", "num"], "True", "n == 2 or n == 3", "False", "False", "True", "False"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 52}, "calls": ["rabin_miller.is_prime.pow2_factor"], "store_vars_calls": {"x": "pow"}, "functions": {"pow2_factor": {"doc": {"short_description": "factor n into a power of 2 times an odd number"}, "args": ["num"], "returns": [["power", "num"]], "min_max_lineno": {"min_lineno": 12, "max_lineno": 19}, "source_code": "def pow2_factor(num):\n    \"\"\"factor n into a power of 2 times an odd number\"\"\"\n    power = 0\n    while num % 2 == 0:\n        num /= 2\n        power += 1\n    return (power, num)"}, "valid_witness": {"doc": {"long_description": "a valid witness increases chances of n being prime\nan invalid witness guarantees n is composite", "short_description": "returns true if a is a valid 'witness' for n"}, "args": ["a"], "returns": ["True", "False", "True", "False"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 40}, "calls": ["pow", "range", "int"], "store_vars_calls": {"x": "pow"}, "source_code": "def valid_witness(a):\n    \"\"\"\n        returns true if a is a valid 'witness' for n\n        a valid witness increases chances of n being prime\n        an invalid witness guarantees n is composite\n        \"\"\"\n    x = pow(int(a), int(d), int(n))\n    if x == 1 or x == n - 1:\n        return False\n    for _ in range(r - 1):\n        x = pow(int(x), int(2), int(n))\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True"}}, "source_code": "def is_prime(n, k):\n\n    def pow2_factor(num):\n        \"\"\"factor n into a power of 2 times an odd number\"\"\"\n        power = 0\n        while num % 2 == 0:\n            num /= 2\n            power += 1\n        return (power, num)\n\n    def valid_witness(a):\n        \"\"\"\n        returns true if a is a valid 'witness' for n\n        a valid witness increases chances of n being prime\n        an invalid witness guarantees n is composite\n        \"\"\"\n        x = pow(int(a), int(d), int(n))\n        if x == 1 or x == n - 1:\n            return False\n        for _ in range(r - 1):\n            x = pow(int(x), int(2), int(n))\n            if x == 1:\n                return True\n            if x == n - 1:\n                return False\n        return True\n    if n < 5:\n        return n == 2 or n == 3\n    (r, d) = pow2_factor(n - 1)\n    for _ in range(k):\n        if valid_witness(random.randrange(2, n - 2)):\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/next_perfect_square.py", "fileNameBase": "next_perfect_square", "extension": "py", "doc": {"long_description": "Check the argument to see if it is a perfect square itself, if it is not then return -1 otherwise\nlook for the next perfect square.\nfor instance if you pass 121 then the script should return the next perfect square which is 144.", "short_description": "This program will look for the next perfect square.", "full": "This program will look for the next perfect square.\nCheck the argument to see if it is a perfect square itself, if it is not then return -1 otherwise\nlook for the next perfect square.\nfor instance if you pass 121 then the script should return the next perfect square which is 144."}}, "functions": {"find_next_square": {"args": ["sq"], "returns": ["-1", "(root + 1) ** 2"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 13}, "calls": ["root.is_integer"], "source_code": "def find_next_square(sq):\n    root = sq ** 0.5\n    if root.is_integer():\n        return (root + 1) ** 2\n    return -1"}, "find_next_square2": {"doc": {"short_description": "Alternative method, works by evaluating anything non-zero as True (0.000001 --> True) "}, "args": ["sq"], "returns": ["-1 if root % 1 else (root + 1) ** 2"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 18}, "source_code": "def find_next_square2(sq):\n    \"\"\" Alternative method, works by evaluating anything non-zero as True (0.000001 --> True) \"\"\"\n    root = sq ** 0.5\n    return -1 if root % 1 else (root + 1) ** 2"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/next_bigger.py", "fileNameBase": "next_bigger", "extension": "py", "doc": {"long_description": "progress on my interview question.\n\nGiven a number, find the next higher number which has the\nexact same set of digits as the original number.\nFor example: given 38276 return 38627.\n             given 99999 return -1. (no such number exists)\n\nCondensed mathematical description:\n\nFind largest index i such that array[i \u2212 1] < array[i].\n(If no such i exists, then this is already the last permutation.)\n\nFind largest index j such that j \u2265 i and array[j] > array[i \u2212 1].\n\nSwap array[j] and array[i \u2212 1].\n\nReverse the suffix starting at array[i].", "short_description": "I just bombed an interview and made pretty much zero", "full": "I just bombed an interview and made pretty much zero\nprogress on my interview question.\n\nGiven a number, find the next higher number which has the\nexact same set of digits as the original number.\nFor example: given 38276 return 38627.\n             given 99999 return -1. (no such number exists)\n\nCondensed mathematical description:\n\nFind largest index i such that array[i \u2212 1] < array[i].\n(If no such i exists, then this is already the last permutation.)\n\nFind largest index j such that j \u2265 i and array[j] > array[i \u2212 1].\n\nSwap array[j] and array[i \u2212 1].\n\nReverse the suffix starting at array[i]."}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 60}, "methods": {"test_next_bigger": {"args": ["self"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 60}, "calls": ["next_bigger.TestSuite.assertEqual", "next_bigger.next_bigger"], "source_code": "def test_next_bigger(self):\n    self.assertEqual(next_bigger(38276), 38627)\n    self.assertEqual(next_bigger(12345), 12354)\n    self.assertEqual(next_bigger(1528452), 1528524)\n    self.assertEqual(next_bigger(138654), 143568)\n    self.assertEqual(next_bigger(54321), -1)\n    self.assertEqual(next_bigger(999), -1)\n    self.assertEqual(next_bigger(5), -1)"}}}}, "functions": {"next_bigger": {"args": ["num"], "returns": ["int(''.join((str(x) for x in digits)))", "-1"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 46}, "calls": ["int", "len", "str"], "source_code": "def next_bigger(num):\n    digits = [int(i) for i in str(num)]\n    idx = len(digits) - 1\n    while idx >= 1 and digits[idx - 1] >= digits[idx]:\n        idx -= 1\n    if idx == 0:\n        return -1\n    pivot = digits[idx - 1]\n    swap_idx = len(digits) - 1\n    while pivot >= digits[swap_idx]:\n        swap_idx -= 1\n    (digits[swap_idx], digits[idx - 1]) = (digits[idx - 1], digits[swap_idx])\n    digits[idx:] = digits[:idx - 1:-1]\n    return int(''.join((str(x) for x in digits)))"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "next_bigger.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/magic_number.py", "fileNameBase": "magic_number", "extension": "py", "doc": {"long_description": "A number is said to be a magic number,\nif summing the digits of the number and then recursively repeating this process for the given sum\nuntill the number becomes a single digit number equal to 1.", "short_description": "Magic Number", "full": "Magic Number\nA number is said to be a magic number,\nif summing the digits of the number and then recursively repeating this process for the given sum\nuntill the number becomes a single digit number equal to 1.\n\nExample:\n    Number = 50113 => 5+0+1+1+3=10 => 1+0=1 [This is a Magic Number]\n    Number = 1234 => 1+2+3+4=10 => 1+0=1 [This is a Magic Number]\n    Number = 199 => 1+9+9=19 => 1+9=10 => 1+0=1 [This is a Magic Number]\n    Number = 111 => 1+1+1=3 [This is NOT a Magic Number]\n\nThe following function checks for Magic numbers and returns a Boolean accordingly."}}, "functions": {"magic_number": {"doc": {"short_description": "Checks if n is a magic number "}, "args": ["n"], "returns": ["total_sum == 1"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 34}, "source_code": "def magic_number(n):\n    \"\"\" Checks if n is a magic number \"\"\"\n    total_sum = 0\n    while n > 0 or total_sum > 9:\n        if n == 0:\n            n = total_sum\n            total_sum = 0\n        total_sum += n % 10\n        n //= 10\n    return total_sum == 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/num_digits.py", "fileNameBase": "num_digits", "extension": "py", "doc": {"long_description": "math.log10() method.", "short_description": "num_digits() method will return the number of digits of a number in O(1) time using", "full": "num_digits() method will return the number of digits of a number in O(1) time using\nmath.log10() method."}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"num_digits": {"args": ["n"], "returns": ["int(math.log10(n)) + 1", "1"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 13}, "calls": ["abs", "int", "math.log10"], "store_vars_calls": {"n": "abs"}, "source_code": "def num_digits(n):\n    n = abs(n)\n    if n == 0:\n        return 1\n    return int(math.log10(n)) + 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/extended_gcd.py", "fileNameBase": "extended_gcd", "extension": "py", "doc": {"long_description": "num1 * s + num2 * t = GCD(num1, num2).\nIe the coefficients of B\u00e9zout's identity.", "short_description": "Provides extended GCD functionality for finding co-prime numbers s and t such that:", "full": "Provides extended GCD functionality for finding co-prime numbers s and t such that:\nnum1 * s + num2 * t = GCD(num1, num2).\nIe the coefficients of B\u00e9zout's identity."}}, "functions": {"extended_gcd": {"doc": {"long_description": "Return s, t, g\nsuch that num1 * s + num2 * t = GCD(num1, num2)\nand s and t are co-prime.", "short_description": "Extended GCD algorithm."}, "args": ["num1", "num2"], "returns": [["old_s", "old_t", "old_r"]], "min_max_lineno": {"min_lineno": 6, "max_lineno": 25}, "source_code": "def extended_gcd(num1, num2):\n    \"\"\"Extended GCD algorithm.\n    Return s, t, g\n    such that num1 * s + num2 * t = GCD(num1, num2)\n    and s and t are co-prime.\n    \"\"\"\n    (old_s, s) = (1, 0)\n    (old_t, t) = (0, 1)\n    (old_r, r) = (num1, num2)\n    while r != 0:\n        quotient = old_r / r\n        (old_r, r) = (r, old_r - quotient * r)\n        (old_s, s) = (s, old_s - quotient * s)\n        (old_t, t) = (t, old_t - quotient * t)\n    return (old_s, old_t, old_r)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/rsa.py", "fileNameBase": "rsa", "extension": "py", "doc": {"long_description": "a method for encrypting a number that uses seperate encryption and decryption keys\nthis file only implements the key generation algorithm\n\nthere are three important numbers in RSA called n, e, and d\ne is called the encryption exponent\nd is called the decryption exponent\nn is called the modulus\n\nthese three numbers satisfy\n((x ** e) ** d) % n == x % n\n\nto use this system for encryption, n and e are made publicly available, and d is kept secret\na number x can be encrypted by computing (x ** e) % n\nthe original number can then be recovered by computing (E ** d) % n, where E is\nthe encrypted number\n\nfortunately, python provides a three argument version of pow() that can compute powers modulo\na number very quickly:\n(a ** b) % c == pow(a,b,c)", "short_description": "RSA encryption algorithm", "full": "RSA encryption algorithm\na method for encrypting a number that uses seperate encryption and decryption keys\nthis file only implements the key generation algorithm\n\nthere are three important numbers in RSA called n, e, and d\ne is called the encryption exponent\nd is called the decryption exponent\nn is called the modulus\n\nthese three numbers satisfy\n((x ** e) ** d) % n == x % n\n\nto use this system for encryption, n and e are made publicly available, and d is kept secret\na number x can be encrypted by computing (x ** e) % n\nthe original number can then be recovered by computing (E ** d) % n, where E is\nthe encrypted number\n\nfortunately, python provides a three argument version of pow() that can compute powers modulo\na number very quickly:\n(a ** b) % c == pow(a,b,c)"}}, "dependencies": [{"import": "random", "type": "external", "type_element": "module"}], "functions": {"generate_key": {"doc": {"long_description": "k is the number of bits in n", "short_description": "the RSA key generating algorithm"}, "args": ["k", "seed"], "returns": [["int(n)", "int(e)", "int(d)"], "b", "True", "True", "key", "False"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 86}, "calls": ["rsa.generate_key.gen_prime"], "store_vars_calls": {"e": "gen_prime", "d": "modinv", "p": "gen_prime", "q": "gen_prime", "key": "random.randrange"}, "functions": {"modinv": {"doc": {"long_description": "that is, find b such that (a * b) % m == 1", "short_description": "calculate the inverse of a mod m"}, "args": ["a", "m"], "returns": ["b"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 47}, "source_code": "def modinv(a, m):\n    \"\"\"calculate the inverse of a mod m\n        that is, find b such that (a * b) % m == 1\"\"\"\n    b = 1\n    while not a * b % m == 1:\n        b += 1\n    return b"}, "gen_prime": {"doc": {"short_description": "generate a prime with k bits"}, "args": ["k", "seed"], "returns": ["True", "True", "key", "False"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 64}, "calls": ["random.seed", "range", "random.randrange", "rsa.generate_key.gen_prime.is_prime"], "store_vars_calls": {"key": "random.randrange"}, "functions": {"is_prime": {"args": ["num"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 58}, "calls": ["range", "int"], "source_code": "def is_prime(num):\n    if num == 2:\n        return True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True"}}, "source_code": "def gen_prime(k, seed=None):\n    \"\"\"generate a prime with k bits\"\"\"\n\n    def is_prime(num):\n        if num == 2:\n            return True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    random.seed(seed)\n    while True:\n        key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n        if is_prime(key):\n            return key"}}, "source_code": "def generate_key(k, seed=None):\n    \"\"\"\n    the RSA key generating algorithm\n    k is the number of bits in n\n    \"\"\"\n\n    def modinv(a, m):\n        \"\"\"calculate the inverse of a mod m\n        that is, find b such that (a * b) % m == 1\"\"\"\n        b = 1\n        while not a * b % m == 1:\n            b += 1\n        return b\n\n    def gen_prime(k, seed=None):\n        \"\"\"generate a prime with k bits\"\"\"\n\n        def is_prime(num):\n            if num == 2:\n                return True\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        random.seed(seed)\n        while True:\n            key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n            if is_prime(key):\n                return key\n    p_size = k / 2\n    q_size = k - p_size\n    e = gen_prime(k, seed)\n    while True:\n        p = gen_prime(p_size, seed)\n        if p % e != 1:\n            break\n    while True:\n        q = gen_prime(q_size, seed)\n        if q % e != 1:\n            break\n    n = p * q\n    l = (p - 1) * (q - 1)\n    d = modinv(e, l)\n    return (int(n), int(e), int(d))"}, "encrypt": {"args": ["data", "e", "n"], "returns": ["pow(int(data), int(e), int(n))"], "min_max_lineno": {"min_lineno": 88, "max_lineno": 90}, "calls": ["pow", "int"], "source_code": "def encrypt(data, e, n):\n    return pow(int(data), int(e), int(n))"}, "decrypt": {"args": ["data", "d", "n"], "returns": ["pow(int(data), int(d), int(n))"], "min_max_lineno": {"min_lineno": 92, "max_lineno": 94}, "calls": ["pow", "int"], "source_code": "def decrypt(data, d, n):\n    return pow(int(data), int(d), int(n))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/maths/primes_sieve_of_eratosthenes.py", "fileNameBase": "primes_sieve_of_eratosthenes", "extension": "py", "doc": {"long_description": "Using sieve of Eratosthenes.\n\nModification:\nWe don't need to check all even numbers, we can make the sieve excluding even\nnumbers and adding 2 to the primes list by default.\n\nWe are going to make an array of: x / 2 - 1 if number is even, else x / 2\n(The -1 with even number it's to exclude the number itself)\nBecause we just need numbers [from 3..x if x is odd]\n\n# We can get value represented at index i with (i*2 + 3)\n\nFor example, for x = 10, we start with an array of x / 2 - 1 = 4\n[1, 1, 1, 1]\n 3  5  7  9\n\nFor x = 11:\n[1, 1, 1, 1, 1]\n 3  5  7  9  11  # 11 is odd, it's included in the list\n\nWith this, we have reduced the array size to a half,\nand complexity it's also a half now.", "short_description": "Return list of all primes less than n,", "full": "Return list of all primes less than n,\nUsing sieve of Eratosthenes.\n\nModification:\nWe don't need to check all even numbers, we can make the sieve excluding even\nnumbers and adding 2 to the primes list by default.\n\nWe are going to make an array of: x / 2 - 1 if number is even, else x / 2\n(The -1 with even number it's to exclude the number itself)\nBecause we just need numbers [from 3..x if x is odd]\n\n# We can get value represented at index i with (i*2 + 3)\n\nFor example, for x = 10, we start with an array of x / 2 - 1 = 4\n[1, 1, 1, 1]\n 3  5  7  9\n\nFor x = 11:\n[1, 1, 1, 1, 1]\n 3  5  7  9  11  # 11 is odd, it's included in the list\n\nWith this, we have reduced the array size to a half,\nand complexity it's also a half now."}}, "functions": {"get_primes": {"doc": {"long_description": "Using sieve of Eratosthenes.", "short_description": "Return list of all primes less than n,"}, "args": ["n"], "returns": ["primes"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 46}, "calls": ["range", "ValueError", "primes.append"], "source_code": "def get_primes(n):\n    \"\"\"Return list of all primes less than n,\n    Using sieve of Eratosthenes.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    sieve_size = n // 2 - 1 if n % 2 == 0 else n // 2\n    sieve = [True for _ in range(sieve_size)]\n    primes = []\n    if n >= 2:\n        primes.append(2)\n    for i in range(sieve_size):\n        if sieve[i]:\n            value_at_i = i * 2 + 3\n            primes.append(value_at_i)\n            for j in range(i, sieve_size, value_at_i):\n                sieve[j] = False\n    return primes"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/sort": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/bubble_sort.py", "fileNameBase": "bubble_sort", "extension": "py", "doc": {"long_description": "Worst-case performance: O(N^2)\n\nIf you call bubble_sort(arr,True), you can see the process of the sort\nDefault is simulation = False", "short_description": "https://en.wikipedia.org/wiki/Bubble_sort", "full": "https://en.wikipedia.org/wiki/Bubble_sort\n\nWorst-case performance: O(N^2)\n\nIf you call bubble_sort(arr,True), you can see the process of the sort\nDefault is simulation = False"}}, "functions": {"bubble_sort": {"args": ["arr", "simulation"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 36}, "calls": ["len", "print", "range", "bubble_sort.bubble_sort.swap"], "store_vars_calls": {"n": "len"}, "functions": {"swap": {"args": ["i", "j"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 16}, "source_code": "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])"}}, "source_code": "def bubble_sort(arr, simulation=False):\n\n    def swap(i, j):\n        (arr[i], arr[j]) = (arr[j], arr[i])\n    n = len(arr)\n    swapped = True\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    x = -1\n    while swapped:\n        swapped = False\n        x = x + 1\n        for i in range(1, n - x):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n                if simulation:\n                    iteration = iteration + 1\n                    print('iteration', iteration, ':', *arr)\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/pigeonhole_sort.py", "fileNameBase": "pigeonhole_sort", "extension": "py", "doc": {"long_description": "Time complexity: O(n + Range) where n = number of elements and Range = possible values in the array\n\nSuitable for lists where the number of elements and key values are mostly the same.", "short_description": "https://en.wikipedia.org/wiki/Pigeonhole_sort", "full": "https://en.wikipedia.org/wiki/Pigeonhole_sort\n\nTime complexity: O(n + Range) where n = number of elements and Range = possible values in the array\n\nSuitable for lists where the number of elements and key values are mostly the same."}}, "functions": {"pigeonhole_sort": {"args": ["arr"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 29}, "calls": ["max", "min", "range"], "store_vars_calls": {"Max": "max", "Min": "min"}, "source_code": "def pigeonhole_sort(arr):\n    Max = max(arr)\n    Min = min(arr)\n    size = Max - Min + 1\n    holes = [0] * size\n    for i in arr:\n        holes[i - Min] += 1\n    i = 0\n    for count in range(size):\n        while holes[count] > 0:\n            holes[count] -= 1\n            arr[i] = count + Min\n            i += 1\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/quick_sort.py", "fileNameBase": "quick_sort", "extension": "py"}, "functions": {"quick_sort": {"doc": {"long_description": "Complexity: best O(n log(n)) avg O(n log(n)), worst O(N^2)", "short_description": "Quick sort"}, "args": ["arr", "simulation"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 11}, "calls": ["quick_sort.quick_sort_recur", "print", "len"], "source_code": "def quick_sort(arr, simulation=False):\n    \"\"\" Quick sort\n        Complexity: best O(n log(n)) avg O(n log(n)), worst O(N^2)\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    (arr, _) = quick_sort_recur(arr, 0, len(arr) - 1, iteration, simulation)\n    return arr"}, "quick_sort_recur": {"args": ["arr", "first", "last", "iteration", "simulation"], "returns": [["arr", "iteration"]], "min_max_lineno": {"min_lineno": 12, "max_lineno": 24}, "calls": ["quick_sort.partition", "quick_sort.quick_sort_recur", "print"], "store_vars_calls": {"pos": "partition"}, "source_code": "def quick_sort_recur(arr, first, last, iteration, simulation):\n    if first < last:\n        pos = partition(arr, first, last)\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n        (_, iteration) = quick_sort_recur(arr, first, pos - 1, iteration, simulation)\n        (_, iteration) = quick_sort_recur(arr, pos + 1, last, iteration, simulation)\n    return (arr, iteration)"}, "partition": {"args": ["arr", "first", "last"], "returns": ["wall"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 33}, "calls": ["range"], "source_code": "def partition(arr, first, last):\n    wall = first\n    for pos in range(first, last):\n        if arr[pos] < arr[last]:\n            (arr[pos], arr[wall]) = (arr[wall], arr[pos])\n            wall += 1\n    (arr[wall], arr[last]) = (arr[last], arr[wall])\n    return wall"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/meeting_rooms.py", "fileNameBase": "meeting_rooms", "extension": "py", "doc": {"long_description": "start and end times [[s1,e1],[s2,e2],...] (si < ei),\ndetermine if a person could attend all meetings.\n\nFor example,\nGiven [[0, 30],[5, 10],[15, 20]],\nreturn false.", "short_description": "Given an array of meeting time intervals consisting of", "full": "Given an array of meeting time intervals consisting of\nstart and end times [[s1,e1],[s2,e2],...] (si < ei),\ndetermine if a person could attend all meetings.\n\nFor example,\nGiven [[0, 30],[5, 10],[15, 20]],\nreturn false."}}, "functions": {"can_attend_meetings": {"args": ["intervals"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 22}, "calls": ["sorted", "range", "len"], "store_vars_calls": {"intervals": "sorted"}, "source_code": "def can_attend_meetings(intervals):\n    \"\"\"\n    :type intervals: List[Interval]\n    :rtype: bool\n    \"\"\"\n    intervals = sorted(intervals, key=lambda x: x.start)\n    for i in range(1, len(intervals)):\n        if intervals[i].start < intervals[i - 1].end:\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/counting_sort.py", "fileNameBase": "counting_sort", "extension": "py"}, "functions": {"counting_sort": {"doc": {"long_description": "Sorting a array which has no element greater than k\nCreating a new temp_arr,where temp_arr[i] contain the number of\nelement less than or equal to i in the arr\nThen placing the number i into a correct position in the result_arr\nreturn the result_arr\nComplexity: 0(n)", "short_description": "Counting_sort"}, "args": ["arr"], "returns": ["result_arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 37}, "calls": ["min", "max", "range", "arr.copy", "len"], "store_vars_calls": {"m": "min", "k": "max", "result_arr": "arr.copy"}, "source_code": "def counting_sort(arr):\n    \"\"\"\n    Counting_sort\n    Sorting a array which has no element greater than k\n    Creating a new temp_arr,where temp_arr[i] contain the number of\n    element less than or equal to i in the arr\n    Then placing the number i into a correct position in the result_arr\n    return the result_arr\n    Complexity: 0(n)\n    \"\"\"\n    m = min(arr)\n    different = 0\n    if m < 0:\n        different = -m\n        for i in range(len(arr)):\n            arr[i] += -m\n    k = max(arr)\n    temp_arr = [0] * (k + 1)\n    for i in range(0, len(arr)):\n        temp_arr[arr[i]] = temp_arr[arr[i]] + 1\n    for i in range(1, k + 1):\n        temp_arr[i] = temp_arr[i] + temp_arr[i - 1]\n    result_arr = arr.copy()\n    for i in range(len(arr) - 1, -1, -1):\n        result_arr[temp_arr[arr[i]] - 1] = arr[i] - different\n        temp_arr[arr[i]] = temp_arr[arr[i]] - 1\n    return result_arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/merge_sort.py", "fileNameBase": "merge_sort", "extension": "py"}, "functions": {"merge_sort": {"doc": {"long_description": "Complexity: O(n log(n))", "short_description": "Merge Sort"}, "args": ["arr"], "returns": ["arr", "arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 16}, "calls": ["merge_sort.merge", "len", "merge_sort.merge_sort"], "source_code": "def merge_sort(arr):\n    \"\"\" Merge Sort\n        Complexity: O(n log(n))\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    (left, right) = (merge_sort(arr[:mid]), merge_sort(arr[mid:]))\n    merge(left, right, arr)\n    return arr"}, "merge": {"doc": {"long_description": "Complexity: O(n)", "short_description": "Merge helper"}, "args": ["left", "right", "merged"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 38}, "calls": ["range", "len"], "source_code": "def merge(left, right, merged):\n    \"\"\" Merge helper\n        Complexity: O(n)\n    \"\"\"\n    (left_cursor, right_cursor) = (0, 0)\n    while left_cursor < len(left) and right_cursor < len(right):\n        if left[left_cursor] <= right[right_cursor]:\n            merged[left_cursor + right_cursor] = left[left_cursor]\n            left_cursor += 1\n        else:\n            merged[left_cursor + right_cursor] = right[right_cursor]\n            right_cursor += 1\n    for left_cursor in range(left_cursor, len(left)):\n        merged[left_cursor + right_cursor] = left[left_cursor]\n    for right_cursor in range(right_cursor, len(right)):\n        merged[left_cursor + right_cursor] = right[right_cursor]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/cycle_sort.py", "fileNameBase": "cycle_sort", "extension": "py"}, "functions": {"cycle_sort": {"doc": {"long_description": "This is based on the idea that the permutations to be sorted\ncan be decomposed into cycles,\nand the results can be individually sorted by cycling.\n\nreference: https://en.wikipedia.org/wiki/Cycle_sort\n\nAverage time complexity : O(N^2)\nWorst case time complexity : O(N^2)", "short_description": "cycle_sort"}, "args": ["arr"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 47}, "calls": ["len", "range"], "store_vars_calls": {"len_arr": "len"}, "source_code": "def cycle_sort(arr):\n    \"\"\"\n    cycle_sort\n    This is based on the idea that the permutations to be sorted\n    can be decomposed into cycles,\n    and the results can be individually sorted by cycling.\n    \n    reference: https://en.wikipedia.org/wiki/Cycle_sort\n    \n    Average time complexity : O(N^2)\n    Worst case time complexity : O(N^2)\n    \"\"\"\n    len_arr = len(arr)\n    for cur in range(len_arr - 1):\n        item = arr[cur]\n        index = cur\n        for i in range(cur + 1, len_arr):\n            if arr[i] < item:\n                index += 1\n        if index == cur:\n            continue\n        while item == arr[index]:\n            index += 1\n        (arr[index], item) = (item, arr[index])\n        while index != cur:\n            index = cur\n            for i in range(cur + 1, len_arr):\n                if arr[i] < item:\n                    index += 1\n            while item == arr[index]:\n                index += 1\n            (arr[index], item) = (item, arr[index])\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/pancake_sort.py", "fileNameBase": "pancake_sort", "extension": "py"}, "functions": {"pancake_sort": {"doc": {"long_description": "Sorting a given array\nmutation of selection sort\n\nreference: https://www.geeksforgeeks.org/pancake-sorting/\n\nOverall time complexity : O(N^2)", "short_description": "Pancake_sort"}, "args": ["arr"], "returns": ["arr", "arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 26}, "calls": ["len", "range", "arr.index", "max", "reversed"], "store_vars_calls": {"len_arr": "len", "index_max": "arr.index"}, "source_code": "def pancake_sort(arr):\n    \"\"\"\n    Pancake_sort\n    Sorting a given array\n    mutation of selection sort\n\n    reference: https://www.geeksforgeeks.org/pancake-sorting/\n    \n    Overall time complexity : O(N^2)\n    \"\"\"\n    len_arr = len(arr)\n    if len_arr <= 1:\n        return arr\n    for cur in range(len(arr), 1, -1):\n        index_max = arr.index(max(arr[0:cur]))\n        if index_max + 1 != cur:\n            if index_max != 0:\n                arr[:index_max + 1] = reversed(arr[:index_max + 1])\n            arr[:cur] = reversed(arr[:cur])\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/bitonic_sort.py", "fileNameBase": "bitonic_sort", "extension": "py"}, "functions": {"bitonic_sort": {"doc": {"long_description": "It can sort only array that sizes power of 2\nIt can sort array in both increasing order and decreasing order by giving argument true(increasing) and false(decreasing)\n\nWorst-case in parallel: O(log(n)^2)\nWorst-case in non-parallel: O(nlog(n)^2)\n\nreference: https://en.wikipedia.org/wiki/Bitonic_sorter", "short_description": "bitonic sort is sorting algorithm to use multiple process, but this code not containing parallel process"}, "args": ["arr", "reverse"], "returns": ["arr", "arr", "left + right", "arr", "arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 44}, "calls": ["len", "bitonic_sort.bitonic_sort", "bitonic_sort.bitonic_sort.bitonic_merge"], "store_vars_calls": {"n": "len", "left": "bitonic_merge", "right": "bitonic_merge", "arr": "compare"}, "functions": {"compare": {"args": ["arr", "reverse"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 18}, "calls": ["range", "len"], "source_code": "def compare(arr, reverse):\n    n = len(arr) // 2\n    for i in range(n):\n        if reverse != (arr[i] > arr[i + n]):\n            (arr[i], arr[i + n]) = (arr[i + n], arr[i])\n    return arr"}, "bitonic_merge": {"args": ["arr", "reverse"], "returns": ["left + right", "arr"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 29}, "calls": ["len", "compare", "bitonic_merge"], "store_vars_calls": {"n": "len", "arr": "compare", "left": "bitonic_merge", "right": "bitonic_merge"}, "source_code": "def bitonic_merge(arr, reverse):\n    n = len(arr)\n    if n <= 1:\n        return arr\n    arr = compare(arr, reverse)\n    left = bitonic_merge(arr[:n // 2], reverse)\n    right = bitonic_merge(arr[n // 2:], reverse)\n    return left + right"}}, "source_code": "def bitonic_sort(arr, reverse=False):\n    \"\"\"\n    bitonic sort is sorting algorithm to use multiple process, but this code not containing parallel process\n    It can sort only array that sizes power of 2\n    It can sort array in both increasing order and decreasing order by giving argument true(increasing) and false(decreasing)\n    \n    Worst-case in parallel: O(log(n)^2)\n    Worst-case in non-parallel: O(nlog(n)^2)\n    \n    reference: https://en.wikipedia.org/wiki/Bitonic_sorter\n    \"\"\"\n\n    def compare(arr, reverse):\n        n = len(arr) // 2\n        for i in range(n):\n            if reverse != (arr[i] > arr[i + n]):\n                (arr[i], arr[i + n]) = (arr[i + n], arr[i])\n        return arr\n\n    def bitonic_merge(arr, reverse):\n        n = len(arr)\n        if n <= 1:\n            return arr\n        arr = compare(arr, reverse)\n        left = bitonic_merge(arr[:n // 2], reverse)\n        right = bitonic_merge(arr[n // 2:], reverse)\n        return left + right\n    n = len(arr)\n    if n <= 1:\n        return arr\n    if not (n and (not n & n - 1)):\n        raise ValueError('the size of input should be power of two')\n    left = bitonic_sort(arr[:n // 2], True)\n    right = bitonic_sort(arr[n // 2:], False)\n    arr = bitonic_merge(left + right, reverse)\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/wiggle_sort.py", "fileNameBase": "wiggle_sort", "extension": "py", "doc": {"short_description": "Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....", "full": "Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]...."}}, "functions": {"wiggle_sort": {"args": ["nums"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 8}, "calls": ["range", "len"], "source_code": "def wiggle_sort(nums):\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            (nums[i - 1], nums[i]) = (nums[i], nums[i - 1])"}}, "body": {"calls": ["print", "wiggle_sort.wiggle_sort"], "source_code": ["print(array)", "wiggle_sort(array)", "print(array)"]}, "main_info": {"main_flag": 1, "main_function": "wiggle_sort.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/exchange_sort.py", "fileNameBase": "exchange_sort", "extension": "py"}, "functions": {"exchange_sort": {"doc": {"long_description": "Complexity : O(n^2)", "short_description": "Reference : https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort"}, "args": ["arr"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 12}, "calls": ["len", "range"], "store_vars_calls": {"arr_len": "len"}, "source_code": "def exchange_sort(arr):\n    \"\"\"\n    Reference : https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    Complexity : O(n^2)\n    \"\"\"\n    arr_len = len(arr)\n    for i in range(arr_len - 1):\n        for j in range(i + 1, arr_len):\n            if arr[i] > arr[j]:\n                (arr[i], arr[j]) = (arr[j], arr[i])\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/heap_sort.py", "fileNameBase": "heap_sort", "extension": "py"}, "functions": {"max_heap_sort": {"doc": {"long_description": "Complexity: O(n log(n))", "short_description": "Heap Sort that uses a max heap to sort an array in ascending order"}, "args": ["arr", "simulation"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 16}, "calls": ["range", "print", "heap_sort.max_heapify", "len"], "store_vars_calls": {"iteration": "max_heapify"}, "source_code": "def max_heap_sort(arr, simulation=False):\n    \"\"\" Heap Sort that uses a max heap to sort an array in ascending order\n        Complexity: O(n log(n))\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr) - 1, 0, -1):\n        iteration = max_heapify(arr, i, simulation, iteration)\n    if simulation:\n        iteration = iteration + 1\n        print('iteration', iteration, ':', *arr)\n    return arr"}, "max_heapify": {"doc": {"short_description": "Max heapify helper for max_heap_sort"}, "args": ["arr", "end", "simulation", "iteration"], "returns": ["iteration"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 46}, "calls": ["range", "print"], "source_code": "def max_heapify(arr, end, simulation, iteration):\n    \"\"\" Max heapify helper for max_heap_sort\n    \"\"\"\n    last_parent = (end - 1) // 2\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent\n        while current_parent <= last_parent:\n            child = 2 * current_parent + 1\n            if child + 1 <= end and arr[child] < arr[child + 1]:\n                child = child + 1\n            if arr[child] > arr[current_parent]:\n                (arr[current_parent], arr[child]) = (arr[child], arr[current_parent])\n                current_parent = child\n                if simulation:\n                    iteration = iteration + 1\n                    print('iteration', iteration, ':', *arr)\n            else:\n                break\n    (arr[0], arr[end]) = (arr[end], arr[0])\n    return iteration"}, "min_heap_sort": {"doc": {"long_description": "Complexity: O(n log(n))", "short_description": "Heap Sort that uses a min heap to sort an array in ascending order"}, "args": ["arr", "simulation"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 59}, "calls": ["range", "print", "heap_sort.min_heapify", "len"], "store_vars_calls": {"iteration": "min_heapify"}, "source_code": "def min_heap_sort(arr, simulation=False):\n    \"\"\" Heap Sort that uses a min heap to sort an array in ascending order\n        Complexity: O(n log(n))\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(0, len(arr) - 1):\n        iteration = min_heapify(arr, i, simulation, iteration)\n    return arr"}, "min_heapify": {"doc": {"short_description": "Min heapify helper for min_heap_sort"}, "args": ["arr", "start", "simulation", "iteration"], "returns": ["iteration"], "min_max_lineno": {"min_lineno": 61, "max_lineno": 93}, "calls": ["range", "len", "print"], "source_code": "def min_heapify(arr, start, simulation, iteration):\n    \"\"\" Min heapify helper for min_heap_sort\n    \"\"\"\n    end = len(arr) - 1\n    last_parent = (end - start - 1) // 2\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent\n        while current_parent <= last_parent:\n            child = 2 * current_parent + 1\n            if child + 1 <= end - start and arr[child + start] > arr[child + 1 + start]:\n                child = child + 1\n            if arr[child + start] < arr[current_parent + start]:\n                (arr[current_parent + start], arr[child + start]) = (arr[child + start], arr[current_parent + start])\n                current_parent = child\n                if simulation:\n                    iteration = iteration + 1\n                    print('iteration', iteration, ':', *arr)\n            else:\n                break\n    return iteration"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/bucket_sort.py", "fileNameBase": "bucket_sort", "extension": "py"}, "functions": {"bucket_sort": {"doc": {"long_description": "Complexity: O(n^2)\nThe complexity is dominated by nextSort", "short_description": "Bucket Sort"}, "args": ["arr"], "returns": ["sorted_list"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 18}, "calls": ["len", "range", "buckets[].append", "sorted_list.extend", "bucket_sort.next_sort", "max"], "store_vars_calls": {"num_buckets": "len"}, "source_code": "def bucket_sort(arr):\n    \"\"\" Bucket Sort\n        Complexity: O(n^2)\n        The complexity is dominated by nextSort\n    \"\"\"\n    num_buckets = len(arr)\n    buckets = [[] for bucket in range(num_buckets)]\n    for value in arr:\n        index = value * num_buckets // (max(arr) + 1)\n        buckets[index].append(value)\n    sorted_list = []\n    for i in range(num_buckets):\n        sorted_list.extend(next_sort(buckets[i]))\n    return sorted_list"}, "next_sort": {"args": ["arr"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 29}, "calls": ["range", "len"], "source_code": "def next_sort(arr):\n    for i in range(1, len(arr)):\n        j = i - 1\n        key = arr[i]\n        while arr[j] > key and j >= 0:\n            arr[j + 1] = arr[j]\n            j = j - 1\n        arr[j + 1] = key\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/shell_sort.py", "fileNameBase": "shell_sort", "extension": "py"}, "functions": {"shell_sort": {"doc": {"long_description": "Complexity: O(n^2)", "short_description": "Shell Sort"}, "args": ["arr"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 22}, "calls": ["len"], "store_vars_calls": {"n": "len"}, "source_code": "def shell_sort(arr):\n    \"\"\" Shell Sort\n        Complexity: O(n^2)\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        y_index = gap\n        while y_index < len(arr):\n            y = arr[y_index]\n            x_index = y_index - gap\n            while x_index >= 0 and y < arr[x_index]:\n                arr[x_index + gap] = arr[x_index]\n                x_index = x_index - gap\n            arr[x_index + gap] = y\n            y_index = y_index + 1\n        gap = gap // 2\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/radix_sort.py", "fileNameBase": "radix_sort", "extension": "py", "doc": {"long_description": "complexity: O(nk + n) . n is the size of input list and k is the digit length of the number", "short_description": "radix sort", "full": "radix sort\ncomplexity: O(nk + n) . n is the size of input list and k is the digit length of the number"}}, "functions": {"radix_sort": {"args": ["arr", "simulation"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 32}, "calls": ["max", "print", "list", "queue_list[].append", "range"], "store_vars_calls": {"max_number": "max"}, "source_code": "def radix_sort(arr, simulation=False):\n    position = 1\n    max_number = max(arr)\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    while position <= max_number:\n        queue_list = [list() for _ in range(10)]\n        for num in arr:\n            digit_number = num // position % 10\n            queue_list[digit_number].append(num)\n        index = 0\n        for numbers in queue_list:\n            for num in numbers:\n                arr[index] = num\n                index += 1\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n        position *= 10\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/cocktail_shaker_sort.py", "fileNameBase": "cocktail_shaker_sort", "extension": "py"}, "functions": {"cocktail_shaker_sort": {"doc": {"long_description": "Sorting a given array\nmutation of bubble sort\n\nreference: https://en.wikipedia.org/wiki/Cocktail_shaker_sort\n\nWorst-case performance: O(N^2)", "short_description": "Cocktail_shaker_sort"}, "args": ["arr"], "returns": ["arr", "arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 31}, "calls": ["len", "range", "cocktail_shaker_sort.cocktail_shaker_sort.swap"], "store_vars_calls": {"n": "len"}, "functions": {"swap": {"args": ["i", "j"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 14}, "source_code": "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])"}}, "source_code": "def cocktail_shaker_sort(arr):\n    \"\"\"\n    Cocktail_shaker_sort\n    Sorting a given array\n    mutation of bubble sort\n\n    reference: https://en.wikipedia.org/wiki/Cocktail_shaker_sort\n    \n    Worst-case performance: O(N^2)\n    \"\"\"\n\n    def swap(i, j):\n        (arr[i], arr[j]) = (arr[j], arr[i])\n    n = len(arr)\n    swapped = True\n    while swapped:\n        swapped = False\n        for i in range(1, n):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n        if swapped == False:\n            return arr\n        swapped = False\n        for i in range(n - 1, 0, -1):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/sort_colors.py", "fileNameBase": "sort_colors", "extension": "py", "doc": {"long_description": "white or blue, sort them so that objects of the same color\nare adjacent, with the colors in the order red, white and blue.\n\nHere, we will use the integers 0, 1, and 2 to represent\nthe color red, white, and blue respectively.\n\nNote:\nYou are not suppose to use the library's sort function for this problem.", "short_description": "Given an array with n objects colored red,", "full": "Given an array with n objects colored red,\nwhite or blue, sort them so that objects of the same color\nare adjacent, with the colors in the order red, white and blue.\n\nHere, we will use the integers 0, 1, and 2 to represent\nthe color red, white, and blue respectively.\n\nNote:\nYou are not suppose to use the library's sort function for this problem."}}, "functions": {"sort_colors": {"args": ["nums"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 25}, "calls": ["range", "len"], "source_code": "def sort_colors(nums):\n    i = j = 0\n    for k in range(len(nums)):\n        v = nums[k]\n        nums[k] = 2\n        if v < 2:\n            nums[j] = 1\n            j += 1\n        if v == 0:\n            nums[i] = 0\n            i += 1"}}, "body": {"calls": ["sort_colors.sort_colors", "print"], "source_code": ["sort_colors(nums)", "print(nums)"]}, "main_info": {"main_flag": 1, "main_function": "sort_colors.sort_colors", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/bogo_sort.py", "fileNameBase": "bogo_sort", "extension": "py"}, "dependencies": [{"import": "random", "type": "external", "type_element": "module"}], "functions": {"bogo_sort": {"doc": {"long_description": "Best Case Complexity: O(n)\nWorst Case Complexity: O(\u221e)\nAverage Case Complexity: O(n(n-1)!)", "short_description": "Bogo Sort"}, "args": ["arr", "simulation"], "returns": ["arr", "True", "False"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 33}, "calls": ["print", "len", "bogo_sort.bogo_sort.is_sorted"], "store_vars_calls": {"arr_len": "len"}, "functions": {"is_sorted": {"args": ["arr"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 25}, "calls": ["len"], "store_vars_calls": {"arr_len": "len"}, "source_code": "def is_sorted(arr):\n    i = 0\n    arr_len = len(arr)\n    while i + 1 < arr_len:\n        if arr[i] > arr[i + 1]:\n            return False\n        i += 1\n    return True"}}, "source_code": "def bogo_sort(arr, simulation=False):\n    \"\"\"Bogo Sort\n        Best Case Complexity: O(n)\n        Worst Case Complexity: O(\u221e)\n        Average Case Complexity: O(n(n-1)!)\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n\n    def is_sorted(arr):\n        i = 0\n        arr_len = len(arr)\n        while i + 1 < arr_len:\n            if arr[i] > arr[i + 1]:\n                return False\n            i += 1\n        return True\n    while not is_sorted(arr):\n        random.shuffle(arr)\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/comb_sort.py", "fileNameBase": "comb_sort", "extension": "py", "doc": {"long_description": "Worst-case performance: O(N^2)", "short_description": "https://en.wikipedia.org/wiki/Comb_sort", "full": "https://en.wikipedia.org/wiki/Comb_sort\n\nWorst-case performance: O(N^2)"}}, "functions": {"comb_sort": {"args": ["arr"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 33}, "calls": ["len", "int", "comb_sort.comb_sort.swap"], "store_vars_calls": {"n": "len", "gap": "int"}, "functions": {"swap": {"args": ["i", "j"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 13}, "source_code": "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])"}}, "source_code": "def comb_sort(arr):\n\n    def swap(i, j):\n        (arr[i], arr[j]) = (arr[j], arr[i])\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap > 1:\n            sorted = False\n        else:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < n:\n            if arr[i] > arr[i + gap]:\n                swap(i, i + gap)\n                sorted = False\n            i = i + 1\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/insertion_sort.py", "fileNameBase": "insertion_sort", "extension": "py"}, "functions": {"insertion_sort": {"doc": {"long_description": "Complexity: O(n^2)", "short_description": "Insertion Sort"}, "args": ["arr", "simulation"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 26}, "calls": ["range", "print", "len"], "source_code": "def insertion_sort(arr, simulation=False):\n    \"\"\" Insertion Sort\n        Complexity: O(n^2)\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr)):\n        cursor = arr[i]\n        pos = i\n        while pos > 0 and arr[pos - 1] > cursor:\n            arr[pos] = arr[pos - 1]\n            pos = pos - 1\n        arr[pos] = cursor\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/top_sort.py", "fileNameBase": "top_sort", "extension": "py"}, "functions": {"top_sort_recursive": {"doc": {"long_description": "Space complexity: O(V)", "short_description": "Time complexity is the same as DFS, which is O(V + E)"}, "args": ["graph"], "returns": ["order"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 25}, "calls": ["set", "graph.get", "order.append", "top_sort.top_sort_recursive.dfs"], "store_vars_calls": {"sk": "state.get"}, "functions": {"dfs": {"args": ["node"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 22}, "calls": ["graph.get", "order.append", "state.get", "enter.discard", "dfs", "ValueError"], "store_vars_calls": {"sk": "state.get"}, "source_code": "def dfs(node):\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK"}}, "source_code": "def top_sort_recursive(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order"}, "top_sort": {"doc": {"long_description": "Space complexity: O(V)", "short_description": "Time complexity is the same as DFS, which is O(V + E)"}, "args": ["graph"], "returns": ["order", "True", "True", "False"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 67}, "calls": ["set", "graph.get", "enter.pop", "len", "state.get", "stack.append", "stack.pop", "ValueError", "enter.discard", "top_sort.top_sort.is_ready"], "store_vars_calls": {"lst": "graph.get", "node": "stack.pop", "sk": "state.get"}, "functions": {"is_ready": {"args": ["node"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 43}, "calls": ["graph.get", "len", "state.get", "ValueError"], "store_vars_calls": {"lst": "graph.get", "sk": "state.get"}, "source_code": "def is_ready(node):\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True"}}, "source_code": "def top_sort(graph):\n    \"\"\" Time complexity is the same as DFS, which is O(V + E)\n        Space complexity: O(V)\n    \"\"\"\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "bitonic_sort", "import": "bitonic_sort", "type": "internal", "type_element": "function"}, {"from_module": "bogo_sort", "import": "bogo_sort", "type": "internal", "type_element": "function"}, {"from_module": "bubble_sort", "import": "bubble_sort", "type": "internal", "type_element": "function"}, {"from_module": "comb_sort", "import": "comb_sort", "type": "internal", "type_element": "function"}, {"from_module": "counting_sort", "import": "counting_sort", "type": "internal", "type_element": "function"}, {"from_module": "cycle_sort", "import": "cycle_sort", "type": "internal", "type_element": "function"}, {"from_module": "exchange_sort", "import": "exchange_sort", "type": "internal", "type_element": "function"}, {"from_module": "heap_sort", "import": "max_heap_sort", "type": "internal", "type_element": "function"}, {"from_module": "heap_sort", "import": "max_heapify", "type": "internal", "type_element": "function"}, {"from_module": "heap_sort", "import": "min_heap_sort", "type": "internal", "type_element": "function"}, {"from_module": "heap_sort", "import": "min_heapify", "type": "internal", "type_element": "function"}, {"from_module": "insertion_sort", "import": "insertion_sort", "type": "internal", "type_element": "function"}, {"from_module": "merge_sort", "import": "merge_sort", "type": "internal", "type_element": "function"}, {"from_module": "merge_sort", "import": "merge", "type": "internal", "type_element": "function"}, {"from_module": "pancake_sort", "import": "pancake_sort", "type": "internal", "type_element": "function"}, {"from_module": "pigeonhole_sort", "import": "pigeonhole_sort", "type": "internal", "type_element": "function"}, {"from_module": "quick_sort", "import": "quick_sort", "type": "internal", "type_element": "function"}, {"from_module": "quick_sort", "import": "quick_sort_recur", "type": "internal", "type_element": "function"}, {"from_module": "quick_sort", "import": "partition", "type": "internal", "type_element": "function"}, {"from_module": "selection_sort", "import": "selection_sort", "type": "internal", "type_element": "function"}, {"from_module": "top_sort", "import": "top_sort_recursive", "type": "internal", "type_element": "function"}, {"from_module": "top_sort", "import": "top_sort", "type": "internal", "type_element": "function"}, {"from_module": "bucket_sort", "import": "bucket_sort", "type": "internal", "type_element": "function"}, {"from_module": "bucket_sort", "import": "next_sort", "type": "internal", "type_element": "function"}, {"from_module": "shell_sort", "import": "shell_sort", "type": "internal", "type_element": "function"}, {"from_module": "stooge_sort", "import": "stoogesort", "type": "internal", "type_element": "function"}, {"from_module": "radix_sort", "import": "radix_sort", "type": "internal", "type_element": "function"}, {"from_module": "gnome_sort", "import": "gnome_sort", "type": "internal", "type_element": "function"}, {"from_module": "cocktail_shaker_sort", "import": "cocktail_shaker_sort", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/selection_sort.py", "fileNameBase": "selection_sort", "extension": "py"}, "functions": {"selection_sort": {"doc": {"long_description": "Complexity: O(n^2)", "short_description": "Selection Sort"}, "args": ["arr", "simulation"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 24}, "calls": ["range", "print", "len"], "source_code": "def selection_sort(arr, simulation=False):\n    \"\"\" Selection Sort\n        Complexity: O(n^2)\n    \"\"\"\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr)):\n        minimum = i\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[minimum]:\n                minimum = j\n        (arr[minimum], arr[i]) = (arr[i], arr[minimum])\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/sort/gnome_sort.py", "fileNameBase": "gnome_sort", "extension": "py", "doc": {"long_description": "Best case performance is O(n)\nWorst case performance is O(n^2)", "short_description": "Gnome Sort", "full": "Gnome Sort\nBest case performance is O(n)\nWorst case performance is O(n^2)"}}, "functions": {"gnome_sort": {"args": ["arr"], "returns": ["arr"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 20}, "calls": ["len"], "store_vars_calls": {"n": "len"}, "source_code": "def gnome_sort(arr):\n    n = len(arr)\n    index = 0\n    while index < n:\n        if index == 0 or arr[index] >= arr[index - 1]:\n            index = index + 1\n        else:\n            (arr[index], arr[index - 1]) = (arr[index - 1], arr[index])\n            index = index - 1\n    return arr"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/graph": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/cycle_detection.py", "fileNameBase": "cycle_detection", "extension": "py", "doc": {"long_description": "Real-life scenario: deadlock detection in a system. Processes may be\nrepresented by vertices, then and an edge A -> B could mean that process A is\nwaiting for B to release its lock on a resource.", "short_description": "Given a directed graph, check whether it contains a cycle.", "full": "Given a directed graph, check whether it contains a cycle.\n\nReal-life scenario: deadlock detection in a system. Processes may be\nrepresented by vertices, then and an edge A -> B could mean that process A is\nwaiting for B to release its lock on a resource."}}, "dependencies": [{"from_module": "enum", "import": "Enum", "type": "external", "type_element": "module"}], "classes": {"TraversalState": {"doc": {"long_description": "- WHITE: has not been visited yet\n- GRAY: is currently being investigated for a cycle\n- BLACK: is not part of a cycle", "short_description": "For a given node:", "full": "For a given node:\n    - WHITE: has not been visited yet\n    - GRAY: is currently being investigated for a cycle\n    - BLACK: is not part of a cycle"}, "extend": ["Enum"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 21}}}, "functions": {"is_in_cycle": {"doc": {"long_description": ":param: traversal_states: for each vertex, the state it is in", "short_description": "Determines if the given vertex is in a cycle."}, "args": ["graph", "traversal_states", "vertex"], "returns": ["False", "True", "True"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 36}, "calls": ["cycle_detection.is_in_cycle"], "source_code": "def is_in_cycle(graph, traversal_states, vertex):\n    \"\"\"\n    Determines if the given vertex is in a cycle.\n\n    :param: traversal_states: for each vertex, the state it is in\n    \"\"\"\n    if traversal_states[vertex] == TraversalState.GRAY:\n        return True\n    traversal_states[vertex] = TraversalState.GRAY\n    for neighbor in graph[vertex]:\n        if is_in_cycle(graph, traversal_states, neighbor):\n            return True\n    traversal_states[vertex] = TraversalState.BLACK\n    return False"}, "contains_cycle": {"doc": {"long_description": "The graph should be given as a dictionary:\n\n    graph = {'A': ['B', 'C'],\n             'B': ['D'],\n             'C': ['F'],\n             'D': ['E', 'F'],\n             'E': ['B'],\n             'F': []}", "short_description": "Determines if there is a cycle in the given graph."}, "args": ["graph"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 56}, "calls": ["traversal_states.items", "cycle_detection.is_in_cycle"], "source_code": "def contains_cycle(graph):\n    \"\"\"\n    Determines if there is a cycle in the given graph.\n    The graph should be given as a dictionary:\n\n        graph = {'A': ['B', 'C'],\n                 'B': ['D'],\n                 'C': ['F'],\n                 'D': ['E', 'F'],\n                 'E': ['B'],\n                 'F': []}\n    \"\"\"\n    traversal_states = {vertex: TraversalState.WHITE for vertex in graph}\n    for (vertex, state) in traversal_states.items():\n        if state == TraversalState.WHITE and is_in_cycle(graph, traversal_states, vertex):\n            return True\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/check_bipartite.py", "fileNameBase": "check_bipartite", "extension": "py", "doc": {"long_description": "(https://en.wikipedia.org/wiki/Bipartite_graph)", "short_description": "Bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets.", "full": "Bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets.\n(https://en.wikipedia.org/wiki/Bipartite_graph)"}}, "functions": {"check_bipartite": {"doc": {"long_description": "Time complexity is O(|E|)\nSpace complexity is O(|V|)", "short_description": "Determine if the given graph is bipartite."}, "args": ["adj_list"], "returns": ["True", "False", "False"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 41}, "calls": ["len", "queue.pop", "range", "queue.append"], "store_vars_calls": {"vertices": "len", "current": "queue.pop"}, "source_code": "def check_bipartite(adj_list):\n    \"\"\"\n    Determine if the given graph is bipartite.\n\n    Time complexity is O(|E|)\n    Space complexity is O(|V|)\n    \"\"\"\n    vertices = len(adj_list)\n    set_type = [-1 for v in range(vertices)]\n    set_type[0] = 0\n    queue = [0]\n    while queue:\n        current = queue.pop(0)\n        if adj_list[current][current]:\n            return False\n        for adjacent in range(vertices):\n            if adj_list[current][adjacent]:\n                if set_type[adjacent] == set_type[current]:\n                    return False\n                if set_type[adjacent] == -1:\n                    set_type[adjacent] = 1 - set_type[current]\n                    queue.append(adjacent)\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/maximum_flow.py", "fileNameBase": "maximum_flow", "extension": "py", "doc": {"long_description": "computes the maximum flow from source to sink.\nInput : capacity, source, sink\nOutput : maximum flow from source to sink\nCapacity is a two-dimensional array that is v*v.\ncapacity[i][j] implies the capacity of the edge from i to j.\nIf there is no edge from i to j, capacity[i][j] should be zero.", "short_description": "Given the capacity, source and sink of a graph,", "full": "Given the capacity, source and sink of a graph,\ncomputes the maximum flow from source to sink.\nInput : capacity, source, sink\nOutput : maximum flow from source to sink\nCapacity is a two-dimensional array that is v*v.\ncapacity[i][j] implies the capacity of the edge from i to j.\nIf there is no edge from i to j, capacity[i][j] should be zero."}}, "dependencies": [{"from_module": "queue", "import": "Queue", "type": "external", "type_element": "module"}], "functions": {"dfs": {"doc": {"short_description": "Depth First Search implementation for Ford-Fulkerson algorithm."}, "args": ["capacity", "flow", "visit", "vertices", "idx", "sink", "current_flow"], "returns": ["0", "current_flow", "tmp"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 32}, "calls": ["range", "min", "maximum_flow.dfs"], "store_vars_calls": {"available_flow": "min", "tmp": "dfs"}, "source_code": "def dfs(capacity, flow, visit, vertices, idx, sink, current_flow=1 << 63):\n    \"\"\"\n    Depth First Search implementation for Ford-Fulkerson algorithm.\n    \"\"\"\n    if idx == sink:\n        return current_flow\n    visit[idx] = True\n    for nxt in range(vertices):\n        if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dfs(capacity, flow, visit, vertices, nxt, sink, available_flow)\n            if tmp:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n    return 0"}, "ford_fulkerson": {"doc": {"long_description": "Time Complexity : O(Ef)\nE is the number of edges and f is the maximum flow in the graph.", "short_description": "Computes maximum flow from source to sink using DFS."}, "args": ["capacity", "source", "sink"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 50}, "calls": ["len", "maximum_flow.dfs", "range"], "store_vars_calls": {"vertices": "len", "tmp": "dfs"}, "source_code": "def ford_fulkerson(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using DFS.\n    Time Complexity : O(Ef)\n    E is the number of edges and f is the maximum flow in the graph.\n    \"\"\"\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        visit = [False for _ in range(vertices)]\n        tmp = dfs(capacity, flow, visit, vertices, source, sink)\n        if tmp:\n            ret += tmp\n        else:\n            break\n    return ret"}, "edmonds_karp": {"doc": {"long_description": "Time complexity : O(V*E^2)\nV is the number of vertices and E is the number of edges.", "short_description": "Computes maximum flow from source to sink using BFS."}, "args": ["capacity", "source", "sink"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 91}, "calls": ["len", "queue.Queue", "queue.Queue.put", "queue.Queue.qsize", "range", "queue.Queue.get", "min"], "store_vars_calls": {"vertices": "len", "queue": "Queue", "front": "queue.get"}, "source_code": "def edmonds_karp(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using BFS.\n    Time complexity : O(V*E^2)\n    V is the number of vertices and E is the number of edges.\n    \"\"\"\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        tmp = 0\n        queue = Queue()\n        visit = [False for _ in range(vertices)]\n        par = [-1 for _ in range(vertices)]\n        visit[source] = True\n        queue.put((source, 1 << 63))\n        while queue.qsize():\n            front = queue.get()\n            (idx, current_flow) = front\n            if idx == sink:\n                tmp = current_flow\n                break\n            for nxt in range(vertices):\n                if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n                    visit[nxt] = True\n                    par[nxt] = idx\n                    queue.put((nxt, min(current_flow, capacity[idx][nxt] - flow[idx][nxt])))\n        if par[sink] == -1:\n            break\n        ret += tmp\n        parent = par[sink]\n        idx = sink\n        while parent != -1:\n            flow[parent][idx] += tmp\n            flow[idx][parent] -= tmp\n            idx = parent\n            parent = par[parent]\n    return ret"}, "dinic_bfs": {"doc": {"long_description": "Check whether sink is reachable only using edges that is not full.", "short_description": "BFS function for Dinic algorithm."}, "args": ["capacity", "flow", "level", "source", "sink"], "returns": ["level[sink] != -1"], "min_max_lineno": {"min_lineno": 92, "max_lineno": 108}, "calls": ["len", "queue.Queue", "queue.Queue.put", "queue.Queue.qsize", "queue.Queue.get", "range"], "store_vars_calls": {"vertices": "len", "queue": "Queue", "front": "queue.get"}, "source_code": "def dinic_bfs(capacity, flow, level, source, sink):\n    \"\"\"\n    BFS function for Dinic algorithm.\n    Check whether sink is reachable only using edges that is not full.\n    \"\"\"\n    vertices = len(capacity)\n    queue = Queue()\n    queue.put(source)\n    level[source] = 0\n    while queue.qsize():\n        front = queue.get()\n        for nxt in range(vertices):\n            if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]:\n                level[nxt] = level[front] + 1\n                queue.put(nxt)\n    return level[sink] != -1"}, "dinic_dfs": {"doc": {"long_description": "Finds new flow using edges that is not full.", "short_description": "DFS function for Dinic algorithm."}, "args": ["capacity", "flow", "level", "idx", "sink", "work", "current_flow"], "returns": ["0", "current_flow", "tmp"], "min_max_lineno": {"min_lineno": 109, "max_lineno": 128}, "calls": ["len", "min", "maximum_flow.dinic_dfs"], "store_vars_calls": {"vertices": "len", "available_flow": "min", "tmp": "dinic_dfs"}, "source_code": "def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow=1 << 63):\n    \"\"\"\n    DFS function for Dinic algorithm.\n    Finds new flow using edges that is not full.\n    \"\"\"\n    if idx == sink:\n        return current_flow\n    vertices = len(capacity)\n    while work[idx] < vertices:\n        nxt = work[idx]\n        if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, available_flow)\n            if tmp > 0:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n        work[idx] += 1\n    return 0"}, "dinic": {"doc": {"long_description": "Time complexity : O(V^2*E)\nV is the number of vertices and E is the number of edges.", "short_description": "Computes maximum flow from source to sink using Dinic algorithm."}, "args": ["capacity", "source", "sink"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 129, "max_lineno": 150}, "calls": ["len", "range", "maximum_flow.dinic_bfs", "maximum_flow.dinic_dfs"], "store_vars_calls": {"vertices": "len", "tmp": "dinic_dfs"}, "source_code": "def dinic(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using Dinic algorithm.\n    Time complexity : O(V^2*E)\n    V is the number of vertices and E is the number of edges.\n    \"\"\"\n    vertices = len(capacity)\n    flow = [[0] * vertices for i in range(vertices)]\n    ret = 0\n    while True:\n        level = [-1 for i in range(vertices)]\n        work = [0 for i in range(vertices)]\n        if not dinic_bfs(capacity, flow, level, source, sink):\n            break\n        while True:\n            tmp = dinic_dfs(capacity, flow, level, source, sink, work)\n            if tmp > 0:\n                ret += tmp\n            else:\n                break\n    return ret"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/find_path.py", "fileNameBase": "find_path", "extension": "py", "doc": {"short_description": "Functions for finding paths in graphs.", "full": "Functions for finding paths in graphs."}}, "functions": {"find_path": {"doc": {"short_description": "Find a path between two nodes using recursion and backtracking."}, "args": ["graph", "start", "end", "path"], "returns": ["None", "path", "None", "newpath"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 20}, "calls": ["find_path.find_path"], "store_vars_calls": {"newpath": "find_path"}, "source_code": "def find_path(graph, start, end, path=[]):\n    \"\"\"\n    Find a path between two nodes using recursion and backtracking.\n    \"\"\"\n    path = path + [start]\n    if start == end:\n        return path\n    if not start in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_path(graph, node, end, path)\n            return newpath\n    return None"}, "find_all_path": {"doc": {"short_description": "Find all paths between two nodes using recursion and backtracking"}, "args": ["graph", "start", "end", "path"], "returns": ["paths", "[path]", "[]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 38}, "calls": ["find_path.find_all_path", "paths.append"], "store_vars_calls": {"newpaths": "find_all_path"}, "source_code": "def find_all_path(graph, start, end, path=[]):\n    \"\"\"\n    Find all paths between two nodes using recursion and backtracking\n    \"\"\"\n    path = path + [start]\n    if start == end:\n        return [path]\n    if not start in graph:\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_path(graph, node, end, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths"}, "find_shortest_path": {"doc": {"short_description": "find the shortest path between two nodes"}, "args": ["graph", "start", "end", "path"], "returns": ["shortest", "path", "None"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 56}, "calls": ["find_path.find_shortest_path", "len"], "store_vars_calls": {"newpath": "find_shortest_path"}, "source_code": "def find_shortest_path(graph, start, end, path=[]):\n    \"\"\"\n    find the shortest path between two nodes\n    \"\"\"\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_shortest_path(graph, node, end, path)\n            if newpath:\n                if not shortest or len(newpath) < len(shortest):\n                    shortest = newpath\n    return shortest"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/find_all_cliques.py", "fileNameBase": "find_all_cliques", "extension": "py", "doc": {"long_description": "graph such that the subgraph is fully connected (ie. for any pair of nodes in\nthe subgraph there is an edge between them).", "short_description": "Finds all cliques in an undirected graph. A clique is a set of vertices in the", "full": "Finds all cliques in an undirected graph. A clique is a set of vertices in the\ngraph such that the subgraph is fully connected (ie. for any pair of nodes in\nthe subgraph there is an edge between them)."}}, "functions": {"find_all_cliques": {"doc": {"long_description": "each key is a vertex\nvalue is set of all edges connected to vertex\nreturns list of lists (each sub list is a maximal clique)\nimplementation of the basic algorithm described in:\nBron, Coen; Kerbosch, Joep (1973), \"Algorithm 457: finding all cliques of an undirected graph\",", "short_description": "takes dict of sets"}, "args": ["edges"], "returns": ["solutions", "new_set"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 43}, "calls": ["set", "find_all_cliques.find_all_cliques.expand_clique"], "store_vars_calls": {"possibles": "set", "new_set": "set", "candidates_temp": "get_connected", "nays_temp": "get_connected"}, "functions": {"expand_clique": {"args": ["candidates", "nays"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 30}, "calls": ["solutions.append", "candidates.copy", "compsub.copy", "candidates.remove", "get_connected", "compsub.append", "expand_clique", "nays.add", "compsub.pop"], "store_vars_calls": {"candidates_temp": "get_connected", "nays_temp": "get_connected"}, "source_code": "def expand_clique(candidates, nays):\n    nonlocal compsub\n    if not candidates and (not nays):\n        nonlocal solutions\n        solutions.append(compsub.copy())\n    else:\n        for selected in candidates.copy():\n            candidates.remove(selected)\n            candidates_temp = get_connected(selected, candidates)\n            nays_temp = get_connected(selected, nays)\n            compsub.append(selected)\n            expand_clique(candidates_temp, nays_temp)\n            nays.add(compsub.pop())"}, "get_connected": {"args": ["vertex", "old_set"], "returns": ["new_set"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 37}, "calls": ["set", "str", "set.add"], "store_vars_calls": {"new_set": "set"}, "source_code": "def get_connected(vertex, old_set):\n    new_set = set()\n    for neighbor in edges[str(vertex)]:\n        if neighbor in old_set:\n            new_set.add(neighbor)\n    return new_set"}}, "source_code": "def find_all_cliques(edges):\n    \"\"\"\n    takes dict of sets\n    each key is a vertex\n    value is set of all edges connected to vertex\n    returns list of lists (each sub list is a maximal clique)\n    implementation of the basic algorithm described in:\n    Bron, Coen; Kerbosch, Joep (1973), \"Algorithm 457: finding all cliques of an undirected graph\",\n    \"\"\"\n\n    def expand_clique(candidates, nays):\n        nonlocal compsub\n        if not candidates and (not nays):\n            nonlocal solutions\n            solutions.append(compsub.copy())\n        else:\n            for selected in candidates.copy():\n                candidates.remove(selected)\n                candidates_temp = get_connected(selected, candidates)\n                nays_temp = get_connected(selected, nays)\n                compsub.append(selected)\n                expand_clique(candidates_temp, nays_temp)\n                nays.add(compsub.pop())\n\n    def get_connected(vertex, old_set):\n        new_set = set()\n        for neighbor in edges[str(vertex)]:\n            if neighbor in old_set:\n                new_set.add(neighbor)\n        return new_set\n    compsub = []\n    solutions = []\n    possibles = set(edges.keys())\n    expand_clique(possibles, set())\n    return solutions"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/maximum_flow_dfs.py", "fileNameBase": "maximum_flow_dfs", "extension": "py", "doc": {"long_description": "it will give you a maximum flow.\nThis version use DFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23", "short_description": "Given a n*n adjacency array.", "full": "Given a n*n adjacency array.\nit will give you a maximum flow.\nThis version use DFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23"}}, "dependencies": [{"import": "copy", "type": "external", "type_element": "module"}, {"import": "math", "type": "external", "type_element": "module"}], "functions": {"maximum_flow_dfs": {"doc": {"short_description": "Get the maximum flow through a graph using a depth first search"}, "args": ["adjacency_matrix"], "returns": ["total"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 88}, "calls": ["copy.deepcopy", "stack.append", "len", "stack.pop", "range"], "store_vars_calls": {"new_array": "copy.deepcopy", "src": "stack.pop"}, "source_code": "def maximum_flow_dfs(adjacency_matrix):\n    \"\"\"\n    Get the maximum flow through a graph using a depth first search\n    \"\"\"\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        stack = []\n        visited[0] = 1\n        stack.append(0)\n        while len(stack) > 0:\n            src = stack.pop()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    stack.append(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min > new_array[path[tmp]][tmp]:\n                min = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min\n            tmp = path[tmp]\n        total = total + min\n    return total"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/transitive_closure_dfs.py", "fileNameBase": "transitive_closure_dfs", "extension": "py", "doc": {"long_description": "reference: https://en.wikipedia.org/wiki/Transitive_closure#In_graph_theory", "short_description": "Finds the transitive closure of a graph.", "full": "Finds the transitive closure of a graph.\n\nreference: https://en.wikipedia.org/wiki/Transitive_closure#In_graph_theory"}}, "classes": {"Graph": {"doc": {"short_description": "This class represents a directed graph using adjacency lists", "full": "This class represents a directed graph using adjacency lists"}, "min_max_lineno": {"min_lineno": 7, "max_lineno": 56}, "methods": {"__init__": {"args": ["self", "vertices"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 20}, "calls": ["range"], "source_code": "def __init__(self, vertices):\n    self.vertex_count = vertices\n    self.graph = {}\n    self.closure = [[0 for j in range(vertices)] for i in range(vertices)]"}, "add_edge": {"doc": {"short_description": "Adds a directed edge to the graph"}, "args": ["self", "source", "target"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 29}, "calls": ["transitive_closure_dfs.Graph.graph[].append"], "source_code": "def add_edge(self, source, target):\n    \"\"\"\n        Adds a directed edge to the graph\n        \"\"\"\n    if source in self.graph:\n        self.graph[source].append(target)\n    else:\n        self.graph[source] = [target]"}, "dfs_util": {"doc": {"long_description": "all reachable vertices for source", "short_description": "A recursive DFS traversal function that finds"}, "args": ["self", "source", "target"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 43}, "calls": ["transitive_closure_dfs.Graph.dfs_util"], "source_code": "def dfs_util(self, source, target):\n    \"\"\"\n        A recursive DFS traversal function that finds\n        all reachable vertices for source\n        \"\"\"\n    self.closure[source][target] = 1\n    for adjacent in self.graph[target]:\n        if self.closure[source][adjacent] == 0:\n            self.dfs_util(source, adjacent)"}, "transitive_closure": {"doc": {"long_description": "recursive dfs_util()", "short_description": "The function to find transitive closure. It uses"}, "args": ["self"], "returns": ["self.closure"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 56}, "calls": ["range", "transitive_closure_dfs.Graph.dfs_util"], "source_code": "def transitive_closure(self):\n    \"\"\"\n        The function to find transitive closure. It uses\n        recursive dfs_util()\n        \"\"\"\n    for i in range(self.vertex_count):\n        self.dfs_util(i, i)\n    return self.closure"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/bellman_ford.py", "fileNameBase": "bellman_ford", "extension": "py", "doc": {"short_description": "Determination of single-source shortest-path.", "full": "Determination of single-source shortest-path."}}, "functions": {"bellman_ford": {"doc": {"long_description": "shortest path from given graph or not for single-source shortest-paths problem.\nIn other words, if given graph has any negative-weight cycle that is reachable\nfrom the source, then it will give answer False for \"no solution exits\".\nFor argument graph, it should be a dictionary type\nsuch as\ngraph = {\n    'a': {'b': 6, 'e': 7},\n    'b': {'c': 5, 'd': -4, 'e': 8},\n    'c': {'b': -2},\n    'd': {'a': 2, 'c': 7},\n    'e': {'b': -3}\n}", "short_description": "This Bellman-Ford Code is for determination whether we can get"}, "args": ["graph", "source"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 39}, "calls": ["bellman_ford.initialize_single_source", "range", "len"], "source_code": "def bellman_ford(graph, source):\n    \"\"\"\n    This Bellman-Ford Code is for determination whether we can get\n    shortest path from given graph or not for single-source shortest-paths problem.\n    In other words, if given graph has any negative-weight cycle that is reachable\n    from the source, then it will give answer False for \"no solution exits\".\n    For argument graph, it should be a dictionary type\n    such as\n    graph = {\n        'a': {'b': 6, 'e': 7},\n        'b': {'c': 5, 'd': -4, 'e': 8},\n        'c': {'b': -2},\n        'd': {'a': 2, 'c': 7},\n        'e': {'b': -3}\n    }\n    \"\"\"\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True"}, "initialize_single_source": {"doc": {"short_description": "Initialize data structures for Bellman-Ford algorithm."}, "args": ["graph", "source", "weight", "pre_node"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 49}, "calls": ["float"], "source_code": "def initialize_single_source(graph, source, weight, pre_node):\n    \"\"\"\n    Initialize data structures for Bellman-Ford algorithm.\n    \"\"\"\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/check_digraph_strongly_connected.py", "fileNameBase": "check_digraph_strongly_connected", "extension": "py", "doc": {"long_description": "that for any pairs of vertices u and v there exists a path (u-...-v) that\nconnects them. A graph is strongly connected if it is a single strongly\nconnected component.", "short_description": "In a directed graph, a strongly connected component is a set of vertices such", "full": "In a directed graph, a strongly connected component is a set of vertices such\nthat for any pairs of vertices u and v there exists a path (u-...-v) that\nconnects them. A graph is strongly connected if it is a single strongly\nconnected component."}}, "dependencies": [{"from_module": "collections", "import": "defaultdict", "type": "external", "type_element": "module"}], "classes": {"Graph": {"doc": {"short_description": "A directed graph where edges are one-way (a two-way edge can be represented by using two edges).", "full": "A directed graph where edges are one-way (a two-way edge can be represented by using two edges)."}, "min_max_lineno": {"min_lineno": 10, "max_lineno": 70}, "methods": {"__init__": {"doc": {"short_description": "Create a new graph with vertex_count vertices."}, "args": ["self", "vertex_count"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 22}, "calls": ["collections.defaultdict"], "store_vars_calls": {"self.graph": "defaultdict"}, "source_code": "def __init__(self, vertex_count):\n    \"\"\"\n        Create a new graph with vertex_count vertices.\n        \"\"\"\n    self.vertex_count = vertex_count\n    self.graph = defaultdict(list)"}, "add_edge": {"doc": {"short_description": "Add an edge going from source to target"}, "args": ["self", "source", "target"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 28}, "calls": ["check_digraph_strongly_connected.Graph.graph[].append"], "source_code": "def add_edge(self, source, target):\n    \"\"\"\n        Add an edge going from source to target\n        \"\"\"\n    self.graph[source].append(target)"}, "dfs": {"doc": {"short_description": "Determine if all nodes are reachable from node 0"}, "args": ["self"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 38}, "calls": ["check_digraph_strongly_connected.Graph.dfs_util"], "source_code": "def dfs(self):\n    \"\"\"\n        Determine if all nodes are reachable from node 0\n        \"\"\"\n    visited = [False] * self.vertex_count\n    self.dfs_util(0, visited)\n    if visited == [True] * self.vertex_count:\n        return True\n    return False"}, "dfs_util": {"doc": {"short_description": "Determine if all nodes are reachable from the given node"}, "args": ["self", "source", "visited"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 47}, "calls": ["check_digraph_strongly_connected.Graph.dfs_util"], "source_code": "def dfs_util(self, source, visited):\n    \"\"\"\n        Determine if all nodes are reachable from the given node\n        \"\"\"\n    visited[source] = True\n    for adjacent in self.graph[source]:\n        if not visited[adjacent]:\n            self.dfs_util(adjacent, visited)"}, "reverse_graph": {"doc": {"short_description": "Create a new graph where every edge a->b is replaced with an edge b->a"}, "args": ["self"], "returns": ["reverse_graph"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 59}, "calls": ["check_digraph_strongly_connected.Graph.graph.items", "check_digraph_strongly_connected.Graph.add_edge"], "store_vars_calls": {"reverse_graph": "Graph"}, "source_code": "def reverse_graph(self):\n    \"\"\"\n        Create a new graph where every edge a->b is replaced with an edge b->a\n        \"\"\"\n    reverse_graph = Graph(self.vertex_count)\n    for (source, adjacent) in self.graph.items():\n        for target in adjacent:\n            reverse_graph.add_edge(target, source)\n    return reverse_graph"}, "is_strongly_connected": {"doc": {"short_description": "Determine if the graph is strongly connected."}, "args": ["self"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 61, "max_lineno": 70}, "calls": ["check_digraph_strongly_connected.Graph.dfs", "check_digraph_strongly_connected.Graph.reverse_graph", "check_digraph_strongly_connected.Graph.dfs"], "store_vars_calls": {"reversed_graph": "self.reverse_graph"}, "source_code": "def is_strongly_connected(self):\n    \"\"\"\n        Determine if the graph is strongly connected.\n        \"\"\"\n    if self.dfs():\n        reversed_graph = self.reverse_graph()\n        if reversed_graph.dfs():\n            return True\n    return False"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/prims_minimum_spanning.py", "fileNameBase": "prims_minimum_spanning", "extension": "py", "doc": {"long_description": "of a connected graph.\nFor argument graph, it should be a dictionary type such as:\n\n    graph = {\n        'a': [ [3, 'b'], [8,'c'] ],\n        'b': [ [3, 'a'], [5, 'd'] ],\n        'c': [ [8, 'a'], [2, 'd'], [4, 'e'] ],\n        'd': [ [5, 'b'], [2, 'c'], [6, 'e'] ],\n        'e': [ [4, 'c'], [6, 'd'] ]\n    }\n\nwhere 'a','b','c','d','e' are nodes (these can be 1,2,3,4,5 as well)", "short_description": "This Prim's Algorithm Code is for finding weight of minimum spanning tree", "full": "This Prim's Algorithm Code is for finding weight of minimum spanning tree\nof a connected graph.\nFor argument graph, it should be a dictionary type such as:\n\n    graph = {\n        'a': [ [3, 'b'], [8,'c'] ],\n        'b': [ [3, 'a'], [5, 'd'] ],\n        'c': [ [8, 'a'], [2, 'd'], [4, 'e'] ],\n        'd': [ [5, 'b'], [2, 'c'], [6, 'e'] ],\n        'e': [ [4, 'c'], [6, 'd'] ]\n    }\n\nwhere 'a','b','c','d','e' are nodes (these can be 1,2,3,4,5 as well)"}}, "dependencies": [{"import": "heapq", "type": "external", "type_element": "module"}], "functions": {"prims_minimum_spanning": {"doc": {"short_description": "Prim's algorithm to find weight of minimum spanning tree"}, "args": ["graph_used"], "returns": ["mincost"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 43}, "calls": ["set", "len", "heapq.heappop", "set.add", "vis.append", "heapq.heappush"], "store_vars_calls": {"prim": "set"}, "source_code": "def prims_minimum_spanning(graph_used):\n    \"\"\"\n    Prim's algorithm to find weight of minimum spanning tree\n    \"\"\"\n    vis = []\n    heap = [[0, 1]]\n    prim = set()\n    mincost = 0\n    while len(heap) > 0:\n        (cost, node) = heapq.heappop(heap)\n        if node in vis:\n            continue\n        mincost += cost\n        prim.add(node)\n        vis.append(node)\n        for (distance, adjacent) in graph_used[node]:\n            if adjacent not in vis:\n                heapq.heappush(heap, [distance, adjacent])\n    return mincost"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/minimum_spanning_tree.py", "fileNameBase": "minimum_spanning_tree", "extension": "py", "doc": {"short_description": "Minimum spanning tree (MST) is going to use an undirected graph", "full": "Minimum spanning tree (MST) is going to use an undirected graph"}}, "dependencies": [{"import": "sys", "type": "external", "type_element": "module"}], "classes": {"Edge": {"doc": {"short_description": "An edge of an undirected graph", "full": "An edge of an undirected graph"}, "min_max_lineno": {"min_lineno": 8, "max_lineno": 17}, "methods": {"__init__": {"args": ["self", "source", "target", "weight"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 17}, "source_code": "def __init__(self, source, target, weight):\n    self.source = source\n    self.target = target\n    self.weight = weight"}}}, "DisjointSet": {"doc": {"long_description": "<n[i]> is the parent of the node at position <i>.\nIf <n[i]> = <i>, <i> it's a root, or a head, of a set", "short_description": "The disjoint set is represented with an list <n> of integers where", "full": "The disjoint set is represented with an list <n> of integers where\n<n[i]> is the parent of the node at position <i>.\nIf <n[i]> = <i>, <i> it's a root, or a head, of a set"}, "min_max_lineno": {"min_lineno": 19, "max_lineno": 68}, "methods": {"__init__": {"doc": {"long_description": "n (int): Number of vertices in the graph", "short_description": "Args:"}, "args": ["self", "size"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 36}, "calls": ["range"], "source_code": "def __init__(self, size):\n    \"\"\"\n        Args:\n            n (int): Number of vertices in the graph\n        \"\"\"\n    self.parent = [None] * size\n    self.size = [1] * size\n    for i in range(size):\n        self.parent[i] = i"}, "merge_set": {"doc": {"long_description": "node1, node2 (int): Indexes of nodes whose sets will be merged.", "short_description": "Args:"}, "args": ["self", "node1", "node2"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 55}, "calls": ["minimum_spanning_tree.DisjointSet.find_set"], "store_vars_calls": {"node1": "self.find_set", "node2": "self.find_set"}, "source_code": "def merge_set(self, node1, node2):\n    \"\"\"\n        Args:\n            node1, node2 (int): Indexes of nodes whose sets will be merged.\n        \"\"\"\n    node1 = self.find_set(node1)\n    node2 = self.find_set(node2)\n    if self.size[node1] < self.size[node2]:\n        self.parent[node1] = node2\n        self.size[node2] += self.size[node1]\n    else:\n        self.parent[node2] = node1\n        self.size[node1] += self.size[node2]"}, "find_set": {"doc": {"short_description": "Get the root element of the set containing <a>"}, "args": ["self", "node"], "returns": ["self.parent[node]"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 68}, "calls": ["minimum_spanning_tree.DisjointSet.find_set"], "source_code": "def find_set(self, node):\n    \"\"\"\n        Get the root element of the set containing <a>\n        \"\"\"\n    if self.parent[node] != node:\n        self.parent[node] = self.find_set(self.parent[node])\n    return self.parent[node]"}}}}, "functions": {"kruskal": {"doc": {"args": {"vertex_count": {"description": "Number of vertices in the graph", "type_name": "int", "is_optional": false}, "edges": {"description": "Edges of the graph", "type_name": "list of Edge", "is_optional": false}, "forest": {"description": "DisjointSet of the vertices", "type_name": "DisjointSet", "is_optional": false}}, "returns": {"description": "sum of weights of the minnimum spanning tree\nKruskal algorithm:\n    This algorithm will find the optimal graph with less edges and less\n    total weight to connect all vertices (MST), the MST will always contain\n    n-1 edges because it's the minimum required to connect n vertices.\n\nProcedure:\n    Sort the edges (criteria: less weight).\n    Only take edges of nodes in different sets.\n    If we take a edge, we need to merge the sets to discard these.\n    After repeat this until select n-1 edges, we will have the complete MST.", "type_name": "int", "is_generator": false}}, "args": ["vertex_count", "edges", "forest"], "returns": ["sum([edge.weight for edge in mst])"], "min_max_lineno": {"min_lineno": 70, "max_lineno": 106}, "calls": ["edges.sort", "sum", "forest.find_set", "forest.merge_set", "mst.append", "len"], "store_vars_calls": {"set_u": "forest.find_set", "set_v": "forest.find_set"}, "source_code": "def kruskal(vertex_count, edges, forest):\n    \"\"\"\n    Args:\n        vertex_count (int): Number of vertices in the graph\n        edges (list of Edge): Edges of the graph\n        forest (DisjointSet): DisjointSet of the vertices\n    Returns:\n        int: sum of weights of the minnimum spanning tree\n\n    Kruskal algorithm:\n        This algorithm will find the optimal graph with less edges and less\n        total weight to connect all vertices (MST), the MST will always contain\n        n-1 edges because it's the minimum required to connect n vertices.\n\n    Procedure:\n        Sort the edges (criteria: less weight).\n        Only take edges of nodes in different sets.\n        If we take a edge, we need to merge the sets to discard these.\n        After repeat this until select n-1 edges, we will have the complete MST.\n    \"\"\"\n    edges.sort(key=lambda edge: edge.weight)\n    mst = []\n    for edge in edges:\n        set_u = forest.find_set(edge.u)\n        set_v = forest.find_set(edge.v)\n        if set_u != set_v:\n            forest.merge_set(set_u, set_v)\n            mst.append(edge)\n            if len(mst) == vertex_count - 1:\n                break\n    return sum([edge.weight for edge in mst])"}, "main": {"doc": {"long_description": "Input consists of different weighted, connected, undirected graphs.\nline 1:\n  integers n, m\nlines 2..m+2:\n  edge with the format -> node index u, node index v, integer weight\n\nSamples of input:\n\n5 6\n1 2 3\n1 3 8\n2 4 5\n3 4 2\n3 5 4\n4 5 6\n\n3 3\n2 1 20\n3 1 20\n2 3 100\n\nSum of weights of the optimal paths:\n14, 40", "short_description": "Test. How input works:"}, "min_max_lineno": {"min_lineno": 108, "max_lineno": 149}, "calls": ["map", "range", "print", "size.split", "minimum_spanning_tree.kruskal", "input().split", "input"], "store_vars_calls": {"forest": "DisjointSet"}, "source_code": "def main():\n    \"\"\"\n    Test. How input works:\n    Input consists of different weighted, connected, undirected graphs.\n    line 1:\n      integers n, m\n    lines 2..m+2:\n      edge with the format -> node index u, node index v, integer weight\n\n    Samples of input:\n\n    5 6\n    1 2 3\n    1 3 8\n    2 4 5\n    3 4 2\n    3 5 4\n    4 5 6\n\n    3 3\n    2 1 20\n    3 1 20\n    2 3 100\n\n    Sum of weights of the optimal paths:\n    14, 40\n    \"\"\"\n    for size in sys.stdin:\n        (vertex_count, edge_count) = map(int, size.split())\n        forest = DisjointSet(edge_count)\n        edges = [None] * edge_count\n        for i in range(edge_count):\n            (source, target, weight) = map(int, input().split())\n            source -= 1\n            target -= 1\n            edges[i] = Edge(source, target, weight)\n        print('MST weights sum:', kruskal(vertex_count, edges, forest))"}}, "body": {"calls": ["minimum_spanning_tree.main"], "source_code": ["main()"]}, "main_info": {"main_flag": 1, "main_function": "minimum_spanning_tree.main", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/__init__.py", "fileNameBase": "__init__", "extension": "py", "doc": {"short_description": "Collection of algorithms on graphs.", "full": "Collection of algorithms on graphs."}}, "dependencies": [{"from_module": "tarjan", "import": "Tarjan", "type": "internal", "type_element": "class"}, {"from_module": "check_bipartite", "import": "check_bipartite", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "dfs", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "ford_fulkerson", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "edmonds_karp", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "dinic_bfs", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "dinic_dfs", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "dinic", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow_bfs", "import": "maximum_flow_bfs", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow_dfs", "import": "maximum_flow_dfs", "type": "internal", "type_element": "function"}, {"from_module": "all_pairs_shortest_path", "import": "all_pairs_shortest_path", "type": "internal", "type_element": "function"}, {"from_module": "bellman_ford", "import": "bellman_ford", "type": "internal", "type_element": "function"}, {"from_module": "bellman_ford", "import": "initialize_single_source", "type": "internal", "type_element": "function"}, {"from_module": "prims_minimum_spanning", "import": "prims_minimum_spanning", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/graph.py", "fileNameBase": "graph", "extension": "py", "doc": {"long_description": "It can be shared across graph algorithms.", "short_description": "These are classes to represent a Graph and its elements.", "full": "These are classes to represent a Graph and its elements.\nIt can be shared across graph algorithms."}}, "classes": {"Node": {"doc": {"short_description": "A node/vertex in a graph.", "full": "A node/vertex in a graph."}, "min_max_lineno": {"min_lineno": 6, "max_lineno": 51}, "methods": {"__init__": {"args": ["self", "name"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 13}, "source_code": "def __init__(self, name):\n    self.name = name"}, "get_name": {"doc": {"short_description": "Return the name of the node"}, "args": ["obj"], "returns": ["''", "obj.name", "obj"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 24}, "calls": ["isinstance"], "source_code": "@staticmethod\ndef get_name(obj):\n    \"\"\"\n        Return the name of the node\n        \"\"\"\n    if isinstance(obj, Node):\n        return obj.name\n    if isinstance(obj, str):\n        return obj\n    return ''"}, "__eq__": {"args": ["self", "obj"], "returns": ["self.name == self.get_name(obj)"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 27}, "calls": ["graph.Node.get_name"], "source_code": "def __eq__(self, obj):\n    return self.name == self.get_name(obj)"}, "__repr__": {"args": ["self"], "returns": ["self.name"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 30}, "source_code": "def __repr__(self):\n    return self.name"}, "__hash__": {"args": ["self"], "returns": ["hash(self.name)"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 33}, "calls": ["hash"], "source_code": "def __hash__(self):\n    return hash(self.name)"}, "__ne__": {"args": ["self", "obj"], "returns": ["self.name != self.get_name(obj)"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 36}, "calls": ["graph.Node.get_name"], "source_code": "def __ne__(self, obj):\n    return self.name != self.get_name(obj)"}, "__lt__": {"args": ["self", "obj"], "returns": ["self.name < self.get_name(obj)"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 39}, "calls": ["graph.Node.get_name"], "source_code": "def __lt__(self, obj):\n    return self.name < self.get_name(obj)"}, "__le__": {"args": ["self", "obj"], "returns": ["self.name <= self.get_name(obj)"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 42}, "calls": ["graph.Node.get_name"], "source_code": "def __le__(self, obj):\n    return self.name <= self.get_name(obj)"}, "__gt__": {"args": ["self", "obj"], "returns": ["self.name > self.get_name(obj)"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 45}, "calls": ["graph.Node.get_name"], "source_code": "def __gt__(self, obj):\n    return self.name > self.get_name(obj)"}, "__ge__": {"args": ["self", "obj"], "returns": ["self.name >= self.get_name(obj)"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 48}, "calls": ["graph.Node.get_name"], "source_code": "def __ge__(self, obj):\n    return self.name >= self.get_name(obj)"}, "__bool__": {"args": ["self"], "returns": ["self.name"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 51}, "source_code": "def __bool__(self):\n    return self.name"}}}, "DirectedEdge": {"doc": {"long_description": "Stores the source and target node of the edge.", "short_description": "A directed edge in a directed graph.", "full": "A directed edge in a directed graph.\nStores the source and target node of the edge."}, "min_max_lineno": {"min_lineno": 52, "max_lineno": 69}, "methods": {"__init__": {"args": ["self", "node_from", "node_to"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 61}, "source_code": "def __init__(self, node_from, node_to):\n    self.source = node_from\n    self.target = node_to"}, "__eq__": {"args": ["self", "obj"], "returns": ["False", "obj.source == self.source and obj.target == self.target"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 66}, "calls": ["isinstance"], "source_code": "def __eq__(self, obj):\n    if isinstance(obj, DirectedEdge):\n        return obj.source == self.source and obj.target == self.target\n    return False"}, "__repr__": {"args": ["self"], "returns": ["f'({self.source} -> {self.target})'"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 69}, "source_code": "def __repr__(self):\n    return f'({self.source} -> {self.target})'"}}}, "DirectedGraph": {"doc": {"long_description": "Stores a set of nodes, edges and adjacency matrix.", "short_description": "A directed graph.", "full": "A directed graph.\nStores a set of nodes, edges and adjacency matrix."}, "min_max_lineno": {"min_lineno": 70, "max_lineno": 112}, "methods": {"__init__": {"args": ["self", "load_dict"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 90}, "calls": ["isinstance", "graph.DirectedGraph.add_node", "graph.DirectedGraph.adjacency_list[].append", "graph.DirectedGraph.add_edge"], "store_vars_calls": {"node_from": "self.add_node", "node_to": "self.add_node"}, "source_code": "def __init__(self, load_dict={}):\n    self.nodes = []\n    self.edges = []\n    self.adjacency_list = {}\n    if load_dict and isinstance(load_dict, dict):\n        for vertex in load_dict:\n            node_from = self.add_node(vertex)\n            self.adjacency_list[node_from] = []\n            for neighbor in load_dict[vertex]:\n                node_to = self.add_node(neighbor)\n                self.adjacency_list[node_from].append(node_to)\n                self.add_edge(vertex, neighbor)"}, "add_node": {"doc": {"short_description": "Add a new named node to the graph."}, "args": ["self", "node_name"], "returns": ["self.nodes[self.nodes.index(node_name)]", "node"], "min_max_lineno": {"min_lineno": 91, "max_lineno": 101}, "calls": ["graph.DirectedGraph.nodes.index", "graph.DirectedGraph.nodes.append"], "store_vars_calls": {"node": "Node"}, "source_code": "def add_node(self, node_name):\n    \"\"\"\n        Add a new named node to the graph.\n        \"\"\"\n    try:\n        return self.nodes[self.nodes.index(node_name)]\n    except ValueError:\n        node = Node(node_name)\n        self.nodes.append(node)\n        return node"}, "add_edge": {"doc": {"short_description": "Add a new edge to the graph between two nodes."}, "args": ["self", "node_name_from", "node_name_to"], "min_max_lineno": {"min_lineno": 102, "max_lineno": 112}, "calls": ["graph.DirectedGraph.edges.append", "graph.DirectedGraph.nodes.index"], "source_code": "def add_edge(self, node_name_from, node_name_to):\n    \"\"\"\n        Add a new edge to the graph between two nodes.\n        \"\"\"\n    try:\n        node_from = self.nodes[self.nodes.index(node_name_from)]\n        node_to = self.nodes[self.nodes.index(node_name_to)]\n        self.edges.append(DirectedEdge(node_from, node_to))\n    except ValueError:\n        pass"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/tarjan.py", "fileNameBase": "tarjan", "extension": "py", "doc": {"long_description": "in a graph.\nhttps://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm", "short_description": "Implements Tarjan's algorithm for finding strongly connected components", "full": "Implements Tarjan's algorithm for finding strongly connected components\nin a graph.\nhttps://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm"}}, "dependencies": [{"from_module": "algorithms.graph.graph", "import": "DirectedGraph", "type": "external", "type_element": "module"}], "classes": {"Tarjan": {"doc": {"short_description": "A directed graph used for finding strongly connected components", "full": "A directed graph used for finding strongly connected components"}, "min_max_lineno": {"min_lineno": 10, "max_lineno": 66}, "methods": {"__init__": {"args": ["self", "dict_graph"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 28}, "calls": ["algorithms.graph.graph.DirectedGraph", "tarjan.Tarjan.strongconnect"], "store_vars_calls": {"self.graph": "DirectedGraph"}, "source_code": "def __init__(self, dict_graph):\n    self.graph = DirectedGraph(dict_graph)\n    self.index = 0\n    self.stack = []\n    for vertex in self.graph.nodes:\n        vertex.index = None\n    self.sccs = []\n    for vertex in self.graph.nodes:\n        if vertex.index is None:\n            self.strongconnect(vertex, self.sccs)"}, "strongconnect": {"doc": {"short_description": "Given a vertex, adds all successors of the given vertex to the same connected component"}, "args": ["self", "vertex", "sccs"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 66}, "calls": ["tarjan.Tarjan.stack.append", "scc.sort", "sccs.append", "tarjan.Tarjan.strongconnect", "min", "tarjan.Tarjan.stack.pop", "scc.append"], "store_vars_calls": {"vertex.lowlink": "min", "adjacent": "self.stack.pop"}, "source_code": "def strongconnect(self, vertex, sccs):\n    \"\"\"\n        Given a vertex, adds all successors of the given vertex to the same connected component\n        \"\"\"\n    vertex.index = self.index\n    vertex.lowlink = self.index\n    self.index += 1\n    self.stack.append(vertex)\n    vertex.on_stack = True\n    for adjacent in self.graph.adjacency_list[vertex]:\n        if adjacent.index is None:\n            self.strongconnect(adjacent, sccs)\n            vertex.lowlink = min(vertex.lowlink, adjacent.lowlink)\n        elif adjacent.on_stack:\n            vertex.lowlink = min(vertex.lowlink, adjacent.index)\n    if vertex.lowlink == vertex.index:\n        scc = []\n        while True:\n            adjacent = self.stack.pop()\n            adjacent.on_stack = False\n            scc.append(adjacent)\n            if adjacent == vertex:\n                break\n        scc.sort()\n        sccs.append(scc)"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/markov_chain.py", "fileNameBase": "markov_chain", "extension": "py", "doc": {"long_description": "my_chain = {\n    'A': {'A': 0.6,\n          'E': 0.4},\n    'E': {'A': 0.7,\n          'E': 0.3}\n}", "short_description": "Implements a markov chain. Chains are described using a dictionary:", "full": "Implements a markov chain. Chains are described using a dictionary:\n\n    my_chain = {\n        'A': {'A': 0.6,\n              'E': 0.4},\n        'E': {'A': 0.7,\n              'E': 0.3}\n    }"}}, "dependencies": [{"import": "random", "type": "external", "type_element": "module"}], "functions": {"__choose_state": {"doc": {"short_description": "Choose the next state randomly"}, "args": ["state_map"], "returns": ["None", "state"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 25}, "calls": ["random.random", "state_map.items"], "store_vars_calls": {"choice": "random.random"}, "source_code": "def __choose_state(state_map):\n    \"\"\"\n    Choose the next state randomly\n    \"\"\"\n    choice = random.random()\n    probability_reached = 0\n    for (state, probability) in state_map.items():\n        probability_reached += probability\n        if probability_reached > choice:\n            return state\n    return None"}, "next_state": {"doc": {"short_description": "Given a markov-chain, randomly chooses the next state given the current state."}, "args": ["chain", "current_state"], "returns": ["__choose_state(next_state_map)"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 32}, "calls": ["chain.get", "markov_chain.__choose_state"], "store_vars_calls": {"next_state_map": "chain.get"}, "source_code": "def next_state(chain, current_state):\n    \"\"\"\n    Given a markov-chain, randomly chooses the next state given the current state.\n    \"\"\"\n    next_state_map = chain.get(current_state)\n    return __choose_state(next_state_map)"}, "iterating_markov_chain": {"doc": {"short_description": "Yield a sequence of states given a markov chain and the initial state"}, "args": ["chain", "state"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 40}, "calls": ["markov_chain.next_state"], "store_vars_calls": {"state": "next_state"}, "source_code": "def iterating_markov_chain(chain, state):\n    \"\"\"\n    Yield a sequence of states given a markov chain and the initial state\n    \"\"\"\n    while True:\n        state = next_state(chain, state)\n        yield state"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/dijkstra.py", "fileNameBase": "dijkstra", "extension": "py", "doc": {"short_description": "Dijkstra's single-source shortest-path algorithm", "full": "Dijkstra's single-source shortest-path algorithm"}}, "classes": {"Dijkstra": {"doc": {"short_description": "A fully connected directed graph with edge weights", "full": "A fully connected directed graph with edge weights"}, "min_max_lineno": {"min_lineno": 5, "max_lineno": 50}, "methods": {"__init__": {"args": ["self", "vertex_count"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 13}, "calls": ["range"], "source_code": "def __init__(self, vertex_count):\n    self.vertex_count = vertex_count\n    self.graph = [[0 for _ in range(vertex_count)] for _ in range(vertex_count)]"}, "min_distance": {"doc": {"short_description": "Find the vertex that is closest to the visited set"}, "args": ["self", "dist", "min_dist_set"], "returns": ["min_index"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 26}, "calls": ["float", "range"], "store_vars_calls": {"min_dist": "float"}, "source_code": "def min_distance(self, dist, min_dist_set):\n    \"\"\"\n        Find the vertex that is closest to the visited set\n        \"\"\"\n    min_dist = float('inf')\n    for target in range(self.vertex_count):\n        if min_dist_set[target]:\n            continue\n        if dist[target] < min_dist:\n            min_dist = dist[target]\n            min_index = target\n    return min_index"}, "dijkstra": {"doc": {"short_description": "Given a node, returns the shortest distance to every other node"}, "args": ["self", "src"], "returns": ["dist"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 50}, "calls": ["range", "dijkstra.Dijkstra.min_distance", "float"], "store_vars_calls": {"source": "self.min_distance"}, "source_code": "def dijkstra(self, src):\n    \"\"\"\n        Given a node, returns the shortest distance to every other node\n        \"\"\"\n    dist = [float('inf')] * self.vertex_count\n    dist[src] = 0\n    min_dist_set = [False] * self.vertex_count\n    for _ in range(self.vertex_count):\n        source = self.min_distance(dist, min_dist_set)\n        min_dist_set[source] = True\n        for target in range(self.vertex_count):\n            if self.graph[source][target] <= 0 or min_dist_set[target]:\n                continue\n            if dist[target] > dist[source] + self.graph[source][target]:\n                dist[target] = dist[source] + self.graph[source][target]\n    return dist"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/count_connected_number_of_component.py", "fileNameBase": "count_connected_number_of_component", "extension": "py", "doc": {"long_description": "of an undirected graph is a subgraph in which any\ntwo vertices are connected to each other by paths.", "short_description": "In graph theory, a component, sometimes called a connected component,", "full": "In graph theory, a component, sometimes called a connected component,\nof an undirected graph is a subgraph in which any\ntwo vertices are connected to each other by paths.\n\nExample:\n\n\n    1                3------------7\n    |\n    |\n    2--------4\n    |        |\n    |        |              output = 2\n    6--------5"}}, "functions": {"dfs": {"doc": {"short_description": "Function that performs DFS "}, "args": ["source", "visited", "adjacency_list"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 29}, "calls": ["count_connected_number_of_component.dfs"], "source_code": "def dfs(source, visited, adjacency_list):\n    \"\"\" Function that performs DFS \"\"\"\n    visited[source] = True\n    for child in adjacency_list[source]:\n        if not visited[child]:\n            dfs(child, visited, adjacency_list)"}, "count_components": {"doc": {"long_description": "return type : int", "short_description": "Function that counts the Connected components on bases of DFS."}, "args": ["adjacency_list", "size"], "returns": ["count"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 43}, "calls": ["range", "count_connected_number_of_component.dfs"], "source_code": "def count_components(adjacency_list, size):\n    \"\"\"\n    Function that counts the Connected components on bases of DFS.\n    return type : int\n    \"\"\"\n    count = 0\n    visited = [False] * (size + 1)\n    for i in range(1, size + 1):\n        if not visited[i]:\n            dfs(i, visited, adjacency_list)\n            count += 1\n    return count"}, "main": {"doc": {"short_description": "Example application"}, "min_max_lineno": {"min_lineno": 44, "max_lineno": 56}, "calls": ["map", "range", "print", "input().split", "adjacency[].append", "count_connected_number_of_component.count_components", "input"], "source_code": "def main():\n    \"\"\"\n    Example application\n    \"\"\"\n    (node_count, edge_count) = map(int, input('Enter the Number of Nodes and Edges \\n').split(' '))\n    adjacency = [[] for _ in range(node_count + 1)]\n    for _ in range(edge_count):\n        print(\"Enter the edge's Nodes in form of `source target`\\n\")\n        (source, target) = map(int, input().split(' '))\n        adjacency[source].append(target)\n        adjacency[target].append(source)\n    print('Total number of Connected Components are : ', count_components(adjacency, node_count))"}}, "body": {"calls": ["count_connected_number_of_component.main"], "source_code": ["main()"]}, "main_info": {"main_flag": 1, "main_function": "count_connected_number_of_component.main", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/all_pairs_shortest_path.py", "fileNameBase": "all_pairs_shortest_path", "extension": "py", "doc": {"long_description": "it will give you all pairs shortest path length.\nuse deepcopy to preserve the original information.\n\nTime complexity : O(E^3)\n\nexample\n\na = [[0    , 0.1  , 0.101, 0.142, 0.277],\n     [0.465, 0    , 0.191, 0.192, 0.587],\n     [0.245, 0.554, 0    , 0.333, 0.931],\n     [1.032, 0.668, 0.656, 0    , 0.151],\n     [0.867, 0.119, 0.352, 0.398, 0]]\n\nresult\n\n[[0    , 0.1  , 0.101, 0.142, 0.277],\n [0.436, 0    , 0.191, 0.192, 0.343],\n [0.245, 0.345, 0    , 0.333, 0.484],\n [0.706, 0.27 , 0.461, 0    , 0.151],\n [0.555, 0.119, 0.31 , 0.311, 0]]", "short_description": "Given a n*n adjacency array.", "full": "Given a n*n adjacency array.\nit will give you all pairs shortest path length.\nuse deepcopy to preserve the original information.\n\nTime complexity : O(E^3)\n\nexample\n\na = [[0    , 0.1  , 0.101, 0.142, 0.277],\n     [0.465, 0    , 0.191, 0.192, 0.587],\n     [0.245, 0.554, 0    , 0.333, 0.931],\n     [1.032, 0.668, 0.656, 0    , 0.151],\n     [0.867, 0.119, 0.352, 0.398, 0]]\n\nresult\n\n[[0    , 0.1  , 0.101, 0.142, 0.277],\n [0.436, 0    , 0.191, 0.192, 0.343],\n [0.245, 0.345, 0    , 0.333, 0.484],\n [0.706, 0.27 , 0.461, 0    , 0.151],\n [0.555, 0.119, 0.31 , 0.311, 0]]"}}, "dependencies": [{"import": "copy", "type": "external", "type_element": "module"}], "functions": {"all_pairs_shortest_path": {"doc": {"long_description": "matrix containing the shortest distance distance between the two nodes.", "short_description": "Given a matrix of the edge weights between respective nodes, returns a"}, "args": ["adjacency_matrix"], "returns": ["new_array"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 43}, "calls": ["copy.deepcopy", "len", "range"], "store_vars_calls": {"new_array": "copy.deepcopy", "size": "len"}, "source_code": "def all_pairs_shortest_path(adjacency_matrix):\n    \"\"\"\n    Given a matrix of the edge weights between respective nodes, returns a\n    matrix containing the shortest distance distance between the two nodes.\n    \"\"\"\n    new_array = copy.deepcopy(adjacency_matrix)\n    size = len(new_array)\n    for k in range(size):\n        for i in range(size):\n            for j in range(size):\n                if new_array[i][j] > new_array[i][k] + new_array[k][j]:\n                    new_array[i][j] = new_array[i][k] + new_array[k][j]\n    return new_array"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/traversal.py", "fileNameBase": "traversal", "extension": "py", "doc": {"short_description": "Different ways to traverse a graph", "full": "Different ways to traverse a graph"}}, "functions": {"dfs_traverse": {"doc": {"short_description": "Traversal by depth first search."}, "args": ["graph", "start"], "returns": ["visited"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 23}, "calls": ["set", "stack.pop", "visited.add", "stack.append"], "store_vars_calls": {"node": "stack.pop"}, "source_code": "def dfs_traverse(graph, start):\n    \"\"\"\n    Traversal by depth first search.\n    \"\"\"\n    (visited, stack) = (set(), [start])\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    stack.append(next_node)\n    return visited"}, "bfs_traverse": {"doc": {"short_description": "Traversal by breadth first search."}, "args": ["graph", "start"], "returns": ["visited"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 37}, "calls": ["set", "queue.pop", "visited.add", "queue.append"], "store_vars_calls": {"node": "queue.pop"}, "source_code": "def bfs_traverse(graph, start):\n    \"\"\"\n    Traversal by breadth first search.\n    \"\"\"\n    (visited, queue) = (set(), [start])\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    queue.append(next_node)\n    return visited"}, "dfs_traverse_recursive": {"doc": {"short_description": "Traversal by recursive depth first search."}, "args": ["graph", "start", "visited"], "returns": ["visited"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 49}, "calls": ["set.add", "set", "traversal.dfs_traverse_recursive"], "store_vars_calls": {"visited": "set"}, "source_code": "def dfs_traverse_recursive(graph, start, visited=None):\n    \"\"\"\n    Traversal by recursive depth first search.\n    \"\"\"\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for next_node in graph[start]:\n        if next_node not in visited:\n            dfs_traverse_recursive(graph, next_node, visited)\n    return visited"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/satisfiability.py", "fileNameBase": "satisfiability", "extension": "py", "doc": {"long_description": "True/False values to all variables to satisfy all clauses, or reports there\nis no solution.\n\nhttps://en.wikipedia.org/wiki/2-satisfiability\n\n\nFormat:\n        - each clause is a pair of literals\n        - each literal in the form (name, is_neg)\n          where name is an arbitrary identifier,\n          and is_neg is true if the literal is negated", "short_description": "Given a formula in conjunctive normal form (2-CNF), finds a way to assign", "full": "Given a formula in conjunctive normal form (2-CNF), finds a way to assign\nTrue/False values to all variables to satisfy all clauses, or reports there\nis no solution.\n\nhttps://en.wikipedia.org/wiki/2-satisfiability\n\n\nFormat:\n        - each clause is a pair of literals\n        - each literal in the form (name, is_neg)\n          where name is an arbitrary identifier,\n          and is_neg is true if the literal is negated"}}, "functions": {"dfs_transposed": {"doc": {"long_description": "Stores the order in which nodes were visited to the list, in transposed order.", "short_description": "Perform a depth first search traversal of the graph starting at the given vertex."}, "args": ["vertex", "graph", "order", "visited"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 28}, "calls": ["order.append", "satisfiability.dfs_transposed"], "source_code": "def dfs_transposed(vertex, graph, order, visited):\n    \"\"\"\n    Perform a depth first search traversal of the graph starting at the given vertex.\n    Stores the order in which nodes were visited to the list, in transposed order.\n    \"\"\"\n    visited[vertex] = True\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs_transposed(adjacent, graph, order, visited)\n    order.append(vertex)"}, "dfs": {"doc": {"long_description": "Records all visited nodes as being of a certain strongly connected component.", "short_description": "Perform a depth first search traversal of the graph starting at the given vertex."}, "args": ["vertex", "current_comp", "vertex_scc", "graph", "visited"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 41}, "calls": ["satisfiability.dfs"], "source_code": "def dfs(vertex, current_comp, vertex_scc, graph, visited):\n    \"\"\"\n    Perform a depth first search traversal of the graph starting at the given vertex.\n    Records all visited nodes as being of a certain strongly connected component.\n    \"\"\"\n    visited[vertex] = True\n    vertex_scc[vertex] = current_comp\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs(adjacent, current_comp, vertex_scc, graph, visited)"}, "add_edge": {"doc": {"short_description": "Add a directed edge to the graph."}, "args": ["graph", "vertex_from", "vertex_to"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 51}, "calls": ["graph[].append"], "source_code": "def add_edge(graph, vertex_from, vertex_to):\n    \"\"\"\n    Add a directed edge to the graph.\n    \"\"\"\n    if vertex_from not in graph:\n        graph[vertex_from] = []\n    graph[vertex_from].append(vertex_to)"}, "scc": {"doc": {"short_description": "Computes the strongly connected components of a graph "}, "args": ["graph"], "returns": ["vertex_scc"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 79}, "calls": ["graph.iteritems", "reversed", "satisfiability.add_edge", "satisfiability.dfs_transposed", "satisfiability.dfs"], "source_code": "def scc(graph):\n    \"\"\" Computes the strongly connected components of a graph \"\"\"\n    order = []\n    visited = {vertex: False for vertex in graph}\n    graph_transposed = {vertex: [] for vertex in graph}\n    for (source, neighbours) in graph.iteritems():\n        for target in neighbours:\n            add_edge(graph_transposed, target, source)\n    for vertex in graph:\n        if not visited[vertex]:\n            dfs_transposed(vertex, graph_transposed, order, visited)\n    visited = {vertex: False for vertex in graph}\n    vertex_scc = {}\n    current_comp = 0\n    for vertex in reversed(order):\n        if not visited[vertex]:\n            dfs(vertex, current_comp, vertex_scc, graph, visited)\n            current_comp += 1\n    return vertex_scc"}, "build_graph": {"doc": {"short_description": "Builds the implication graph from the formula "}, "args": ["formula"], "returns": ["graph"], "min_max_lineno": {"min_lineno": 81, "max_lineno": 95}, "calls": ["satisfiability.add_edge"], "source_code": "def build_graph(formula):\n    \"\"\" Builds the implication graph from the formula \"\"\"\n    graph = {}\n    for clause in formula:\n        for (lit, _) in clause:\n            for neg in [False, True]:\n                graph[lit, neg] = []\n    for ((a_lit, a_neg), (b_lit, b_neg)) in formula:\n        add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg))\n        add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg))\n    return graph"}, "solve_sat": {"doc": {"short_description": "Solves the 2-SAT problem"}, "args": ["formula"], "returns": ["value", "None"], "min_max_lineno": {"min_lineno": 97, "max_lineno": 127}, "calls": ["satisfiability.build_graph", "satisfiability.scc", "sorted", "scc.values"], "store_vars_calls": {"graph": "build_graph", "vertex_scc": "scc", "components": "sorted"}, "source_code": "def solve_sat(formula):\n    \"\"\"\n    Solves the 2-SAT problem\n    \"\"\"\n    graph = build_graph(formula)\n    vertex_scc = scc(graph)\n    for (var, _) in graph:\n        if vertex_scc[var, False] == vertex_scc[var, True]:\n            return None\n    comp_repr = {}\n    for vertex in graph:\n        if not vertex_scc[vertex] in comp_repr:\n            comp_repr[vertex_scc[vertex]] = vertex\n    comp_value = {}\n    components = sorted(vertex_scc.values())\n    for comp in components:\n        if comp not in comp_value:\n            comp_value[comp] = False\n            (lit, neg) = comp_repr[comp]\n            comp_value[vertex_scc[lit, not neg]] = True\n    value = {var: comp_value[vertex_scc[var, False]] for (var, _) in graph}\n    return value"}, "main": {"doc": {"short_description": "Entry point for testing"}, "min_max_lineno": {"min_lineno": 129, "max_lineno": 143}, "calls": ["satisfiability.solve_sat", "solve_sat.items", "print"], "store_vars_calls": {"result": "solve_sat"}, "source_code": "def main():\n    \"\"\"\n    Entry point for testing\n    \"\"\"\n    formula = [(('x', False), ('y', False)), (('y', True), ('y', True)), (('a', False), ('b', False)), (('a', True), ('c', True)), (('c', False), ('b', True))]\n    result = solve_sat(formula)\n    for (variable, assign) in result.items():\n        print(f'{variable}:{assign}')"}}, "body": {"calls": ["satisfiability.main"], "source_code": ["main()"]}, "main_info": {"main_flag": 1, "main_function": "satisfiability.main", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/clone_graph.py", "fileNameBase": "clone_graph", "extension": "py", "doc": {"long_description": "of its neighbors.\n\n\nOJ's undirected graph serialization:\nNodes are labeled uniquely.\n\nWe use # as a separator for each node, and , as a separator for node label and\neach neighbor of the node.\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\n\nThe graph has a total of three nodes, and therefore contains three parts as\nseparated by #.\n\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\nSecond node is labeled as 1. Connect node 1 to node 2.\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a\nself-cycle.\nVisually, the graph looks like the following:\n\n       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/", "short_description": "Clone an undirected graph. Each node in the graph contains a label and a list", "full": "Clone an undirected graph. Each node in the graph contains a label and a list\nof its neighbors.\n\n\nOJ's undirected graph serialization:\nNodes are labeled uniquely.\n\nWe use # as a separator for each node, and , as a separator for node label and\neach neighbor of the node.\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\n\nThe graph has a total of three nodes, and therefore contains three parts as\nseparated by #.\n\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\nSecond node is labeled as 1. Connect node 1 to node 2.\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a\nself-cycle.\nVisually, the graph looks like the following:\n\n       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "classes": {"UndirectedGraphNode": {"doc": {"long_description": "nodes (initially empty).", "short_description": "A node in an undirected graph. Contains a label and a list of neighbouring", "full": "A node in an undirected graph. Contains a label and a list of neighbouring\nnodes (initially empty)."}, "min_max_lineno": {"min_lineno": 32, "max_lineno": 53}, "methods": {"__init__": {"args": ["self", "label"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 41}, "source_code": "def __init__(self, label):\n    self.label = label\n    self.neighbors = []"}, "shallow_copy": {"doc": {"short_description": "Return a shallow copy of this node (ignoring any neighbors)"}, "args": ["self"], "returns": ["UndirectedGraphNode(self.label)"], "min_max_lineno": {"min_lineno": 42, "max_lineno": 47}, "source_code": "def shallow_copy(self):\n    \"\"\"\n        Return a shallow copy of this node (ignoring any neighbors)\n        \"\"\"\n    return UndirectedGraphNode(self.label)"}, "add_neighbor": {"doc": {"short_description": "Adds a new neighbor"}, "args": ["self", "node"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 53}, "calls": ["clone_graph.UndirectedGraphNode.neighbors.append"], "source_code": "def add_neighbor(self, node):\n    \"\"\"\n        Adds a new neighbor\n        \"\"\"\n    self.neighbors.append(node)"}}}}, "functions": {"clone_graph1": {"doc": {"short_description": "Returns a new graph as seen from the given node using a breadth first search (BFS)."}, "args": ["node"], "returns": ["node_copy", "None"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 75}, "calls": ["queue.popleft.shallow_copy", "collections.deque", "collections.deque.popleft", "neighbor.shallow_copy", "dic[].add_neighbor", "collections.deque.append"], "store_vars_calls": {"node_copy": "node.shallow_copy", "queue": "collections.deque", "node": "queue.popleft", "neighbor_copy": "neighbor.shallow_copy"}, "source_code": "def clone_graph1(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using a breadth first search (BFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    queue = collections.deque([node])\n    while queue:\n        node = queue.popleft()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                queue.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy"}, "clone_graph2": {"doc": {"short_description": "Returns a new graph as seen from the given node using an iterative depth first search (DFS)."}, "args": ["node"], "returns": ["node_copy", "None"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 97}, "calls": ["stack.pop.shallow_copy", "stack.pop", "neighbor.shallow_copy", "dic[].add_neighbor", "stack.append"], "store_vars_calls": {"node_copy": "node.shallow_copy", "node": "stack.pop", "neighbor_copy": "neighbor.shallow_copy"}, "source_code": "def clone_graph2(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using an iterative depth first search (DFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                stack.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy"}, "clone_graph": {"doc": {"short_description": "Returns a new graph as seen from the given node using a recursive depth first search (DFS)."}, "args": ["node"], "returns": ["node_copy", "None"], "min_max_lineno": {"min_lineno": 99, "max_lineno": 109}, "calls": ["node.shallow_copy", "clone_graph.dfs"], "store_vars_calls": {"node_copy": "node.shallow_copy"}, "source_code": "def clone_graph(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using a recursive depth first search (DFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    dfs(node, dic)\n    return node_copy"}, "dfs": {"doc": {"long_description": "the dictionary, keyed by the original nodes.", "short_description": "Clones a graph using a recursive depth first search. Stores the clones in"}, "args": ["node", "dic"], "min_max_lineno": {"min_lineno": 111, "max_lineno": 124}, "calls": ["neighbor.shallow_copy", "dic[].add_neighbor", "clone_graph.dfs"], "store_vars_calls": {"neighbor_copy": "neighbor.shallow_copy"}, "source_code": "def dfs(node, dic):\n    \"\"\"\n    Clones a graph using a recursive depth first search. Stores the clones in\n    the dictionary, keyed by the original nodes.\n    \"\"\"\n    for neighbor in node.neighbors:\n        if neighbor not in dic:\n            neighbor_copy = neighbor.shallow_copy()\n            dic[neighbor] = neighbor_copy\n            dic[node].add_neighbor(neighbor_copy)\n            dfs(neighbor, dic)\n        else:\n            dic[node].add_neighbor(dic[neighbor])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/graph/maximum_flow_bfs.py", "fileNameBase": "maximum_flow_bfs", "extension": "py", "doc": {"long_description": "it will give you a maximum flow.\nThis version use BFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23", "short_description": "Given a n*n adjacency array.", "full": "Given a n*n adjacency array.\nit will give you a maximum flow.\nThis version use BFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23"}}, "dependencies": [{"import": "copy", "type": "external", "type_element": "module"}, {"import": "queue", "type": "external", "type_element": "module"}, {"import": "math", "type": "external", "type_element": "module"}], "functions": {"maximum_flow_bfs": {"doc": {"short_description": "Get the maximum flow through a graph using a breadth first search"}, "args": ["adjacency_matrix"], "returns": ["total"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 88}, "calls": ["copy.deepcopy", "queue.Queue", "queue.Queue.put", "len", "queue.Queue.qsize", "queue.Queue.get", "range"], "store_vars_calls": {"new_array": "copy.deepcopy", "bfs": "queue.Queue", "src": "bfs.get"}, "source_code": "def maximum_flow_bfs(adjacency_matrix):\n    \"\"\"\n    Get the maximum flow through a graph using a breadth first search\n    \"\"\"\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min_flow = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        bfs = queue.Queue()\n        visited[0] = 1\n        bfs.put(0)\n        while bfs.qsize() > 0:\n            src = bfs.get()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    bfs.put(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min_flow > new_array[path[tmp]][tmp]:\n                min_flow = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min_flow\n            tmp = path[tmp]\n        total = total + min_flow\n    return total"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/streaming": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/streaming/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "one_sparse_recovery", "import": "one_sparse", "type": "internal", "type_element": "function"}, {"from_module": "one_sparse_recovery", "import": "_check_every_number_in_bitsum", "type": "internal", "type_element": "function"}, {"from_module": "one_sparse_recovery", "import": "_get_bit_sum", "type": "internal", "type_element": "function"}, {"from_module": "misra_gries", "import": "misras_gries", "type": "internal", "type_element": "function"}, {"from_module": "misra_gries", "import": "_count_frequency", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/streaming/one_sparse_recovery.py", "fileNameBase": "one_sparse_recovery", "extension": "py", "doc": {"long_description": "This algorithm assumes we have a non negative dynamic stream.\n\nGiven a stream of tuples, where each tuple contains a number and a sign (+/-), it check if the\nstream is 1-sparse, meaning if the elements in the stream cancel eacheother out in such\na way that ther is only a unique number at the end.\n\nExamples:\n#1\nInput:  [(4,'+'), (2,'+'),(2,'-'),(4,'+'),(3,'+'),(3,'-')],\nOutput: 4\nComment: Since 2 and 3 gets removed.\n#2\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+')]\nOutput: 2\nComment: No other numbers present\n#3\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(1,'+')]\nOutput: None\nComment: Not 1-sparse", "short_description": "Non-negative 1-sparse recovery problem.", "full": "Non-negative 1-sparse recovery problem.\nThis algorithm assumes we have a non negative dynamic stream.\n\nGiven a stream of tuples, where each tuple contains a number and a sign (+/-), it check if the\nstream is 1-sparse, meaning if the elements in the stream cancel eacheother out in such\na way that ther is only a unique number at the end.\n\nExamples:\n#1\nInput:  [(4,'+'), (2,'+'),(2,'-'),(4,'+'),(3,'+'),(3,'-')],\nOutput: 4\nComment: Since 2 and 3 gets removed.\n#2\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+')]\nOutput: 2\nComment: No other numbers present\n#3\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(1,'+')]\nOutput: None\nComment: Not 1-sparse"}}, "functions": {"one_sparse": {"doc": {"long_description": "Keyword arguments:\narray -- stream of tuples", "short_description": "1-sparse algorithm"}, "args": ["array"], "returns": ["int(sum_values / sum_signs)", "None"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 47}, "calls": ["one_sparse_recovery._get_bit_sum", "one_sparse_recovery._check_every_number_in_bitsum", "int"], "source_code": "def one_sparse(array):\n    \"\"\"1-sparse algorithm\n\n    Keyword arguments:\n    array -- stream of tuples\n    \"\"\"\n    sum_signs = 0\n    bitsum = [0] * 32\n    sum_values = 0\n    for (val, sign) in array:\n        if sign == '+':\n            sum_signs += 1\n            sum_values += val\n        else:\n            sum_signs -= 1\n            sum_values -= val\n        _get_bit_sum(bitsum, val, sign)\n    if sum_signs > 0 and _check_every_number_in_bitsum(bitsum, sum_signs):\n        return int(sum_values / sum_signs)\n    else:\n        return None"}, "_check_every_number_in_bitsum": {"args": ["bitsum", "sum_signs"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 55}, "source_code": "def _check_every_number_in_bitsum(bitsum, sum_signs):\n    for val in bitsum:\n        if val != 0 and val != sum_signs:\n            return False\n    return True"}, "_get_bit_sum": {"args": ["bitsum", "val", "sign"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 69}, "source_code": "def _get_bit_sum(bitsum, val, sign):\n    i = 0\n    if sign == '+':\n        while val:\n            bitsum[i] += val & 1\n            i += 1\n            val >>= 1\n    else:\n        while val:\n            bitsum[i] -= val & 1\n            i += 1\n            val >>= 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/streaming/misra_gries.py", "fileNameBase": "misra_gries", "extension": "py", "doc": {"long_description": "Given a list of items and a value k, it returns the every item in the list\nthat appears at least n/k times, where n is the length of the array\n\nBy default, k is set to 2, solving the majority problem.\n\nFor the majority problem, this algorithm only guarantees that if there is\nan element that appears more than n/2 times, it will be outputed. If there\nis no such element, any arbitrary element is returned by the algorithm.\nTherefore, we need to iterate through again at the end. But since we have filtred\nout the suspects, the memory complexity is significantly lower than\nit would be to create counter for every element in the list.\n\nFor example:\nInput misras_gries([1,4,4,4,5,4,4])\nOutput {'4':5}\nInput misras_gries([0,0,0,1,1,1,1])\nOutput {'1':4}\nInput misras_gries([0,0,0,0,1,1,1,2,2],3)\nOutput {'0':4,'1':3}\nInput misras_gries([0,0,0,1,1,1]\nOutput None", "short_description": "Implementation of the Misra-Gries algorithm.", "full": "Implementation of the Misra-Gries algorithm.\nGiven a list of items and a value k, it returns the every item in the list\nthat appears at least n/k times, where n is the length of the array\n\nBy default, k is set to 2, solving the majority problem.\n\nFor the majority problem, this algorithm only guarantees that if there is\nan element that appears more than n/2 times, it will be outputed. If there\nis no such element, any arbitrary element is returned by the algorithm.\nTherefore, we need to iterate through again at the end. But since we have filtred\nout the suspects, the memory complexity is significantly lower than\nit would be to create counter for every element in the list.\n\nFor example:\nInput misras_gries([1,4,4,4,5,4,4])\nOutput {'4':5}\nInput misras_gries([0,0,0,1,1,1,1])\nOutput {'1':4}\nInput misras_gries([0,0,0,0,1,1,1,2,2],3)\nOutput {'0':4,'1':3}\nInput misras_gries([0,0,0,1,1,1]\nOutput None"}}, "functions": {"misras_gries": {"doc": {"long_description": "Keyword arguments:\narray -- list of integers\nk -- value of k (default 2)", "short_description": "Misra-Gries algorithm"}, "args": ["array", "k"], "returns": ["frequencies if len(frequencies) > 0 else None"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 57}, "calls": ["keys.keys", "str", "misra_gries._count_frequency", "int", "len", "list"], "store_vars_calls": {"suspects": "keys.keys", "val": "str", "freq": "_count_frequency"}, "source_code": "def misras_gries(array, k=2):\n    \"\"\"Misra-Gries algorithm\n\n    Keyword arguments:\n    array -- list of integers\n    k -- value of k (default 2)\n    \"\"\"\n    keys = {}\n    for i in array:\n        val = str(i)\n        if val in keys:\n            keys[val] = keys[val] + 1\n        elif len(keys) < k - 1:\n            keys[val] = 1\n        else:\n            for key in list(keys):\n                keys[key] = keys[key] - 1\n                if keys[key] == 0:\n                    del keys[key]\n    suspects = keys.keys()\n    frequencies = {}\n    for suspect in suspects:\n        freq = _count_frequency(array, int(suspect))\n        if freq >= len(array) / k:\n            frequencies[suspect] = freq\n    return frequencies if len(frequencies) > 0 else None"}, "_count_frequency": {"args": ["array", "element"], "returns": ["array.count(element)"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 61}, "calls": ["array.count"], "source_code": "def _count_frequency(array, element):\n    return array.count(element)"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/dp": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/fib.py", "fileNameBase": "fib", "extension": "py", "doc": {"long_description": "form a sequence, called the Fibonacci sequence,\nsuch that each number is the sum of the two preceding ones,\nstarting from 0 and 1.\nThat is,\n    F0=0 , F1=1\nand\n    Fn= F(n-1) + F(n-2)\nThe Fibonacci numbers are the numbers in the following integer sequence.\n    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026\u2026.\n\nIn mathematical terms, the sequence Fn of Fibonacci numbers is\ndefined by the recurrence relation\n\nHere, given a number n, print n-th Fibonacci Number.", "short_description": "In mathematics, the Fibonacci numbers, commonly denoted Fn,", "full": "In mathematics, the Fibonacci numbers, commonly denoted Fn,\nform a sequence, called the Fibonacci sequence,\nsuch that each number is the sum of the two preceding ones,\nstarting from 0 and 1.\nThat is,\n    F0=0 , F1=1\nand\n    Fn= F(n-1) + F(n-2)\nThe Fibonacci numbers are the numbers in the following integer sequence.\n    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026\u2026.\n\nIn mathematical terms, the sequence Fn of Fibonacci numbers is\ndefined by the recurrence relation\n\nHere, given a number n, print n-th Fibonacci Number."}}, "functions": {"fib_recursive": {"args": ["n"], "returns": ["fib_recursive(n - 1) + fib_recursive(n - 2)", "n"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 39}, "calls": ["fib.fib_recursive"], "source_code": "def fib_recursive(n):\n    \"\"\"[summary]\n    Computes the n-th fibonacci number recursive.\n    Problem: This implementation is very slow.\n    approximate O(2^n)\n\n    Arguments:\n        n {[int]} -- [description]\n\n    Returns:\n        [int] -- [description]\n    \"\"\"\n    assert n >= 0, 'n must be a positive integer'\n    if n <= 1:\n        return n\n    return fib_recursive(n - 1) + fib_recursive(n - 2)"}, "fib_list": {"args": ["n"], "returns": ["list_results[n]"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 63}, "calls": ["range", "list_results.append"], "source_code": "def fib_list(n):\n    \"\"\"[summary]\n    This algorithm computes the n-th fibbonacci number\n    very quick. approximate O(n)\n    The algorithm use dynamic programming.\n\n    Arguments:\n        n {[int]} -- [description]\n\n    Returns:\n        [int] -- [description]\n    \"\"\"\n    assert n >= 0, 'n must be a positive integer'\n    list_results = [0, 1]\n    for i in range(2, n + 1):\n        list_results.append(list_results[i - 1] + list_results[i - 2])\n    return list_results[n]"}, "fib_iter": {"args": ["n"], "returns": ["res", "n"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 91}, "calls": ["range"], "source_code": "def fib_iter(n):\n    \"\"\"[summary]\n    Works iterative approximate O(n)\n\n    Arguments:\n        n {[int]} -- [description]\n\n    Returns:\n        [int] -- [description]\n    \"\"\"\n    assert n >= 0, 'n must be positive integer'\n    fib_1 = 0\n    fib_2 = 1\n    res = 0\n    if n <= 1:\n        return n\n    for _ in range(n - 1):\n        res = fib_1 + fib_2\n        fib_1 = fib_2\n        fib_2 = res\n    return res"}}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/knapsack.py", "fileNameBase": "knapsack", "extension": "py", "doc": {"long_description": "return the maximum summarized value of the items that can be fit in the\nknapsack.\n\nExample:\ncapacity = 5, items(value, weight) = [(60, 5), (50, 3), (70, 4), (30, 2)]\nresult = 80 (items valued 50 and 30 can both be fit in the knapsack)\n\nThe time complexity is O(n * m) and the space complexity is O(m), where n is\nthe total number of items and m is the knapsack's capacity.", "short_description": "Given the capacity of the knapsack and items specified by weights and values,", "full": "Given the capacity of the knapsack and items specified by weights and values,\nreturn the maximum summarized value of the items that can be fit in the\nknapsack.\n\nExample:\ncapacity = 5, items(value, weight) = [(60, 5), (50, 3), (70, 4), (30, 2)]\nresult = 80 (items valued 50 and 30 can both be fit in the knapsack)\n\nThe time complexity is O(n * m) and the space complexity is O(m), where n is\nthe total number of items and m is the knapsack's capacity."}}, "classes": {"Item": {"min_max_lineno": {"min_lineno": 15, "max_lineno": 20}, "methods": {"__init__": {"args": ["self", "value", "weight"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 20}, "source_code": "def __init__(self, value, weight):\n    self.value = value\n    self.weight = weight"}}}}, "functions": {"get_maximum_value": {"args": ["items", "capacity"], "returns": ["dp[capacity]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 28}, "calls": ["reversed", "range", "max"], "source_code": "def get_maximum_value(items, capacity):\n    dp = [0] * (capacity + 1)\n    for item in items:\n        for cur_weight in reversed(range(item.weight, capacity + 1)):\n            dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight])\n    return dp[capacity]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/house_robber.py", "fileNameBase": "house_robber", "extension": "py", "doc": {"long_description": "Each house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them\nis that adjacent houses have security system connected and\nit will automatically contact the police if two adjacent houses\nwere broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money\nof each house, determine the maximum amount of money you\ncan rob tonight without alerting the police.", "short_description": "You are a professional robber planning to rob houses along a street.", "full": "You are a professional robber planning to rob houses along a street.\nEach house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them\nis that adjacent houses have security system connected and\nit will automatically contact the police if two adjacent houses\nwere broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money\nof each house, determine the maximum amount of money you\ncan rob tonight without alerting the police."}}, "functions": {"house_robber": {"args": ["houses"], "returns": ["now"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 20}, "calls": ["max"], "source_code": "def house_robber(houses):\n    (last, now) = (0, 0)\n    for house in houses:\n        (last, now) = (now, max(last + house, now))\n    return now"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/int_divide.py", "fileNameBase": "int_divide", "extension": "py", "doc": {"long_description": "non-negative number division, or decomposition.\n\nThe complexity is O(n^2).\n\nExample 1:\nInput: 4\nOutput: 5\nExplaination:\n4=4\n4=3+1\n4=2+2\n4=2+1+1\n4=1+1+1+1\n\nExample :\nInput: 7\nOutput: 15\nExplaination:\n7=7\n7=6+1\n7=5+2\n7=5+1+1\n7=4+3\n7=4+2+1\n7=4+1+1+1\n7=3+3+1\n7=3+2+2\n7=3+2+1+1\n7=3+1+1+1+1\n7=2+2+2+1\n7=2+2+1+1+1\n7=2+1+1+1+1+1\n7=1+1+1+1+1+1+1", "short_description": "Given positive integer decompose, find an algorithm to find the number of", "full": "Given positive integer decompose, find an algorithm to find the number of\nnon-negative number division, or decomposition.\n\nThe complexity is O(n^2).\n\nExample 1:\nInput: 4\nOutput: 5\nExplaination:\n4=4\n4=3+1\n4=2+2\n4=2+1+1\n4=1+1+1+1\n\nExample :\nInput: 7\nOutput: 15\nExplaination:\n7=7\n7=6+1\n7=5+2\n7=5+1+1\n7=4+3\n7=4+2+1\n7=4+1+1+1\n7=3+3+1\n7=3+2+2\n7=3+2+1+1\n7=3+1+1+1+1\n7=2+2+2+1\n7=2+2+1+1+1\n7=2+1+1+1+1+1\n7=1+1+1+1+1+1+1"}}, "functions": {"int_divide": {"doc": {"long_description": "decompose -- integer", "short_description": "Find number of decompositions from `decompose`"}, "args": ["decompose"], "returns": ["arr[decompose][decompose]"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 56}, "calls": ["range"], "source_code": "def int_divide(decompose):\n    \"\"\"Find number of decompositions from `decompose`\n\n    decompose -- integer\n    \"\"\"\n    arr = [[0 for i in range(decompose + 1)] for j in range(decompose + 1)]\n    arr[1][1] = 1\n    for i in range(1, decompose + 1):\n        for j in range(1, decompose + 1):\n            if i < j:\n                arr[i][j] = arr[i][i]\n            elif i == j:\n                arr[i][j] = 1 + arr[i][j - 1]\n            else:\n                arr[i][j] = arr[i][j - 1] + arr[i - j][j]\n    return arr[decompose][decompose]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/job_scheduling.py", "fileNameBase": "job_scheduling", "extension": "py", "doc": {"long_description": "Programming and Binary Search", "short_description": "Python program for weighted job scheduling using Dynamic", "full": "Python program for weighted job scheduling using Dynamic\nProgramming and Binary Search"}}, "classes": {"Job": {"doc": {"short_description": "Class to represent a job", "full": "Class to represent a job"}, "min_max_lineno": {"min_lineno": 6, "max_lineno": 14}, "methods": {"__init__": {"args": ["self", "start", "finish", "profit"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 14}, "source_code": "def __init__(self, start, finish, profit):\n    self.start = start\n    self.finish = finish\n    self.profit = profit"}}}}, "functions": {"binary_search": {"doc": {"long_description": "(before current job) that doesn't conflict with current\njob.  \"index\" is index of the current job.  This function\nreturns -1 if all jobs before index conflict with it.\nThe array jobs[] is sorted in increasing order of finish\ntime.", "short_description": "A Binary Search based function to find the latest job"}, "args": ["job", "start_index"], "returns": ["-1", "mid"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 39}, "source_code": "def binary_search(job, start_index):\n    \"\"\"\n    A Binary Search based function to find the latest job\n    (before current job) that doesn't conflict with current\n    job.  \"index\" is index of the current job.  This function\n    returns -1 if all jobs before index conflict with it.\n    The array jobs[] is sorted in increasing order of finish\n    time.\n    \"\"\"\n    left = 0\n    right = start_index - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if job[mid].finish <= job[start_index].start:\n            if job[mid + 1].finish <= job[start_index].start:\n                left = mid + 1\n            else:\n                return mid\n        else:\n            right = mid - 1\n    return -1"}, "schedule": {"doc": {"long_description": "profit from given array of jobs", "short_description": "The main function that returns the maximum possible"}, "args": ["job"], "returns": ["table[length - 1]"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 69}, "calls": ["sorted", "len", "range", "job_scheduling.binary_search", "max"], "store_vars_calls": {"job": "sorted", "length": "len", "pos": "binary_search"}, "source_code": "def schedule(job):\n    \"\"\"\n    The main function that returns the maximum possible\n    profit from given array of jobs\n    \"\"\"\n    job = sorted(job, key=lambda j: j.finish)\n    length = len(job)\n    table = [0 for _ in range(length)]\n    table[0] = job[0].profit\n    for i in range(1, length):\n        incl_prof = job[i].profit\n        pos = binary_search(job, i)\n        if pos != -1:\n            incl_prof += table[pos]\n        table[i] = max(incl_prof, table[i - 1])\n    return table[length - 1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/climbing_stairs.py", "fileNameBase": "climbing_stairs", "extension": "py", "doc": {"long_description": "It takes `steps` number of steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps.\nIn how many distinct ways can you climb to the top?\n\nNote: Given argument `steps` will be a positive integer.", "short_description": "You are climbing a stair case.", "full": "You are climbing a stair case.\nIt takes `steps` number of steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps.\nIn how many distinct ways can you climb to the top?\n\nNote: Given argument `steps` will be a positive integer."}}, "functions": {"climb_stairs": {"args": ["steps"], "returns": ["arr[-1]"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 23}, "calls": ["range", "arr.append"], "source_code": "def climb_stairs(steps):\n    \"\"\"\n    :type steps: int\n    :rtype: int\n    \"\"\"\n    arr = [1, 1]\n    for _ in range(1, steps):\n        arr.append(arr[-1] + arr[-2])\n    return arr[-1]"}, "climb_stairs_optimized": {"args": ["steps"], "returns": ["a_steps"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 37}, "calls": ["range"], "source_code": "def climb_stairs_optimized(steps):\n    \"\"\"\n    :type steps: int\n    :rtype: int\n    \"\"\"\n    a_steps = b_steps = 1\n    for _ in range(steps):\n        (a_steps, b_steps) = (b_steps, a_steps + b_steps)\n    return a_steps"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/hosoya_triangle.py", "fileNameBase": "hosoya_triangle", "extension": "py", "doc": {"long_description": "of numbers, where if you take any number it is the sum of 2 numbers above.\nFirst line is always 1, and second line is always {1     1}.\n\nThis printHosoya function takes argument n which is the height of the triangle\n(number of lines).\n\nFor example:\nprintHosoya( 6 ) would return:\n1\n1 1\n2 1 2\n3 2 2 3\n5 3 4 3 5\n8 5 6 6 5 8\n\nThe complexity is O(n^3).", "short_description": "Hosoya triangle (originally Fibonacci triangle) is a triangular arrangement", "full": "Hosoya triangle (originally Fibonacci triangle) is a triangular arrangement\nof numbers, where if you take any number it is the sum of 2 numbers above.\nFirst line is always 1, and second line is always {1     1}.\n\nThis printHosoya function takes argument n which is the height of the triangle\n(number of lines).\n\nFor example:\nprintHosoya( 6 ) would return:\n1\n1 1\n2 1 2\n3 2 2 3\n5 3 4 3 5\n8 5 6 6 5 8\n\nThe complexity is O(n^3)."}}, "functions": {"hosoya": {"doc": {"long_description": "height -- height of the triangle", "short_description": "Calculates the hosoya triangle"}, "args": ["height", "width"], "returns": ["0", "1", "1", "hosoya(height - 1, width) + hosoya(height - 2, width)", "hosoya(height - 1, width - 1) + hosoya(height - 2, width - 2)"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 36}, "calls": ["hosoya_triangle.hosoya"], "source_code": "def hosoya(height, width):\n    \"\"\" Calculates the hosoya triangle\n\n    height -- height of the triangle\n    \"\"\"\n    if width == 0 and height in (0, 1):\n        return 1\n    if width == 1 and height in (1, 2):\n        return 1\n    if height > width:\n        return hosoya(height - 1, width) + hosoya(height - 2, width)\n    if width == height:\n        return hosoya(height - 1, width - 1) + hosoya(height - 2, width - 2)\n    return 0"}, "print_hosoya": {"doc": {"long_description": "height -- height of the triangle", "short_description": "Prints the hosoya triangle"}, "args": ["height"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 46}, "calls": ["range", "print", "hosoya_triangle.hosoya"], "source_code": "def print_hosoya(height):\n    \"\"\"Prints the hosoya triangle\n\n    height -- height of the triangle\n    \"\"\"\n    for i in range(height):\n        for j in range(i + 1):\n            print(hosoya(i, j), end=' ')\n        print('\\n', end='')"}, "hosoya_testing": {"doc": {"long_description": "height -- height of the triangle", "short_description": "Test hosoya function"}, "args": ["height"], "returns": ["res"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 57}, "calls": ["range", "res.append", "hosoya_triangle.hosoya"], "source_code": "def hosoya_testing(height):\n    \"\"\"Test hosoya function\n\n    height -- height of the triangle\n    \"\"\"\n    res = []\n    for i in range(height):\n        for j in range(i + 1):\n            res.append(hosoya(i, j))\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/edit_distance.py", "fileNameBase": "edit_distance", "extension": "py", "doc": {"long_description": "of letter insertions, letter deletions, and letter substitutions\nrequired to transform one word into another.\n\nFor example, the edit distance between FOOD and MONEY is at\nmost four:\n\nFOOD -> MOOD -> MOND -> MONED -> MONEY\n\nGiven two words A and B, find the minimum number of operations\nrequired to transform one string into the other.\nIn other words, find the edit distance between A and B.\n\nThought process:\n\nLet edit(i, j) denote the edit distance between\nthe prefixes A[1..i] and B[1..j].\n\nThen, the function satifies the following recurrence:\n\nedit(i, j) = i if j = 0\n             j if i = 0\n             min(edit(i-1, j) + 1,\n                 edit(i, j-1), + 1,\n                 edit(i-1, j-1) + cost) otherwise\n\nThere are two base cases, both of which occur when one string is empty\nand the other is not.\n1. To convert an empty string A into a string B of length n,\nperform n insertions.\n2. To convert a string A of length m into an empty string B,\nperform m deletions.\n\nHere, the cost is 1 if a substitution is required,\nor 0 if both chars in words A and B are the same at\nindexes i and j, respectively.\n\nTo find the edit distance between two words A and B,\nwe need to find edit(length_a, length_b).\n\nTime: O(length_a*length_b)\nSpace: O(length_a*length_b)", "short_description": "The edit distance between two words is the minimum number", "full": "The edit distance between two words is the minimum number\nof letter insertions, letter deletions, and letter substitutions\nrequired to transform one word into another.\n\nFor example, the edit distance between FOOD and MONEY is at\nmost four:\n\nFOOD -> MOOD -> MOND -> MONED -> MONEY\n\nGiven two words A and B, find the minimum number of operations\nrequired to transform one string into the other.\nIn other words, find the edit distance between A and B.\n\nThought process:\n\nLet edit(i, j) denote the edit distance between\nthe prefixes A[1..i] and B[1..j].\n\nThen, the function satifies the following recurrence:\n\nedit(i, j) = i if j = 0\n             j if i = 0\n             min(edit(i-1, j) + 1,\n                 edit(i, j-1), + 1,\n                 edit(i-1, j-1) + cost) otherwise\n\nThere are two base cases, both of which occur when one string is empty\nand the other is not.\n1. To convert an empty string A into a string B of length n,\nperform n insertions.\n2. To convert a string A of length m into an empty string B,\nperform m deletions.\n\nHere, the cost is 1 if a substitution is required,\nor 0 if both chars in words A and B are the same at\nindexes i and j, respectively.\n\nTo find the edit distance between two words A and B,\nwe need to find edit(length_a, length_b).\n\nTime: O(length_a*length_b)\nSpace: O(length_a*length_b)"}}, "functions": {"edit_distance": {"doc": {"long_description": "Kwyword arguments:\nword_a -- string\nword_b -- string", "short_description": "Finds edit distance between word_a and word_b"}, "args": ["word_a", "word_b"], "returns": ["edit[-1][-1]"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 70}, "calls": ["range", "len", "min"], "source_code": "def edit_distance(word_a, word_b):\n    \"\"\"Finds edit distance between word_a and word_b\n\n    Kwyword arguments:\n    word_a -- string\n    word_b -- string\n    \"\"\"\n    (length_a, length_b) = (len(word_a) + 1, len(word_b) + 1)\n    edit = [[0 for _ in range(length_b)] for _ in range(length_a)]\n    for i in range(1, length_a):\n        edit[i][0] = i\n    for j in range(1, length_b):\n        edit[0][j] = j\n    for i in range(1, length_a):\n        for j in range(1, length_b):\n            cost = 0 if word_a[i - 1] == word_b[j - 1] else 1\n            edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + cost)\n    return edit[-1][-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/max_subarray.py", "fileNameBase": "max_subarray", "extension": "py"}, "functions": {"max_subarray": {"args": ["array"], "returns": ["max_so_far"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 8}, "calls": ["range", "len", "max"], "store_vars_calls": {"max_now": "max", "max_so_far": "max"}, "source_code": "def max_subarray(array):\n    max_so_far = max_now = array[0]\n    for i in range(1, len(array)):\n        max_now = max(array[i], max_now + array[i])\n        max_so_far = max(max_so_far, max_now)\n    return max_so_far"}}, "body": {"calls": ["print", "max_subarray.max_subarray"], "source_code": ["print(a)", "print(max_subarray(a))", "max_subarray(a)"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/egg_drop.py", "fileNameBase": "egg_drop", "extension": "py", "doc": {"long_description": "from 1 to N. Each egg is identical in function, and if an egg breaks,\nyou cannot drop it again. You know that there exists a floor F with\n0 <= F <= N such that any egg dropped at a floor higher than F will\nbreak, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop\nit from any floor X (with 1 <= X <= N). Your goal is to know with\ncertainty what the value of F is. What is the minimum number of moves\nthat you need to know with certainty what F is, regardless of the\ninitial value of F?\n\nExample:\nInput: K = 1, N = 2\nOutput: 2\nExplanation:\nDrop the egg from floor 1.  If it breaks, we know with certainty that F = 0.\nOtherwise, drop the egg from floor 2.  If it breaks, we know with\ncertainty that F = 1.\nIf it didn't break, then we know with certainty F = 2.\nHence, we needed 2 moves in the worst case to know what F is with certainty.", "short_description": "You are given K eggs, and you have access to a building with N floors", "full": "You are given K eggs, and you have access to a building with N floors\nfrom 1 to N. Each egg is identical in function, and if an egg breaks,\nyou cannot drop it again. You know that there exists a floor F with\n0 <= F <= N such that any egg dropped at a floor higher than F will\nbreak, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop\nit from any floor X (with 1 <= X <= N). Your goal is to know with\ncertainty what the value of F is. What is the minimum number of moves\nthat you need to know with certainty what F is, regardless of the\ninitial value of F?\n\nExample:\nInput: K = 1, N = 2\nOutput: 2\nExplanation:\nDrop the egg from floor 1.  If it breaks, we know with certainty that F = 0.\nOtherwise, drop the egg from floor 2.  If it breaks, we know with\ncertainty that F = 1.\nIf it didn't break, then we know with certainty F = 2.\nHence, we needed 2 moves in the worst case to know what F is with certainty."}}, "functions": {"egg_drop": {"doc": {"long_description": "n -- number of floors\nk -- number of eggs", "short_description": "Keyword arguments:"}, "args": ["n", "k"], "returns": ["egg_floor[n][k]"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 59}, "calls": ["range", "max"], "source_code": "def egg_drop(n, k):\n    \"\"\"\n    Keyword arguments:\n    n -- number of floors\n    k -- number of eggs\n    \"\"\"\n    egg_floor = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        egg_floor[i][1] = 1\n        egg_floor[i][0] = 0\n    for j in range(1, k + 1):\n        egg_floor[1][j] = j\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            egg_floor[i][j] = INT_MAX\n            for x in range(1, j + 1):\n                res = 1 + max(egg_floor[i - 1][x - 1], egg_floor[i][j - x])\n                if res < egg_floor[i][j]:\n                    egg_floor[i][j] = res\n    return egg_floor[n][k]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/matrix_chain_order.py", "fileNameBase": "matrix_chain_order", "extension": "py", "doc": {"long_description": "Implementation of matrix Chain Multiplication\nTime Complexity: O(n^3)\nSpace Complexity: O(n^2)", "short_description": "Dynamic Programming", "full": "Dynamic Programming\nImplementation of matrix Chain Multiplication\nTime Complexity: O(n^3)\nSpace Complexity: O(n^2)"}}, "functions": {"matrix_chain_order": {"doc": {"long_description": "array -- int[]", "short_description": "Finds optimal order to multiply matrices"}, "args": ["array"], "returns": [["matrix", "sol"]], "min_max_lineno": {"min_lineno": 10, "max_lineno": 29}, "calls": ["len", "range"], "store_vars_calls": {"n": "len"}, "source_code": "def matrix_chain_order(array):\n    \"\"\"Finds optimal order to multiply matrices\n\n    array -- int[]\n    \"\"\"\n    n = len(array)\n    matrix = [[0 for x in range(n)] for x in range(n)]\n    sol = [[0 for x in range(n)] for x in range(n)]\n    for chain_length in range(2, n):\n        for a in range(1, n - chain_length + 1):\n            b = a + chain_length - 1\n            matrix[a][b] = INF\n            for c in range(a, b):\n                cost = matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]\n                if cost < matrix[a][b]:\n                    matrix[a][b] = cost\n                    sol[a][b] = c\n    return (matrix, sol)"}, "print_optimal_solution": {"doc": {"long_description": "optimal_solution -- int[][]\ni -- int[]\nj -- int[]", "short_description": "Print the solution"}, "args": ["optimal_solution", "i", "j"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 45}, "calls": ["print", "matrix_chain_order.print_optimal_solution", "str"], "source_code": "def print_optimal_solution(optimal_solution, i, j):\n    \"\"\"Print the solution\n\n    optimal_solution -- int[][]\n    i -- int[]\n    j -- int[]\n    \"\"\"\n    if i == j:\n        print('A' + str(i), end=' ')\n    else:\n        print('(', end=' ')\n        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])\n        print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)\n        print(')', end=' ')"}, "main": {"doc": {"short_description": "Testing for matrix_chain_ordering"}, "min_max_lineno": {"min_lineno": 47, "max_lineno": 59}, "calls": ["len", "matrix_chain_order.matrix_chain_order", "print", "matrix_chain_order.print_optimal_solution", "str"], "store_vars_calls": {"length": "len"}, "source_code": "def main():\n    \"\"\"\n    Testing for matrix_chain_ordering\n    \"\"\"\n    array = [30, 35, 15, 5, 10, 20, 25]\n    length = len(array)\n    (matrix, optimal_solution) = matrix_chain_order(array)\n    print('No. of Operation required: ' + str(matrix[1][length - 1]))\n    print_optimal_solution(optimal_solution, 1, length - 1)"}}, "body": {"calls": ["float", "matrix_chain_order.main"], "store_vars_calls": {"INF": "float"}, "source_code": ["float('inf')", "main()"]}, "main_info": {"main_flag": 1, "main_function": "matrix_chain_order.main", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/word_break.py", "fileNameBase": "word_break", "extension": "py", "doc": {"long_description": "containing a list of non-empty words,\ndetermine if word can be segmented into a space-separated\nsequence of one or more dictionary words.\nYou may assume the dictionary does not contain duplicate words.\n\nFor example, given\nword = \"leetcode\",\ndict = [\"leet\", \"code\"].\n\nReturn true because \"leetcode\" can be segmented as \"leet code\".\n\nword = abc word_dict = [\"a\",\"bc\"]\nTrue False False False", "short_description": "Given a non-empty string s and a dictionary wordDict", "full": "Given a non-empty string s and a dictionary wordDict\ncontaining a list of non-empty words,\ndetermine if word can be segmented into a space-separated\nsequence of one or more dictionary words.\nYou may assume the dictionary does not contain duplicate words.\n\nFor example, given\nword = \"leetcode\",\ndict = [\"leet\", \"code\"].\n\nReturn true because \"leetcode\" can be segmented as \"leet code\".\n\nword = abc word_dict = [\"a\",\"bc\"]\nTrue False False False"}}, "functions": {"word_break": {"args": ["word", "word_dict"], "returns": ["dp_array[-1]"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 35}, "calls": ["range", "len"], "source_code": "def word_break(word, word_dict):\n    \"\"\"\n    :type word: str\n    :type word_dict: Set[str]\n    :rtype: bool\n    \"\"\"\n    dp_array = [False] * (len(word) + 1)\n    dp_array[0] = True\n    for i in range(1, len(word) + 1):\n        for j in range(0, i):\n            if dp_array[j] and word[j:i] in word_dict:\n                dp_array[i] = True\n                break\n    return dp_array[-1]"}}, "body": {"calls": ["print", "word_break.word_break"], "source_code": ["print(word_break(str, dic))", "word_break(str, dic)"]}, "main_info": {"main_flag": 1, "main_function": "word_break.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/min_cost_path.py", "fileNameBase": "min_cost_path", "extension": "py", "doc": {"long_description": "To find minimum cost path\nfrom station 0 to station N-1,\nwhere cost of moving from ith station to jth station is given as:\n\nMatrix of size (N x N)\nwhere Matrix[i][j] denotes the cost of moving from\nstation i --> station j   for i < j\n\nNOTE that values where Matrix[i][j] and i > j does not\nmean anything, and hence represented by -1 or INF\n\nFor the input below (cost matrix),\nMinimum cost is obtained as from  { 0 --> 1 --> 3}\n                                  = cost[0][1] + cost[1][3] = 65\nthe Output will be:\n\nThe Minimum cost to reach station 4 is 65\n\nTime Complexity: O(n^2)\nSpace Complexity: O(n)", "short_description": "author @goswami-rahul", "full": "author @goswami-rahul\n\nTo find minimum cost path\nfrom station 0 to station N-1,\nwhere cost of moving from ith station to jth station is given as:\n\nMatrix of size (N x N)\nwhere Matrix[i][j] denotes the cost of moving from\nstation i --> station j   for i < j\n\nNOTE that values where Matrix[i][j] and i > j does not\nmean anything, and hence represented by -1 or INF\n\nFor the input below (cost matrix),\nMinimum cost is obtained as from  { 0 --> 1 --> 3}\n                                  = cost[0][1] + cost[1][3] = 65\nthe Output will be:\n\nThe Minimum cost to reach station 4 is 65\n\nTime Complexity: O(n^2)\nSpace Complexity: O(n)"}}, "functions": {"min_cost": {"doc": {"long_description": "Keyword arguments:\ncost -- matrix containing costs", "short_description": "Find minimum cost."}, "args": ["cost"], "returns": ["dist[length - 1]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 46}, "calls": ["len", "range", "min"], "store_vars_calls": {"length": "len"}, "source_code": "def min_cost(cost):\n    \"\"\"Find minimum cost.\n\n    Keyword arguments:\n    cost -- matrix containing costs\n    \"\"\"\n    length = len(cost)\n    dist = [INF] * length\n    dist[0] = 0\n    for i in range(length):\n        for j in range(i + 1, length):\n            dist[j] = min(dist[j], dist[i] + cost[i][j])\n    return dist[length - 1]"}}, "body": {"calls": ["float", "len", "min_cost_path.min_cost", "print"], "store_vars_calls": {"INF": "float", "TOTAL_LEN": "len", "mcost": "min_cost"}, "source_code": ["float('inf')", "len(costs)", "min_cost(costs)", "print(f'The minimum cost to reach station {TOTAL_LEN} is {mcost}')"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/max_product_subarray.py", "fileNameBase": "max_product_subarray", "extension": "py", "doc": {"long_description": "(containing at least one number) which has the largest product.\n\nFor example, given the array [2,3,-2,4],\nthe contiguous subarray [2,3] has the largest product = 6.", "short_description": "Find the contiguous subarray within an array", "full": "Find the contiguous subarray within an array\n(containing at least one number) which has the largest product.\n\nFor example, given the array [2,3,-2,4],\nthe contiguous subarray [2,3] has the largest product = 6."}}, "dependencies": [{"from_module": "functools", "import": "reduce", "type": "external", "type_element": "module"}], "functions": {"max_product": {"args": ["nums"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 23}, "calls": ["max", "min"], "store_vars_calls": {"lmax": "max", "lmin": "min", "gmax": "max"}, "source_code": "def max_product(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    lmin = lmax = gmax = nums[0]\n    for num in nums:\n        t_1 = num * lmax\n        t_2 = num * lmin\n        lmax = max(max(t_1, t_2), num)\n        lmin = min(min(t_1, t_2), num)\n        gmax = max(gmax, lmax)"}, "subarray_with_max_product": {"doc": {"short_description": "arr is list of positive/negative numbers "}, "args": ["arr"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 67}, "calls": ["len", "range", "print", "functools.reduce"], "store_vars_calls": {"length": "len"}, "source_code": "def subarray_with_max_product(arr):\n    \"\"\" arr is list of positive/negative numbers \"\"\"\n    length = len(arr)\n    product_so_far = max_product_end = 1\n    max_start_i = 0\n    so_far_start_i = so_far_end_i = 0\n    all_negative_flag = True\n    for i in range(length):\n        max_product_end *= arr[i]\n        if arr[i] > 0:\n            all_negative_flag = False\n        if max_product_end <= 0:\n            max_product_end = arr[i]\n            max_start_i = i\n        if product_so_far <= max_product_end:\n            product_so_far = max_product_end\n            so_far_end_i = i\n            so_far_start_i = max_start_i\n    if all_negative_flag:\n        print(f'max_product_so_far: {reduce(lambda x, y: x * y, arr)}, {arr}')\n    else:\n        print(f'max_product_so_far: {product_so_far},{arr[so_far_start_i:so_far_end_i + 1]}')"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/combination_sum.py", "fileNameBase": "combination_sum", "extension": "py", "doc": {"long_description": "find the number of possible combinations that\nadd up to a positive integer target.\n\nExample:\n\nnums = [1, 2, 3]\ntarget = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is 7.\nFollow up:\nWhat if negative numbers are allowed in the given array?\nHow does it change the problem?\nWhat limitation we need to add to the question to allow negative numbers?", "short_description": "Given an integer array with all positive numbers and no duplicates,", "full": "Given an integer array with all positive numbers and no duplicates,\nfind the number of possible combinations that\nadd up to a positive integer target.\n\nExample:\n\nnums = [1, 2, 3]\ntarget = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is 7.\nFollow up:\nWhat if negative numbers are allowed in the given array?\nHow does it change the problem?\nWhat limitation we need to add to the question to allow negative numbers?"}}, "functions": {"helper_topdown": {"doc": {"long_description": "Keyword arguments:\nnums -- positive integer array without duplicates\ntarget -- integer describing what a valid combination should add to", "short_description": "Generates DP and finds result."}, "args": ["nums", "target"], "returns": ["res", "DP[target]"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 47}, "calls": ["combination_sum.helper_topdown"], "source_code": "def helper_topdown(nums, target):\n    \"\"\"Generates DP and finds result.\n\n    Keyword arguments:\n    nums -- positive integer array without duplicates\n    target -- integer describing what a valid combination should add to\n    \"\"\"\n    if DP[target] != -1:\n        return DP[target]\n    res = 0\n    for num in nums:\n        if target >= num:\n            res += helper_topdown(nums, target - num)\n    DP[target] = res\n    return res"}, "combination_sum_topdown": {"doc": {"long_description": "Keyword arguments:\nnums -- positive integer array without duplicates\ntarget -- integer describing what a valid combination should add to", "short_description": "Find number of possible combinations in nums that add up to target, in top-down manner."}, "args": ["nums", "target"], "returns": ["helper_topdown(nums, target)"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 60}, "calls": ["combination_sum.helper_topdown"], "source_code": "def combination_sum_topdown(nums, target):\n    \"\"\"Find number of possible combinations in nums that add up to target, in top-down manner.\n\n    Keyword arguments:\n    nums -- positive integer array without duplicates\n    target -- integer describing what a valid combination should add to\n    \"\"\"\n    global DP\n    DP = [-1] * (target + 1)\n    DP[0] = 1\n    return helper_topdown(nums, target)"}, "combination_sum_bottom_up": {"doc": {"long_description": "Keyword arguments:\nnums -- positive integer array without duplicates\ntarget -- integer describing what a valid combination should add to", "short_description": "Find number of possible combinations in nums that add up to target, in bottom-up manner."}, "args": ["nums", "target"], "returns": ["combs[target]"], "min_max_lineno": {"min_lineno": 61, "max_lineno": 75}, "calls": ["range", "len"], "source_code": "def combination_sum_bottom_up(nums, target):\n    \"\"\"Find number of possible combinations in nums that add up to target, in bottom-up manner.\n\n    Keyword arguments:\n    nums -- positive integer array without duplicates\n    target -- integer describing what a valid combination should add to\n    \"\"\"\n    combs = [0] * (target + 1)\n    combs[0] = 1\n    for i in range(0, len(combs)):\n        for num in nums:\n            if i - num >= 0:\n                combs[i] += combs[i - num]\n    return combs[target]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/regex_matching.py", "fileNameBase": "regex_matching", "extension": "py", "doc": {"long_description": "'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nThe function prototype should be:\nbool is_match(const char *s, const char *p)\n\nSome examples:\nis_match(\"aa\",\"a\") \u2192 false\nis_match(\"aa\",\"aa\") \u2192 true\nis_match(\"aaa\",\"aa\") \u2192 false\nis_match(\"aa\", \"a*\") \u2192 true\nis_match(\"aa\", \".*\") \u2192 true\nis_match(\"ab\", \".*\") \u2192 true\nis_match(\"aab\", \"c*a*b\") \u2192 true", "short_description": "Implement regular expression matching with support for '.' and '*'.", "full": "Implement regular expression matching with support for '.' and '*'.\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nThe function prototype should be:\nbool is_match(const char *s, const char *p)\n\nSome examples:\nis_match(\"aa\",\"a\") \u2192 false\nis_match(\"aa\",\"aa\") \u2192 true\nis_match(\"aaa\",\"aa\") \u2192 false\nis_match(\"aa\", \"a*\") \u2192 true\nis_match(\"aa\", \".*\") \u2192 true\nis_match(\"ab\", \".*\") \u2192 true\nis_match(\"aab\", \"c*a*b\") \u2192 true"}}, "functions": {"is_match": {"doc": {"long_description": "Keyword arguments:\nstr_a -- string\nstr_b -- string", "short_description": "Finds if `str_a` matches `str_b`"}, "args": ["str_a", "str_b"], "returns": ["matches[-1][-1]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 62}, "calls": ["enumerate", "len", "range"], "source_code": "def is_match(str_a, str_b):\n    \"\"\"Finds if `str_a` matches `str_b`\n\n    Keyword arguments:\n    str_a -- string\n    str_b -- string\n    \"\"\"\n    (len_a, len_b) = (len(str_a) + 1, len(str_b) + 1)\n    matches = [[False] * len_b for _ in range(len_a)]\n    matches[0][0] = True\n    for (i, element) in enumerate(str_b[1:], 2):\n        matches[0][i] = matches[0][i - 2] and element == '*'\n    for (i, char_a) in enumerate(str_a, 1):\n        for (j, char_b) in enumerate(str_b, 1):\n            if char_b != '*':\n                matches[i][j] = matches[i - 1][j - 1] and char_b in (char_a, '.')\n            else:\n                matches[i][j] |= matches[i][j - 2]\n                if char_a == str_b[j - 2] or str_b[j - 2] == '.':\n                    matches[i][j] |= matches[i - 1][j]\n    return matches[-1][-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/k_factor.py", "fileNameBase": "k_factor", "extension": "py", "doc": {"long_description": "substring. Given two numbers `length` and `k_factor`, find the number of\nstrings of length `length` with 'K factor' = `k_factor`.\n\nThe algorithms is as follows:\n\ndp[length][k_factor] will be a 4 element array, wherein each element can be the\nnumber of strings of length `length` and 'K factor' = `k_factor` which belong\nto the criteria represented by that index:\n\n    - dp[length][k_factor][0] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'a'\n\n    - dp[length][k_factor][1] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'ab'\n\n    - dp[length][k_factor][2] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'abb'\n\n    - dp[length][k_factor][3] can be the number of strings of `length` and\n      K-factor = `k_factor` which end with anything other than the above\n      substrings (anything other than 'a' 'ab' 'abb')\n\nExample inputs\n\nlength=4 k_factor=1  no of strings = 1\nlength=7 k_factor=1 no of strings = 70302\nlength=10 k_factor=2 no of strings = 74357", "short_description": "The K factor of a string is defined as the number of times 'abba' appears as a", "full": "The K factor of a string is defined as the number of times 'abba' appears as a\nsubstring. Given two numbers `length` and `k_factor`, find the number of\nstrings of length `length` with 'K factor' = `k_factor`.\n\nThe algorithms is as follows:\n\ndp[length][k_factor] will be a 4 element array, wherein each element can be the\nnumber of strings of length `length` and 'K factor' = `k_factor` which belong\nto the criteria represented by that index:\n\n    - dp[length][k_factor][0] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'a'\n\n    - dp[length][k_factor][1] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'ab'\n\n    - dp[length][k_factor][2] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'abb'\n\n    - dp[length][k_factor][3] can be the number of strings of `length` and\n      K-factor = `k_factor` which end with anything other than the above\n      substrings (anything other than 'a' 'ab' 'abb')\n\nExample inputs\n\nlength=4 k_factor=1  no of strings = 1\nlength=7 k_factor=1 no of strings = 70302\nlength=10 k_factor=2 no of strings = 74357"}}, "functions": {"find_k_factor": {"doc": {"long_description": "Keyword arguments:\nlength -- integer\nk_factor -- integer", "short_description": "Find the number of strings of length `length` with K factor = `k_factor`."}, "args": ["length", "k_factor"], "returns": ["sum(mat[length][k_factor])", "0"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 86}, "calls": ["range", "sum"], "source_code": "def find_k_factor(length, k_factor):\n    \"\"\"Find the number of strings of length `length` with K factor = `k_factor`.\n\n    Keyword arguments:\n    length -- integer\n    k_factor -- integer\n    \"\"\"\n    mat = [[[0 for i in range(4)] for j in range((length - 1) // 3 + 2)] for k in range(length + 1)]\n    if 3 * k_factor + 1 > length:\n        return 0\n    mat[1][0][0] = 1\n    mat[1][0][1] = 0\n    mat[1][0][2] = 0\n    mat[1][0][3] = 25\n    for i in range(2, length + 1):\n        for j in range((length - 1) // 3 + 2):\n            if j == 0:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 < i:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3] + mat[i - 1][j - 1][2]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 == i:\n                mat[i][j][0] = 1\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n            else:\n                mat[i][j][0] = 0\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n    return sum(mat[length][k_factor])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/coin_change.py", "fileNameBase": "coin_change", "extension": "py", "doc": {"long_description": "Given a value `value`, if we want to make change for `value` cents, and we have infinite\nsupply of each of coins = {S1, S2, .. , Sm} valued `coins`, how many ways can we make the change?\nThe order of `coins` doesn't matter.\nFor example, for `value` = 4 and `coins` = [1, 2, 3], there are four solutions:\n[1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3].\nSo output should be 4.\n\nFor `value` = 10 and `coins` = [2, 5, 3, 6], there are five solutions:\n\n[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5] and [5, 5].\nSo the output should be 5.\n\nTime complexity: O(n * m) where n is the `value` and m is the number of `coins`\nSpace complexity: O(n)", "short_description": "Problem", "full": "Problem\nGiven a value `value`, if we want to make change for `value` cents, and we have infinite\nsupply of each of coins = {S1, S2, .. , Sm} valued `coins`, how many ways can we make the change?\nThe order of `coins` doesn't matter.\nFor example, for `value` = 4 and `coins` = [1, 2, 3], there are four solutions:\n[1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3].\nSo output should be 4.\n\nFor `value` = 10 and `coins` = [2, 5, 3, 6], there are five solutions:\n\n[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5] and [5, 5].\nSo the output should be 5.\n\nTime complexity: O(n * m) where n is the `value` and m is the number of `coins`\nSpace complexity: O(n)"}}, "functions": {"count": {"doc": {"long_description": "Keyword arguments:\ncoins -- int[]\nvalue -- int", "short_description": "Find number of combination of `coins` that adds upp to `value`"}, "args": ["coins", "value"], "returns": ["dp_array[value]"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 35}, "calls": ["range"], "source_code": "def count(coins, value):\n    \"\"\" Find number of combination of `coins` that adds upp to `value`\n\n    Keyword arguments:\n    coins -- int[]\n    value -- int\n    \"\"\"\n    dp_array = [1] + [0] * value\n    for coin in coins:\n        for i in range(coin, value + 1):\n            dp_array[i] += dp_array[i - coin]\n    return dp_array[value]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/buy_sell_stock.py", "fileNameBase": "buy_sell_stock", "extension": "py", "doc": {"long_description": "is the price of a given stock on day i.\n\nIf you were only permitted to complete at most one transaction\n(ie, buy one and sell one share of the stock),\ndesign an algorithm to find the maximum profit.\n\nExample 1:\nInput: [7, 1, 5, 3, 6, 4]\nOutput: 5\n\nmax. difference = 6-1 = 5\n(not 7-1 = 6, as selling price needs to be larger than buying price)\nExample 2:\nInput: [7, 6, 4, 3, 1]\nOutput: 0\n\nIn this case, no transaction is done, i.e. max profit = 0.", "short_description": "Say you have an array for which the ith element", "full": "Say you have an array for which the ith element\nis the price of a given stock on day i.\n\nIf you were only permitted to complete at most one transaction\n(ie, buy one and sell one share of the stock),\ndesign an algorithm to find the maximum profit.\n\nExample 1:\nInput: [7, 1, 5, 3, 6, 4]\nOutput: 5\n\nmax. difference = 6-1 = 5\n(not 7-1 = 6, as selling price needs to be larger than buying price)\nExample 2:\nInput: [7, 6, 4, 3, 1]\nOutput: 0\n\nIn this case, no transaction is done, i.e. max profit = 0."}}, "functions": {"max_profit_naive": {"args": ["prices"], "returns": ["max_so_far"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 34}, "calls": ["range", "len", "max"], "store_vars_calls": {"max_so_far": "max"}, "source_code": "def max_profit_naive(prices):\n    \"\"\"\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    max_so_far = 0\n    for i in range(0, len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            max_so_far = max(max_so_far, prices[j] - prices[i])\n    return max_so_far"}, "max_profit_optimized": {"doc": {"long_description": "diff : [X, -6, 4, -2, 3, -2]", "short_description": "input: [7, 1, 5, 3, 6, 4]"}, "args": ["prices"], "returns": ["max_so_far"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 49}, "calls": ["range", "len", "max"], "store_vars_calls": {"cur_max": "max", "max_so_far": "max"}, "source_code": "def max_profit_optimized(prices):\n    \"\"\"\n    input: [7, 1, 5, 3, 6, 4]\n    diff : [X, -6, 4, -2, 3, -2]\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    (cur_max, max_so_far) = (0, 0)\n    for i in range(1, len(prices)):\n        cur_max = max(0, cur_max + prices[i] - prices[i - 1])\n        max_so_far = max(max_so_far, cur_max)\n    return max_so_far"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/num_decodings.py", "fileNameBase": "num_decodings", "extension": "py", "doc": {"long_description": "encoded to numbers using the following mapping:\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\nGiven an encoded message containing digits,\ndetermine the total number of ways to decode it.\n\nFor example,\nGiven encoded message \"12\",\nit could be decoded as \"AB\" (1 2) or \"L\" (12).\n\nThe number of ways decoding \"12\" is 2.", "short_description": "A message containing letters from A-Z is being", "full": "A message containing letters from A-Z is being\nencoded to numbers using the following mapping:\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\nGiven an encoded message containing digits,\ndetermine the total number of ways to decode it.\n\nFor example,\nGiven encoded message \"12\",\nit could be decoded as \"AB\" (1 2) or \"L\" (12).\n\nThe number of ways decoding \"12\" is 2."}}, "functions": {"num_decodings": {"args": ["enc_mes"], "returns": ["last_char", "0"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 34}, "calls": ["range", "len", "int"], "source_code": "def num_decodings(enc_mes):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if not enc_mes or enc_mes[0] == '0':\n        return 0\n    (last_char, last_two_chars) = (1, 1)\n    for i in range(1, len(enc_mes)):\n        last = last_char if enc_mes[i] != '0' else 0\n        last_two = last_two_chars if int(enc_mes[i - 1:i + 1]) < 27 and enc_mes[i - 1] != '0' else 0\n        last_two_chars = last_char\n        last_char = last + last_two\n    return last_char"}, "num_decodings2": {"args": ["enc_mes"], "returns": ["stack[-1]", "0", "0"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 57}, "calls": ["range", "enc_mes.startswith", "len", "stack.append", "int"], "source_code": "def num_decodings2(enc_mes):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if not enc_mes or enc_mes.startswith('0'):\n        return 0\n    stack = [1, 1]\n    for i in range(1, len(enc_mes)):\n        if enc_mes[i] == '0':\n            if enc_mes[i - 1] == '0' or enc_mes[i - 1] > '2':\n                return 0\n            stack.append(stack[-2])\n        elif 9 < int(enc_mes[i - 1:i + 1]) < 27:\n            stack.append(stack[-2] + stack[-1])\n        else:\n            stack.append(stack[-1])\n    return stack[-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/rod_cut.py", "fileNameBase": "rod_cut", "extension": "py", "doc": {"short_description": "A Dynamic Programming solution for Rod cutting problem", "full": "A Dynamic Programming solution for Rod cutting problem"}}, "functions": {"cut_rod": {"doc": {"long_description": "price[] as prices of different pieces", "short_description": "Returns the best obtainable price for a rod of length n and"}, "args": ["price"], "returns": ["val[n]"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 23}, "calls": ["len", "range", "max"], "store_vars_calls": {"n": "len", "max_val": "max"}, "source_code": "def cut_rod(price):\n    \"\"\"\n    Returns the best obtainable price for a rod of length n and\n    price[] as prices of different pieces\n    \"\"\"\n    n = len(price)\n    val = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_val = INT_MIN\n        for j in range(i):\n            max_val = max(max_val, price[j] + val[i - j - 1])\n        val[i] = max_val\n    return val[n]"}}, "body": {"calls": ["print", "str", "rod_cut.cut_rod"], "source_code": ["print('Maximum Obtainable Value is ' + str(cut_rod(arr)))", "str(cut_rod(arr))", "cut_rod(arr)"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/longest_common_subsequence.py", "fileNameBase": "longest_common_subsequence", "extension": "py", "doc": {"long_description": "sequence by deleting some or no elements without changing the\norder of the remaining elements.\n\nFor example, 'abd' is a subsequence of 'abcd' whereas 'adc' is not\n\nGiven 2 strings containing lowercase english alphabets, find the length\nof the Longest Common Subsequence (L.C.S.).", "short_description": "A subsequence is a sequence that can be derived from another", "full": "A subsequence is a sequence that can be derived from another\nsequence by deleting some or no elements without changing the\norder of the remaining elements.\n\nFor example, 'abd' is a subsequence of 'abcd' whereas 'adc' is not\n\nGiven 2 strings containing lowercase english alphabets, find the length\nof the Longest Common Subsequence (L.C.S.).\n\nExample:\n    Input:  'abcdgh'\n            'aedfhr'\n    Output: 3\n\n    Explanation: The longest subsequence common to both the string is \"adh\"\n\nTime Complexity : O(M*N)\nSpace Complexity : O(M*N), where M and N are the lengths of the 1st and 2nd string\nrespectively."}}, "functions": {"longest_common_subsequence": {"doc": {"args": {"s1": {"description": "string"}, "s2": {"description": "string"}}, "returns": {"description": "int", "is_generator": false}}, "args": ["s_1", "s_2"], "returns": ["mat[m][n]"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 47}, "calls": ["len", "range", "max"], "store_vars_calls": {"m": "len", "n": "len"}, "source_code": "def longest_common_subsequence(s_1, s_2):\n    \"\"\"\n    :param s1: string\n    :param s2: string\n    :return: int\n    \"\"\"\n    m = len(s_1)\n    n = len(s_2)\n    mat = [[0] * (n + 1) for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                mat[i][j] = 0\n            elif s_1[i - 1] == s_2[j - 1]:\n                mat[i][j] = mat[i - 1][j - 1] + 1\n            else:\n                mat[i][j] = max(mat[i - 1][j], mat[i][j - 1])\n    return mat[m][n]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/planting_trees.py", "fileNameBase": "planting_trees", "extension": "py", "doc": {"long_description": "assigned the job to plant these trees at an even interval on both sides of the\nroad. The length and width of the road are variable, and a pair of trees must\nbe planted at the beginning (at 0) and at the end (at length) of the road. Only\none tree can be moved at a time. The goal is to calculate the lowest amount of\ndistance that the trees have to be moved before they are all in a valid\nposition.", "short_description": "An even number of trees are left along one side of a country road. You've been", "full": "An even number of trees are left along one side of a country road. You've been\nassigned the job to plant these trees at an even interval on both sides of the\nroad. The length and width of the road are variable, and a pair of trees must\nbe planted at the beginning (at 0) and at the end (at length) of the road. Only\none tree can be moved at a time. The goal is to calculate the lowest amount of\ndistance that the trees have to be moved before they are all in a valid\nposition."}}, "dependencies": [{"from_module": "math", "import": "sqrt", "type": "external", "type_element": "module"}], "functions": {"planting_trees": {"doc": {"long_description": "are all in a valid state.\n\n    Parameters:\n        tree (list<int>): A sorted list of integers with all trees'\n                          position along the road.\n        length (int): An integer with the length of the road.\n        width (int): An integer with the width of the road.\n\n    Returns:\n        A float number with the total distance trees have been moved.", "short_description": "Returns the minimum distance that trees have to be moved before they"}, "args": ["trees", "length", "width"], "returns": ["cmatrix[n_pairs][n_pairs]"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 50}, "calls": ["int", "range", "len", "math.sqrt", "abs", "min"], "store_vars_calls": {"n_pairs": "int"}, "source_code": "def planting_trees(trees, length, width):\n    \"\"\"\n    Returns the minimum distance that trees have to be moved before they\n    are all in a valid state.\n\n        Parameters:\n            tree (list<int>): A sorted list of integers with all trees'\n                              position along the road.\n            length (int): An integer with the length of the road.\n            width (int): An integer with the width of the road.\n\n        Returns:\n            A float number with the total distance trees have been moved.\n    \"\"\"\n    trees = [0] + trees\n    n_pairs = int(len(trees) / 2)\n    space_between_pairs = length / (n_pairs - 1)\n    target_locations = [location * space_between_pairs for location in range(n_pairs)]\n    cmatrix = [[0 for _ in range(n_pairs + 1)] for _ in range(n_pairs + 1)]\n    for r_i in range(1, n_pairs + 1):\n        cmatrix[r_i][0] = cmatrix[r_i - 1][0] + sqrt(width + abs(trees[r_i] - target_locations[r_i - 1]) ** 2)\n    for l_i in range(1, n_pairs + 1):\n        cmatrix[0][l_i] = cmatrix[0][l_i - 1] + abs(trees[l_i] - target_locations[l_i - 1])\n    for r_i in range(1, n_pairs + 1):\n        for l_i in range(1, n_pairs + 1):\n            cmatrix[r_i][l_i] = min(cmatrix[r_i - 1][l_i] + sqrt(width + (trees[l_i + r_i] - target_locations[r_i - 1]) ** 2), cmatrix[r_i][l_i - 1] + abs(trees[l_i + r_i] - target_locations[l_i - 1]))\n    return cmatrix[n_pairs][n_pairs]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dp/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "buy_sell_stock", "import": "max_profit_naive", "type": "internal", "type_element": "function"}, {"from_module": "buy_sell_stock", "import": "max_profit_optimized", "type": "internal", "type_element": "function"}, {"from_module": "climbing_stairs", "import": "climb_stairs", "type": "internal", "type_element": "function"}, {"from_module": "climbing_stairs", "import": "climb_stairs_optimized", "type": "internal", "type_element": "function"}, {"from_module": "coin_change", "import": "count", "type": "internal", "type_element": "function"}, {"from_module": "combination_sum", "import": "helper_topdown", "type": "internal", "type_element": "function"}, {"from_module": "combination_sum", "import": "combination_sum_topdown", "type": "internal", "type_element": "function"}, {"from_module": "combination_sum", "import": "combination_sum_bottom_up", "type": "internal", "type_element": "function"}, {"from_module": "edit_distance", "import": "edit_distance", "type": "internal", "type_element": "function"}, {"from_module": "egg_drop", "import": "egg_drop", "type": "internal", "type_element": "function"}, {"from_module": "fib", "import": "fib_recursive", "type": "internal", "type_element": "function"}, {"from_module": "fib", "import": "fib_list", "type": "internal", "type_element": "function"}, {"from_module": "fib", "import": "fib_iter", "type": "internal", "type_element": "function"}, {"from_module": "hosoya_triangle", "import": "hosoya", "type": "internal", "type_element": "function"}, {"from_module": "hosoya_triangle", "import": "print_hosoya", "type": "internal", "type_element": "function"}, {"from_module": "hosoya_triangle", "import": "hosoya_testing", "type": "internal", "type_element": "function"}, {"from_module": "house_robber", "import": "house_robber", "type": "internal", "type_element": "function"}, {"from_module": "job_scheduling", "import": "binary_search", "type": "internal", "type_element": "function"}, {"from_module": "job_scheduling", "import": "schedule", "type": "internal", "type_element": "function"}, {"from_module": "job_scheduling", "import": "Job", "type": "internal", "type_element": "class"}, {"from_module": "knapsack", "import": "get_maximum_value", "type": "internal", "type_element": "function"}, {"from_module": "knapsack", "import": "Item", "type": "internal", "type_element": "class"}, {"from_module": "longest_increasing", "import": "longest_increasing_subsequence", "type": "internal", "type_element": "function"}, {"from_module": "longest_increasing", "import": "longest_increasing_subsequence_optimized", "type": "internal", "type_element": "function"}, {"from_module": "longest_increasing", "import": "longest_increasing_subsequence_optimized2", "type": "internal", "type_element": "function"}, {"from_module": "matrix_chain_order", "import": "matrix_chain_order", "type": "internal", "type_element": "function"}, {"from_module": "matrix_chain_order", "import": "print_optimal_solution", "type": "internal", "type_element": "function"}, {"from_module": "matrix_chain_order", "import": "main", "type": "internal", "type_element": "function"}, {"from_module": "max_product_subarray", "import": "max_product", "type": "internal", "type_element": "function"}, {"from_module": "max_product_subarray", "import": "subarray_with_max_product", "type": "internal", "type_element": "function"}, {"from_module": "max_subarray", "import": "max_subarray", "type": "internal", "type_element": "function"}, {"from_module": "min_cost_path", "import": "min_cost", "type": "internal", "type_element": "function"}, {"from_module": "num_decodings", "import": "num_decodings", "type": "internal", "type_element": "function"}, {"from_module": "num_decodings", "import": "num_decodings2", "type": "internal", "type_element": "function"}, {"from_module": "regex_matching", "import": "is_match", "type": "internal", "type_element": "function"}, {"from_module": "rod_cut", "import": "cut_rod", "type": "internal", "type_element": "function"}, {"from_module": "word_break", "import": "word_break", "type": "internal", "type_element": "function"}, {"from_module": "int_divide", "import": "int_divide", "type": "internal", "type_element": "function"}, {"from_module": "k_factor", "import": "find_k_factor", "type": "internal", "type_element": "function"}, {"from_module": "planting_trees", "import": "planting_trees", "type": "internal", "type_element": "function"}], "is_test": false}], "output/keon/algorithms/algorithms/algorithms/unix": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/unix/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "path.join_with_slash", "import": "join_with_slash", "type": "internal", "type_element": "function"}, {"from_module": "path.full_path", "import": "full_path", "type": "internal", "type_element": "function"}, {"from_module": "path.split", "import": "split", "type": "internal", "type_element": "function"}, {"from_module": "path.simplify_path", "import": "simplify_path_v1", "type": "internal", "type_element": "function"}, {"from_module": "path.simplify_path", "import": "simplify_path_v2", "type": "internal", "type_element": "function"}], "is_test": false}], "output/keon/algorithms/algorithms/algorithms/unix/path": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/unix/path/join_with_slash.py", "fileNameBase": "join_with_slash", "extension": "py", "doc": {"long_description": "For example:\n\npath/to/dir + file --> path/to/dir/file\npath/to/dir/ + file --> path/to/dir/file\nhttp://algorithms.com/ + part --> http://algorithms.com/part\nhttp://algorithms.com + part --> http://algorithms/part", "short_description": "Both URL and file path joins use slashes as dividers between their parts.", "full": "Both URL and file path joins use slashes as dividers between their parts.\nFor example:\n\npath/to/dir + file --> path/to/dir/file\npath/to/dir/ + file --> path/to/dir/file\nhttp://algorithms.com/ + part --> http://algorithms.com/part\nhttp://algorithms.com + part --> http://algorithms/part"}}, "dependencies": [{"import": "os", "type": "external", "type_element": "module"}], "functions": {"join_with_slash": {"args": ["base", "suffix"], "returns": ["full_path"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 19}, "calls": ["base.rstrip.rstrip", "suffix.lstrip().rstrip.lstrip().rstrip", "suffix.lstrip().rstrip.lstrip"], "store_vars_calls": {"base": "base.rstrip", "suffix": "suffix.lstrip().rstrip"}, "source_code": "def join_with_slash(base, suffix):\n    base = base.rstrip('/')\n    suffix = suffix.lstrip('/').rstrip()\n    full_path = '{}/{}'.format(base, suffix)\n    return full_path"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/unix/path/split.py", "fileNameBase": "split", "extension": "py", "doc": {"long_description": "Example:\nInput: https://algorithms/unix/test.py   (for url)\nOutput:\n    part[0]: https://algorithms/unix\n    part[1]: test.py\n\nInput: algorithms/unix/test.py          (for file path)\nOutput:\n    part[0]: algorithms/unix\n    part[1]: test.py", "short_description": "Splitting a path into 2 parts", "full": "Splitting a path into 2 parts\nExample:\nInput: https://algorithms/unix/test.py   (for url)\nOutput:\n    part[0]: https://algorithms/unix\n    part[1]: test.py\n\nInput: algorithms/unix/test.py          (for file path)\nOutput:\n    part[0]: algorithms/unix\n    part[1]: test.py"}}, "dependencies": [{"import": "os", "type": "external", "type_element": "module"}], "functions": {"split": {"args": ["path"], "returns": ["parts"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 24}, "calls": ["path.rpartition", "parts.append"], "store_vars_calls": {"split_part": "path.rpartition"}, "source_code": "def split(path):\n    parts = []\n    split_part = path.rpartition('/')\n    parts.append(split_part[0])\n    parts.append(split_part[2])\n    return parts"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/unix/path/simplify_path.py", "fileNameBase": "simplify_path", "extension": "py", "doc": {"long_description": "For example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\nCorner Cases:\n\nDid you consider the case where path = \"/../\"?\nIn this case, you should return \"/\".\nAnother corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\nIn this case, you should ignore redundant slashes and return \"/home/foo\".\n\nReference: https://leetcode.com/problems/simplify-path/description/", "short_description": "Given an absolute path for a file (Unix-style), simplify it.", "full": "Given an absolute path for a file (Unix-style), simplify it.\n\nFor example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\nCorner Cases:\n\nDid you consider the case where path = \"/../\"?\nIn this case, you should return \"/\".\nAnother corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\nIn this case, you should ignore redundant slashes and return \"/home/foo\".\n\nReference: https://leetcode.com/problems/simplify-path/description/"}}, "dependencies": [{"import": "os", "type": "external", "type_element": "module"}], "functions": {"simplify_path_v1": {"args": ["path"], "returns": ["os.path.abspath(path)"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 21}, "calls": ["os.path.abspath"], "source_code": "def simplify_path_v1(path):\n    return os.path.abspath(path)"}, "simplify_path_v2": {"args": ["path"], "returns": ["'/' + '/'.join(stack)"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 30}, "calls": ["path.split", "stack.pop", "stack.append"], "source_code": "def simplify_path_v2(path):\n    (stack, tokens) = ([], path.split('/'))\n    for token in tokens:\n        if token == '..' and stack:\n            stack.pop()\n        elif token != '..' and token != '.' and token:\n            stack.append(token)\n    return '/' + '/'.join(stack)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/unix/path/full_path.py", "fileNameBase": "full_path", "extension": "py", "doc": {"short_description": "Get a full absolute path a file", "full": "Get a full absolute path a file"}}, "dependencies": [{"import": "os", "type": "external", "type_element": "module"}], "functions": {"full_path": {"args": ["file"], "returns": ["os.path.abspath(os.path.expanduser(file))"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 7}, "calls": ["os.path.abspath", "os.path.expanduser"], "source_code": "def full_path(file):\n    return os.path.abspath(os.path.expanduser(file))"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/heap": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/heap/binary_heap.py", "fileNameBase": "binary_heap", "extension": "py", "doc": {"long_description": "its children. The root, therefore, is the minimum element in the tree. The min\nheap uses an array to represent the data and operation. For example a min heap:\n\n     4\n   /   \\\n  50    7\n / \\   /\n55 90 87\n\nHeap [0, 4, 50, 7, 55, 90, 87]\n\nMethod in class: insert, remove_min\nFor example insert(2) in a min heap:\n\n     4                     4                     2\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     2       -->     50    4\n / \\   /  \\           /  \\   / \\             /  \\  /  \\\n55 90 87   2         55  90 87  7           55  90 87  7\n\nFor example remove_min() in a min heap:\n\n     4                     87                    7\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     7       -->     50    87\n / \\   /              /  \\                   /  \\\n55 90 87             55  90                 55  90", "short_description": "Binary Heap. A min heap is a complete binary tree where each node is smaller than", "full": "Binary Heap. A min heap is a complete binary tree where each node is smaller than\nits children. The root, therefore, is the minimum element in the tree. The min\nheap uses an array to represent the data and operation. For example a min heap:\n\n     4\n   /   \\\n  50    7\n / \\   /\n55 90 87\n\nHeap [0, 4, 50, 7, 55, 90, 87]\n\nMethod in class: insert, remove_min\nFor example insert(2) in a min heap:\n\n     4                     4                     2\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     2       -->     50    4\n / \\   /  \\           /  \\   / \\             /  \\  /  \\\n55 90 87   2         55  90 87  7           55  90 87  7\n\nFor example remove_min() in a min heap:\n\n     4                     87                    7\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     7       -->     50    87\n / \\   /              /  \\                   /  \\\n55 90 87             55  90                 55  90"}}, "dependencies": [{"from_module": "abc", "import": "ABCMeta", "type": "external", "type_element": "module"}, {"from_module": "abc", "import": "abstractmethod", "type": "external", "type_element": "module"}], "classes": {"AbstractHeap": {"doc": {"short_description": "Abstract Class for Binary Heap.", "full": "Abstract Class for Binary Heap."}, "min_max_lineno": {"min_lineno": 35, "max_lineno": 60}, "methods": {"__init__": {"doc": {"short_description": "Pass."}, "args": ["self"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 40}, "source_code": "def __init__(self):\n    \"\"\"Pass.\"\"\""}, "perc_up": {"doc": {"short_description": "Pass."}, "args": ["self", "i"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 44}, "source_code": "@abstractmethod\ndef perc_up(self, i):\n    \"\"\"Pass.\"\"\""}, "insert": {"doc": {"short_description": "Pass."}, "args": ["self", "val"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 48}, "source_code": "@abstractmethod\ndef insert(self, val):\n    \"\"\"Pass.\"\"\""}, "perc_down": {"doc": {"short_description": "Pass."}, "args": ["self", "i"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 52}, "source_code": "@abstractmethod\ndef perc_down(self, i):\n    \"\"\"Pass.\"\"\""}, "min_child": {"doc": {"short_description": "Pass."}, "args": ["self", "i"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 56}, "source_code": "@abstractmethod\ndef min_child(self, i):\n    \"\"\"Pass.\"\"\""}, "remove_min": {"doc": {"short_description": "Pass."}, "args": ["self"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 60}, "source_code": "@abstractmethod\ndef remove_min(self):\n    \"\"\"Pass.\"\"\""}}}, "BinaryHeap": {"doc": {"short_description": "Binary Heap Class", "full": "Binary Heap Class"}, "extend": ["AbstractHeap"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 123}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 68}, "source_code": "def __init__(self):\n    self.current_size = 0\n    self.heap = [0]"}, "perc_up": {"args": ["self", "i"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 75}, "source_code": "def perc_up(self, i):\n    while i // 2 > 0:\n        if self.heap[i] < self.heap[i // 2]:\n            (self.heap[i], self.heap[i // 2]) = (self.heap[i // 2], self.heap[i])\n        i = i // 2"}, "insert": {"doc": {"long_description": "It inserts rightmost spot so as to maintain the complete tree property.\nThen, it fixes the tree by swapping the new element with its parent,\nuntil it finds an appropriate spot for the element. It essentially\nperc_up the minimum element\nComplexity: O(logN)", "short_description": "Method insert always start by inserting the element at the bottom."}, "args": ["self", "val"], "min_max_lineno": {"min_lineno": 76, "max_lineno": 90}, "calls": ["binary_heap.BinaryHeap.heap.append", "binary_heap.BinaryHeap.perc_up"], "source_code": "def insert(self, val):\n    \"\"\"\n        Method insert always start by inserting the element at the bottom.\n        It inserts rightmost spot so as to maintain the complete tree property.\n        Then, it fixes the tree by swapping the new element with its parent,\n        until it finds an appropriate spot for the element. It essentially\n        perc_up the minimum element\n        Complexity: O(logN)\n        \"\"\"\n    self.heap.append(val)\n    self.current_size = self.current_size + 1\n    self.perc_up(self.current_size)\n    '\\n        Method min_child returns the index of smaller of 2 children of parent at index i\\n        '"}, "min_child": {"args": ["self", "i"], "returns": ["2 * i", "2 * i", "2 * i + 1"], "min_max_lineno": {"min_lineno": 93, "max_lineno": 99}, "source_code": "def min_child(self, i):\n    if 2 * i + 1 > self.current_size:\n        return 2 * i\n    if self.heap[2 * i] > self.heap[2 * i + 1]:\n        return 2 * i + 1\n    return 2 * i"}, "perc_down": {"args": ["self", "i"], "min_max_lineno": {"min_lineno": 100, "max_lineno": 107}, "calls": ["binary_heap.BinaryHeap.min_child"], "store_vars_calls": {"min_child": "self.min_child"}, "source_code": "def perc_down(self, i):\n    while 2 * i < self.current_size:\n        min_child = self.min_child(i)\n        if self.heap[min_child] < self.heap[i]:\n            (self.heap[min_child], self.heap[i]) = (self.heap[i], self.heap[min_child])\n        i = min_child"}, "remove_min": {"args": ["self"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 115, "max_lineno": 123}, "calls": ["binary_heap.BinaryHeap.heap.pop", "binary_heap.BinaryHeap.perc_down"], "source_code": "def remove_min(self):\n    ret = self.heap[1]\n    self.heap[1] = self.heap[self.current_size]\n    self.current_size = self.current_size - 1\n    self.heap.pop()\n    self.perc_down(1)\n    return ret"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/heap/sliding_window_max.py", "fileNameBase": "sliding_window_max", "extension": "py", "doc": {"long_description": "which is moving from the very left of the array to the very right.\nYou can only see the k numbers in the window.\nEach time the sliding window moves right by one position.\n\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\n\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\nTherefore, return the max sliding window as [3,3,5,5,6,7].", "short_description": "Given an array nums, there is a sliding window of size k", "full": "Given an array nums, there is a sliding window of size k\nwhich is moving from the very left of the array to the very right.\nYou can only see the k numbers in the window.\nEach time the sliding window moves right by one position.\n\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\n\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\nTherefore, return the max sliding window as [3,3,5,5,6,7]."}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"max_sliding_window": {"args": ["nums", "k"], "returns": ["res", "nums"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 42}, "calls": ["collections.deque", "res.append", "max", "len", "collections.deque.append", "collections.deque.popleft"], "store_vars_calls": {"queue": "collections.deque"}, "source_code": "def max_sliding_window(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if not nums:\n        return nums\n    queue = collections.deque()\n    res = []\n    for num in nums:\n        if len(queue) < k:\n            queue.append(num)\n        else:\n            res.append(max(queue))\n            queue.popleft()\n            queue.append(num)\n    res.append(max(queue))\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/heap/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "binary_heap", "import": "AbstractHeap", "type": "internal", "type_element": "class"}, {"from_module": "binary_heap", "import": "BinaryHeap", "type": "internal", "type_element": "class"}, {"from_module": "skyline", "import": "get_skyline", "type": "internal", "type_element": "function"}, {"from_module": "sliding_window_max", "import": "max_sliding_window", "type": "internal", "type_element": "function"}, {"from_module": "merge_sorted_k_lists", "import": "merge_k_lists", "type": "internal", "type_element": "function"}, {"from_module": "merge_sorted_k_lists", "import": "merge_k_lists", "type": "internal", "type_element": "function"}, {"from_module": "merge_sorted_k_lists", "import": "ListNode", "type": "internal", "type_element": "class"}, {"from_module": "k_closest_points", "import": "k_closest", "type": "internal", "type_element": "function"}, {"from_module": "k_closest_points", "import": "distance", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/heap/merge_sorted_k_lists.py", "fileNameBase": "merge_sorted_k_lists", "extension": "py", "doc": {"short_description": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.", "full": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity."}}, "dependencies": [{"from_module": "heapq", "import": "heappop", "type": "external", "type_element": "module"}, {"from_module": "heapq", "import": "heapreplace", "type": "external", "type_element": "module"}, {"from_module": "heapq", "import": "heapify", "type": "external", "type_element": "module"}, {"from_module": "queue", "import": "PriorityQueue", "type": "external", "type_element": "module"}], "classes": {"ListNode": {"doc": {"short_description": "ListNode Class", "full": "ListNode Class"}, "extend": ["object"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 17}, "methods": {"__init__": {"args": ["self", "val"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 17}, "source_code": "def __init__(self, val):\n    self.val = val\n    self.next = None"}}}}, "functions": {"merge_k_lists": {"doc": {"short_description": "Merge List "}, "args": ["lists"], "returns": ["dummy.next"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 50}, "calls": ["queue.PriorityQueue", "queue.PriorityQueue.empty", "queue.PriorityQueue.put", "queue.PriorityQueue.get"], "store_vars_calls": {"dummy": "ListNode", "q": "PriorityQueue"}, "source_code": "def merge_k_lists(lists):\n    \"\"\" Merge List \"\"\"\n    dummy = ListNode(None)\n    curr = dummy\n    q = PriorityQueue()\n    for node in lists:\n        if node:\n            q.put((node.val, node))\n    while not q.empty():\n        curr.next = q.get()[1]\n        curr = curr.next\n        if curr.next:\n            q.put((curr.next.val, curr.next))\n    return dummy.next"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/heap/k_closest_points.py", "fileNameBase": "k_closest_points", "extension": "py", "doc": {"long_description": "Idea: Maintain a max heap of k elements.\nWe can iterate through all points.\nIf a point p has a smaller distance to the origin than the top element of a\nheap, we add point p to the heap and remove the top element.\nAfter iterating through all points, our heap contains the k closest points to\nthe origin.", "short_description": "Given a list of points, find the k closest to the origin.", "full": "Given a list of points, find the k closest to the origin.\n\nIdea: Maintain a max heap of k elements.\nWe can iterate through all points.\nIf a point p has a smaller distance to the origin than the top element of a\nheap, we add point p to the heap and remove the top element.\nAfter iterating through all points, our heap contains the k closest points to\nthe origin."}}, "dependencies": [{"from_module": "heapq", "import": "heapify", "type": "external", "type_element": "module"}, {"from_module": "heapq", "import": "heappushpop", "type": "external", "type_element": "module"}], "functions": {"k_closest": {"doc": {"long_description": "Python does not support a max heap; thus we can use the default min heap\nwhere the keys (distance) are negated.", "short_description": "Initialize max heap with first k points."}, "args": ["points", "k", "origin"], "returns": ["[point for (nd, point) in heap]"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 44}, "calls": ["heapq.heapify", "k_closest_points.distance", "heapq.heappushpop"], "store_vars_calls": {"dist": "distance"}, "source_code": "def k_closest(points, k, origin=(0, 0)):\n    \"\"\"Initialize max heap with first k points.\n    Python does not support a max heap; thus we can use the default min heap\n    where the keys (distance) are negated.\n    \"\"\"\n    heap = [(-distance(p, origin), p) for p in points[:k]]\n    heapify(heap)\n    '\\n    For every point p in points[k:],\\n    check if p is smaller than the root of the max heap;\\n    if it is, add p to heap and remove root. Reheapify.\\n    '\n    for point in points[k:]:\n        dist = distance(point, origin)\n        heappushpop(heap, (-dist, point))\n        'Same as:\\n            if d < -heap[0][0]:\\n                heappush(heap, (-d,p))\\n                heappop(heap)\\n\\n        Note: heappushpop is more efficient than separate push and pop calls.\\n        Each heappushpop call takes O(logk) time.\\n        '\n    return [point for (nd, point) in heap]"}, "distance": {"doc": {"short_description": "Calculates the distance for a point from origo"}, "args": ["point", "origin"], "returns": ["(point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 49}, "source_code": "def distance(point, origin=(0, 0)):\n    \"\"\" Calculates the distance for a point from origo\"\"\"\n    return (point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/heap/skyline.py", "fileNameBase": "skyline", "extension": "py", "doc": {"long_description": "in that city when viewed from a distance.\nNow suppose you are given the locations and height of all the buildings\nas shown on a cityscape photo (Figure A),\nwrite a program to output the skyline formed by these buildings collectively (Figure B).\n\nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi],\nwhere Li and Ri are the x coordinates of the left and right edge of the ith building, respectively,\nand Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0 < Hi \u2264 INT_MAX, and Ri - Li > 0.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nFor instance, the dimensions of all buildings in Figure A are recorded as:\n[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\n\nThe output is a list of \"key points\" (red dots in Figure B) in the format of\n[ [x1,y1], [x2, y2], [x3, y3], ... ]\nthat uniquely defines a skyline.\nA key point is the left endpoint of a horizontal line segment. Note that the last key point,\nwhere the rightmost building ends,\nis merely used to mark the termination of the skyline, and always has zero height.\nAlso, the ground in between any two adjacent buildings should be considered part of the skyline contour.\n\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\n\nNotes:\n\nThe number of buildings in any input list is guaranteed to be in the range [0, 10000].\nThe input list is already sorted in ascending order by the left x position Li.\nThe output list must be sorted by the x position.\nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance,\n[...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged\ninto one in the final output as such: [...[2 3], [4 5], [12 7], ...]", "short_description": "A city's skyline is the outer contour of the silhouette formed by all the buildings", "full": "A city's skyline is the outer contour of the silhouette formed by all the buildings\nin that city when viewed from a distance.\nNow suppose you are given the locations and height of all the buildings\nas shown on a cityscape photo (Figure A),\nwrite a program to output the skyline formed by these buildings collectively (Figure B).\n\nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi],\nwhere Li and Ri are the x coordinates of the left and right edge of the ith building, respectively,\nand Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0 < Hi \u2264 INT_MAX, and Ri - Li > 0.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nFor instance, the dimensions of all buildings in Figure A are recorded as:\n[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\n\nThe output is a list of \"key points\" (red dots in Figure B) in the format of\n[ [x1,y1], [x2, y2], [x3, y3], ... ]\nthat uniquely defines a skyline.\nA key point is the left endpoint of a horizontal line segment. Note that the last key point,\nwhere the rightmost building ends,\nis merely used to mark the termination of the skyline, and always has zero height.\nAlso, the ground in between any two adjacent buildings should be considered part of the skyline contour.\n\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\n\nNotes:\n\nThe number of buildings in any input list is guaranteed to be in the range [0, 10000].\nThe input list is already sorted in ascending order by the left x position Li.\nThe output list must be sorted by the x position.\nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance,\n[...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged\ninto one in the final output as such: [...[2 3], [4 5], [12 7], ...]"}}, "dependencies": [{"import": "heapq", "type": "external", "type_element": "module"}], "functions": {"get_skyline": {"doc": {"short_description": "Wortst Time Complexity: O(NlogN)"}, "args": ["lrh"], "returns": ["skyline"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 61}, "calls": ["len", "heapq.heappush", "heapq.heappop"], "source_code": "def get_skyline(lrh):\n    \"\"\"\n    Wortst Time Complexity: O(NlogN)\n    :type buildings: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    (skyline, live) = ([], [])\n    (i, n) = (0, len(lrh))\n    while i < n or live:\n        if not live or (i < n and lrh[i][0] <= -live[0][1]):\n            x = lrh[i][0]\n            while i < n and lrh[i][0] == x:\n                heapq.heappush(live, (-lrh[i][2], -lrh[i][1]))\n                i += 1\n        else:\n            x = -live[0][1]\n            while live and -live[0][1] <= x:\n                heapq.heappop(live)\n        height = len(live) and -live[0][0]\n        if not skyline or height != skyline[-1][1]:\n            skyline += ([x, height],)\n    return skyline"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/map": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/map/valid_sudoku.py", "fileNameBase": "valid_sudoku", "extension": "py", "doc": {"long_description": "The Sudoku board could be partially filled, where empty cells are filled with\nthe character '.'.", "short_description": "Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.", "full": "Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\n\nThe Sudoku board could be partially filled, where empty cells are filled with\nthe character '.'."}}, "functions": {"is_valid_sudoku": {"args": ["self", "board"], "returns": ["len(seen) == len(set(seen))"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 15}, "calls": ["enumerate", "len", "set"], "source_code": "def is_valid_sudoku(self, board):\n    seen = []\n    for (i, row) in enumerate(board):\n        for (j, c) in enumerate(row):\n            if c != '.':\n                seen += [(c, j), (i, c), (i / 3, j / 3, c)]\n    return len(seen) == len(set(seen))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/map/randomized_set.py", "fileNameBase": "randomized_set", "extension": "py", "doc": {"long_description": "in average O(1) time.\n\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\ngetRandom: Returns a random element from current set of elements.\nEach element must have the same probability of being returned.", "short_description": "Design a data structure that supports all following operations", "full": "Design a data structure that supports all following operations\nin average O(1) time.\n\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\ngetRandom: Returns a random element from current set of elements.\nEach element must have the same probability of being returned."}}, "dependencies": [{"import": "random", "type": "external", "type_element": "module"}], "classes": {"RandomizedSet": {"min_max_lineno": {"min_lineno": 15, "max_lineno": 39}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 19}, "source_code": "def __init__(self):\n    self.nums = []\n    self.idxs = {}"}, "insert": {"args": ["self", "val"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 26}, "calls": ["randomized_set.RandomizedSet.nums.append", "len"], "source_code": "def insert(self, val):\n    if val not in self.idxs:\n        self.nums.append(val)\n        self.idxs[val] = len(self.nums) - 1\n        return True\n    return False"}, "remove": {"args": ["self", "val"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 35}, "calls": ["randomized_set.RandomizedSet.nums.pop", "randomized_set.RandomizedSet.idxs.pop"], "source_code": "def remove(self, val):\n    if val in self.idxs:\n        (idx, last) = (self.idxs[val], self.nums[-1])\n        (self.nums[idx], self.idxs[last]) = (last, idx)\n        self.nums.pop()\n        self.idxs.pop(val, 0)\n        return True\n    return False"}, "get_random": {"args": ["self"], "returns": ["self.nums[idx]"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 39}, "calls": ["random.randint", "len"], "store_vars_calls": {"idx": "random.randint"}, "source_code": "def get_random(self):\n    idx = random.randint(0, len(self.nums) - 1)\n    return self.nums[idx]"}}}}, "body": {"calls": ["print", "randomized_set.RandomizedSet.insert", "randomized_set.RandomizedSet.remove", "randomized_set.RandomizedSet.get_random"], "store_vars_calls": {"rs": "RandomizedSet"}, "source_code": ["RandomizedSet()", "print('insert 1: ', rs.insert(1))", "rs.insert(1)", "print('insert 2: ', rs.insert(2))", "rs.insert(2)", "print('insert 3: ', rs.insert(3))", "rs.insert(3)", "print('insert 4: ', rs.insert(4))", "rs.insert(4)", "print('remove 3: ', rs.remove(3))", "rs.remove(3)", "print('remove 3: ', rs.remove(3))", "rs.remove(3)", "print('remove 1: ', rs.remove(1))", "rs.remove(1)", "print('random: ', rs.get_random())", "rs.get_random()", "print('random: ', rs.get_random())", "rs.get_random()", "print('random: ', rs.get_random())", "rs.get_random()", "print('random: ', rs.get_random())", "rs.get_random()"]}, "main_info": {"main_flag": 1, "main_function": "randomized_set.RandomizedSet", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/map/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "hashtable", "import": "HashTable", "type": "internal", "type_element": "class"}, {"from_module": "hashtable", "import": "ResizableHashTable", "type": "internal", "type_element": "class"}, {"from_module": "separate_chaining_hashtable", "import": "Node", "type": "internal", "type_element": "class"}, {"from_module": "separate_chaining_hashtable", "import": "SeparateChainingHashTable", "type": "internal", "type_element": "class"}, {"from_module": "word_pattern", "import": "word_pattern", "type": "internal", "type_element": "function"}, {"from_module": "is_isomorphic", "import": "is_isomorphic", "type": "internal", "type_element": "function"}, {"from_module": "is_anagram", "import": "is_anagram", "type": "internal", "type_element": "function"}, {"from_module": "longest_palindromic_subsequence", "import": "longest_palindromic_subsequence", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/map/longest_palindromic_subsequence.py", "fileNameBase": "longest_palindromic_subsequence", "extension": "py"}, "functions": {"longest_palindromic_subsequence": {"args": ["s"], "returns": ["logestLen"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 30}, "calls": ["len", "range"], "store_vars_calls": {"k": "len"}, "source_code": "def longest_palindromic_subsequence(s):\n    k = len(s)\n    olist = [0] * k\n    nList = [0] * k\n    logestSubStr = ''\n    logestLen = 0\n    for j in range(0, k):\n        for i in range(0, j + 1):\n            if j - i <= 1:\n                if s[i] == s[j]:\n                    nList[i] = 1\n                    len_t = j - i + 1\n                    if logestLen < len_t:\n                        logestSubStr = s[i:j + 1]\n                        logestLen = len_t\n            elif s[i] == s[j] and olist[i + 1]:\n                nList[i] = 1\n                len_t = j - i + 1\n                if logestLen < len_t:\n                    logestSubStr = s[i:j + 1]\n                    logestLen = len_t\n        olist = nList\n        nList = [0] * k\n    return logestLen"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/map/is_isomorphic.py", "fileNameBase": "is_isomorphic", "extension": "py", "doc": {"long_description": "Two strings are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while\npreserving the order of characters. No two characters may map to the same\ncharacter but a character may map to itself.\n\nExample 1:\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\nExample 2:\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\nInput: s = \"paper\", t = \"title\"\nOutput: true\nReference: https://leetcode.com/problems/isomorphic-strings/description/", "short_description": "Given two strings s and t, determine if they are isomorphic.", "full": "Given two strings s and t, determine if they are isomorphic.\nTwo strings are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while\npreserving the order of characters. No two characters may map to the same\ncharacter but a character may map to itself.\n\nExample 1:\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\nExample 2:\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\nInput: s = \"paper\", t = \"title\"\nOutput: true\nReference: https://leetcode.com/problems/isomorphic-strings/description/"}}, "functions": {"is_isomorphic": {"args": ["s", "t"], "returns": ["True", "False", "False", "False"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 41}, "calls": ["set", "range", "len", "set.add"], "store_vars_calls": {"set_value": "set"}, "source_code": "def is_isomorphic(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    dict = {}\n    set_value = set()\n    for i in range(len(s)):\n        if s[i] not in dict:\n            if t[i] in set_value:\n                return False\n            dict[s[i]] = t[i]\n            set_value.add(t[i])\n        elif dict[s[i]] != t[i]:\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/map/longest_common_subsequence.py", "fileNameBase": "longest_common_subsequence", "extension": "py", "doc": {"long_description": "find the longest common sub sequence's length.\n\nExpected complexity O(n logn).", "short_description": "Given string a and b, with b containing all distinct characters,", "full": "Given string a and b, with b containing all distinct characters,\nfind the longest common sub sequence's length.\n\nExpected complexity O(n logn)."}}, "functions": {"max_common_sub_string": {"args": ["s1", "s2"], "returns": ["subs"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 29}, "calls": ["len", "range"], "source_code": "def max_common_sub_string(s1, s2):\n    s2dic = {s2[i]: i for i in range(len(s2))}\n    maxr = 0\n    subs = ''\n    i = 0\n    while i < len(s1):\n        if s1[i] in s2dic:\n            j = s2dic[s1[i]]\n            k = i\n            while j < len(s2) and k < len(s1) and (s1[k] == s2[j]):\n                k += 1\n                j += 1\n            if k - i > maxr:\n                maxr = k - i\n                subs = s1[i:k]\n            i = k\n        else:\n            i += 1\n    return subs"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/map/is_anagram.py", "fileNameBase": "is_anagram", "extension": "py", "doc": {"long_description": "Example 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nNote:\nYou may assume the string contains only lowercase alphabets.\n\nReference: https://leetcode.com/problems/valid-anagram/description/", "short_description": "Given two strings s and t , write a function to determine if t is an anagram of s.", "full": "Given two strings s and t , write a function to determine if t is an anagram of s.\n\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nNote:\nYou may assume the string contains only lowercase alphabets.\n\nReference: https://leetcode.com/problems/valid-anagram/description/"}}, "functions": {"is_anagram": {"args": ["s", "t"], "returns": ["maps == mapt"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 30}, "calls": ["maps.get", "mapt.get"], "source_code": "def is_anagram(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    maps = {}\n    mapt = {}\n    for i in s:\n        maps[i] = maps.get(i, 0) + 1\n    for i in t:\n        mapt[i] = mapt.get(i, 0) + 1\n    return maps == mapt"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/map/word_pattern.py", "fileNameBase": "word_pattern", "extension": "py", "doc": {"long_description": "Here follow means a full match, such that there is a bijection between a\nletter in pattern and a non-empty word in str.\n\nExample 1:\nInput: pattern = \"abba\", str = \"dog cat cat dog\"\nOutput: true\n\nExample 2:\nInput:pattern = \"abba\", str = \"dog cat cat fish\"\nOutput: false\n\nExample 3:\nInput: pattern = \"aaaa\", str = \"dog cat cat dog\"\nOutput: false\n\nExample 4:\nInput: pattern = \"abba\", str = \"dog dog dog dog\"\nOutput: false\nNotes:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\nReference: https://leetcode.com/problems/word-pattern/description/", "short_description": "Given a pattern and a string str, find if str follows the same pattern.", "full": "Given a pattern and a string str, find if str follows the same pattern.\nHere follow means a full match, such that there is a bijection between a\nletter in pattern and a non-empty word in str.\n\nExample 1:\nInput: pattern = \"abba\", str = \"dog cat cat dog\"\nOutput: true\n\nExample 2:\nInput:pattern = \"abba\", str = \"dog cat cat fish\"\nOutput: false\n\nExample 3:\nInput: pattern = \"aaaa\", str = \"dog cat cat dog\"\nOutput: false\n\nExample 4:\nInput: pattern = \"abba\", str = \"dog dog dog dog\"\nOutput: false\nNotes:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\nReference: https://leetcode.com/problems/word-pattern/description/"}}, "functions": {"word_pattern": {"args": ["pattern", "str"], "returns": ["True", "False", "False", "False"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 41}, "calls": ["set", "str.split", "range", "len", "set.add"], "store_vars_calls": {"set_value": "set", "list_str": "str.split"}, "source_code": "def word_pattern(pattern, str):\n    dict = {}\n    set_value = set()\n    list_str = str.split()\n    if len(list_str) != len(pattern):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] not in dict:\n            if list_str[i] in set_value:\n                return False\n            dict[pattern[i]] = list_str[i]\n            set_value.add(list_str[i])\n        elif dict[pattern[i]] != list_str[i]:\n            return False\n    return True"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/dfs": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dfs/sudoku_solver.py", "fileNameBase": "sudoku_solver", "extension": "py", "doc": {"long_description": "create a hash table (dictionary) val to store possible values in every location.\nEach time, start from the location with fewest possible values, choose one value\nfrom it and then update the board and possible values at other locations.\nIf this update is valid, keep solving (DFS). If this update is invalid (leaving\nzero possible values at some locations) or this value doesn't lead to the\nsolution, undo the updates and then choose the next value.\nSince we calculated val at the beginning and start filling the board from the\nlocation with fewest possible values, the amount of calculation and thus the\nruntime can be significantly reduced:\n\n\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest\npython solutions here.\n\n\nThe PossibleVals function may be further simplified/optimized, but it works just\nfine for now. (it would look less lengthy if we are allowed to use numpy array\nfor the board lol).", "short_description": "It's similar to how human solve Sudoku.", "full": "It's similar to how human solve Sudoku.\n\ncreate a hash table (dictionary) val to store possible values in every location.\nEach time, start from the location with fewest possible values, choose one value\nfrom it and then update the board and possible values at other locations.\nIf this update is valid, keep solving (DFS). If this update is invalid (leaving\nzero possible values at some locations) or this value doesn't lead to the\nsolution, undo the updates and then choose the next value.\nSince we calculated val at the beginning and start filling the board from the\nlocation with fewest possible values, the amount of calculation and thus the\nruntime can be significantly reduced:\n\n\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest\npython solutions here.\n\n\nThe PossibleVals function may be further simplified/optimized, but it works just\nfine for now. (it would look less lengthy if we are allowed to use numpy array\nfor the board lol)."}}, "classes": {"Sudoku": {"min_max_lineno": {"min_lineno": 23, "max_lineno": 96}, "methods": {"__init__": {"args": ["self", "board", "row", "col"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 29}, "calls": ["sudoku_solver.Sudoku.possible_values"], "store_vars_calls": {"self.val": "self.possible_values"}, "source_code": "def __init__(self, board, row, col):\n    self.board = board\n    self.row = row\n    self.col = col\n    self.val = self.possible_values()"}, "possible_values": {"args": ["self"], "returns": ["val"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 46}, "calls": ["range", "val.keys", "d.get"], "source_code": "def possible_values(self):\n    a = '123456789'\n    (d, val) = ({}, {})\n    for i in range(self.row):\n        for j in range(self.col):\n            ele = self.board[i][j]\n            if ele != '.':\n                d['r', i] = d.get(('r', i), []) + [ele]\n                d['c', j] = d.get(('c', j), []) + [ele]\n                d[i // 3, j // 3] = d.get((i // 3, j // 3), []) + [ele]\n            else:\n                val[i, j] = []\n    for (i, j) in val.keys():\n        inval = d.get(('r', i), []) + d.get(('c', j), []) + d.get((i / 3, j / 3), [])\n        val[i, j] = [n for n in a if n not in inval]\n    return val"}, "solve": {"args": ["self"], "returns": ["False", "True", "True"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 59}, "calls": ["min", "len", "sudoku_solver.Sudoku.val.keys", "sudoku_solver.Sudoku.valid_one", "sudoku_solver.Sudoku.undo", "sudoku_solver.Sudoku.solve"], "store_vars_calls": {"kee": "min"}, "source_code": "def solve(self):\n    if len(self.val) == 0:\n        return True\n    kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\n    nums = self.val[kee]\n    for n in nums:\n        update = {kee: self.val[kee]}\n        if self.valid_one(n, kee, update):\n            if self.solve():\n                return True\n        self.undo(kee, update)\n    return False"}, "valid_one": {"args": ["self", "n", "kee", "update"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 60, "max_lineno": 72}, "calls": ["sudoku_solver.Sudoku.val.keys", "sudoku_solver.Sudoku.val[].remove", "len"], "source_code": "def valid_one(self, n, kee, update):\n    self.board[kee[0]][kee[1]] = n\n    del self.val[kee]\n    (i, j) = kee\n    for ind in self.val.keys():\n        if n in self.val[ind]:\n            if ind[0] == i or ind[1] == j or (ind[0] / 3, ind[1] / 3) == (i / 3, j / 3):\n                update[ind] = n\n                self.val[ind].remove(n)\n                if len(self.val[ind]) == 0:\n                    return False\n    return True"}, "undo": {"args": ["self", "kee", "update"], "returns": ["None"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 81}, "calls": ["sudoku_solver.Sudoku.val[].append"], "source_code": "def undo(self, kee, update):\n    self.board[kee[0]][kee[1]] = '.'\n    for k in update:\n        if k not in self.val:\n            self.val[k] = update[k]\n        else:\n            self.val[k].append(update[k])\n    return None"}, "__str__": {"doc": {"long_description": "Generates a board representation as string.", "short_description": "[summary]", "returns": {"description": "[str] -- [board representation]", "is_generator": false}}, "args": ["self"], "returns": ["resp"], "min_max_lineno": {"min_lineno": 82, "max_lineno": 96}, "calls": ["range"], "source_code": "def __str__(self):\n    \"\"\"[summary]\n        Generates a board representation as string.\n\n        Returns:\n            [str] -- [board representation]\n        \"\"\"\n    resp = ''\n    for i in range(self.row):\n        for j in range(self.col):\n            resp += ' {0} '.format(self.board[i][j])\n        resp += '\\n'\n    return resp"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dfs/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "all_factors", "import": "get_factors", "type": "internal", "type_element": "function"}, {"from_module": "all_factors", "import": "get_factors_iterative1", "type": "internal", "type_element": "function"}, {"from_module": "all_factors", "import": "get_factors_iterative2", "type": "internal", "type_element": "function"}, {"from_module": "count_islands", "import": "num_islands", "type": "internal", "type_element": "function"}, {"from_module": "count_islands", "import": "dfs", "type": "internal", "type_element": "function"}, {"from_module": "pacific_atlantic", "import": "pacific_atlantic", "type": "internal", "type_element": "function"}, {"from_module": "pacific_atlantic", "import": "dfs", "type": "internal", "type_element": "function"}, {"from_module": "sudoku_solver", "import": "Sudoku", "type": "internal", "type_element": "class"}, {"from_module": "walls_and_gates", "import": "walls_and_gates", "type": "internal", "type_element": "function"}, {"from_module": "walls_and_gates", "import": "dfs", "type": "internal", "type_element": "function"}, {"from_module": "maze_search", "import": "find_path", "type": "internal", "type_element": "function"}, {"from_module": "maze_search", "import": "dfs", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dfs/maze_search.py", "fileNameBase": "maze_search", "extension": "py", "doc": {"long_description": "only step on the columns whose value is 1\nif there is no path, it returns -1\n(The first column(top left column) is not included in the answer.)\n\nEx 1)\nIf maze is\n[[1,0,1,1,1,1],\n [1,0,1,0,1,0],\n [1,0,1,0,1,1],\n [1,1,1,0,1,1]],\nthe answer is: 14\n\nEx 2)\nIf maze is\n[[1,0,0],\n [0,1,1],\n [0,1,1]],\nthe answer is: -1", "short_description": "Find shortest path from top left column to the right lowest column using DFS.", "full": "Find shortest path from top left column to the right lowest column using DFS.\nonly step on the columns whose value is 1\nif there is no path, it returns -1\n(The first column(top left column) is not included in the answer.)\n\nEx 1)\nIf maze is\n[[1,0,1,1,1,1],\n [1,0,1,0,1,0],\n [1,0,1,0,1,1],\n [1,1,1,0,1,1]],\nthe answer is: 14\n\nEx 2)\nIf maze is\n[[1,0,0],\n [0,1,1],\n [0,1,1]],\nthe answer is: -1"}}, "functions": {"find_path": {"args": ["maze"], "returns": ["cnt"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 27}, "calls": ["maze_search.dfs"], "store_vars_calls": {"cnt": "dfs"}, "source_code": "def find_path(maze):\n    cnt = dfs(maze, 0, 0, 0, -1)\n    return cnt"}, "dfs": {"args": ["maze", "i", "j", "depth", "cnt"], "returns": ["cnt", "cnt"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 56}, "calls": ["len", "range", "maze_search.dfs"], "store_vars_calls": {"row": "len", "col": "len", "cnt": "dfs"}, "source_code": "def dfs(maze, i, j, depth, cnt):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    row = len(maze)\n    col = len(maze[0])\n    if i == row - 1 and j == col - 1:\n        if cnt == -1:\n            cnt = depth\n        elif cnt > depth:\n            cnt = depth\n        return cnt\n    maze[i][j] = 0\n    for k in range(len(directions)):\n        nx_i = i + directions[k][0]\n        nx_j = j + directions[k][1]\n        if nx_i >= 0 and nx_i < row and (nx_j >= 0) and (nx_j < col):\n            if maze[nx_i][nx_j] == 1:\n                cnt = dfs(maze, nx_i, nx_j, depth + 1, cnt)\n    maze[i][j] = 1\n    return cnt"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/dfs/all_factors.py", "fileNameBase": "all_factors", "extension": "py", "doc": {"long_description": "8 = 2 x 2 x 2;\n  = 2 x 4.\n\n\nWrite a function that takes an integer n and return all possible combinations\nof its factors.Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\nExamples:\ninput: 1\noutput:\n[]\n\n\ninput: 37\noutput:\n[]\n\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],", "short_description": "Numbers can be regarded as product of its factors. For example,", "full": "Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\n\nWrite a function that takes an integer n and return all possible combinations\nof its factors.Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\nExamples:\ninput: 1\noutput:\n[]\n\n\ninput: 37\noutput:\n[]\n\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],"}}, "functions": {"get_factors": {"args": ["n"], "returns": ["factor(n, 2, [], [])", "res"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 61}, "calls": ["all_factors.get_factors.factor"], "functions": {"factor": {"args": ["n", "i", "combi", "res"], "returns": ["res"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 60}, "calls": ["factor", "int"], "source_code": "def factor(n, i, combi, res):\n    \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res"}}, "source_code": "def get_factors(n):\n    \"\"\"[summary]\n    \n    Arguments:\n        n {[int]} -- [to analysed number]\n    \n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])"}, "get_factors_iterative1": {"args": ["n"], "returns": ["res"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 85}, "calls": ["todo.pop", "todo.append"], "source_code": "def get_factors_iterative1(n):\n    \"\"\"[summary]\n    Computes all factors of n.\n    Translated the function get_factors(...) in\n    a call-stack modell.\n\n    Arguments:\n        n {[int]} -- [to analysed number]\n    \n    Returns:\n        [list of lists] -- [all factors]\n    \"\"\"\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res"}, "get_factors_iterative2": {"args": ["n"], "returns": ["ans"], "min_max_lineno": {"min_lineno": 87, "max_lineno": 112}, "calls": ["ans.append", "stack.pop", "stack.append"], "store_vars_calls": {"x": "stack.pop"}, "source_code": "def get_factors_iterative2(n):\n    \"\"\"[summary]\n    analog as above\n\n    Arguments:\n        n {[int]} -- [description]\n    \n    Returns:\n        [list of lists] -- [all factors of n]\n    \"\"\"\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/compression": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/compression/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/compression/rle_compression.py", "fileNameBase": "rle_compression", "extension": "py", "doc": {"long_description": "that gets a stream of data as the input and returns a\nsequence of counts of consecutive data values in a row.\nWhen decompressed the data will be fully recovered as RLE\nis a lossless data compression.", "short_description": "Run-length encoding (RLE) is a simple compression algorithm ", "full": "Run-length encoding (RLE) is a simple compression algorithm \nthat gets a stream of data as the input and returns a\nsequence of counts of consecutive data values in a row.\nWhen decompressed the data will be fully recovered as RLE\nis a lossless data compression."}}, "functions": {"encode_rle": {"doc": {"long_description": "under a Run-Length Encoding.", "short_description": "Gets a stream of data and compresses it", "args": {"input": {"description": "The data to be encoded."}}, "returns": {"description": "The encoded string.", "is_generator": false}}, "args": ["input"], "returns": ["''", "encoded_str + (str(count) + prev_ch)"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 37}, "calls": ["str"], "source_code": "def encode_rle(input):\n    \"\"\"\n    Gets a stream of data and compresses it\n    under a Run-Length Encoding.\n    :param input: The data to be encoded.\n    :return: The encoded string.\n    \"\"\"\n    if not input:\n        return ''\n    encoded_str = ''\n    prev_ch = ''\n    count = 1\n    for ch in input:\n        if ch != prev_ch:\n            if prev_ch:\n                encoded_str += str(count) + prev_ch\n            count = 1\n            prev_ch = ch\n        else:\n            count += 1\n    else:\n        return encoded_str + (str(count) + prev_ch)"}, "decode_rle": {"doc": {"long_description": "under a Run-Length Decoding.", "short_description": "Gets a stream of data and decompresses it", "args": {"input": {"description": "The data to be decoded."}}, "returns": {"description": "The decoded string.", "is_generator": false}}, "args": ["input"], "returns": ["decode_str"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 59}, "calls": ["ch.isdigit", "int"], "source_code": "def decode_rle(input):\n    \"\"\"\n    Gets a stream of data and decompresses it\n    under a Run-Length Decoding.\n    :param input: The data to be decoded.\n    :return: The decoded string.\n    \"\"\"\n    decode_str = ''\n    count = ''\n    for ch in input:\n        if not ch.isdigit():\n            decode_str += ch * int(count)\n            count = ''\n        else:\n            count += ch\n    return decode_str"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/compression/huffman_coding.py", "fileNameBase": "huffman_coding", "extension": "py", "doc": {"long_description": "This algorithm analyzes the symbols that appear in a message.\nSymbols that appear more often will be encoded as a shorter-bit string\nwhile symbols that aren't used as much will be encoded as longer strings.", "short_description": "Huffman coding is an efficient method of compressing data without losing information.", "full": "Huffman coding is an efficient method of compressing data without losing information.\nThis algorithm analyzes the symbols that appear in a message.\nSymbols that appear more often will be encoded as a shorter-bit string\nwhile symbols that aren't used as much will be encoded as longer strings."}}, "dependencies": [{"from_module": "collections", "import": "defaultdict", "type": "external", "type_element": "module"}, {"from_module": "collections", "import": "deque", "type": "external", "type_element": "module"}, {"import": "heapq", "type": "external", "type_element": "module"}], "classes": {"Node": {"min_max_lineno": {"min_lineno": 12, "max_lineno": 33}, "methods": {"__init__": {"args": ["self", "frequency", "sign", "left", "right"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 18}, "source_code": "def __init__(self, frequency=0, sign=None, left=None, right=None):\n    self.frequency = frequency\n    self.sign = sign\n    self.left = left\n    self.right = right"}, "__lt__": {"args": ["self", "other"], "returns": ["self.frequency < other.frequency"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 21}, "source_code": "def __lt__(self, other):\n    return self.frequency < other.frequency"}, "__gt__": {"args": ["self", "other"], "returns": ["self.frequency > other.frequency"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 24}, "source_code": "def __gt__(self, other):\n    return self.frequency > other.frequency"}, "__eq__": {"args": ["self", "other"], "returns": ["self.frequency == other.frequency"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 27}, "source_code": "def __eq__(self, other):\n    return self.frequency == other.frequency"}, "__str__": {"args": ["self"], "returns": ["'<ch: {0}: {1}>'.format(self.sign, self.frequency)"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 30}, "source_code": "def __str__(self):\n    return '<ch: {0}: {1}>'.format(self.sign, self.frequency)"}, "__repr__": {"args": ["self"], "returns": ["'<ch: {0}: {1}>'.format(self.sign, self.frequency)"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 33}, "source_code": "def __repr__(self):\n    return '<ch: {0}: {1}>'.format(self.sign, self.frequency)"}}}, "HuffmanReader": {"min_max_lineno": {"min_lineno": 35, "max_lineno": 119}, "methods": {"__init__": {"args": ["self", "file"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 40}, "source_code": "def __init__(self, file):\n    self.file = file\n    self.buffer = []\n    self.is_last_byte = False"}, "get_number_of_additional_bits_in_the_last_byte": {"args": ["self"], "annotated_return_type": "int", "returns": ["int(bin_num, 2)"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 44}, "calls": ["int", "huffman_coding.HuffmanReader.get_bit"], "source_code": "def get_number_of_additional_bits_in_the_last_byte(self) -> int:\n    bin_num = self.get_bit() + self.get_bit() + self.get_bit()\n    return int(bin_num, 2)"}, "load_tree": {"doc": {"short_description": "Load tree from file", "returns": {"is_generator": false}}, "args": ["self"], "annotated_return_type": "Node", "returns": ["root"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 74}, "calls": ["collections.deque", "huffman_coding.HuffmanReader._fill_tree", "huffman_coding.HuffmanReader.get_bit", "huffman_coding.Node", "collections.deque.append", "collections.deque.append", "collections.deque.pop"], "store_vars_calls": {"node_stack": "deque", "queue_leaves": "deque", "root": "Node", "current_bit": "self.get_bit", "current_node.left": "Node", "current_node.right": "Node", "current_node": "node_stack.pop"}, "source_code": "def load_tree(self) -> Node:\n    \"\"\"\n        Load tree from file\n\n        :return:\n        \"\"\"\n    node_stack = deque()\n    queue_leaves = deque()\n    root = Node()\n    current_node = root\n    is_end_of_tree = False\n    while not is_end_of_tree:\n        current_bit = self.get_bit()\n        if current_bit == '0':\n            current_node.left = Node()\n            current_node.right = Node()\n            node_stack.append(current_node.right)\n            current_node = current_node.left\n        else:\n            queue_leaves.append(current_node)\n            if node_stack:\n                current_node = node_stack.pop()\n            else:\n                is_end_of_tree = True\n    self._fill_tree(queue_leaves)\n    return root"}, "_fill_tree": {"doc": {"short_description": "Load values to tree after reading tree", "returns": {"is_generator": false}}, "args": ["self", "leaves_queue"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 86}, "calls": ["leaves_queue.reverse", "leaves_queue.pop", "int", "huffman_coding.HuffmanReader.get_byte"], "store_vars_calls": {"node": "leaves_queue.pop", "s": "int"}, "source_code": "def _fill_tree(self, leaves_queue):\n    \"\"\"\n        Load values to tree after reading tree\n        :param leaves_queue:\n        :return:\n        \"\"\"\n    leaves_queue.reverse()\n    while leaves_queue:\n        node = leaves_queue.pop()\n        s = int(self.get_byte(), 2)\n        node.sign = s"}, "_load_byte": {"doc": {"short_description": "Load next byte is buffer is less than buff_limit", "returns": {"description": "True if there is enough bits in buffer to read", "is_generator": false}}, "args": ["self", "buff_limit"], "annotated_return_type": "bool", "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 87, "max_lineno": 103}, "calls": ["len", "huffman_coding.HuffmanReader.file.read", "int.from_bytes", "huffman_coding.HuffmanReader.buffer.extend", "list"], "store_vars_calls": {"byte": "self.file.read", "i": "int.from_bytes"}, "source_code": "def _load_byte(self, buff_limit=8) -> bool:\n    \"\"\"\n        Load next byte is buffer is less than buff_limit\n        :param buff_limit:\n        :return: True if there is enough bits in buffer to read\n        \"\"\"\n    if len(self.buffer) <= buff_limit:\n        byte = self.file.read(1)\n        if not byte:\n            return False\n        i = int.from_bytes(byte, 'big')\n        self.buffer.extend(list('{0:08b}'.format(i)))\n    return True"}, "get_bit": {"args": ["self", "buff_limit"], "returns": ["bit", "-1"], "min_max_lineno": {"min_lineno": 104, "max_lineno": 110}, "calls": ["huffman_coding.HuffmanReader._load_byte", "huffman_coding.HuffmanReader.buffer.pop"], "store_vars_calls": {"bit": "self.buffer.pop"}, "source_code": "def get_bit(self, buff_limit=8):\n    if self._load_byte(buff_limit):\n        bit = self.buffer.pop(0)\n        return bit\n    else:\n        return -1"}, "get_byte": {"args": ["self"], "returns": ["''.join(byte_list)", "-1"], "min_max_lineno": {"min_lineno": 111, "max_lineno": 119}, "calls": ["huffman_coding.HuffmanReader._load_byte"], "source_code": "def get_byte(self):\n    if self._load_byte():\n        byte_list = self.buffer[:8]\n        self.buffer = self.buffer[8:]\n        return ''.join(byte_list)\n    else:\n        return -1"}}}, "HuffmanWriter": {"min_max_lineno": {"min_lineno": 121, "max_lineno": 190}, "methods": {"__init__": {"args": ["self", "file"], "min_max_lineno": {"min_lineno": 122, "max_lineno": 126}, "source_code": "def __init__(self, file):\n    self.file = file\n    self.buffer = ''\n    self.saved_bits = 0"}, "write_char": {"args": ["self", "char"], "min_max_lineno": {"min_lineno": 127, "max_lineno": 129}, "calls": ["huffman_coding.HuffmanWriter.write_int", "ord"], "source_code": "def write_char(self, char):\n    self.write_int(ord(char))"}, "write_int": {"args": ["self", "num"], "min_max_lineno": {"min_lineno": 130, "max_lineno": 133}, "calls": ["huffman_coding.HuffmanWriter.write_bits"], "source_code": "def write_int(self, num):\n    bin_int = '{0:08b}'.format(num)\n    self.write_bits(bin_int)"}, "write_bits": {"args": ["self", "bits"], "min_max_lineno": {"min_lineno": 134, "max_lineno": 143}, "calls": ["len", "int", "huffman_coding.HuffmanWriter.file.write", "bytes"], "store_vars_calls": {"i": "int"}, "source_code": "def write_bits(self, bits):\n    self.saved_bits += len(bits)\n    self.buffer += bits\n    while len(self.buffer) >= 8:\n        i = int(self.buffer[:8], 2)\n        self.file.write(bytes([i]))\n        self.buffer = self.buffer[8:]"}, "save_tree": {"doc": {"short_description": "Generate and save tree code to file", "returns": {"is_generator": false}}, "args": ["self", "tree"], "min_max_lineno": {"min_lineno": 144, "max_lineno": 168}, "calls": ["huffman_coding.HuffmanWriter.save_tree.get_code_tree"], "functions": {"get_code_tree": {"args": ["T"], "min_max_lineno": {"min_lineno": 153, "max_lineno": 163}, "calls": ["signs.append", "get_code_tree"], "source_code": "def get_code_tree(T):\n    nonlocal tree_code\n    if T.sign is not None:\n        signs.append(T.sign)\n    if T.left:\n        tree_code += '0'\n        get_code_tree(T.left)\n    if T.right:\n        tree_code += '1'\n        get_code_tree(T.right)"}}, "source_code": "def save_tree(self, tree):\n    \"\"\"\n        Generate and save tree code to file\n        :param tree:\n        :return:\n        \"\"\"\n    signs = []\n    tree_code = ''\n\n    def get_code_tree(T):\n        nonlocal tree_code\n        if T.sign is not None:\n            signs.append(T.sign)\n        if T.left:\n            tree_code += '0'\n            get_code_tree(T.left)\n        if T.right:\n            tree_code += '1'\n            get_code_tree(T.right)\n    get_code_tree(tree)\n    self.write_bits(tree_code + '1')\n    for int_sign in signs:\n        self.write_int(int_sign)"}, "_save_information_about_additional_bits": {"doc": {"short_description": "Overwrite first three bits in the file", "args": {"additional_bits": {"description": "number of bits that were appended to fill last byte"}}, "returns": {"is_generator": false}}, "args": ["self", "additional_bits"], "annotated_arg_types": {"additional_bits": "int"}, "min_max_lineno": {"min_lineno": 169, "max_lineno": 184}, "calls": ["huffman_coding.HuffmanWriter.file.seek", "huffman_coding.HuffmanWriter.file.read", "huffman_coding.HuffmanWriter.write_bits", "int.from_bytes"], "store_vars_calls": {"first_byte_raw": "self.file.read"}, "source_code": "def _save_information_about_additional_bits(self, additional_bits: int):\n    \"\"\"\n        Overwrite first three bits in the file\n        :param additional_bits: number of bits that were appended to fill last byte\n        :return:\n        \"\"\"\n    self.file.seek(0)\n    first_byte_raw = self.file.read(1)\n    self.file.seek(0)\n    first_byte = '{0:08b}'.format(int.from_bytes(first_byte_raw, 'big'))\n    first_byte = first_byte[3:]\n    first_byte = '{0:03b}'.format(additional_bits) + first_byte\n    self.write_bits(first_byte)"}, "close": {"args": ["self"], "min_max_lineno": {"min_lineno": 185, "max_lineno": 190}, "calls": ["len", "huffman_coding.HuffmanWriter.write_bits", "huffman_coding.HuffmanWriter._save_information_about_additional_bits"], "source_code": "def close(self):\n    additional_bits = 8 - len(self.buffer)\n    if additional_bits != 8:\n        self.write_bits('0' * additional_bits)\n        self._save_information_about_additional_bits(additional_bits)"}}}, "TreeFinder": {"doc": {"short_description": "Class to help find signs in tree", "full": "Class to help find signs in tree"}, "min_max_lineno": {"min_lineno": 192, "max_lineno": 225}, "methods": {"__init__": {"args": ["self", "tree"], "min_max_lineno": {"min_lineno": 197, "max_lineno": 201}, "source_code": "def __init__(self, tree):\n    self.root = tree\n    self.current_node = tree\n    self.found = None"}, "find": {"doc": {"short_description": "Find sign in tree", "returns": {"description": "True if sign is found", "is_generator": false}}, "args": ["self", "bit"], "returns": ["True", "False", "True"], "min_max_lineno": {"min_lineno": 202, "max_lineno": 221}, "calls": ["huffman_coding.TreeFinder._reset"], "source_code": "def find(self, bit):\n    \"\"\"\n        Find sign in tree\n        :param bit:\n        :return: True if sign is found\n        \"\"\"\n    if bit == '0':\n        self.current_node = self.current_node.left\n    elif bit == '1':\n        self.current_node = self.current_node.right\n    else:\n        self._reset()\n        return True\n    if self.current_node.sign is not None:\n        self._reset(self.current_node.sign)\n        return True\n    else:\n        return False"}, "_reset": {"args": ["self", "found"], "min_max_lineno": {"min_lineno": 222, "max_lineno": 225}, "source_code": "def _reset(self, found=''):\n    self.found = found\n    self.current_node = self.root"}}}, "HuffmanCoding": {"min_max_lineno": {"min_lineno": 227, "max_lineno": 329}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 228, "max_lineno": 230}, "source_code": "def __init__(self):\n    pass"}, "decode_file": {"args": ["file_in_name", "file_out_name"], "min_max_lineno": {"min_lineno": 231, "max_lineno": 241}, "calls": ["print", "open", "huffman_coding.HuffmanReader.get_number_of_additional_bits_in_the_last_byte", "huffman_coding.HuffmanReader.load_tree", "huffman_coding.HuffmanCoding._decode_and_write_signs_to_file"], "store_vars_calls": {"reader": "HuffmanReader", "additional_bits": "reader.get_number_of_additional_bits_in_the_last_byte", "tree": "reader.load_tree"}, "source_code": "@staticmethod\ndef decode_file(file_in_name, file_out_name):\n    with open(file_in_name, 'rb') as file_in, open(file_out_name, 'wb') as file_out:\n        reader = HuffmanReader(file_in)\n        additional_bits = reader.get_number_of_additional_bits_in_the_last_byte()\n        tree = reader.load_tree()\n        HuffmanCoding._decode_and_write_signs_to_file(file_out, reader, tree, additional_bits)\n    print('File decoded.')"}, "_decode_and_write_signs_to_file": {"args": ["file", "reader", "tree", "additional_bits"], "annotated_arg_types": {"reader": "HuffmanReader", "tree": "Node", "additional_bits": "int"}, "min_max_lineno": {"min_lineno": 242, "max_lineno": 260}, "calls": ["reader.get_bit", "file.write", "huffman_coding.TreeFinder.find", "bytes"], "store_vars_calls": {"tree_finder": "TreeFinder", "bit": "reader.get_bit"}, "source_code": "@staticmethod\ndef _decode_and_write_signs_to_file(file, reader: HuffmanReader, tree: Node, additional_bits: int):\n    tree_finder = TreeFinder(tree)\n    is_end_of_file = False\n    while not is_end_of_file:\n        bit = reader.get_bit()\n        if bit != -1:\n            while not tree_finder.find(bit):\n                bit = reader.get_bit(0)\n            file.write(bytes([tree_finder.found]))\n        else:\n            is_end_of_file = True\n            last_byte = reader.buffer\n            last_byte = last_byte[:-additional_bits]\n            for bit in last_byte:\n                if tree_finder.find(bit):\n                    file.write(bytes([tree_finder.found]))"}, "encode_file": {"args": ["file_in_name", "file_out_name"], "min_max_lineno": {"min_lineno": 261, "max_lineno": 276}, "calls": ["print", "open", "huffman_coding.HuffmanCoding._get_char_frequency", "file_in.seek", "huffman_coding.HuffmanCoding._create_tree", "huffman_coding.HuffmanCoding._generate_codes", "huffman_coding.HuffmanWriter.write_bits", "huffman_coding.HuffmanWriter.save_tree", "huffman_coding.HuffmanCoding._encode_and_write_signs_to_file", "huffman_coding.HuffmanWriter.close"], "store_vars_calls": {"signs_frequency": "HuffmanCoding._get_char_frequency", "tree": "HuffmanCoding._create_tree", "codes": "HuffmanCoding._generate_codes", "writer": "HuffmanWriter"}, "source_code": "@staticmethod\ndef encode_file(file_in_name, file_out_name):\n    with open(file_in_name, 'rb') as file_in, open(file_out_name, mode='wb+') as file_out:\n        signs_frequency = HuffmanCoding._get_char_frequency(file_in)\n        file_in.seek(0)\n        tree = HuffmanCoding._create_tree(signs_frequency)\n        codes = HuffmanCoding._generate_codes(tree)\n        writer = HuffmanWriter(file_out)\n        writer.write_bits('000')\n        writer.save_tree(tree)\n        HuffmanCoding._encode_and_write_signs_to_file(file_in, writer, codes)\n        writer.close()\n    print('File encoded.')"}, "_encode_and_write_signs_to_file": {"args": ["file", "writer", "codes"], "annotated_arg_types": {"writer": "HuffmanWriter", "codes": "dict"}, "min_max_lineno": {"min_lineno": 277, "max_lineno": 284}, "calls": ["file.read", "int.from_bytes", "writer.write_bits"], "store_vars_calls": {"sign": "file.read", "int_char": "int.from_bytes"}, "source_code": "@staticmethod\ndef _encode_and_write_signs_to_file(file, writer: HuffmanWriter, codes: dict):\n    sign = file.read(1)\n    while sign:\n        int_char = int.from_bytes(sign, 'big')\n        writer.write_bits(codes[int_char])\n        sign = file.read(1)"}, "_get_char_frequency": {"args": ["file"], "annotated_return_type": "dict", "returns": ["signs_frequency"], "min_max_lineno": {"min_lineno": 285, "max_lineno": 299}, "calls": ["collections.defaultdict", "file.tell", "file.read", "int.from_bytes"], "store_vars_calls": {"signs_frequency": "defaultdict", "prev_pos": "file.tell", "sign": "file.read", "curr_pos": "file.tell"}, "source_code": "@staticmethod\ndef _get_char_frequency(file) -> dict:\n    is_end_of_file = False\n    signs_frequency = defaultdict(lambda : 0)\n    while not is_end_of_file:\n        prev_pos = file.tell()\n        sign = file.read(1)\n        curr_pos = file.tell()\n        if prev_pos == curr_pos:\n            is_end_of_file = True\n        else:\n            signs_frequency[int.from_bytes(sign, 'big')] += 1\n    return signs_frequency"}, "_generate_codes": {"args": ["tree"], "annotated_arg_types": {"tree": "Node"}, "annotated_return_type": "dict", "returns": ["codes"], "min_max_lineno": {"min_lineno": 300, "max_lineno": 305}, "calls": ["dict", "huffman_coding.HuffmanCoding._go_through_tree_and_create_codes"], "store_vars_calls": {"codes": "dict"}, "source_code": "@staticmethod\ndef _generate_codes(tree: Node) -> dict:\n    codes = dict()\n    HuffmanCoding._go_through_tree_and_create_codes(tree, '', codes)\n    return codes"}, "_create_tree": {"args": ["signs_frequency"], "annotated_arg_types": {"signs_frequency": "dict"}, "annotated_return_type": "Node", "returns": ["nodes[0]"], "min_max_lineno": {"min_lineno": 306, "max_lineno": 318}, "calls": ["heapq.heapify", "len", "heapq.heappop", "huffman_coding.Node", "heapq.heappush", "signs_frequency.items"], "store_vars_calls": {"left": "heapq.heappop", "right": "heapq.heappop", "new_node": "Node"}, "source_code": "@staticmethod\ndef _create_tree(signs_frequency: dict) -> Node:\n    nodes = [Node(frequency=frequency, sign=char_int) for (char_int, frequency) in signs_frequency.items()]\n    heapq.heapify(nodes)\n    while len(nodes) > 1:\n        left = heapq.heappop(nodes)\n        right = heapq.heappop(nodes)\n        new_node = Node(frequency=left.frequency + right.frequency, left=left, right=right)\n        heapq.heappush(nodes, new_node)\n    return nodes[0]"}, "_go_through_tree_and_create_codes": {"args": ["tree", "code", "dict_codes"], "annotated_arg_types": {"tree": "Node", "code": "str", "dict_codes": "dict"}, "min_max_lineno": {"min_lineno": 319, "max_lineno": 329}, "calls": ["huffman_coding.HuffmanCoding._go_through_tree_and_create_codes"], "source_code": "@staticmethod\ndef _go_through_tree_and_create_codes(tree: Node, code: str, dict_codes: dict):\n    if tree.sign is not None:\n        dict_codes[tree.sign] = code\n    if tree.left:\n        HuffmanCoding._go_through_tree_and_create_codes(tree.left, code + '0', dict_codes)\n    if tree.right:\n        HuffmanCoding._go_through_tree_and_create_codes(tree.right, code + '1', dict_codes)"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/compression/elias.py", "fileNameBase": "elias", "extension": "py", "doc": {"long_description": "encoding positive integers.\nIt is used most commonly when coding integers whose\nupper-bound cannot be determined beforehand.\nElias \u03b4 code or Elias delta code is a universal code\n encoding the positive integers,\nthat includes Elias \u03b3 code when calculating.\nBoth were developed by Peter Elias.", "short_description": "Elias \u03b3 code or Elias gamma code is a universal code", "full": "Elias \u03b3 code or Elias gamma code is a universal code\nencoding positive integers.\nIt is used most commonly when coding integers whose\nupper-bound cannot be determined beforehand.\nElias \u03b4 code or Elias delta code is a universal code\n encoding the positive integers,\nthat includes Elias \u03b3 code when calculating.\nBoth were developed by Peter Elias."}}, "dependencies": [{"from_module": "math", "import": "log", "type": "external", "type_element": "module"}], "functions": {"binary": {"args": ["x", "l"], "returns": ["fmt.format(x)"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 20}, "calls": ["fmt.format"], "source_code": "def binary(x, l=1):\n    fmt = '{0:0%db}' % l\n    return fmt.format(x)"}, "unary": {"args": ["x"], "returns": ["(x - 1) * '1' + '0'"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 24}, "source_code": "def unary(x):\n    return (x - 1) * '1' + '0'"}, "elias_generic": {"doc": {"long_description": "The first part is the unary number of 1 + \u230alog2(x)\u230b.\nThe second part is the binary number of x - 2^(\u230alog2(x)\u230b).\nFor the final result we add these two parts.", "short_description": "The compressed data is calculated in two parts."}, "args": ["lencoding", "x"], "returns": ["lencoding(first_part) + binary(a, k)", "'0'"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 42}, "calls": ["int", "log2", "elias.binary", "elias.unary", "elias.elias_gamma"], "store_vars_calls": {"k": "int"}, "source_code": "def elias_generic(lencoding, x):\n    \"\"\"\n\tThe compressed data is calculated in two parts.\n\tThe first part is the unary number of 1 + \u230alog2(x)\u230b.\n\tThe second part is the binary number of x - 2^(\u230alog2(x)\u230b).\n\tFor the final result we add these two parts.\n\t\"\"\"\n    if x == 0:\n        return '0'\n    first_part = 1 + int(log2(x))\n    a = x - 2 ** int(log2(x))\n    k = int(log2(x))\n    return lencoding(first_part) + binary(a, k)"}, "elias_gamma": {"doc": {"short_description": "For the first part we put the unary number of x."}, "args": ["x"], "returns": ["elias_generic(unary, x)"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 48}, "calls": ["elias.elias_generic"], "source_code": "def elias_gamma(x):\n    \"\"\"\n\tFor the first part we put the unary number of x.\n\t\"\"\"\n    return elias_generic(unary, x)"}, "elias_delta": {"doc": {"short_description": "For the first part we put the elias_g of the number."}, "args": ["x"], "returns": ["elias_generic(elias_gamma, x)"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 54}, "calls": ["elias.elias_generic"], "source_code": "def elias_delta(x):\n    \"\"\"\n\tFor the first part we put the elias_g of the number.\n\t\"\"\"\n    return elias_generic(elias_gamma, x)"}}, "body": {"calls": ["math.log"], "source_code": ["log(x, 2)"]}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/queues": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/queues/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "queue", "import": "AbstractQueue", "type": "internal", "type_element": "class"}, {"from_module": "queue", "import": "ArrayQueue", "type": "internal", "type_element": "class"}, {"from_module": "queue", "import": "QueueNode", "type": "internal", "type_element": "class"}, {"from_module": "queue", "import": "LinkedListQueue", "type": "internal", "type_element": "class"}, {"from_module": "max_sliding_window", "import": "max_sliding_window", "type": "internal", "type_element": "function"}, {"from_module": "reconstruct_queue", "import": "reconstruct_queue", "type": "internal", "type_element": "function"}, {"from_module": "priority_queue", "import": "PriorityQueueNode", "type": "internal", "type_element": "class"}, {"from_module": "priority_queue", "import": "PriorityQueue", "type": "internal", "type_element": "class"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/queues/max_sliding_window.py", "fileNameBase": "max_sliding_window", "extension": "py", "doc": {"long_description": "Find the max elements of each of its sub-arrays of length k.\n\nKeep indexes of good candidates in deque d.\nThe indexes in d are from the current window, they're increasing,\nand their corresponding nums are decreasing.\nThen the first deque element is the index of the largest window value.\n\nFor each index i:\n\n1. Pop (from the end) indexes of smaller elements (they'll be useless).\n2. Append the current index.\n3. Pop (from the front) the index i - k, if it's still in the deque\n   (it falls out of the window).\n4. If our window has reached size k,\n   append the current window maximum to the output.", "short_description": "Given an array and a number k", "full": "Given an array and a number k\nFind the max elements of each of its sub-arrays of length k.\n\nKeep indexes of good candidates in deque d.\nThe indexes in d are from the current window, they're increasing,\nand their corresponding nums are decreasing.\nThen the first deque element is the index of the largest window value.\n\nFor each index i:\n\n1. Pop (from the end) indexes of smaller elements (they'll be useless).\n2. Append the current index.\n3. Pop (from the front) the index i - k, if it's still in the deque\n   (it falls out of the window).\n4. If our window has reached size k,\n   append the current window maximum to the output."}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"max_sliding_window": {"args": ["arr", "k"], "returns": ["result"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 35}, "calls": ["collections.deque", "enumerate", "collections.deque.append", "collections.deque.pop", "collections.deque.popleft", "result.append"], "store_vars_calls": {"qi": "collections.deque"}, "source_code": "def max_sliding_window(arr, k):\n    qi = collections.deque()\n    result = []\n    for (i, n) in enumerate(arr):\n        while qi and arr[qi[-1]] < n:\n            qi.pop()\n        qi.append(i)\n        if qi[0] == i - k:\n            qi.popleft()\n        if i >= k - 1:\n            result.append(arr[qi[0]])\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/queues/zigzagiterator.py", "fileNameBase": "zigzagiterator", "extension": "py"}, "classes": {"ZigZagIterator": {"min_max_lineno": {"min_lineno": 1, "max_lineno": 28}, "methods": {"__init__": {"doc": {"short_description": "Initialize your data structure here."}, "args": ["self", "v1", "v2"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 10}, "calls": ["print"], "source_code": "def __init__(self, v1, v2):\n    \"\"\"\n        Initialize your data structure here.\n        :type v1: List[int]\n        :type v2: List[int]\n        \"\"\"\n    self.queue = [_ for _ in (v1, v2) if _]\n    print(self.queue)"}, "next": {"args": ["self"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 20}, "calls": ["zigzagiterator.ZigZagIterator.queue.pop", "zigzagiterator.ZigZagIterator.pop", "zigzagiterator.ZigZagIterator.queue.append"], "store_vars_calls": {"v": "self.queue.pop", "ret": "v.pop"}, "source_code": "def next(self):\n    \"\"\"\n        :rtype: int\n        \"\"\"\n    v = self.queue.pop(0)\n    ret = v.pop(0)\n    if v:\n        self.queue.append(v)\n    return ret"}, "has_next": {"args": ["self"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 28}, "source_code": "def has_next(self):\n    \"\"\"\n        :rtype: bool\n        \"\"\"\n    if self.queue:\n        return True\n    return False"}}}}, "body": {"calls": ["zigzagiterator.ZigZagIterator.has_next", "print", "zigzagiterator.ZigZagIterator.next"], "store_vars_calls": {"it": "ZigZagIterator"}, "source_code": ["ZigZagIterator(l1, l2)", "it.has_next()", "print(it.next())", "it.next()"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/queues/reconstruct_queue.py", "fileNameBase": "reconstruct_queue", "extension": "py"}, "functions": {"reconstruct_queue": {"args": ["people"], "returns": ["queue"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 28}, "calls": ["people.sort", "queue.insert"], "source_code": "def reconstruct_queue(people):\n    \"\"\"\n    :type people: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n    for (h, k) in people:\n        queue.insert(k, [h, k])\n    return queue"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/queues/moving_average.py", "fileNameBase": "moving_average", "extension": "py"}, "dependencies": [{"from_module": "__future__", "import": "division", "type": "external", "type_element": "module"}, {"from_module": "collections", "import": "deque", "type": "external", "type_element": "module"}], "classes": {"MovingAverage": {"extend": ["object"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 20}, "methods": {"__init__": {"doc": {"short_description": "Initialize your data structure here."}, "args": ["self", "size"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 12}, "calls": ["collections.deque"], "store_vars_calls": {"self.queue": "deque"}, "source_code": "def __init__(self, size):\n    \"\"\"\n        Initialize your data structure here.\n        :type size: int\n        \"\"\"\n    self.queue = deque(maxlen=size)"}, "next": {"args": ["self", "val"], "returns": ["sum(self.queue) / len(self.queue)"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 20}, "calls": ["moving_average.MovingAverage.queue.append", "sum", "len"], "source_code": "def next(self, val):\n    \"\"\"\n        :type val: int\n        :rtype: float\n        \"\"\"\n    self.queue.append(val)\n    return sum(self.queue) / len(self.queue)"}}}}, "body": {"calls": ["moving_average.MovingAverage.next"], "store_vars_calls": {"m": "MovingAverage"}, "source_code": ["MovingAverage(3)", "m.next(1)", "m.next(10)", "m.next(3)", "m.next(5)"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": true}], "output/keon/algorithms/algorithms/algorithms/greedy": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/greedy/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "max_contiguous_subsequence_sum", "import": "max_contiguous_subsequence_sum", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/greedy/max_contiguous_subsequence_sum.py", "fileNameBase": "max_contiguous_subsequence_sum", "extension": "py", "doc": {"long_description": "kadane's algorithm is used for finding the maximum sum of contiguous subsequence in a sequence.\nIt is considered a greedy/dp algorithm but I think they more greedy than dp\nhere are some of the examples to understand the use case more clearly\nExample1 => [-2, 3, 8, -1, 4]\nresult =>  {3, 8, -1, 4} => 14\nExample2 => [-1, 1, 0]\nresult => {1} => 1\nExample3 => [-1, -3, -4]\nresult => -1\nExample1 => [-2, 3, 8, -12, 8, 4]\nresult =>  {8, 4} => 12\nBasic Algorithm Idea\n    If the sum of the current contiguous subsequence after adding the value at the current position is less than the value\n    at the current position then we know that it will be better if we start the current contiguous subsequence from this position.\n    Else we add the value at the current position to the current contiguous subsequence.\nNote\n    In the implementation, the contiguous subsequence has at least one element.\n    If it can have 0 elements then the result will be max(max_till_now, 0)", "short_description": "Algorithm used => Kadane's Algorithm", "full": "Algorithm used => Kadane's Algorithm\n\nkadane's algorithm is used for finding the maximum sum of contiguous subsequence in a sequence.\nIt is considered a greedy/dp algorithm but I think they more greedy than dp\nhere are some of the examples to understand the use case more clearly\nExample1 => [-2, 3, 8, -1, 4]\nresult =>  {3, 8, -1, 4} => 14\nExample2 => [-1, 1, 0]\nresult => {1} => 1\nExample3 => [-1, -3, -4]\nresult => -1\nExample1 => [-2, 3, 8, -12, 8, 4]\nresult =>  {8, 4} => 12\nBasic Algorithm Idea\n    If the sum of the current contiguous subsequence after adding the value at the current position is less than the value\n    at the current position then we know that it will be better if we start the current contiguous subsequence from this position.\n    Else we add the value at the current position to the current contiguous subsequence.\nNote\n    In the implementation, the contiguous subsequence has at least one element.\n    If it can have 0 elements then the result will be max(max_till_now, 0)"}}, "functions": {"max_contiguous_subsequence_sum": {"args": ["arr"], "annotated_return_type": "int", "returns": ["max_till_now", "0"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 43}, "calls": ["len", "range", "max"], "store_vars_calls": {"arr_size": "len", "max_till_now": "max"}, "source_code": "def max_contiguous_subsequence_sum(arr) -> int:\n    arr_size = len(arr)\n    if arr_size == 0:\n        return 0\n    max_till_now = arr[0]\n    curr_sub_sum = 0\n    for i in range(0, arr_size):\n        if curr_sub_sum + arr[i] < arr[i]:\n            curr_sub_sum = arr[i]\n        else:\n            curr_sub_sum += arr[i]\n        max_till_now = max(max_till_now, curr_sub_sum)\n    return max_till_now"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/search": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/interpolation_search.py", "fileNameBase": "interpolation_search", "extension": "py", "doc": {"long_description": "Given a sorted array in increasing order, interpolation search calculates\nthe starting point of its search according to the search key.\n\nFORMULA: start_pos = low + [ (x - arr[low])*(high - low) / (arr[high] - arr[low]) ]\n\nDoc: https://en.wikipedia.org/wiki/Interpolation_search\n\nTime Complexity: O(log2(log2 n)) for average cases, O(n) for the worst case.\nThe algorithm performs best with uniformly distributed arrays.", "short_description": "Python implementation of the Interpolation Search algorithm.", "full": "Python implementation of the Interpolation Search algorithm.\nGiven a sorted array in increasing order, interpolation search calculates\nthe starting point of its search according to the search key.\n\nFORMULA: start_pos = low + [ (x - arr[low])*(high - low) / (arr[high] - arr[low]) ]\n\nDoc: https://en.wikipedia.org/wiki/Interpolation_search\n\nTime Complexity: O(log2(log2 n)) for average cases, O(n) for the worst case.\nThe algorithm performs best with uniformly distributed arrays."}}, "dependencies": [{"from_module": "typing", "import": "List", "type": "external", "type_element": "module"}], "functions": {"interpolation_search": {"doc": {"args": {"array": {"description": "The array to be searched."}, "search_key": {"description": "The key to be searched in the array."}}, "returns": {"description": "Index of search_key in array if found, else -1.\nExamples:\n\n>>> interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)\n2\n>>> interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)\n-1\n>>> interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)\n-1", "is_generator": false}}, "args": ["array", "search_key"], "annotated_arg_types": {"array": "List[int]", "search_key": "int"}, "annotated_return_type": "int", "returns": ["-1", "pos"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 57}, "calls": ["len", "int"], "source_code": "def interpolation_search(array: List[int], search_key: int) -> int:\n    \"\"\"\n    :param array: The array to be searched.\n    :param search_key: The key to be searched in the array.\n\n    :returns: Index of search_key in array if found, else -1.\n\n    Examples:\n\n    >>> interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)\n    2\n    >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)\n    -1\n    >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)\n    -1\n\n    \"\"\"\n    high = len(array) - 1\n    low = 0\n    while low <= high and array[low] <= search_key <= array[high]:\n        pos = low + int((search_key - array[low]) * (high - low) / (array[high] - array[low]))\n        if array[pos] == search_key:\n            return pos\n        if array[pos] < search_key:\n            low = pos + 1\n        else:\n            high = pos - 1\n    return -1"}}, "body": {"calls": ["doctest.testmod"], "source_code": ["doctest.testmod()"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/search_rotate.py", "fileNameBase": "search_rotate", "extension": "py", "doc": {"long_description": "Suppose an array sorted in ascending order is rotated at some pivot unknown\nto you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\n\nYou are given a target value to search. If found in the array return its index,\notherwise return -1.\n\nYour algorithm's runtime complexity must be in the order of O(log n).\n---------------------------------------------------------------------------------\nExplanation algorithm:\n\nIn classic binary search, we compare val with the midpoint to figure out if\nval belongs on the low or the high side. The complication here is that the\narray is rotated and may have an inflection point. Consider, for example:\n\nArray1: [10, 15, 20, 0, 5]\nArray2: [50, 5, 20, 30, 40]\n\nNote that both arrays have a midpoint of 20, but 5 appears on the left side of\none and on the right side of the other. Therefore, comparing val with the\nmidpoint is insufficient.\n\nHowever, if we look a bit deeper, we can see that one half of the array must be\nordered normally(increasing order). We can therefore look at the normally ordered\nhalf to determine whether we should search the low or hight side.\n\nFor example, if we are searching for 5 in Array1, we can look at the left element (10)\nand middle element (20). Since 10 < 20, the left half must be ordered normally. And, since 5\nis not between those, we know that we must search the right half\n\nIn array2, we can see that since 50 > 20, the right half must be ordered normally. We turn to\nthe middle 20, and right 40 element to check if 5 would fall between them. The value 5 would not\nTherefore, we search the left half.\n\nThere are 2 possible solution: iterative and recursion.\nRecursion helps you understand better the above algorithm explanation", "short_description": "Search in Rotated Sorted Array", "full": "Search in Rotated Sorted Array\nSuppose an array sorted in ascending order is rotated at some pivot unknown\nto you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\n\nYou are given a target value to search. If found in the array return its index,\notherwise return -1.\n\nYour algorithm's runtime complexity must be in the order of O(log n).\n---------------------------------------------------------------------------------\nExplanation algorithm:\n\nIn classic binary search, we compare val with the midpoint to figure out if\nval belongs on the low or the high side. The complication here is that the\narray is rotated and may have an inflection point. Consider, for example:\n\nArray1: [10, 15, 20, 0, 5]\nArray2: [50, 5, 20, 30, 40]\n\nNote that both arrays have a midpoint of 20, but 5 appears on the left side of\none and on the right side of the other. Therefore, comparing val with the\nmidpoint is insufficient.\n\nHowever, if we look a bit deeper, we can see that one half of the array must be\nordered normally(increasing order). We can therefore look at the normally ordered\nhalf to determine whether we should search the low or hight side.\n\nFor example, if we are searching for 5 in Array1, we can look at the left element (10)\nand middle element (20). Since 10 < 20, the left half must be ordered normally. And, since 5\nis not between those, we know that we must search the right half\n\nIn array2, we can see that since 50 > 20, the right half must be ordered normally. We turn to\nthe middle 20, and right 40 element to check if 5 would fall between them. The value 5 would not\nTherefore, we search the left half.\n\nThere are 2 possible solution: iterative and recursion.\nRecursion helps you understand better the above algorithm explanation"}}, "functions": {"search_rotate": {"doc": {"long_description": "ascending order and then rotated at some unknown pivot.", "short_description": "Finds the index of the given value in an array that has been sorted in"}, "args": ["array", "val"], "returns": ["-1", "mid"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 62}, "calls": ["len"], "source_code": "def search_rotate(array, val):\n    \"\"\"\n    Finds the index of the given value in an array that has been sorted in\n    ascending order and then rotated at some unknown pivot.\n    \"\"\"\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if val == array[mid]:\n            return mid\n        if array[low] <= array[mid]:\n            if array[low] <= val <= array[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        elif array[mid] <= val <= array[high]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1"}, "search_rotate_recur": {"doc": {"long_description": "ascending order and then rotated at some unknown pivot.", "short_description": "Finds the index of the given value in an array that has been sorted in"}, "args": ["array", "low", "high", "val"], "returns": ["search_rotate_recur(array, low, mid - 1, val)", "-1", "mid", "search_rotate_recur(array, mid + 1, high, val)", "search_rotate_recur(array, mid + 1, high, val)", "search_rotate_recur(array, low, mid - 1, val)"], "min_max_lineno": {"min_lineno": 64, "max_lineno": 81}, "calls": ["search_rotate.search_rotate_recur"], "source_code": "def search_rotate_recur(array, low, high, val):\n    \"\"\"\n    Finds the index of the given value in an array that has been sorted in\n    ascending order and then rotated at some unknown pivot.\n    \"\"\"\n    if low >= high:\n        return -1\n    mid = (low + high) // 2\n    if val == array[mid]:\n        return mid\n    if array[low] <= array[mid]:\n        if array[low] <= val <= array[mid]:\n            return search_rotate_recur(array, low, mid - 1, val)\n        return search_rotate_recur(array, mid + 1, high, val)\n    if array[mid] <= val <= array[high]:\n        return search_rotate_recur(array, mid + 1, high, val)\n    return search_rotate_recur(array, low, mid - 1, val)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/search_range.py", "fileNameBase": "search_range", "extension": "py", "doc": {"long_description": "and ending position of a given target value. If the target is not found in the\narray, return [-1, -1].\n\nFor example:\nInput: nums = [5,7,7,8,8,8,10], target = 8\nOutput: [3,5]\nInput: nums = [5,7,7,8,8,8,10], target = 11\nOutput: [-1,-1]", "short_description": "Given an array of integers nums sorted in ascending order, find the starting", "full": "Given an array of integers nums sorted in ascending order, find the starting\nand ending position of a given target value. If the target is not found in the\narray, return [-1, -1].\n\nFor example:\nInput: nums = [5,7,7,8,8,8,10], target = 8\nOutput: [3,5]\nInput: nums = [5,7,7,8,8,8,10], target = 11\nOutput: [-1,-1]"}}, "functions": {"search_range": {"args": ["nums", "target"], "returns": ["[-1, -1]", "[low, j]"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 34}, "calls": ["range", "len"], "source_code": "def search_range(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if target <= nums[mid]:\n            high = mid\n        else:\n            low = mid + 1\n    for j in range(len(nums) - 1, -1, -1):\n        if nums[j] == target:\n            return [low, j]\n    return [-1, -1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/jump_search.py", "fileNameBase": "jump_search", "extension": "py", "doc": {"long_description": "Find an element in a sorted array.", "short_description": "Jump Search", "full": "Jump Search\n\nFind an element in a sorted array."}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"jump_search": {"doc": {"long_description": "All items in list must be sorted like binary search\n\nFind block that contains target value and search it linearly in that block\nIt returns a first target value in array\n\nreference: https://en.wikipedia.org/wiki/Jump_search", "short_description": "Worst-case Complexity: O(\u221an) (root(n))"}, "args": ["arr", "target"], "returns": ["-1", "-1", "block_prev", "-1"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 46}, "calls": ["len", "int", "math.sqrt", "min"], "store_vars_calls": {"length": "len", "block_size": "int"}, "source_code": "def jump_search(arr, target):\n    \"\"\"\n    Worst-case Complexity: O(\u221an) (root(n))\n    All items in list must be sorted like binary search\n\n    Find block that contains target value and search it linearly in that block\n    It returns a first target value in array\n\n    reference: https://en.wikipedia.org/wiki/Jump_search\n    \"\"\"\n    length = len(arr)\n    block_size = int(math.sqrt(length))\n    block_prev = 0\n    block = block_size\n    if arr[length - 1] < target:\n        return -1\n    while block <= length and arr[block - 1] < target:\n        block_prev = block\n        block += block_size\n    while arr[block_prev] < target:\n        block_prev += 1\n        if block_prev == min(block, length):\n            return -1\n    if arr[block_prev] == target:\n        return block_prev\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/__init__.py", "fileNameBase": "__init__", "extension": "py", "doc": {"short_description": "Collection of search algorithms: finding the needle in a haystack.", "full": "Collection of search algorithms: finding the needle in a haystack."}}, "dependencies": [{"from_module": "binary_search", "import": "binary_search", "type": "internal", "type_element": "function"}, {"from_module": "binary_search", "import": "binary_search_recur", "type": "internal", "type_element": "function"}, {"from_module": "ternary_search", "import": "ternary_search", "type": "internal", "type_element": "function"}, {"from_module": "first_occurrence", "import": "first_occurrence", "type": "internal", "type_element": "function"}, {"from_module": "last_occurrence", "import": "last_occurrence", "type": "internal", "type_element": "function"}, {"from_module": "linear_search", "import": "linear_search", "type": "internal", "type_element": "function"}, {"from_module": "search_insert", "import": "search_insert", "type": "internal", "type_element": "function"}, {"from_module": "two_sum", "import": "two_sum", "type": "internal", "type_element": "function"}, {"from_module": "two_sum", "import": "two_sum1", "type": "internal", "type_element": "function"}, {"from_module": "two_sum", "import": "two_sum2", "type": "internal", "type_element": "function"}, {"from_module": "search_range", "import": "search_range", "type": "internal", "type_element": "function"}, {"from_module": "find_min_rotate", "import": "find_min_rotate", "type": "internal", "type_element": "function"}, {"from_module": "find_min_rotate", "import": "find_min_rotate_recur", "type": "internal", "type_element": "function"}, {"from_module": "search_rotate", "import": "search_rotate", "type": "internal", "type_element": "function"}, {"from_module": "search_rotate", "import": "search_rotate_recur", "type": "internal", "type_element": "function"}, {"from_module": "jump_search", "import": "jump_search", "type": "internal", "type_element": "function"}, {"from_module": "next_greatest_letter", "import": "next_greatest_letter", "type": "internal", "type_element": "function"}, {"from_module": "next_greatest_letter", "import": "next_greatest_letter_v1", "type": "internal", "type_element": "function"}, {"from_module": "next_greatest_letter", "import": "next_greatest_letter_v2", "type": "internal", "type_element": "function"}, {"from_module": "interpolation_search", "import": "interpolation_search", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/find_min_rotate.py", "fileNameBase": "find_min_rotate", "extension": "py", "doc": {"long_description": "to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n\nFind the minimum element. The complexity must be O(logN)\n\nYou may assume no duplicate exists in the array.", "short_description": "Suppose an array sorted in ascending order is rotated at some pivot unknown", "full": "Suppose an array sorted in ascending order is rotated at some pivot unknown\nto you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n\nFind the minimum element. The complexity must be O(logN)\n\nYou may assume no duplicate exists in the array."}}, "functions": {"find_min_rotate": {"doc": {"short_description": "Finds the minimum element in a sorted array that has been rotated."}, "args": ["array"], "returns": ["array[low]"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 23}, "calls": ["len"], "source_code": "def find_min_rotate(array):\n    \"\"\"\n    Finds the minimum element in a sorted array that has been rotated.\n    \"\"\"\n    low = 0\n    high = len(array) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if array[mid] > array[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return array[low]"}, "find_min_rotate_recur": {"doc": {"short_description": "Finds the minimum element in a sorted array that has been rotated."}, "args": ["array", "low", "high"], "returns": ["find_min_rotate_recur(array, low, mid)", "array[low]", "find_min_rotate_recur(array, mid + 1, high)"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 34}, "calls": ["find_min_rotate.find_min_rotate_recur"], "source_code": "def find_min_rotate_recur(array, low, high):\n    \"\"\"\n    Finds the minimum element in a sorted array that has been rotated.\n    \"\"\"\n    mid = (low + high) // 2\n    if mid == low:\n        return array[low]\n    if array[mid] > array[high]:\n        return find_min_rotate_recur(array, mid + 1, high)\n    return find_min_rotate_recur(array, low, mid)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/next_greatest_letter.py", "fileNameBase": "next_greatest_letter", "extension": "py", "doc": {"long_description": "and given a target letter target, find the smallest element in the list that\nis larger than the given target.\n\nLetters also wrap around. For example, if the target is target = 'z' and\nletters = ['a', 'b'], the answer is 'a'.\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nOutput: \"c\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\n\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/", "short_description": "Given a list of sorted characters letters containing only lowercase letters,", "full": "Given a list of sorted characters letters containing only lowercase letters,\nand given a target letter target, find the smallest element in the list that\nis larger than the given target.\n\nLetters also wrap around. For example, if the target is target = 'z' and\nletters = ['a', 'b'], the answer is 'a'.\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nOutput: \"c\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\n\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/"}}, "dependencies": [{"import": "bisect", "type": "external", "type_element": "module"}], "functions": {"next_greatest_letter": {"doc": {"short_description": "Using bisect libarary"}, "args": ["letters", "target"], "returns": ["letters[index % len(letters)]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 35}, "calls": ["bisect.bisect", "len"], "store_vars_calls": {"index": "bisect.bisect"}, "source_code": "def next_greatest_letter(letters, target):\n    \"\"\"\n    Using bisect libarary\n    \"\"\"\n    index = bisect.bisect(letters, target)\n    return letters[index % len(letters)]"}, "next_greatest_letter_v1": {"doc": {"short_description": "Using binary search: complexity O(logN)"}, "args": ["letters", "target"], "returns": ["letters[left]", "letters[0]", "letters[0]"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 52}, "calls": ["len"], "source_code": "def next_greatest_letter_v1(letters, target):\n    \"\"\"\n    Using binary search: complexity O(logN)\n    \"\"\"\n    if letters[0] > target:\n        return letters[0]\n    if letters[len(letters) - 1] <= target:\n        return letters[0]\n    (left, right) = (0, len(letters) - 1)\n    while left <= right:\n        mid = left + (right - left) // 2\n        if letters[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return letters[left]"}, "next_greatest_letter_v2": {"doc": {"short_description": "Brute force: complexity O(N)"}, "args": ["letters", "target"], "returns": ["letters[0]", "index"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 61}, "source_code": "def next_greatest_letter_v2(letters, target):\n    \"\"\"\n    Brute force: complexity O(N)\n    \"\"\"\n    for index in letters:\n        if index > target:\n            return index\n    return letters[0]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/search_insert.py", "fileNameBase": "search_insert", "extension": "py", "doc": {"short_description": "Helper methods for implementing insertion sort.", "full": "Helper methods for implementing insertion sort."}}, "functions": {"search_insert": {"doc": {"long_description": "found. If not, return the index where it would be if it were inserted in order.\n\nFor example:\n[1,3,5,6], 5 -> 2\n[1,3,5,6], 2 -> 1\n[1,3,5,6], 7 -> 4\n[1,3,5,6], 0 -> 0", "short_description": "Given a sorted array and a target value, return the index if the target is"}, "args": ["array", "val"], "returns": ["low"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 25}, "calls": ["len"], "source_code": "def search_insert(array, val):\n    \"\"\"\n    Given a sorted array and a target value, return the index if the target is\n    found. If not, return the index where it would be if it were inserted in order.\n\n    For example:\n    [1,3,5,6], 5 -> 2\n    [1,3,5,6], 2 -> 1\n    [1,3,5,6], 7 -> 4\n    [1,3,5,6], 0 -> 0\n    \"\"\"\n    low = 0\n    high = len(array) - 1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if val > array[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/last_occurrence.py", "fileNameBase": "last_occurrence", "extension": "py", "doc": {"long_description": "Approach- Binary Search\nT(n)- O(log n)", "short_description": "Find last occurance of a number in a sorted array (increasing order)", "full": "Find last occurance of a number in a sorted array (increasing order)\nApproach- Binary Search\nT(n)- O(log n)"}}, "functions": {"last_occurrence": {"doc": {"long_description": "The array has to be sorted in increasing order.", "short_description": "Returns the index of the last occurance of the given element in an array."}, "args": ["array", "query"], "returns": ["mid"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 21}, "calls": ["len"], "source_code": "def last_occurrence(array, query):\n    \"\"\"\n    Returns the index of the last occurance of the given element in an array.\n    The array has to be sorted in increasing order.\n    \"\"\"\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (high + low) // 2\n        if array[mid] == query and mid == len(array) - 1 or (array[mid] == query and array[mid + 1] > query):\n            return mid\n        if array[mid] <= query:\n            low = mid + 1\n        else:\n            high = mid - 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/binary_search.py", "fileNameBase": "binary_search", "extension": "py", "doc": {"long_description": "Find an element in a sorted array (in ascending order).", "short_description": "Binary Search", "full": "Binary Search\n\nFind an element in a sorted array (in ascending order)."}}, "functions": {"binary_search": {"doc": {"long_description": "reference: https://en.wikipedia.org/wiki/Binary_search_algorithm", "short_description": "Worst-case Complexity: O(log(n))"}, "args": ["array", "query"], "returns": ["None", "mid"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 36}, "calls": ["len"], "source_code": "def binary_search(array, query):\n    \"\"\"\n    Worst-case Complexity: O(log(n))\n\n    reference: https://en.wikipedia.org/wiki/Binary_search_algorithm\n    \"\"\"\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (high + low) // 2\n        val = array[mid]\n        if val == query:\n            return mid\n        if val < query:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None"}, "binary_search_recur": {"doc": {"long_description": "reference: https://en.wikipedia.org/wiki/Binary_search_algorithm", "short_description": "Worst-case Complexity: O(log(n))"}, "args": ["array", "low", "high", "val"], "returns": ["mid", "-1", "binary_search_recur(array, low, mid - 1, val)", "binary_search_recur(array, mid + 1, high, val)"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 53}, "calls": ["binary_search.binary_search_recur"], "source_code": "def binary_search_recur(array, low, high, val):\n    \"\"\"\n    Worst-case Complexity: O(log(n))\n\n    reference: https://en.wikipedia.org/wiki/Binary_search_algorithm\n    \"\"\"\n    if low > high:\n        return -1\n    mid = low + (high - low) // 2\n    if val < array[mid]:\n        return binary_search_recur(array, low, mid - 1, val)\n    if val > array[mid]:\n        return binary_search_recur(array, mid + 1, high, val)\n    return mid"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/first_occurrence.py", "fileNameBase": "first_occurrence", "extension": "py", "doc": {"long_description": "Approach- Binary Search\nT(n)- O(log n)", "short_description": "Find first occurance of a number in a sorted array (increasing order)", "full": "Find first occurance of a number in a sorted array (increasing order)\nApproach- Binary Search\nT(n)- O(log n)"}}, "functions": {"first_occurrence": {"doc": {"long_description": "The array has to be sorted in increasing order.", "short_description": "Returns the index of the first occurance of the given element in an array."}, "args": ["array", "query"], "returns": ["low"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 24}, "calls": ["len"], "source_code": "def first_occurrence(array, query):\n    \"\"\"\n    Returns the index of the first occurance of the given element in an array.\n    The array has to be sorted in increasing order.\n    \"\"\"\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = low + (high - low) // 2\n        if low == high:\n            break\n        if array[mid] < query:\n            low = mid + 1\n        else:\n            high = mid\n    if array[low] == query:\n        return low"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/linear_search.py", "fileNameBase": "linear_search", "extension": "py", "doc": {"long_description": "T(n): O(n)", "short_description": "Linear search works in any array.", "full": "Linear search works in any array.\nT(n): O(n)"}}, "functions": {"linear_search": {"doc": {"long_description": "There are no restrictions on the order of the elements in the array.\nIf the element couldn't be found, returns -1.", "short_description": "Find the index of the given element in the array."}, "args": ["array", "query"], "returns": ["-1", "i"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 16}, "calls": ["enumerate"], "source_code": "def linear_search(array, query):\n    \"\"\"\n    Find the index of the given element in the array.\n    There are no restrictions on the order of the elements in the array.\n    If the element couldn't be found, returns -1.\n    \"\"\"\n    for (i, value) in enumerate(array):\n        if value == query:\n            return i\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/two_sum.py", "fileNameBase": "two_sum", "extension": "py", "doc": {"long_description": "numbers such that they add up to a specific target number. The function two_sum\nshould return indices of the two numbers such that they add up to the target,\nwhere index1 must be less than index2. Please note that your returned answers\n(both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution and you\nmay not use the same element twice.\n\nInput: numbers = [2, 7, 11, 15], target=9\nOutput: index1 = 1, index2 = 2\n\nSolution:\ntwo_sum: using binary search\ntwo_sum1: using dictionary as a hash table\ntwo_sum2: using two pointers", "short_description": "Given an array of integers that is already sorted in ascending order, find two", "full": "Given an array of integers that is already sorted in ascending order, find two\nnumbers such that they add up to a specific target number. The function two_sum\nshould return indices of the two numbers such that they add up to the target,\nwhere index1 must be less than index2. Please note that your returned answers\n(both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution and you\nmay not use the same element twice.\n\nInput: numbers = [2, 7, 11, 15], target=9\nOutput: index1 = 1, index2 = 2\n\nSolution:\ntwo_sum: using binary search\ntwo_sum1: using dictionary as a hash table\ntwo_sum2: using two pointers"}}, "functions": {"two_sum": {"doc": {"long_description": "numbers such that their sum is the given target.\n\nUsing binary search.", "short_description": "Given a list of numbers sorted in ascending order, find the indices of two"}, "args": ["numbers", "target"], "returns": ["None", "[i + 1, mid + 1]"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 39}, "calls": ["enumerate", "len"], "source_code": "def two_sum(numbers, target):\n    \"\"\"\n    Given a list of numbers sorted in ascending order, find the indices of two\n    numbers such that their sum is the given target.\n\n    Using binary search.\n    \"\"\"\n    for (i, number) in enumerate(numbers):\n        second_val = target - number\n        (low, high) = (i + 1, len(numbers) - 1)\n        while low <= high:\n            mid = low + (high - low) // 2\n            if second_val == numbers[mid]:\n                return [i + 1, mid + 1]\n            if second_val > numbers[mid]:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return None"}, "two_sum1": {"doc": {"long_description": "sum is the given target.\n\nUsing a hash table.", "short_description": "Given a list of numbers, find the indices of two numbers such that their"}, "args": ["numbers", "target"], "returns": ["None", "[dic[target - num] + 1, i + 1]"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 53}, "calls": ["enumerate"], "source_code": "def two_sum1(numbers, target):\n    \"\"\"\n    Given a list of numbers, find the indices of two numbers such that their\n    sum is the given target.\n\n    Using a hash table.\n    \"\"\"\n    dic = {}\n    for (i, num) in enumerate(numbers):\n        if target - num in dic:\n            return [dic[target - num] + 1, i + 1]\n        dic[num] = i\n    return None"}, "two_sum2": {"doc": {"long_description": "numbers such that their sum is the given target.\n\nUsing a bidirectional linear search.", "short_description": "Given a list of numbers sorted in ascending order, find the indices of two"}, "args": ["numbers", "target"], "returns": ["[left + 1, right + 1]"], "min_max_lineno": {"min_lineno": 54, "max_lineno": 72}, "calls": ["len"], "source_code": "def two_sum2(numbers, target):\n    \"\"\"\n    Given a list of numbers sorted in ascending order, find the indices of two\n    numbers such that their sum is the given target.\n\n    Using a bidirectional linear search.\n    \"\"\"\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        if current_sum > target:\n            right = right - 1\n        else:\n            left = left + 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/search/ternary_search.py", "fileNameBase": "ternary_search", "extension": "py", "doc": {"long_description": "It is similar to binary search where we divide the array into two parts but in this algorithm,\nwe divide the given array into three parts and determine which has the key (searched element).\nWe can divide the array into three parts by taking mid1 and mid2.\nInitially, l and r will be equal to 0 and n-1 respectively, where n is the length of the array.\nmid1 = l + (r-l)/3\nmid2 = r \u2013 (r-l)/3\n\nNote: Array needs to be sorted to perform ternary search on it.\nT(N) = O(log3(N))\nlog3 = log base 3", "short_description": "Ternary search is a divide and conquer algorithm that can be used to find an element in an array.", "full": "Ternary search is a divide and conquer algorithm that can be used to find an element in an array.\nIt is similar to binary search where we divide the array into two parts but in this algorithm,\nwe divide the given array into three parts and determine which has the key (searched element).\nWe can divide the array into three parts by taking mid1 and mid2.\nInitially, l and r will be equal to 0 and n-1 respectively, where n is the length of the array.\nmid1 = l + (r-l)/3\nmid2 = r \u2013 (r-l)/3\n\nNote: Array needs to be sorted to perform ternary search on it.\nT(N) = O(log3(N))\nlog3 = log base 3"}}, "functions": {"ternary_search": {"doc": {"long_description": "Returns the index of the value if found, and -1 otherwise.\nIf the index is not in the range left..right (ie. left <= index < right) returns -1.", "short_description": "Find the given value (key) in an array sorted in ascending order."}, "args": ["left", "right", "key", "arr"], "returns": ["-1", "mid1", "mid2"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 43}, "source_code": "def ternary_search(left, right, key, arr):\n    \"\"\"\n    Find the given value (key) in an array sorted in ascending order.\n    Returns the index of the value if found, and -1 otherwise.\n    If the index is not in the range left..right (ie. left <= index < right) returns -1.\n    \"\"\"\n    while right >= left:\n        mid1 = left + (right - left) // 3\n        mid2 = right - (right - left) // 3\n        if key == arr[mid1]:\n            return mid1\n        if key == mid2:\n            return mid2\n        if key < arr[mid1]:\n            right = mid1 - 1\n        elif key > arr[mid2]:\n            left = mid2 + 1\n        else:\n            left = mid1 + 1\n            right = mid2 - 1\n    return -1"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/distribution": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/distribution/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/distribution/histogram.py", "fileNameBase": "histogram", "extension": "py", "doc": {"long_description": "Histogram is an accurate representation of the distribution of numerical data.\nIt is an estimate of the probability distribution of a continuous variable.\nhttps://en.wikipedia.org/wiki/Histogram", "short_description": "Histogram function.", "full": "Histogram function.\n\nHistogram is an accurate representation of the distribution of numerical data.\nIt is an estimate of the probability distribution of a continuous variable.\nhttps://en.wikipedia.org/wiki/Histogram\n\nExample:\n    list_1 = [3, 3, 2, 1]\n    :return {1: 1, 2: 1, 3: 2}\n\n    list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7]\n    :return {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}"}}, "functions": {"get_histogram": {"doc": {"short_description": "Get histogram representation", "args": {"input_list": {"description": "list with different and unordered values"}}, "returns": {"description": "dict with histogram of input_list", "type_name": "histogram", "is_generator": false}}, "args": ["input_list"], "annotated_arg_types": {"input_list": "list"}, "annotated_return_type": "dict", "returns": ["histogram"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 29}, "calls": ["histogram.get"], "source_code": "def get_histogram(input_list: list) -> dict:\n    \"\"\"\n    Get histogram representation\n    :param input_list: list with different and unordered values\n    :return histogram: dict with histogram of input_list\n    \"\"\"\n    histogram = {}\n    for i in input_list:\n        histogram[i] = histogram.get(i, 0) + 1\n    return histogram"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/is_subtree.py", "fileNameBase": "is_subtree", "extension": "py", "doc": {"long_description": "A subtree of a tree t is a tree consisting of a node in t and\nall of its descendants in t.\n\nExample 1:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n\nGiven t:\n\n   4\n  /  1   2\nReturn true, because t is a subtree of s.\n\nExample 2:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n    /\n   0\n\nGiven t:\n\n     3\n    /\n   4\n  /  1   2\nReturn false, because even though t is part of s,\nit does not contain all descendants of t.\n\nFollow up:\nWhat if one tree is significantly lager than the other?", "short_description": "Given two binary trees s and t, check if t is a subtree of s.", "full": "Given two binary trees s and t, check if t is a subtree of s.\nA subtree of a tree t is a tree consisting of a node in t and\nall of its descendants in t.\n\nExample 1:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n\nGiven t:\n\n   4\n  /  1   2\nReturn true, because t is a subtree of s.\n\nExample 2:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n    /\n   0\n\nGiven t:\n\n     3\n    /\n   4\n  /  1   2\nReturn false, because even though t is part of s,\nit does not contain all descendants of t.\n\nFollow up:\nWhat if one tree is significantly lager than the other?"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"is_subtree": {"args": ["big", "small"], "returns": ["flag"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 64}, "calls": ["collections.deque", "collections.deque.append", "collections.deque.popleft", "is_subtree.comp"], "store_vars_calls": {"queue": "collections.deque", "node": "queue.popleft", "flag": "comp"}, "source_code": "def is_subtree(big, small):\n    flag = False\n    queue = collections.deque()\n    queue.append(big)\n    while queue:\n        node = queue.popleft()\n        if node.val == small.val:\n            flag = comp(node, small)\n            break\n        else:\n            queue.append(node.left)\n            queue.append(node.right)\n    return flag"}, "comp": {"args": ["p", "q"], "returns": ["False", "True", "p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right)"], "min_max_lineno": {"min_lineno": 66, "max_lineno": 72}, "calls": ["is_subtree.comp"], "source_code": "def comp(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None and q is not None:\n        return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right)\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/is_balanced.py", "fileNameBase": "is_balanced", "extension": "py"}, "functions": {"is_balanced": {"args": ["root"], "returns": ["__is_balanced_recursive(root)"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 3}, "calls": ["is_balanced.__is_balanced_recursive"], "source_code": "def is_balanced(root):\n    return __is_balanced_recursive(root)"}, "__is_balanced_recursive": {"doc": {"short_description": "O(N) solution"}, "args": ["root"], "returns": ["-1 != __get_depth(root)"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 10}, "calls": ["is_balanced.__get_depth"], "source_code": "def __is_balanced_recursive(root):\n    \"\"\"\n    O(N) solution\n    \"\"\"\n    return -1 != __get_depth(root)"}, "__get_depth": {"doc": {"short_description": "return 0 if unbalanced else depth + 1"}, "args": ["root"], "returns": ["1 + max(left, right)", "0", "-1"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 23}, "calls": ["is_balanced.__get_depth", "max", "abs"], "store_vars_calls": {"left": "__get_depth", "right": "__get_depth"}, "source_code": "def __get_depth(root):\n    \"\"\"\n    return 0 if unbalanced else depth + 1\n    \"\"\"\n    if root is None:\n        return 0\n    left = __get_depth(root.left)\n    right = __get_depth(root.right)\n    if abs(left - right) > 1 or -1 in [left, right]:\n        return -1\n    return 1 + max(left, right)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/b_tree.py", "fileNameBase": "b_tree", "extension": "py", "doc": {"long_description": "at least t-1 keys (t children) and at most 2*t - 1 keys (2*t children)\nwhere t is the degree of b-tree. It is not a kind of typical bst tree, because\nthis tree grows up.\nB-tree is balanced which means that the difference between height of left\nsubtree and right subtree is at most 1.\n\nComplexity\n    n - number of elements\n    t - degree of tree\n    Tree always has height at most logt (n+1)/2\n    Algorithm        Average        Worst case\n    Space            O(n)           O(n)\n    Search           O(log n)       O(log n)\n    Insert           O(log n)       O(log n)\n    Delete           O(log n)       O(log n)", "short_description": "B-tree is used to disk operations. Each node (except root) contains", "full": "B-tree is used to disk operations. Each node (except root) contains\nat least t-1 keys (t children) and at most 2*t - 1 keys (2*t children)\nwhere t is the degree of b-tree. It is not a kind of typical bst tree, because\nthis tree grows up.\nB-tree is balanced which means that the difference between height of left\nsubtree and right subtree is at most 1.\n\nComplexity\n    n - number of elements\n    t - degree of tree\n    Tree always has height at most logt (n+1)/2\n    Algorithm        Average        Worst case\n    Space            O(n)           O(n)\n    Search           O(log n)       O(log n)\n    Insert           O(log n)       O(log n)\n    Delete           O(log n)       O(log n)"}}, "classes": {"Node": {"doc": {"short_description": "Class of Node", "full": "Class of Node"}, "min_max_lineno": {"min_lineno": 21, "max_lineno": 36}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 28}, "source_code": "def __init__(self):\n    self.keys = []\n    self.children = []"}, "__repr__": {"args": ["self"], "returns": ["'<id_node: {0}>'.format(self.keys)"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 31}, "source_code": "def __repr__(self):\n    return '<id_node: {0}>'.format(self.keys)"}, "is_leaf": {"doc": {"short_description": "Return if it is a leaf"}, "args": ["self"], "returns": ["len(self.children) == 0"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 36}, "calls": ["len"], "source_code": "@property\ndef is_leaf(self):\n    \"\"\" Return if it is a leaf\"\"\"\n    return len(self.children) == 0"}}}, "BTree": {"doc": {"short_description": "Class of BTree ", "full": "Class of BTree "}, "min_max_lineno": {"min_lineno": 38, "max_lineno": 252}, "methods": {"__init__": {"args": ["self", "t_val"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 46}, "store_vars_calls": {"self.root": "Node"}, "source_code": "def __init__(self, t_val=2):\n    self.min_numbers_of_keys = t_val - 1\n    self.max_number_of_keys = 2 * t_val - 1\n    self.root = Node()"}, "_split_child": {"args": ["self", "parent", "child_index"], "annotated_arg_types": {"parent": "Node", "child_index": "int"}, "min_max_lineno": {"min_lineno": 47, "max_lineno": 62}, "calls": ["parent.keys.insert", "parent.children.insert"], "store_vars_calls": {"new_right_child": "Node"}, "source_code": "def _split_child(self, parent: Node, child_index: int):\n    new_right_child = Node()\n    half_max = self.max_number_of_keys // 2\n    child = parent.children[child_index]\n    middle_key = child.keys[half_max]\n    new_right_child.keys = child.keys[half_max + 1:]\n    child.keys = child.keys[:half_max]\n    if not child.is_leaf:\n        new_right_child.children = child.children[half_max + 1:]\n        child.children = child.children[:half_max + 1]\n    parent.keys.insert(child_index, middle_key)\n    parent.children.insert(child_index + 1, new_right_child)"}, "insert_key": {"doc": {"short_description": "overflow, tree increases in height "}, "args": ["self", "key"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 73}, "calls": ["len", "Node.children.append", "b_tree.BTree._split_child", "b_tree.BTree._insert_to_nonfull_node"], "store_vars_calls": {"new_root": "Node"}, "source_code": "def insert_key(self, key):\n    \"\"\" overflow, tree increases in height \"\"\"\n    if len(self.root.keys) >= self.max_number_of_keys:\n        new_root = Node()\n        new_root.children.append(self.root)\n        self.root = new_root\n        self._split_child(new_root, 0)\n        self._insert_to_nonfull_node(self.root, key)\n    else:\n        self._insert_to_nonfull_node(self.root, key)"}, "_insert_to_nonfull_node": {"args": ["self", "node", "key"], "annotated_arg_types": {"node": "Node"}, "min_max_lineno": {"min_lineno": 74, "max_lineno": 90}, "calls": ["len", "node.keys.insert", "b_tree.BTree._insert_to_nonfull_node", "b_tree.BTree._split_child"], "source_code": "def _insert_to_nonfull_node(self, node: Node, key):\n    i = len(node.keys) - 1\n    while i >= 0 and node.keys[i] >= key:\n        i -= 1\n    if node.is_leaf:\n        node.keys.insert(i + 1, key)\n    else:\n        if len(node.children[i + 1].keys) >= self.max_number_of_keys:\n            self._split_child(node, i + 1)\n            if node.keys[i + 1] < key:\n                i += 1\n        self._insert_to_nonfull_node(node.children[i + 1], key)"}, "find": {"doc": {"short_description": "Finds key "}, "args": ["self", "key"], "annotated_return_type": "bool", "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 91, "max_lineno": 103}, "calls": ["len"], "source_code": "def find(self, key) -> bool:\n    \"\"\" Finds key \"\"\"\n    current_node = self.root\n    while True:\n        i = len(current_node.keys) - 1\n        while i >= 0 and current_node.keys[i] > key:\n            i -= 1\n        if i >= 0 and current_node.keys[i] == key:\n            return True\n        if current_node.is_leaf:\n            return False\n        current_node = current_node.children[i + 1]"}, "remove_key": {"args": ["self", "key"], "min_max_lineno": {"min_lineno": 104, "max_lineno": 106}, "calls": ["b_tree.BTree._remove_key"], "source_code": "def remove_key(self, key):\n    self._remove_key(self.root, key)"}, "_remove_key": {"args": ["self", "node", "key"], "annotated_arg_types": {"node": "Node"}, "annotated_return_type": "bool", "returns": ["True", "False", "self._remove_key(node, key)", "self._remove_key(node.children[i], key)"], "min_max_lineno": {"min_lineno": 107, "max_lineno": 132}, "calls": ["node.keys.index", "node.keys.remove", "b_tree.BTree._remove_from_nonleaf_node", "print", "len", "b_tree.BTree._repair_tree", "b_tree.BTree._remove_key"], "store_vars_calls": {"key_index": "node.keys.index", "number_of_keys": "len", "action_performed": "self._repair_tree"}, "source_code": "def _remove_key(self, node: Node, key) -> bool:\n    try:\n        key_index = node.keys.index(key)\n        if node.is_leaf:\n            node.keys.remove(key)\n        else:\n            self._remove_from_nonleaf_node(node, key_index)\n        return True\n    except ValueError:\n        if node.is_leaf:\n            print('Key not found.')\n            return False\n        else:\n            i = 0\n            number_of_keys = len(node.keys)\n            while i < number_of_keys and key > node.keys[i]:\n                i += 1\n            action_performed = self._repair_tree(node, i)\n            if action_performed:\n                return self._remove_key(node, key)\n            else:\n                return self._remove_key(node.children[i], key)"}, "_repair_tree": {"args": ["self", "node", "child_index"], "annotated_arg_types": {"node": "Node", "child_index": "int"}, "annotated_return_type": "bool", "returns": ["True", "False", "True", "True"], "min_max_lineno": {"min_lineno": 133, "max_lineno": 156}, "calls": ["len", "b_tree.BTree._rotate_right", "b_tree.BTree._rotate_left", "b_tree.BTree._merge"], "source_code": "def _repair_tree(self, node: Node, child_index: int) -> bool:\n    child = node.children[child_index]\n    if self.min_numbers_of_keys < len(child.keys) <= self.max_number_of_keys:\n        return False\n    if child_index > 0 and len(node.children[child_index - 1].keys) > self.min_numbers_of_keys:\n        self._rotate_right(node, child_index)\n        return True\n    if child_index < len(node.children) - 1 and len(node.children[child_index + 1].keys) > self.min_numbers_of_keys:\n        self._rotate_left(node, child_index)\n        return True\n    if child_index > 0:\n        self._merge(node, child_index - 1, child_index)\n    else:\n        self._merge(node, child_index, child_index + 1)\n    return True"}, "_rotate_left": {"doc": {"short_description": "Take key from right brother of the child and transfer to the child"}, "args": ["self", "parent_node", "child_index"], "annotated_arg_types": {"parent_node": "Node", "child_index": "int"}, "min_max_lineno": {"min_lineno": 157, "max_lineno": 172}, "calls": ["parent_node.children[].keys.pop", "parent_node.children[].keys.append", "parent_node.children[].children.pop", "parent_node.children[].children.append"], "store_vars_calls": {"new_parent_key": "parent_node.children[].keys.pop", "ownerless_child": "parent_node.children[].children.pop"}, "source_code": "def _rotate_left(self, parent_node: Node, child_index: int):\n    \"\"\"\n        Take key from right brother of the child and transfer to the child\n        \"\"\"\n    new_child_key = parent_node.keys[child_index]\n    new_parent_key = parent_node.children[child_index + 1].keys.pop(0)\n    parent_node.children[child_index].keys.append(new_child_key)\n    parent_node.keys[child_index] = new_parent_key\n    if not parent_node.children[child_index + 1].is_leaf:\n        ownerless_child = parent_node.children[child_index + 1].children.pop(0)\n        parent_node.children[child_index].children.append(ownerless_child)"}, "_rotate_right": {"doc": {"short_description": "Take key from left brother of the child and transfer to the child"}, "args": ["self", "parent_node", "child_index"], "annotated_arg_types": {"parent_node": "Node", "child_index": "int"}, "min_max_lineno": {"min_lineno": 173, "max_lineno": 189}, "calls": ["parent_node.children[].keys.pop", "parent_node.children[].keys.insert", "parent_node.children[].children.pop", "parent_node.children[].children.insert"], "store_vars_calls": {"new_parent_key": "parent_node.children[].keys.pop", "ownerless_child": "parent_node.children[].children.pop"}, "source_code": "def _rotate_right(self, parent_node: Node, child_index: int):\n    \"\"\"\n        Take key from left brother of the child and transfer to the child\n        \"\"\"\n    parent_key = parent_node.keys[child_index - 1]\n    new_parent_key = parent_node.children[child_index - 1].keys.pop()\n    parent_node.children[child_index].keys.insert(0, parent_key)\n    parent_node.keys[child_index - 1] = new_parent_key\n    if not parent_node.children[child_index - 1].is_leaf:\n        ownerless_child = parent_node.children[child_index - 1].children.pop()\n        parent_node.children[child_index].children.insert(0, ownerless_child)"}, "_merge": {"args": ["self", "parent_node", "to_merge_index", "transfered_child_index"], "annotated_arg_types": {"parent_node": "Node", "to_merge_index": "int", "transfered_child_index": "int"}, "min_max_lineno": {"min_lineno": 190, "max_lineno": 202}, "calls": ["parent_node.children.pop", "parent_node.keys.pop", "to_merge_node.keys.append", "to_merge_node.keys.extend", "to_merge_node.children.extend"], "store_vars_calls": {"from_merge_node": "parent_node.children.pop", "parent_key_to_merge": "parent_node.keys.pop"}, "source_code": "def _merge(self, parent_node: Node, to_merge_index: int, transfered_child_index: int):\n    from_merge_node = parent_node.children.pop(transfered_child_index)\n    parent_key_to_merge = parent_node.keys.pop(to_merge_index)\n    to_merge_node = parent_node.children[to_merge_index]\n    to_merge_node.keys.append(parent_key_to_merge)\n    to_merge_node.keys.extend(from_merge_node.keys)\n    if not to_merge_node.is_leaf:\n        to_merge_node.children.extend(from_merge_node.children)\n    if parent_node == self.root and (not parent_node.keys):\n        self.root = to_merge_node"}, "_remove_from_nonleaf_node": {"args": ["self", "node", "key_index"], "annotated_arg_types": {"node": "Node", "key_index": "int"}, "returns": ["self._remove_key(node, key)"], "min_max_lineno": {"min_lineno": 203, "max_lineno": 217}, "calls": ["len", "b_tree.BTree._find_largest_and_delete_in_left_subtree", "b_tree.BTree._find_largest_and_delete_in_right_subtree", "b_tree.BTree._merge", "b_tree.BTree._remove_key"], "store_vars_calls": {"largest_key": "self._find_largest_and_delete_in_right_subtree"}, "source_code": "def _remove_from_nonleaf_node(self, node: Node, key_index: int):\n    key = node.keys[key_index]\n    left_subtree = node.children[key_index]\n    if len(left_subtree.keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_left_subtree(left_subtree)\n    elif len(node.children[key_index + 1].keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_right_subtree(node.children[key_index + 1])\n    else:\n        self._merge(node, key_index, key_index + 1)\n        return self._remove_key(node, key)\n    node.keys[key_index] = largest_key"}, "_find_largest_and_delete_in_left_subtree": {"args": ["self", "node"], "annotated_arg_types": {"node": "Node"}, "returns": ["node.keys.pop()", "largest_key_in_subtree"], "min_max_lineno": {"min_lineno": 218, "max_lineno": 228}, "calls": ["node.keys.pop", "b_tree.BTree._repair_tree", "b_tree.BTree._find_largest_and_delete_in_left_subtree", "len"], "store_vars_calls": {"largest_key_in_subtree": "self._find_largest_and_delete_in_left_subtree"}, "source_code": "def _find_largest_and_delete_in_left_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop()\n    else:\n        ch_index = len(node.children) - 1\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_left_subtree(node.children[len(node.children) - 1])\n        return largest_key_in_subtree"}, "_find_largest_and_delete_in_right_subtree": {"args": ["self", "node"], "annotated_arg_types": {"node": "Node"}, "returns": ["node.keys.pop(0)", "largest_key_in_subtree"], "min_max_lineno": {"min_lineno": 229, "max_lineno": 239}, "calls": ["node.keys.pop", "b_tree.BTree._repair_tree", "b_tree.BTree._find_largest_and_delete_in_right_subtree"], "store_vars_calls": {"largest_key_in_subtree": "self._find_largest_and_delete_in_right_subtree"}, "source_code": "def _find_largest_and_delete_in_right_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop(0)\n    else:\n        ch_index = 0\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_right_subtree(node.children[0])\n        return largest_key_in_subtree"}, "traverse_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 240, "max_lineno": 243}, "calls": ["b_tree.BTree._traverse_tree", "print"], "source_code": "def traverse_tree(self):\n    self._traverse_tree(self.root)\n    print()"}, "_traverse_tree": {"args": ["self", "node"], "annotated_arg_types": {"node": "Node"}, "min_max_lineno": {"min_lineno": 244, "max_lineno": 252}, "calls": ["print", "enumerate", "b_tree.BTree._traverse_tree"], "source_code": "def _traverse_tree(self, node: Node):\n    if node.is_leaf:\n        print(node.keys, end=' ')\n    else:\n        for (i, key) in enumerate(node.keys):\n            self._traverse_tree(node.children[i])\n            print(key, end=' ')\n        self._traverse_tree(node.children[-1])"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/lowest_common_ancestor.py", "fileNameBase": "lowest_common_ancestor", "extension": "py", "doc": {"long_description": "(LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two nodes\n    v and w as the lowest node in T that has both v and w as\n    descendants\n    (where we allow a node to be a descendant of itself).\u201d\n\n        _______3______\n       /                  ___5__          ___1__\n   /      \\        /         6      _2       0       8\n         /           7   4\nFor example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3.\nAnother example is LCA of nodes 5 and 4 is 5,\nsince a node can be a descendant of itself according to the LCA definition.", "short_description": "Given a binary tree, find the lowest common ancestor", "full": "Given a binary tree, find the lowest common ancestor\n(LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two nodes\n    v and w as the lowest node in T that has both v and w as\n    descendants\n    (where we allow a node to be a descendant of itself).\u201d\n\n        _______3______\n       /                  ___5__          ___1__\n   /      \\        /         6      _2       0       8\n         /           7   4\nFor example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3.\nAnother example is LCA of nodes 5 and 4 is 5,\nsince a node can be a descendant of itself according to the LCA definition."}}, "functions": {"lca": {"args": ["root", "p", "q"], "returns": ["left if left else right", "root", "root"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 38}, "calls": ["lowest_common_ancestor.lca"], "store_vars_calls": {"left": "lca", "right": "lca"}, "source_code": "def lca(root, p, q):\n    \"\"\"\n    :type root: TreeNode\n    :type p: TreeNode\n    :type q: TreeNode\n    :rtype: TreeNode\n    \"\"\"\n    if root is None or root is p or root is q:\n        return root\n    left = lca(root.left, p, q)\n    right = lca(root.right, p, q)\n    if left is not None and right is not None:\n        return root\n    return left if left else right"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/max_path_sum.py", "fileNameBase": "max_path_sum", "extension": "py"}, "functions": {"max_path_sum": {"args": ["root"], "returns": ["maximum"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 5}, "calls": ["float", "max_path_sum.helper"], "store_vars_calls": {"maximum": "float"}, "source_code": "def max_path_sum(root):\n    maximum = float('-inf')\n    helper(root, maximum)\n    return maximum"}, "helper": {"args": ["root", "maximum"], "returns": ["root.val + maximum", "0"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 14}, "calls": ["max_path_sum.helper", "max"], "store_vars_calls": {"left": "helper", "right": "helper", "maximum": "max"}, "source_code": "def helper(root, maximum):\n    if root is None:\n        return 0\n    left = helper(root.left, maximum)\n    right = helper(root.right, maximum)\n    maximum = max(maximum, left + right + root.val)\n    return root.val + maximum"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/binary_tree_paths.py", "fileNameBase": "binary_tree_paths", "extension": "py"}, "functions": {"binary_tree_paths": {"args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 7}, "calls": ["binary_tree_paths.dfs", "str"], "source_code": "def binary_tree_paths(root):\n    res = []\n    if root is None:\n        return res\n    dfs(res, root, str(root.val))\n    return res"}, "dfs": {"args": ["res", "root", "cur"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 16}, "calls": ["res.append", "binary_tree_paths.dfs", "str"], "source_code": "def dfs(res, root, cur):\n    if root.left is None and root.right is None:\n        res.append(cur)\n    if root.left:\n        dfs(res, root.left, cur + '->' + str(root.left.val))\n    if root.right:\n        dfs(res, root.right, cur + '->' + str(root.right.val))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/construct_tree_postorder_preorder.py", "fileNameBase": "construct_tree_postorder_preorder", "extension": "py", "doc": {"long_description": "binary tree, construct the binary tree and print the inorder traversal of the\ntree.\nA full binary tree has either 0 or 2 children.\nAlgorithm:\n    1. Assign the first element of preorder array as root of the tree.\n    2. Find the same element in the postorder array and divide the postorder\n        array into left and right subtree.\n    3. Repeat the above steps for all the elements and construct the tree.\nEg: pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7}\n    post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1}\n    Tree:\n            1\n          /                2     3\n        / \\   /            4   5 6   7\n      /          8   9\n  Output: 8 4 9 2 5 1 6 3 7", "short_description": "Given two arrays representing preorder and postorder traversal of a full", "full": "Given two arrays representing preorder and postorder traversal of a full\nbinary tree, construct the binary tree and print the inorder traversal of the\ntree.\nA full binary tree has either 0 or 2 children.\nAlgorithm:\n    1. Assign the first element of preorder array as root of the tree.\n    2. Find the same element in the postorder array and divide the postorder\n        array into left and right subtree.\n    3. Repeat the above steps for all the elements and construct the tree.\nEg: pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7}\n    post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1}\n    Tree:\n            1\n          /                2     3\n        / \\   /            4   5 6   7\n      /          8   9\n  Output: 8 4 9 2 5 1 6 3 7"}}, "classes": {"TreeNode": {"min_max_lineno": {"min_lineno": 24, "max_lineno": 30}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 30}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}}, "functions": {"construct_tree_util": {"doc": {"long_description": "preIndex is a global variable that keeps track of the index in preorder\narray.\npreorder and postorder array are represented are pre[] and post[] respectively.\nlow and high are the indices for the postorder array.", "short_description": "Recursive function that constructs tree from preorder and postorder array."}, "args": ["pre", "post", "low", "high", "size"], "annotated_arg_types": {"pre": "list", "post": "list", "low": "int", "high": "int", "size": "int"}, "returns": ["root", "None", "root"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 75}, "calls": ["construct_tree_postorder_preorder.construct_tree_util"], "store_vars_calls": {"root": "TreeNode", "root.left": "construct_tree_util", "root.right": "construct_tree_util"}, "source_code": "def construct_tree_util(pre: list, post: list, low: int, high: int, size: int):\n    \"\"\"\n        Recursive function that constructs tree from preorder and postorder array.\n        \n        preIndex is a global variable that keeps track of the index in preorder\n        array.\n        preorder and postorder array are represented are pre[] and post[] respectively.\n        low and high are the indices for the postorder array.\n    \"\"\"\n    global pre_index\n    if pre_index == -1:\n        pre_index = 0\n    if pre_index >= size or low > high:\n        return None\n    root = TreeNode(pre[pre_index])\n    pre_index += 1\n    if low == high or pre_index >= size:\n        return root\n    i = low\n    while i <= high:\n        if pre[pre_index] == post[i]:\n            break\n        i += 1\n    if i <= high:\n        root.left = construct_tree_util(pre, post, low, i, size)\n        root.right = construct_tree_util(pre, post, i + 1, high, size)\n    return root"}, "construct_tree": {"doc": {"long_description": "and postorder array.", "short_description": "Main Function that will construct the full binary tree from given preorder"}, "args": ["pre", "post", "size"], "annotated_arg_types": {"pre": "list", "post": "list", "size": "int"}, "returns": ["print_inorder(root)"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 87}, "calls": ["construct_tree_postorder_preorder.construct_tree_util", "construct_tree_postorder_preorder.print_inorder"], "store_vars_calls": {"root": "construct_tree_util"}, "source_code": "def construct_tree(pre: list, post: list, size: int):\n    \"\"\"\n        Main Function that will construct the full binary tree from given preorder\n        and postorder array.\n    \"\"\"\n    global pre_index\n    root = construct_tree_util(pre, post, 0, size - 1, size)\n    return print_inorder(root)"}, "print_inorder": {"doc": {"short_description": "Prints the tree constructed in inorder format"}, "args": ["root", "result"], "annotated_arg_types": {"root": "TreeNode"}, "returns": ["result", "[]"], "min_max_lineno": {"min_lineno": 90, "max_lineno": 103}, "calls": ["construct_tree_postorder_preorder.print_inorder", "result.append"], "source_code": "def print_inorder(root: TreeNode, result=None):\n    \"\"\"\n        Prints the tree constructed in inorder format\n    \"\"\"\n    if root is None:\n        return []\n    if result is None:\n        result = []\n    print_inorder(root.left, result)\n    result.append(root.val)\n    print_inorder(root.right, result)\n    return result"}}, "body": {"calls": ["len", "construct_tree_postorder_preorder.construct_tree", "print"], "store_vars_calls": {"size": "len", "result": "construct_tree"}, "source_code": ["len(pre)", "construct_tree(pre, post, size)", "print(result)"]}, "main_info": {"main_flag": 1, "main_function": "construct_tree_postorder_preorder.len", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/same_tree.py", "fileNameBase": "same_tree", "extension": "py", "doc": {"long_description": "if they are equal or not.\n\nTwo binary trees are considered equal if they are\nstructurally identical and the nodes have the same value.", "short_description": "Given two binary trees, write a function to check", "full": "Given two binary trees, write a function to check\nif they are equal or not.\n\nTwo binary trees are considered equal if they are\nstructurally identical and the nodes have the same value."}}, "functions": {"is_same_tree": {"args": ["tree_p", "tree_q"], "returns": ["False", "True", "is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 16}, "calls": ["same_tree.is_same_tree"], "source_code": "def is_same_tree(tree_p, tree_q):\n    if tree_p is None and tree_q is None:\n        return True\n    if tree_p is not None and tree_q is not None and (tree_p.val == tree_q.val):\n        return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bin_tree_to_list.py", "fileNameBase": "bin_tree_to_list", "extension": "py"}, "dependencies": [{"from_module": "tree.tree", "import": "TreeNode", "type": "external", "type_element": "module"}], "functions": {"bin_tree_to_list": {"doc": {"short_description": "type root: root class"}, "args": ["root"], "returns": ["root", "root"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 14}, "calls": ["bin_tree_to_list.bin_tree_to_list_util"], "store_vars_calls": {"root": "bin_tree_to_list_util"}, "source_code": "def bin_tree_to_list(root):\n    \"\"\"\n    type root: root class\n    \"\"\"\n    if not root:\n        return root\n    root = bin_tree_to_list_util(root)\n    while root.left:\n        root = root.left\n    return root"}, "bin_tree_to_list_util": {"args": ["root"], "returns": ["root", "root"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 32}, "calls": ["bin_tree_to_list.bin_tree_to_list_util"], "store_vars_calls": {"left": "bin_tree_to_list_util", "right": "bin_tree_to_list_util"}, "source_code": "def bin_tree_to_list_util(root):\n    if not root:\n        return root\n    if root.left:\n        left = bin_tree_to_list_util(root.left)\n        while left.right:\n            left = left.right\n        left.right = root\n        root.left = left\n    if root.right:\n        right = bin_tree_to_list_util(root.right)\n        while right.left:\n            right = right.left\n        right.left = root\n        root.right = right\n    return root"}, "print_tree": {"args": ["root"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 38}, "calls": ["print"], "source_code": "def print_tree(root):\n    while root:\n        print(root.val)\n        root = root.right"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/pretty_print.py", "fileNameBase": "pretty_print", "extension": "py"}, "dependencies": [{"from_module": "__future__", "import": "print_function", "type": "external", "type_element": "module"}], "functions": {"tree_print": {"args": ["tree"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 24}, "calls": ["print", "type"], "source_code": "def tree_print(tree):\n    for key in tree:\n        print(key, end=' ')\n        tree_element = tree[key]\n        for subElem in tree_element:\n            print(' -> ', subElem, end=' ')\n            if type(subElem) != str:\n                print('\\n ')\n        print()"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/path_sum.py", "fileNameBase": "path_sum", "extension": "py", "doc": {"long_description": "path such that adding up all the values along the path equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\              7    2      1\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.", "short_description": "Given a binary tree and a sum, determine if the tree has a root-to-leaf", "full": "Given a binary tree and a sum, determine if the tree has a root-to-leaf\npath such that adding up all the values along the path equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\              7    2      1\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22."}}, "functions": {"has_path_sum": {"args": ["root", "sum"], "returns": ["has_path_sum(root.left, sum) or has_path_sum(root.right, sum)", "False", "True"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 30}, "calls": ["path_sum.has_path_sum"], "source_code": "def has_path_sum(root, sum):\n    \"\"\"\n    :type root: TreeNode\n    :type sum: int\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return False\n    if root.left is None and root.right is None and (root.val == sum):\n        return True\n    sum -= root.val\n    return has_path_sum(root.left, sum) or has_path_sum(root.right, sum)"}, "has_path_sum2": {"args": ["root", "sum"], "returns": ["False", "False", "True"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 47}, "calls": ["stack.pop", "stack.append"], "source_code": "def has_path_sum2(root, sum):\n    if root is None:\n        return False\n    stack = [(root, root.val)]\n    while stack:\n        (node, val) = stack.pop()\n        if node.left is None and node.right is None:\n            if val == sum:\n                return True\n        if node.left is not None:\n            stack.append((node.left, val + node.left.val))\n        if node.right is not None:\n            stack.append((node.right, val + node.right.val))\n    return False"}, "has_path_sum3": {"args": ["root", "sum"], "returns": ["False", "False", "True"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 64}, "calls": ["queue.pop", "queue.append"], "source_code": "def has_path_sum3(root, sum):\n    if root is None:\n        return False\n    queue = [(root, sum - root.val)]\n    while queue:\n        (node, val) = queue.pop(0)\n        if node.left is None and node.right is None:\n            if val == 0:\n                return True\n        if node.left is not None:\n            queue.append((node.left, val - node.left.val))\n        if node.right is not None:\n            queue.append((node.right, val - node.right.val))\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/tree.py", "fileNameBase": "tree", "extension": "py"}, "classes": {"TreeNode": {"min_max_lineno": {"min_lineno": 1, "max_lineno": 6}, "methods": {"__init__": {"args": ["self", "val"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 6}, "source_code": "def __init__(self, val=0):\n    self.val = val\n    self.left = None\n    self.right = None"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/min_height.py", "fileNameBase": "min_height", "extension": "py"}, "dependencies": [{"from_module": "tree", "import": "TreeNode", "type": "internal", "type_element": "module"}], "functions": {"min_depth": {"args": ["self", "root"], "returns": ["min(self.minDepth(root.left), self.minDepth(root.right)) + 1", "0", "max(self.minDepth(root.left), self.minDepth(root.right)) + 1"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 14}, "calls": ["min", "max", "min_height..minDepth"], "source_code": "def min_depth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right)) + 1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, "min_height": {"args": ["root"], "returns": ["height", "0", "height"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 34}, "calls": ["new_level.append"], "source_code": "def min_height(root):\n    if root is None:\n        return 0\n    height = 0\n    level = [root]\n    while level:\n        height += 1\n        new_level = []\n        for node in level:\n            if node.left is None and node.right is None:\n                return height\n            if node.left is not None:\n                new_level.append(node.left)\n            if node.right is not None:\n                new_level.append(node.right)\n        level = new_level\n    return height"}, "print_tree": {"args": ["root"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 41}, "calls": ["print", "min_height.print_tree"], "source_code": "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)"}}, "body": {"calls": ["tree.TreeNode", "min_height.min_height", "min_height.print_tree", "print"], "store_vars_calls": {"tree": "TreeNode", "tree.left": "TreeNode", "tree.right": "TreeNode", "tree.left.left": "TreeNode", "tree.left.left.right": "TreeNode", "tree.left.right": "TreeNode", "tree.right.left": "TreeNode", "height": "min_height"}, "source_code": ["TreeNode(10)", "TreeNode(12)", "TreeNode(15)", "TreeNode(25)", "TreeNode(100)", "TreeNode(30)", "TreeNode(36)", "min_height(tree)", "print_tree(tree)", "print('height:', height)"]}, "main_info": {"main_flag": 1, "main_function": "min_height.TreeNode", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/path_sum2.py", "fileNameBase": "path_sum2", "extension": "py", "doc": {"long_description": "paths where each path's sum equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\    /         7    2  5   1\nreturn\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]", "short_description": "Given a binary tree and a sum, find all root-to-leaf", "full": "Given a binary tree and a sum, find all root-to-leaf\npaths where each path's sum equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\    /         7    2  5   1\nreturn\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]"}}, "functions": {"path_sum": {"args": ["root", "sum"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 28}, "calls": ["path_sum2.dfs"], "source_code": "def path_sum(root, sum):\n    if root is None:\n        return []\n    res = []\n    dfs(root, sum, [], res)\n    return res"}, "dfs": {"args": ["root", "sum", "ls", "res"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 38}, "calls": ["ls.append", "res.append", "path_sum2.dfs"], "source_code": "def dfs(root, sum, ls, res):\n    if root.left is None and root.right is None and (root.val == sum):\n        ls.append(root.val)\n        res.append(ls)\n    if root.left is not None:\n        dfs(root.left, sum - root.val, ls + [root.val], res)\n    if root.right is not None:\n        dfs(root.right, sum - root.val, ls + [root.val], res)"}, "path_sum2": {"args": ["root", "s"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 55}, "calls": ["stack.pop", "res.append", "stack.append", "sum"], "source_code": "def path_sum2(root, s):\n    if root is None:\n        return []\n    res = []\n    stack = [(root, [root.val])]\n    while stack:\n        (node, ls) = stack.pop()\n        if node.left is None and node.right is None and (sum(ls) == s):\n            res.append(ls)\n        if node.left is not None:\n            stack.append((node.left, ls + [node.left.val]))\n        if node.right is not None:\n            stack.append((node.right, ls + [node.right.val]))\n    return res"}, "path_sum3": {"args": ["root", "sum"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 72}, "calls": ["queue.pop", "res.append", "queue.append"], "source_code": "def path_sum3(root, sum):\n    if root is None:\n        return []\n    res = []\n    queue = [(root, root.val, [root.val])]\n    while queue:\n        (node, val, ls) = queue.pop(0)\n        if node.left is None and node.right is None and (val == sum):\n            res.append(ls)\n        if node.left is not None:\n            queue.append((node.left, val + node.left.val, ls + [node.left.val]))\n        if node.right is not None:\n            queue.append((node.right, val + node.right.val, ls + [node.right.val]))\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/max_height.py", "fileNameBase": "max_height", "extension": "py", "doc": {"long_description": "The maximum depth is the number of nodes along the\nlongest path from the root node down to the farthest leaf node.", "short_description": "Given a binary tree, find its maximum depth.", "full": "Given a binary tree, find its maximum depth.\n\nThe maximum depth is the number of nodes along the\nlongest path from the root node down to the farthest leaf node."}}, "dependencies": [{"from_module": "tree", "import": "TreeNode", "type": "internal", "type_element": "module"}], "functions": {"max_height": {"args": ["root"], "returns": ["height", "0"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 34}, "calls": ["queue.pop", "level.append"], "store_vars_calls": {"node": "queue.pop"}, "source_code": "def max_height(root):\n    if root is None:\n        return 0\n    height = 0\n    queue = [root]\n    while queue:\n        height += 1\n        level = []\n        while queue:\n            node = queue.pop(0)\n            if node.left is not None:\n                level.append(node.left)\n            if node.right is not None:\n                level.append(node.right)\n        queue = level\n    return height"}, "print_tree": {"args": ["root"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 41}, "calls": ["print", "max_height.print_tree"], "source_code": "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)"}}, "body": {"calls": ["tree.TreeNode", "max_height.max_height", "max_height.print_tree", "print"], "store_vars_calls": {"tree": "TreeNode", "tree.left": "TreeNode", "tree.right": "TreeNode", "tree.left.left": "TreeNode", "tree.left.left.right": "TreeNode", "tree.left.right": "TreeNode", "tree.right.left": "TreeNode", "height": "max_height"}, "source_code": ["TreeNode(10)", "TreeNode(12)", "TreeNode(15)", "TreeNode(25)", "TreeNode(100)", "TreeNode(30)", "TreeNode(36)", "max_height(tree)", "print_tree(tree)", "print('height:', height)"]}, "main_info": {"main_flag": 1, "main_function": "max_height.TreeNode", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/is_symmetric.py", "fileNameBase": "is_symmetric", "extension": "py", "doc": {"long_description": "itself (ie, symmetric around its center).\n\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n    1\n   /   2   2\n / \\ / 3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   /   2   2\n   \\      3    3\nNote:\nBonus points if you could solve it both recursively and iteratively.", "short_description": "Given a binary tree, check whether it is a mirror of", "full": "Given a binary tree, check whether it is a mirror of\nitself (ie, symmetric around its center).\n\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n    1\n   /   2   2\n / \\ / 3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   /   2   2\n   \\      3    3\nNote:\nBonus points if you could solve it both recursively and iteratively."}}, "functions": {"is_symmetric": {"args": ["root"], "returns": ["helper(root.left, root.right)", "True"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 27}, "calls": ["is_symmetric.helper"], "source_code": "def is_symmetric(root):\n    if root is None:\n        return True\n    return helper(root.left, root.right)"}, "helper": {"args": ["p", "q"], "returns": ["helper(p.left, q.right) and helper(p.right, q.left)", "True", "False"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 35}, "calls": ["is_symmetric.helper"], "source_code": "def helper(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None or q is not None or q.val != p.val:\n        return False\n    return helper(p.left, q.right) and helper(p.right, q.left)"}, "is_symmetric_iterative": {"args": ["root"], "returns": ["True", "True", "False", "False"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 53}, "calls": ["stack.pop", "stack.append"], "source_code": "def is_symmetric_iterative(root):\n    if root is None:\n        return True\n    stack = [[root.left, root.right]]\n    while stack:\n        (left, right) = stack.pop()\n        if left is None and right is None:\n            continue\n        if left is None or right is None:\n            return False\n        if left.val == right.val:\n            stack.append([left.left, right.right])\n            stack.append([left.right, right.left])\n        else:\n            return False\n    return True"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/bst": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/num_empty.py", "fileNameBase": "num_empty", "extension": "py", "doc": {"long_description": "tree. Function should count the total number of empty branches among the nodes\nof the tree. A leaf node has two empty branches. In the case, if root is None,\nit considered as a 1 empty branch\nFor example: the following tree has 10 empty branch (* is empty branch)\n\n                    9 __\n                 /      \\___\n               6            12\n              / \\          /               3     8       10      15\n          /  \\   / \\     /  \\    /            *    * 7   *   *    *  *    18\n               / \\                   /                *   *                 *    *\n\n    empty_branch = 10", "short_description": "Write a function num_empty returns returns the number of empty branches in a", "full": "Write a function num_empty returns returns the number of empty branches in a\ntree. Function should count the total number of empty branches among the nodes\nof the tree. A leaf node has two empty branches. In the case, if root is None,\nit considered as a 1 empty branch\nFor example: the following tree has 10 empty branch (* is empty branch)\n\n                    9 __\n                 /      \\___\n               6            12\n              / \\          /               3     8       10      15\n          /  \\   / \\     /  \\    /            *    * 7   *   *    *  *    18\n               / \\                   /                *   *                 *    *\n\n    empty_branch = 10"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "bst", "import": "Node", "type": "internal", "type_element": "module"}, {"from_module": "bst", "import": "bst", "type": "internal", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 65}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 62}, "calls": ["bst.bst.bst", "num_empty.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "bst"}, "source_code": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)"}, "test_num_empty": {"args": ["self"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 65}, "calls": ["num_empty.TestSuite.assertEqual", "num_empty.num_empty"], "source_code": "def test_num_empty(self):\n    self.assertEqual(10, num_empty(self.tree.root))"}}}}, "functions": {"num_empty": {"args": ["root"], "returns": ["1", "1 + num_empty(root.right)", "1 + num_empty(root.left)", "num_empty(root.left) + num_empty(root.right)"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 34}, "calls": ["num_empty.num_empty"], "source_code": "def num_empty(root):\n    if root is None:\n        return 1\n    elif root.left is None and root.right:\n        return 1 + num_empty(root.right)\n    elif root.right is None and root.left:\n        return 1 + num_empty(root.left)\n    else:\n        return num_empty(root.left) + num_empty(root.right)"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "num_empty.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/unique_bst.py", "fileNameBase": "unique_bst", "extension": "py", "doc": {"long_description": "(binary search trees) that store values 1...n?\n\nFor example,\nGiven n = 3, there are a total of 5 unique BST's.\n\n   1         3     3      2      1\n    \\       /     /      / \\           3     2     1      1   3      2\n    /     /       \\                    2     1         2                 3", "short_description": "Given n, how many structurally unique BST's", "full": "Given n, how many structurally unique BST's\n(binary search trees) that store values 1...n?\n\nFor example,\nGiven n = 3, there are a total of 5 unique BST's.\n\n   1         3     3      2      1\n    \\       /     /      / \\           3     2     1      1   3      2\n    /     /       \\                    2     1         2                 3"}}, "functions": {"num_trees": {"args": ["n"], "returns": ["dp[-1]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 41}, "calls": ["range"], "source_code": "def num_trees(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i + 1):\n            dp[i] += dp[i - j] * dp[j - 1]\n    return dp[-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/bst.py", "fileNameBase": "bst", "extension": "py", "doc": {"long_description": "1. Insert\n2. Search\n3. Size\n4. Traversal (Preorder, Inorder, Postorder)", "short_description": "Implement Binary Search Tree. It has method:", "full": "Implement Binary Search Tree. It has method:\n    1. Insert\n    2. Search\n    3. Size\n    4. Traversal (Preorder, Inorder, Postorder)"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"Node": {"extend": ["object"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 16}, "methods": {"__init__": {"args": ["self", "data"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 16}, "source_code": "def __init__(self, data):\n    self.data = data\n    self.left = None\n    self.right = None"}}}, "BST": {"extend": ["object"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 101}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 20}, "source_code": "def __init__(self):\n    self.root = None"}, "get_root": {"args": ["self"], "returns": ["self.root"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 23}, "source_code": "def get_root(self):\n    return self.root"}, "size": {"args": ["self"], "returns": ["self.recur_size(self.root)"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 30}, "calls": ["bst.BST.recur_size"], "source_code": "def size(self):\n    return self.recur_size(self.root)"}, "recur_size": {"args": ["self", "root"], "returns": ["0", "1 + self.recur_size(root.left) + self.recur_size(root.right)"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 36}, "calls": ["bst.BST.recur_size"], "source_code": "def recur_size(self, root):\n    if root is None:\n        return 0\n    else:\n        return 1 + self.recur_size(root.left) + self.recur_size(root.right)"}, "search": {"args": ["self", "data"], "returns": ["self.recur_search(self.root, data)"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 43}, "calls": ["bst.BST.recur_search"], "source_code": "def search(self, data):\n    return self.recur_search(self.root, data)"}, "recur_search": {"args": ["self", "root", "data"], "returns": ["False", "True", "self.recur_search(root.right, data)", "self.recur_search(root.left, data)"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 53}, "calls": ["bst.BST.recur_search"], "source_code": "def recur_search(self, root, data):\n    if root is None:\n        return False\n    if root.data == data:\n        return True\n    elif data > root.data:\n        return self.recur_search(root.right, data)\n    else:\n        return self.recur_search(root.left, data)"}, "insert": {"args": ["self", "data"], "returns": ["self.recur_insert(self.root, data)", "True"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 64}, "calls": ["bst.BST.recur_insert"], "store_vars_calls": {"self.root": "Node"}, "source_code": "def insert(self, data):\n    if self.root:\n        return self.recur_insert(self.root, data)\n    else:\n        self.root = Node(data)\n        return True"}, "recur_insert": {"args": ["self", "root", "data"], "returns": ["False", "self.recur_insert(root.left, data)", "True", "self.recur_insert(root.right, data)", "True"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 80}, "calls": ["bst.BST.recur_insert", "bst.Node"], "store_vars_calls": {"root.left": "Node", "root.right": "Node"}, "source_code": "def recur_insert(self, root, data):\n    if root.data == data:\n        return False\n    elif data < root.data:\n        if root.left:\n            return self.recur_insert(root.left, data)\n        else:\n            root.left = Node(data)\n            return True\n    elif root.right:\n        return self.recur_insert(root.right, data)\n    else:\n        root.right = Node(data)\n        return True"}, "preorder": {"args": ["self", "root"], "min_max_lineno": {"min_lineno": 84, "max_lineno": 89}, "calls": ["print", "bst.BST.preorder", "str"], "source_code": "def preorder(self, root):\n    if root:\n        print(str(root.data), end=' ')\n        self.preorder(root.left)\n        self.preorder(root.right)"}, "inorder": {"args": ["self", "root"], "min_max_lineno": {"min_lineno": 90, "max_lineno": 95}, "calls": ["bst.BST.inorder", "print", "str"], "source_code": "def inorder(self, root):\n    if root:\n        self.inorder(root.left)\n        print(str(root.data), end=' ')\n        self.inorder(root.right)"}, "postorder": {"args": ["self", "root"], "min_max_lineno": {"min_lineno": 96, "max_lineno": 101}, "calls": ["bst.BST.postorder", "print", "str"], "source_code": "def postorder(self, root):\n    if root:\n        self.postorder(root.left)\n        self.postorder(root.right)\n        print(str(root.data), end=' ')"}}}, "TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 116, "max_lineno": 137}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 117, "max_lineno": 130}, "calls": ["bst.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "BST"}, "source_code": "def setUp(self):\n    self.tree = BST()\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(6)\n    self.tree.insert(4)\n    self.tree.insert(9)\n    self.tree.insert(12)\n    self.tree.insert(24)\n    self.tree.insert(7)\n    self.tree.insert(20)\n    self.tree.insert(30)\n    self.tree.insert(18)"}, "test_search": {"args": ["self"], "min_max_lineno": {"min_lineno": 131, "max_lineno": 134}, "calls": ["bst.TestSuite.assertTrue", "bst.TestSuite.assertFalse", "bst.TestSuite.tree.search"], "source_code": "def test_search(self):\n    self.assertTrue(self.tree.search(24))\n    self.assertFalse(self.tree.search(50))"}, "test_size": {"args": ["self"], "min_max_lineno": {"min_lineno": 135, "max_lineno": 137}, "calls": ["bst.TestSuite.assertEqual", "bst.TestSuite.tree.size"], "source_code": "def test_size(self):\n    self.assertEqual(11, self.tree.size())"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "bst.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/BSTIterator.py", "fileNameBase": "BSTIterator", "extension": "py"}, "classes": {"BSTIterator": {"min_max_lineno": {"min_lineno": 2, "max_lineno": 21}, "methods": {"__init__": {"args": ["self", "root"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 8}, "calls": ["BSTIterator.BSTIterator.stack.append"], "source_code": "def __init__(self, root):\n    self.stack = []\n    while root:\n        self.stack.append(root)\n        root = root.left"}, "has_next": {"args": ["self"], "returns": ["bool(self.stack)"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 11}, "calls": ["bool"], "source_code": "def has_next(self):\n    return bool(self.stack)"}, "next": {"args": ["self"], "returns": ["node.val"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 21}, "calls": ["BSTIterator.BSTIterator.stack.pop", "BSTIterator.BSTIterator.stack.append"], "store_vars_calls": {"node": "self.stack.pop"}, "source_code": "def next(self):\n    node = self.stack.pop()\n    tmp = node\n    if tmp.right:\n        tmp = tmp.right\n        while tmp:\n            self.stack.append(tmp)\n            tmp = tmp.left\n    return node.val"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/predecessor.py", "fileNameBase": "predecessor", "extension": "py"}, "functions": {"predecessor": {"args": ["root", "node"], "returns": ["pred"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 10}, "source_code": "def predecessor(root, node):\n    pred = None\n    while root:\n        if node.val > root.val:\n            pred = root\n            root = root.right\n        else:\n            root = root.left\n    return pred"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/depth_sum.py", "fileNameBase": "depth_sum", "extension": "py", "doc": {"long_description": "in a binary search tree of integers weighted by the depth of each value.\n\nFor example:\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    depth_sum = 1*9 + 2*(6+12) + 3*(3+8+10+15) + 4*(7+18)", "short_description": "Write a function depthSum returns the sum of the values stored", "full": "Write a function depthSum returns the sum of the values stored\nin a binary search tree of integers weighted by the depth of each value.\n\nFor example:\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    depth_sum = 1*9 + 2*(6+12) + 3*(3+8+10+15) + 4*(7+18)"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "bst", "import": "Node", "type": "internal", "type_element": "module"}, {"from_module": "bst", "import": "bst", "type": "internal", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 64}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 61}, "calls": ["bst.bst.bst", "depth_sum.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "bst"}, "source_code": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)"}, "test_depth_sum": {"args": ["self"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 64}, "calls": ["depth_sum.TestSuite.assertEqual", "depth_sum.depth_sum"], "source_code": "def test_depth_sum(self):\n    self.assertEqual(253, depth_sum(self.tree.root, 4))"}}}}, "functions": {"depth_sum": {"args": ["root", "n"], "returns": ["recur_depth_sum(root, 1)"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 25}, "calls": ["depth_sum.recur_depth_sum"], "source_code": "def depth_sum(root, n):\n    if root:\n        return recur_depth_sum(root, 1)"}, "recur_depth_sum": {"args": ["root", "n"], "returns": ["0", "root.data * n", "n * root.data + recur_depth_sum(root.left, n + 1) + recur_depth_sum(root.right, n + 1)"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 33}, "calls": ["depth_sum.recur_depth_sum"], "source_code": "def recur_depth_sum(root, n):\n    if root is None:\n        return 0\n    elif root.left is None and root.right is None:\n        return root.data * n\n    else:\n        return n * root.data + recur_depth_sum(root.left, n + 1) + recur_depth_sum(root.right, n + 1)"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "depth_sum.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/count_left_node.py", "fileNameBase": "count_left_node", "extension": "py", "doc": {"long_description": "tree. For example: the following tree has four left children (the nodes\nstoring the values 6, 3, 7, and 10):\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    count_left_node = 4", "short_description": "Write a function count_left_node returns the number of left children in the", "full": "Write a function count_left_node returns the number of left children in the\ntree. For example: the following tree has four left children (the nodes\nstoring the values 6, 3, 7, and 10):\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    count_left_node = 4"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "bst", "import": "Node", "type": "internal", "type_element": "module"}, {"from_module": "bst", "import": "bst", "type": "internal", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 59}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 56}, "calls": ["bst.bst.bst", "count_left_node.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "bst"}, "source_code": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)"}, "test_count_left_node": {"args": ["self"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 59}, "calls": ["count_left_node.TestSuite.assertEqual", "count_left_node.count_left_node"], "source_code": "def test_count_left_node(self):\n    self.assertEqual(4, count_left_node(self.tree.root))"}}}}, "functions": {"count_left_node": {"args": ["root"], "returns": ["0", "count_left_node(root.right)", "1 + count_left_node(root.left) + count_left_node(root.right)"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 28}, "calls": ["count_left_node.count_left_node"], "source_code": "def count_left_node(root):\n    if root is None:\n        return 0\n    elif root.left is None:\n        return count_left_node(root.right)\n    else:\n        return 1 + count_left_node(root.left) + count_left_node(root.right)"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "count_left_node.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/serialize_deserialize.py", "fileNameBase": "serialize_deserialize", "extension": "py"}, "classes": {"TreeNode": {"extend": ["object"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 8}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 8}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.left = None\n    self.right = None"}}}}, "functions": {"serialize": {"args": ["root"], "returns": ["' '.join(vals)"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 21}, "calls": ["serialize_deserialize.serialize.build_string"], "functions": {"build_string": {"args": ["node"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 18}, "calls": ["vals.append", "build_string", "str"], "source_code": "def build_string(node):\n    if node:\n        vals.append(str(node.val))\n        build_string(node.left)\n        build_string(node.right)\n    else:\n        vals.append('#')"}}, "source_code": "def serialize(root):\n\n    def build_string(node):\n        if node:\n            vals.append(str(node.val))\n            build_string(node.left)\n            build_string(node.right)\n        else:\n            vals.append('#')\n    vals = []\n    build_string(root)\n    return ' '.join(vals)"}, "deserialize": {"args": ["data"], "returns": ["build_tree()", "node", "None"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 34}, "calls": ["iter", "serialize_deserialize.deserialize.build_tree"], "store_vars_calls": {"vals": "iter", "val": "next", "node": "TreeNode", "node.left": "build_tree", "node.right": "build_tree"}, "functions": {"build_tree": {"returns": ["node", "None"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 32}, "calls": ["next", "build_tree", "int"], "store_vars_calls": {"val": "next", "node": "TreeNode", "node.left": "build_tree", "node.right": "build_tree"}, "source_code": "def build_tree():\n    val = next(vals)\n    if val == '#':\n        return None\n    node = TreeNode(int(val))\n    node.left = build_tree()\n    node.right = build_tree()\n    return node"}}, "source_code": "def deserialize(data):\n\n    def build_tree():\n        val = next(vals)\n        if val == '#':\n            return None\n        node = TreeNode(int(val))\n        node.left = build_tree()\n        node.right = build_tree()\n        return node\n    vals = iter(data.split())\n    return build_tree()"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/bst_closest_value.py", "fileNameBase": "bst_closest_value", "extension": "py"}, "functions": {"closest_value": {"args": ["root", "target"], "returns": ["min((a, b), key=lambda x: abs(target - x))", "a"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 29}, "calls": ["bst_closest_value.closest_value", "min", "abs"], "store_vars_calls": {"b": "closest_value"}, "source_code": "def closest_value(root, target):\n    \"\"\"\n    :type root: TreeNode\n    :type target: float\n    :rtype: int\n    \"\"\"\n    a = root.val\n    kid = root.left if target < a else root.right\n    if not kid:\n        return a\n    b = closest_value(kid, target)\n    return min((a, b), key=lambda x: abs(target - x))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/array_to_bst.py", "fileNameBase": "array_to_bst", "extension": "py", "doc": {"long_description": "convert it to a height balanced BST.", "short_description": "Given an array where elements are sorted in ascending order,", "full": "Given an array where elements are sorted in ascending order,\nconvert it to a height balanced BST."}}, "classes": {"TreeNode": {"extend": ["object"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 12}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 12}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.left = None\n    self.right = None"}}}}, "functions": {"array_to_bst": {"args": ["nums"], "returns": ["node", "None"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 22}, "calls": ["array_to_bst.array_to_bst", "len"], "store_vars_calls": {"node": "TreeNode", "node.left": "array_to_bst", "node.right": "array_to_bst"}, "source_code": "def array_to_bst(nums):\n    if not nums:\n        return None\n    mid = len(nums) // 2\n    node = TreeNode(nums[mid])\n    node.left = array_to_bst(nums[:mid])\n    node.right = array_to_bst(nums[mid + 1:])\n    return node"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/successor.py", "fileNameBase": "successor", "extension": "py"}, "functions": {"successor": {"args": ["root", "node"], "returns": ["succ"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 10}, "source_code": "def successor(root, node):\n    succ = None\n    while root:\n        if node.val < root.val:\n            succ = root\n            root = root.left\n        else:\n            root = root.right\n    return succ"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/delete_node.py", "fileNameBase": "delete_node", "extension": "py", "doc": {"long_description": "Basically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\nNote: Time complexity should be O(height of tree).\n\nExample:\n\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   /   3   6\n / \\   2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   /   4   6\n /     2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   /   2   6\n   \\       4   7", "short_description": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.", "full": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n\nBasically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\nNote: Time complexity should be O(height of tree).\n\nExample:\n\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   /   3   6\n / \\   2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   /   4   6\n /     2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   /   2   6\n   \\       4   7"}}, "classes": {"Solution": {"extend": ["object"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 67}, "methods": {"delete_node": {"args": ["self", "root", "key"], "returns": ["root", "None", "root.left", "root.right"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 67}, "calls": ["delete_node.Solution.deleteNode"], "store_vars_calls": {"root.left": "self.deleteNode", "root.right": "self.deleteNode"}, "source_code": "def delete_node(self, root, key):\n    \"\"\"\n        :type root: TreeNode\n        :type key: int\n        :rtype: TreeNode\n        \"\"\"\n    if not root:\n        return None\n    if root.val == key:\n        if root.left:\n            left_right_most = root.left\n            while left_right_most.right:\n                left_right_most = left_right_most.right\n            left_right_most.right = root.right\n            return root.left\n        else:\n            return root.right\n    elif root.val > key:\n        root.left = self.deleteNode(root.left, key)\n    else:\n        root.right = self.deleteNode(root.right, key)\n    return root"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/height.py", "fileNameBase": "height", "extension": "py", "doc": {"long_description": "be the number of levels. The empty tree has height 0, a tree of one node has\nheight 1, a root node with one or two leaves as children has height 2, and so on\nFor example: height of tree is 4\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    height = 4", "short_description": "Write a function height returns the height of a tree. The height is defined to", "full": "Write a function height returns the height of a tree. The height is defined to\nbe the number of levels. The empty tree has height 0, a tree of one node has\nheight 1, a root node with one or two leaves as children has height 2, and so on\nFor example: height of tree is 4\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    height = 4"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "bst", "import": "Node", "type": "internal", "type_element": "module"}, {"from_module": "bst", "import": "bst", "type": "internal", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 58}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 55}, "calls": ["bst.bst.bst", "height.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "bst"}, "source_code": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)"}, "test_height": {"args": ["self"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 58}, "calls": ["height.TestSuite.assertEqual", "height.height"], "source_code": "def test_height(self):\n    self.assertEqual(4, height(self.tree.root))"}}}}, "functions": {"height": {"args": ["root"], "returns": ["0", "1 + max(height(root.left), height(root.right))"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 27}, "calls": ["max", "height.height"], "source_code": "def height(root):\n    if root is None:\n        return 0\n    else:\n        return 1 + max(height(root.left), height(root.right))"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "height.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/is_bst.py", "fileNameBase": "is_bst", "extension": "py", "doc": {"long_description": "Assume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes\nwith keys less than the node's key.\nThe right subtree of a node contains only nodes\nwith keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\n    2\n   /   1   3\nBinary tree [2,1,3], return true.\nExample 2:\n    1\n   /   2   3\nBinary tree [1,2,3], return false.", "short_description": "Given a binary tree, determine if it is a valid binary search tree (BST).", "full": "Given a binary tree, determine if it is a valid binary search tree (BST).\n\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes\nwith keys less than the node's key.\nThe right subtree of a node contains only nodes\nwith keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\n    2\n   /   1   3\nBinary tree [2,1,3], return true.\nExample 2:\n    1\n   /   2   3\nBinary tree [1,2,3], return false."}}, "functions": {"is_bst": {"args": ["root"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 43}, "calls": ["stack.pop", "stack.append"], "store_vars_calls": {"root": "stack.pop"}, "source_code": "def is_bst(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    stack = []\n    pre = None\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if pre and root.val <= pre.val:\n            return False\n        pre = root\n        root = root.right\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/bst/lowest_common_ancestor.py", "fileNameBase": "lowest_common_ancestor", "extension": "py", "doc": {"long_description": "find the lowest common ancestor (LCA) of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two\n    nodes v and w as the lowest node in T that has both v and w\n    as descendants (where we allow a node to be a descendant of itself).\u201d\n\n        _______6______\n       /                  ___2__          ___8__\n   /      \\        /         0      _4       7       9\n         /           3   5\n\nFor example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6.\nAnother example is LCA of nodes 2 and 4 is 2,\nsince a node can be a descendant of itself according to the LCA definition.", "short_description": "Given a binary search tree (BST),", "full": "Given a binary search tree (BST),\nfind the lowest common ancestor (LCA) of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two\n    nodes v and w as the lowest node in T that has both v and w\n    as descendants (where we allow a node to be a descendant of itself).\u201d\n\n        _______6______\n       /                  ___2__          ___8__\n   /      \\        /         0      _4       7       9\n         /           3   5\n\nFor example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6.\nAnother example is LCA of nodes 2 and 4 is 2,\nsince a node can be a descendant of itself according to the LCA definition."}}, "functions": {"lowest_common_ancestor": {"args": ["root", "p", "q"], "returns": ["root"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 38}, "source_code": "def lowest_common_ancestor(root, p, q):\n    \"\"\"\n    :type root: Node\n    :type p: Node\n    :type q: Node\n    :rtype: Node\n    \"\"\"\n    while root:\n        if p.val > root.val < q.val:\n            root = root.right\n        elif p.val < root.val > q.val:\n            root = root.left\n        else:\n            return root"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/trie": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/trie/trie.py", "fileNameBase": "trie", "extension": "py", "doc": {"long_description": "Note:\nYou may assume that all inputs are consist of lowercase letters a-z.", "short_description": "Implement a trie with insert, search, and startsWith methods.", "full": "Implement a trie with insert, search, and startsWith methods.\n\nNote:\nYou may assume that all inputs are consist of lowercase letters a-z."}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "classes": {"TrieNode": {"min_max_lineno": {"min_lineno": 10, "max_lineno": 14}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 14}, "calls": ["collections.defaultdict"], "store_vars_calls": {"self.children": "collections.defaultdict"}, "source_code": "def __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False"}}}, "Trie": {"min_max_lineno": {"min_lineno": 16, "max_lineno": 41}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 19}, "store_vars_calls": {"self.root": "TrieNode"}, "source_code": "def __init__(self):\n    self.root = TrieNode()"}, "insert": {"args": ["self", "word"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 25}, "source_code": "def insert(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children[letter]\n    current.is_word = True"}, "search": {"args": ["self", "word"], "returns": ["current.is_word", "False"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 33}, "calls": ["current.children.get.children.get.children.get"], "store_vars_calls": {"current": "current.children.get"}, "source_code": "def search(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return current.is_word"}, "starts_with": {"args": ["self", "prefix"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 41}, "calls": ["current.children.get.children.get.children.get"], "store_vars_calls": {"current": "current.children.get"}, "source_code": "def starts_with(self, prefix):\n    current = self.root\n    for letter in prefix:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return True"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/trie/add_and_search.py", "fileNameBase": "add_and_search", "extension": "py", "doc": {"long_description": "that allows us to add and search for words.\nThe search can be a literal word or regular expression\ncontaining \u201c.\u201d, where \u201c.\u201d can be any letter.\n\nExample:\naddWord(\u201cbad\u201d)\naddWord(\u201cdad\u201d)\naddWord(\u201cmad\u201d)\nsearch(\u201cpad\u201d) -> false\nsearch(\u201cbad\u201d) -> true\nsearch(\u201c.ad\u201d) -> true\nsearch(\u201cb..\u201d) -> true", "short_description": "We are asked to design an efficient data structure", "full": "We are asked to design an efficient data structure\nthat allows us to add and search for words.\nThe search can be a literal word or regular expression\ncontaining \u201c.\u201d, where \u201c.\u201d can be any letter.\n\nExample:\naddWord(\u201cbad\u201d)\naddWord(\u201cdad\u201d)\naddWord(\u201cmad\u201d)\nsearch(\u201cpad\u201d) -> false\nsearch(\u201cbad\u201d) -> true\nsearch(\u201c.ad\u201d) -> true\nsearch(\u201cb..\u201d) -> true"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "classes": {"TrieNode": {"extend": ["object"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 23}, "methods": {"__init__": {"args": ["self", "letter", "is_terminal"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 23}, "calls": ["dict"], "store_vars_calls": {"self.children": "dict"}, "source_code": "def __init__(self, letter, is_terminal=False):\n    self.children = dict()\n    self.letter = letter\n    self.is_terminal = is_terminal"}}}, "WordDictionary": {"extend": ["object"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 57}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 27}, "store_vars_calls": {"self.root": "TrieNode"}, "source_code": "def __init__(self):\n    self.root = TrieNode('')"}, "add_word": {"args": ["self", "word"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 35}, "source_code": "def add_word(self, word):\n    cur = self.root\n    for letter in word:\n        if letter not in cur.children:\n            cur.children[letter] = TrieNode(letter)\n        cur = cur.children[letter]\n    cur.is_terminal = True"}, "search": {"args": ["self", "word", "node"], "returns": ["cur.is_terminal", "False", "False", "False", "True", "True"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 57}, "calls": ["enumerate", "cur.children.itervalues", "len", "add_and_search.WordDictionary.search"], "source_code": "def search(self, word, node=None):\n    cur = node\n    if not cur:\n        cur = self.root\n    for (i, letter) in enumerate(word):\n        if letter == '.':\n            if i == len(word) - 1:\n                for child in cur.children.itervalues():\n                    if child.is_terminal:\n                        return True\n                return False\n            for child in cur.children.itervalues():\n                if self.search(word[i + 1:], child) == True:\n                    return True\n            return False\n        if letter not in cur.children:\n            return False\n        cur = cur.children[letter]\n    return cur.is_terminal"}}}, "WordDictionary2": {"extend": ["object"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 80}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 61}, "calls": ["collections.defaultdict"], "store_vars_calls": {"self.word_dict": "collections.defaultdict"}, "source_code": "def __init__(self):\n    self.word_dict = collections.defaultdict(list)"}, "add_word": {"args": ["self", "word"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 66}, "calls": ["add_and_search.WordDictionary2.word_dict[].append", "len"], "source_code": "def add_word(self, word):\n    if word:\n        self.word_dict[len(word)].append(word)"}, "search": {"args": ["self", "word"], "returns": ["False", "False", "word in self.word_dict[len(word)]", "True"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 80}, "calls": ["len", "enumerate"], "source_code": "def search(self, word):\n    if not word:\n        return False\n    if '.' not in word:\n        return word in self.word_dict[len(word)]\n    for v in self.word_dict[len(word)]:\n        for (i, ch) in enumerate(word):\n            if ch != v[i] and ch != '.':\n                break\n        else:\n            return True\n    return False"}}}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/avl": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/avl/avl.py", "fileNameBase": "avl", "extension": "py", "doc": {"short_description": "Imports TreeNodes", "full": "Imports TreeNodes"}}, "dependencies": [{"from_module": "tree.tree", "import": "TreeNode", "type": "external", "type_element": "module"}], "classes": {"AvlTree": {"doc": {"short_description": "An avl tree.", "full": "An avl tree."}, "extend": ["object"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 127}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 15}, "source_code": "def __init__(self):\n    self.node = None\n    self.height = -1\n    self.balance = 0"}, "insert": {"doc": {"short_description": "Insert new key into node"}, "args": ["self", "key"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 31}, "calls": ["tree.tree.TreeNode", "avl.AvlTree.re_balance", "avl.AvlTree", "avl.AvlTree.node.left.insert", "avl.AvlTree.node.right.insert"], "store_vars_calls": {"node": "TreeNode", "self.node.left": "AvlTree", "self.node.right": "AvlTree"}, "source_code": "def insert(self, key):\n    \"\"\"\n        Insert new key into node\n        \"\"\"\n    node = TreeNode(key)\n    if not self.node:\n        self.node = node\n        self.node.left = AvlTree()\n        self.node.right = AvlTree()\n    elif key < self.node.val:\n        self.node.left.insert(key)\n    elif key > self.node.val:\n        self.node.right.insert(key)\n    self.re_balance()"}, "re_balance": {"doc": {"short_description": "Re balance tree. After inserting or deleting a node,"}, "args": ["self"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 57}, "calls": ["avl.AvlTree.update_heights", "avl.AvlTree.update_balances", "avl.AvlTree.rotate_right", "avl.AvlTree.rotate_left", "avl.AvlTree.node.left.rotate_left", "avl.AvlTree.node.right.rotate_right"], "source_code": "def re_balance(self):\n    \"\"\"\n        Re balance tree. After inserting or deleting a node,\n        \"\"\"\n    self.update_heights(recursive=False)\n    self.update_balances(False)\n    while self.balance < -1 or self.balance > 1:\n        if self.balance > 1:\n            if self.node.left.balance < 0:\n                self.node.left.rotate_left()\n                self.update_heights()\n                self.update_balances()\n            self.rotate_right()\n            self.update_heights()\n            self.update_balances()\n        if self.balance < -1:\n            if self.node.right.balance > 0:\n                self.node.right.rotate_right()\n                self.update_heights()\n                self.update_balances()\n            self.rotate_left()\n            self.update_heights()\n            self.update_balances()"}, "update_heights": {"doc": {"short_description": "Update tree height"}, "args": ["self", "recursive"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 73}, "calls": ["max", "avl.AvlTree.node.left.update_heights", "avl.AvlTree.node.right.update_heights"], "source_code": "def update_heights(self, recursive=True):\n    \"\"\"\n        Update tree height\n        \"\"\"\n    if self.node:\n        if recursive:\n            if self.node.left:\n                self.node.left.update_heights()\n            if self.node.right:\n                self.node.right.update_heights()\n        self.height = 1 + max(self.node.left.height, self.node.right.height)\n    else:\n        self.height = -1"}, "update_balances": {"doc": {"short_description": "Calculate tree balance factor"}, "args": ["self", "recursive"], "min_max_lineno": {"min_lineno": 74, "max_lineno": 89}, "calls": ["avl.AvlTree.node.left.update_balances", "avl.AvlTree.node.right.update_balances"], "source_code": "def update_balances(self, recursive=True):\n    \"\"\"\n        Calculate tree balance factor\n\n        \"\"\"\n    if self.node:\n        if recursive:\n            if self.node.left:\n                self.node.left.update_balances()\n            if self.node.right:\n                self.node.right.update_balances()\n        self.balance = self.node.left.height - self.node.right.height\n    else:\n        self.balance = 0"}, "rotate_right": {"doc": {"short_description": "Right rotation"}, "args": ["self"], "min_max_lineno": {"min_lineno": 90, "max_lineno": 101}, "source_code": "def rotate_right(self):\n    \"\"\"\n        Right rotation\n        \"\"\"\n    new_root = self.node.left.node\n    new_left_sub = new_root.right.node\n    old_root = self.node\n    self.node = new_root\n    old_root.left.node = new_left_sub\n    new_root.right.node = old_root"}, "rotate_left": {"doc": {"short_description": "Left rotation"}, "args": ["self"], "min_max_lineno": {"min_lineno": 102, "max_lineno": 113}, "source_code": "def rotate_left(self):\n    \"\"\"\n        Left rotation\n        \"\"\"\n    new_root = self.node.right.node\n    new_left_sub = new_root.left.node\n    old_root = self.node\n    self.node = new_root\n    old_root.right.node = new_left_sub\n    new_root.left.node = old_root"}, "in_order_traverse": {"doc": {"short_description": "In-order traversal of the tree"}, "args": ["self"], "returns": ["result", "result"], "min_max_lineno": {"min_lineno": 114, "max_lineno": 127}, "calls": ["result.extend", "result.append", "avl.AvlTree.node.left.in_order_traverse", "avl.AvlTree.node.right.in_order_traverse"], "source_code": "def in_order_traverse(self):\n    \"\"\"\n        In-order traversal of the tree\n        \"\"\"\n    result = []\n    if not self.node:\n        return result\n    result.extend(self.node.left.in_order_traverse())\n    result.append(self.node.key)\n    result.extend(self.node.right.in_order_traverse())\n    return result"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/avl/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/traversal": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/traversal/inorder.py", "fileNameBase": "inorder", "extension": "py", "doc": {"short_description": "Time complexity : O(n)", "full": "Time complexity : O(n)"}}, "classes": {"Node": {"min_max_lineno": {"min_lineno": 6, "max_lineno": 12}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 12}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}}, "functions": {"inorder": {"doc": {"short_description": "In order function "}, "args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 28}, "calls": ["stack.pop", "res.append", "stack.append"], "store_vars_calls": {"root": "stack.pop"}, "source_code": "def inorder(root):\n    \"\"\" In order function \"\"\"\n    res = []\n    if not root:\n        return res\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        res.append(root.val)\n        root = root.right\n    return res"}, "inorder_rec": {"doc": {"short_description": "Recursive Implementation "}, "args": ["root", "res"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 39}, "calls": ["inorder.inorder_rec", "res.append"], "source_code": "def inorder_rec(root, res=None):\n    \"\"\" Recursive Implementation \"\"\"\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    inorder_rec(root.left, res)\n    res.append(root.val)\n    inorder_rec(root.right, res)\n    return res"}}, "body": {"calls": ["inorder.Node", "inorder.inorder", "inorder.inorder_rec"], "store_vars_calls": {"n1": "Node", "n2": "Node", "n3": "Node", "n4": "Node", "n5": "Node", "n6": "Node", "n7": "Node"}, "source_code": ["Node(100)", "Node(50)", "Node(150)", "Node(25)", "Node(75)", "Node(125)", "Node(175)", "inorder(n1)", "inorder_rec(n1)"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/traversal/postorder.py", "fileNameBase": "postorder", "extension": "py", "doc": {"short_description": "Time complexity : O(n)", "full": "Time complexity : O(n)"}}, "classes": {"Node": {"min_max_lineno": {"min_lineno": 5, "max_lineno": 11}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 11}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}}, "functions": {"postorder": {"args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 30}, "calls": ["stack.append", "stack.pop", "res_temp.append", "res.append", "res_temp.pop"], "store_vars_calls": {"root": "stack.pop"}, "source_code": "def postorder(root):\n    res_temp = []\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res_temp.append(root.val)\n        if root.left:\n            stack.append(root.left)\n        if root.right:\n            stack.append(root.right)\n    while res_temp:\n        res.append(res_temp.pop())\n    return res"}, "postorder_rec": {"args": ["root", "res"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 41}, "calls": ["postorder.postorder_rec", "res.append"], "source_code": "def postorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    postorder_rec(root.left, res)\n    postorder_rec(root.right, res)\n    res.append(root.val)\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/traversal/zigzag.py", "fileNameBase": "zigzag", "extension": "py", "doc": {"long_description": "of its nodes' values.\n(ie, from left to right, then right to left\nfor the next level and alternate between).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   /   9  20\n    /     15   7\nreturn its zigzag level order traversal as:\n[\n  [3],\n  [20,9],\n  [15,7]\n]", "short_description": "Given a binary tree, return the zigzag level order traversal", "full": "Given a binary tree, return the zigzag level order traversal\nof its nodes' values.\n(ie, from left to right, then right to left\nfor the next level and alternate between).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   /   9  20\n    /     15   7\nreturn its zigzag level order traversal as:\n[\n  [3],\n  [20,9],\n  [15,7]\n]"}}, "functions": {"zigzag_level": {"args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 42}, "calls": ["res.append", "current.append", "new_level.append"], "source_code": "def zigzag_level(root):\n    res = []\n    if not root:\n        return res\n    level = [root]\n    flag = 1\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        res.append(current[::flag])\n        flag *= -1\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/traversal/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "preorder", "import": "preorder", "type": "internal", "type_element": "function"}, {"from_module": "preorder", "import": "preorder_rec", "type": "internal", "type_element": "function"}, {"from_module": "preorder", "import": "Node", "type": "internal", "type_element": "class"}, {"from_module": "postorder", "import": "postorder", "type": "internal", "type_element": "function"}, {"from_module": "postorder", "import": "postorder_rec", "type": "internal", "type_element": "function"}, {"from_module": "postorder", "import": "Node", "type": "internal", "type_element": "class"}, {"from_module": "inorder", "import": "inorder", "type": "internal", "type_element": "function"}, {"from_module": "inorder", "import": "inorder_rec", "type": "internal", "type_element": "function"}, {"from_module": "inorder", "import": "Node", "type": "internal", "type_element": "class"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/traversal/preorder.py", "fileNameBase": "preorder", "extension": "py", "doc": {"short_description": "Time complexity : O(n)", "full": "Time complexity : O(n)"}}, "classes": {"Node": {"doc": {"short_description": "This is a class of Node ", "full": "This is a class of Node "}, "min_max_lineno": {"min_lineno": 6, "max_lineno": 13}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 13}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}}, "functions": {"preorder": {"doc": {"short_description": "Function to Preorder "}, "args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 30}, "calls": ["stack.append", "stack.pop", "res.append"], "store_vars_calls": {"root": "stack.pop"}, "source_code": "def preorder(root):\n    \"\"\" Function to Preorder \"\"\"\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res.append(root.val)\n        if root.right:\n            stack.append(root.right)\n        if root.left:\n            stack.append(root.left)\n    return res"}, "preorder_rec": {"doc": {"short_description": "Recursive Implementation "}, "args": ["root", "res"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 41}, "calls": ["res.append", "preorder.preorder_rec"], "source_code": "def preorder_rec(root, res=None):\n    \"\"\" Recursive Implementation \"\"\"\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    res.append(root.val)\n    preorder_rec(root.left, res)\n    preorder_rec(root.right, res)\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/traversal/level_order.py", "fileNameBase": "level_order", "extension": "py", "doc": {"long_description": "its nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   /   9  20\n    /     15   7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]", "short_description": "Given a binary tree, return the level order traversal of", "full": "Given a binary tree, return the level order traversal of\nits nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   /   9  20\n    /     15   7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]"}}, "functions": {"level_order": {"args": ["root"], "returns": ["ans", "ans"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 38}, "calls": ["ans.append", "current.append", "new_level.append"], "source_code": "def level_order(root):\n    ans = []\n    if not root:\n        return ans\n    level = [root]\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        ans.append(current)\n    return ans"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/fenwick_tree": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/fenwick_tree/fenwick_tree.py", "fileNameBase": "fenwick_tree", "extension": "py", "doc": {"long_description": "Consider we have an array arr[0 . . . n-1]. We would like to\n1. Compute the sum of the first i elements.\n2. Modify the value of a specified element of the array arr[i] = x where 0 <= i <= n-1.\n\nA simple solution is to run a loop from 0 to i-1 and calculate the sum of the elements. To update a value, simply do arr[i] = x.\nThe first operation takes O(n) time and the second operation takes O(1) time.\nAnother simple solution is to create an extra array and store the sum of the first i-th elements at the i-th index in this new array.\nThe sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now.\nThis works well if there are a large number of query operations but a very few number of update operations.\n\n\nThere are two solutions that can perform both the query and update operations in O(logn) time.\n1. Fenwick Tree\n2. Segment Tree\n\nCompared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement.", "short_description": "Fenwick Tree / Binary Indexed Tree", "full": "Fenwick Tree / Binary Indexed Tree\n\nConsider we have an array arr[0 . . . n-1]. We would like to\n1. Compute the sum of the first i elements.\n2. Modify the value of a specified element of the array arr[i] = x where 0 <= i <= n-1.\n\nA simple solution is to run a loop from 0 to i-1 and calculate the sum of the elements. To update a value, simply do arr[i] = x.\nThe first operation takes O(n) time and the second operation takes O(1) time.\nAnother simple solution is to create an extra array and store the sum of the first i-th elements at the i-th index in this new array.\nThe sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now.\nThis works well if there are a large number of query operations but a very few number of update operations.\n\n\nThere are two solutions that can perform both the query and update operations in O(logn) time.\n1. Fenwick Tree\n2. Segment Tree\n\nCompared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement."}}, "classes": {"Fenwick_Tree": {"extend": ["object"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 78}, "methods": {"__init__": {"args": ["self", "freq"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 26}, "calls": ["len"], "store_vars_calls": {"self.n": "len"}, "source_code": "def __init__(self, freq):\n    self.arr = freq\n    self.n = len(freq)"}, "get_sum": {"doc": {"short_description": "Returns sum of arr[0..index]. This function assumes that the array is preprocessed and partial sums of array elements are stored in bit_tree[]. "}, "args": ["self", "bit_tree", "i"], "returns": ["s"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 46}, "source_code": "def get_sum(self, bit_tree, i):\n    \"\"\"\n             Returns sum of arr[0..index]. This function assumes that the array is preprocessed and partial sums of array elements are stored in bit_tree[]. \n        \"\"\"\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += bit_tree[i]\n        i -= i & -i\n    return s"}, "update_bit": {"doc": {"short_description": "Updates a node in Binary Index Tree (bit_tree) at given index in bit_tree. The given value 'val' is added to bit_tree[i] and all of its ancestors in tree. "}, "args": ["self", "bit_tree", "i", "v"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 63}, "source_code": "def update_bit(self, bit_tree, i, v):\n    \"\"\"\n             Updates a node in Binary Index Tree (bit_tree) at given index in bit_tree. The given value 'val' is added to bit_tree[i] and all of its ancestors in tree. \n        \"\"\"\n    i += 1\n    while i <= self.n:\n        bit_tree[i] += v\n        i += i & -i"}, "construct": {"doc": {"short_description": "Constructs and returns a Binary Indexed Tree for given array of size n. "}, "args": ["self"], "returns": ["bit_tree"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 78}, "calls": ["range", "fenwick_tree.Fenwick_Tree.update_bit"], "source_code": "def construct(self):\n    \"\"\"\n             Constructs and returns a Binary Indexed Tree for given array of size n. \n        \"\"\"\n    bit_tree = [0] * (self.n + 1)\n    for i in range(self.n):\n        self.update_bit(bit_tree, i, self.arr[i])\n    return bit_tree"}}}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/segment_tree": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/segment_tree/segment_tree.py", "fileNameBase": "segment_tree", "extension": "py", "doc": {"long_description": "allowing queries to be done later in log(N) time\nfunction takes 2 values and returns a same type value", "short_description": "Segment_tree creates a segment tree with a given array and function,", "full": "Segment_tree creates a segment tree with a given array and function,\nallowing queries to be done later in log(N) time\nfunction takes 2 values and returns a same type value"}}, "classes": {"SegmentTree": {"min_max_lineno": {"min_lineno": 6, "max_lineno": 38}, "methods": {"__init__": {"args": ["self", "arr", "function"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 12}, "calls": ["segment_tree.SegmentTree.make_tree", "range", "len"], "source_code": "def __init__(self, arr, function):\n    self.segment = [0 for x in range(3 * len(arr) + 3)]\n    self.arr = arr\n    self.fn = function\n    self.make_tree(0, 0, len(arr) - 1)"}, "make_tree": {"args": ["self", "i", "l", "r"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 20}, "calls": ["segment_tree.SegmentTree.make_tree", "segment_tree.SegmentTree.fn", "int"], "source_code": "def make_tree(self, i, l, r):\n    if l == r:\n        self.segment[i] = self.arr[l]\n    elif l < r:\n        self.make_tree(2 * i + 1, l, int((l + r) / 2))\n        self.make_tree(2 * i + 2, int((l + r) / 2) + 1, r)\n        self.segment[i] = self.fn(self.segment[2 * i + 1], self.segment[2 * i + 2])"}, "__query": {"args": ["self", "i", "L", "R", "l", "r"], "returns": ["val2", "None", "self.segment[i]", "val1", "self.fn(val1, val2)"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 34}, "calls": ["segment_tree.SegmentTree.__query", "print", "int", "segment_tree.SegmentTree.fn"], "store_vars_calls": {"val1": "self.__query", "val2": "self.__query"}, "source_code": "def __query(self, i, L, R, l, r):\n    if l > R or r < L or L > R or (l > r):\n        return None\n    if L >= l and R <= r:\n        return self.segment[i]\n    val1 = self.__query(2 * i + 1, L, int((L + R) / 2), l, r)\n    val2 = self.__query(2 * i + 2, int((L + R + 2) / 2), R, l, r)\n    print(L, R, ' returned ', val1, val2)\n    if val1 != None:\n        if val2 != None:\n            return self.fn(val1, val2)\n        return val1\n    return val2"}, "query": {"args": ["self", "L", "R"], "returns": ["self.__query(0, 0, len(self.arr) - 1, L, R)"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 38}, "calls": ["segment_tree.SegmentTree.__query", "len"], "source_code": "def query(self, L, R):\n    return self.__query(0, 0, len(self.arr) - 1, L, R)"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/tree/segment_tree/iterative_segment_tree.py", "fileNameBase": "iterative_segment_tree", "extension": "py", "doc": {"long_description": "this non-recursive version uses less memory than the recursive version and include:\n1. range queries in log(N) time\n2. update an element in log(N) time\nthe function should be commutative and takes 2 values and returns the same type value\n\nExamples -\nmytree = SegmentTree([2, 4, 5, 3, 4],max)\nprint(mytree.query(2, 4))\nmytree.update(3, 6)\nprint(mytree.query(0, 3)) ...\n\nmytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b)\nprint(mytree.query(0, 6))\nmytree.update(2, -10)\nprint(mytree.query(0, 6)) ...\n\nmytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))\nmytree.update(2, (-1, 2))\nprint(mytree.query(0, 2)) ...", "short_description": "SegmentTree creates a segment tree with a given array and a \"commutative\" function,", "full": "SegmentTree creates a segment tree with a given array and a \"commutative\" function,\nthis non-recursive version uses less memory than the recursive version and include:\n1. range queries in log(N) time\n2. update an element in log(N) time\nthe function should be commutative and takes 2 values and returns the same type value\n\nExamples -\nmytree = SegmentTree([2, 4, 5, 3, 4],max)\nprint(mytree.query(2, 4))\nmytree.update(3, 6)\nprint(mytree.query(0, 3)) ...\n\nmytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b)\nprint(mytree.query(0, 6))\nmytree.update(2, -10)\nprint(mytree.query(0, 6)) ...\n\nmytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))\nmytree.update(2, (-1, 2))\nprint(mytree.query(0, 2)) ..."}}, "classes": {"SegmentTree": {"min_max_lineno": {"min_lineno": 26, "max_lineno": 54}, "methods": {"__init__": {"args": ["self", "arr", "function"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 32}, "calls": ["len", "iterative_segment_tree.SegmentTree.build_tree", "range"], "store_vars_calls": {"self.size": "len"}, "source_code": "def __init__(self, arr, function):\n    self.tree = [None for _ in range(len(arr))] + arr\n    self.size = len(arr)\n    self.fn = function\n    self.build_tree()"}, "build_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 36}, "calls": ["range", "iterative_segment_tree.SegmentTree.fn"], "source_code": "def build_tree(self):\n    for i in range(self.size - 1, 0, -1):\n        self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])"}, "update": {"args": ["self", "p", "v"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 43}, "calls": ["iterative_segment_tree.SegmentTree.fn"], "source_code": "def update(self, p, v):\n    p += self.size\n    self.tree[p] = v\n    while p > 1:\n        p = p // 2\n        self.tree[p] = self.fn(self.tree[p * 2], self.tree[p * 2 + 1])"}, "query": {"args": ["self", "l", "r"], "returns": ["res"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 54}, "calls": ["iterative_segment_tree.SegmentTree.fn"], "source_code": "def query(self, l, r):\n    (l, r) = (l + self.size, r + self.size)\n    res = None\n    while l <= r:\n        if l % 2 == 1:\n            res = self.tree[l] if res is None else self.fn(res, self.tree[l])\n        if r % 2 == 0:\n            res = self.tree[r] if res is None else self.fn(res, self.tree[r])\n        (l, r) = ((l + 1) // 2, (r - 1) // 2)\n    return res"}}}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/stack": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/remove_min.py", "fileNameBase": "remove_min", "extension": "py", "doc": {"long_description": "and removes the smallest value from the stack.\n\nFor example:\nbottom [2, 8, 3, -6, 7, 3] top\nAfter remove_min(stack):\nbottom [2, 8, 3, 7, 3] top", "short_description": "Given a stack, a function remove_min accepts a stack as a parameter", "full": "Given a stack, a function remove_min accepts a stack as a parameter\nand removes the smallest value from the stack.\n\nFor example:\nbottom [2, 8, 3, -6, 7, 3] top\nAfter remove_min(stack):\nbottom [2, 8, 3, 7, 3] top"}}, "functions": {"remove_min": {"args": ["stack"], "returns": ["stack", "stack"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 31}, "calls": ["stack.pop", "stack.append", "range", "len", "storage_stack.append", "storage_stack.pop"], "store_vars_calls": {"min": "stack.pop", "val": "storage_stack.pop"}, "source_code": "def remove_min(stack):\n    storage_stack = []\n    if len(stack) == 0:\n        return stack\n    min = stack.pop()\n    stack.append(min)\n    for i in range(len(stack)):\n        val = stack.pop()\n        if val <= min:\n            min = val\n        storage_stack.append(val)\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        if val != min:\n            stack.append(val)\n    return stack"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/valid_parenthesis.py", "fileNameBase": "valid_parenthesis", "extension": "py", "doc": {"long_description": "'(', ')', '{', '}', '[' and ']',\ndetermine if the input string is valid.\n\nThe brackets must close in the correct order,\n\"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.", "short_description": "Given a string containing just the characters", "full": "Given a string containing just the characters\n'(', ')', '{', '}', '[' and ']',\ndetermine if the input string is valid.\n\nThe brackets must close in the correct order,\n\"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not."}}, "functions": {"is_valid": {"args": ["s"], "annotated_arg_types": {"s": "str"}, "annotated_return_type": "bool", "returns": ["not stack", "False"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 23}, "calls": ["dic.values", "stack.append", "stack.pop"], "source_code": "def is_valid(s: str) -> bool:\n    stack = []\n    dic = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in dic.values():\n            stack.append(char)\n        elif char in dic:\n            if not stack or dic[char] != stack.pop():\n                return False\n    return not stack"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/simplify_path.py", "fileNameBase": "simplify_path", "extension": "py", "doc": {"long_description": "For example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\n* Did you consider the case where path = \"/../\"?\n    In this case, you should return \"/\".\n* Another corner case is the path might contain multiple slashes '/' together,\n    such as \"/home//foo/\". In this case, you should ignore redundant\n    slashes and return \"/home/foo\".", "short_description": "Given an absolute path for a file (Unix-style), simplify it.", "full": "Given an absolute path for a file (Unix-style), simplify it.\n\nFor example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\n* Did you consider the case where path = \"/../\"?\n    In this case, you should return \"/\".\n* Another corner case is the path might contain multiple slashes '/' together,\n    such as \"/home//foo/\". In this case, you should ignore redundant\n    slashes and return \"/home/foo\"."}}, "functions": {"simplify_path": {"args": ["path"], "returns": ["'/' + '/'.join(stack)"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 29}, "calls": ["path.split", "stack.pop", "stack.append"], "store_vars_calls": {"paths": "path.split"}, "source_code": "def simplify_path(path):\n    \"\"\"\n    :type path: str\n    :rtype: str\n    \"\"\"\n    skip = {'..', '.', ''}\n    stack = []\n    paths = path.split('/')\n    for tok in paths:\n        if tok == '..':\n            if stack:\n                stack.pop()\n        elif tok not in skip:\n            stack.append(tok)\n    return '/' + '/'.join(stack)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/stutter.py", "fileNameBase": "stutter", "extension": "py", "doc": {"long_description": "in the stack with two occurrences of that value.\n\nFor example, suppose the stack stores these values:\nbottom [3, 7, 1, 14, 9] top\nThen the stack should store these values after the method terminates:\nbottom [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] top\n\nNote: There are 2 solutions:\nfirst_stutter: it uses a single stack as auxiliary storage\nsecond_stutter: it uses a single queue as auxiliary storage", "short_description": "Given a stack, stutter takes a stack as a parameter and  replaces every value", "full": "Given a stack, stutter takes a stack as a parameter and  replaces every value\nin the stack with two occurrences of that value.\n\nFor example, suppose the stack stores these values:\nbottom [3, 7, 1, 14, 9] top\nThen the stack should store these values after the method terminates:\nbottom [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] top\n\nNote: There are 2 solutions:\nfirst_stutter: it uses a single stack as auxiliary storage\nsecond_stutter: it uses a single queue as auxiliary storage"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"first_stutter": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 27}, "calls": ["range", "len", "storage_stack.append", "storage_stack.pop", "stack.append", "stack.pop"], "store_vars_calls": {"val": "storage_stack.pop"}, "source_code": "def first_stutter(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        stack.append(val)\n        stack.append(val)\n    return stack"}, "second_stutter": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 47}, "calls": ["collections.deque", "range", "len", "collections.deque.append", "stack.append", "collections.deque.pop", "stack.pop"], "store_vars_calls": {"q": "collections.deque", "val": "q.pop"}, "source_code": "def second_stutter(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        val = q.pop()\n        stack.append(val)\n        stack.append(val)\n    return stack"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/switch_pairs.py", "fileNameBase": "switch_pairs", "extension": "py", "doc": {"long_description": "switches successive pairs of numbers starting at the bottom of the stack.\n\nFor example, if the stack initially stores these values:\nbottom [3, 8, 17, 9, 1, 10] top\nYour function should switch the first pair (3, 8),\nthe second pair (17, 9), ...:\nbottom [8, 3, 9, 17, 10, 1] top\n\nif there are an odd number of values in the stack, the value at the top of the\nstack is not moved: For example:\nbottom [3, 8, 17, 9, 1] top\nIt would again switch pairs of values, but the value at the\ntop of the stack (1)\nwould not be moved\nbottom [8, 3, 9, 17, 1] top\n\nNote: There are 2 solutions:\nfirst_switch_pairs: it uses a single stack as auxiliary storage\nsecond_switch_pairs: it uses a single queue as auxiliary storage", "short_description": "Given a stack, switch_pairs function takes a stack as a parameter and that", "full": "Given a stack, switch_pairs function takes a stack as a parameter and that\nswitches successive pairs of numbers starting at the bottom of the stack.\n\nFor example, if the stack initially stores these values:\nbottom [3, 8, 17, 9, 1, 10] top\nYour function should switch the first pair (3, 8),\nthe second pair (17, 9), ...:\nbottom [8, 3, 9, 17, 10, 1] top\n\nif there are an odd number of values in the stack, the value at the top of the\nstack is not moved: For example:\nbottom [3, 8, 17, 9, 1] top\nIt would again switch pairs of values, but the value at the\ntop of the stack (1)\nwould not be moved\nbottom [8, 3, 9, 17, 1] top\n\nNote: There are 2 solutions:\nfirst_switch_pairs: it uses a single stack as auxiliary storage\nsecond_switch_pairs: it uses a single queue as auxiliary storage"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"first_switch_pairs": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 41}, "calls": ["range", "len", "storage_stack.append", "storage_stack.pop", "stack.append", "stack.pop"], "store_vars_calls": {"first": "storage_stack.pop", "second": "storage_stack.pop"}, "source_code": "def first_switch_pairs(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        if len(storage_stack) == 0:\n            break\n        first = storage_stack.pop()\n        if len(storage_stack) == 0:\n            stack.append(first)\n            break\n        second = storage_stack.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack"}, "second_switch_pairs": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 67}, "calls": ["collections.deque", "range", "len", "collections.deque.append", "stack.append", "collections.deque.pop", "stack.pop"], "store_vars_calls": {"q": "collections.deque", "first": "q.pop", "second": "q.pop"}, "source_code": "def second_switch_pairs(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        if len(q) == 0:\n            break\n        first = q.pop()\n        if len(q) == 0:\n            stack.append(first)\n            break\n        second = q.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "stack", "import": "AbstractStack", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "ArrayStack", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "StackNode", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "LinkedListStack", "type": "internal", "type_element": "class"}, {"from_module": "is_consecutive", "import": "first_is_consecutive", "type": "internal", "type_element": "function"}, {"from_module": "is_consecutive", "import": "second_is_consecutive", "type": "internal", "type_element": "function"}, {"from_module": "is_sorted", "import": "is_sorted", "type": "internal", "type_element": "function"}, {"from_module": "remove_min", "import": "remove_min", "type": "internal", "type_element": "function"}, {"from_module": "stutter", "import": "first_stutter", "type": "internal", "type_element": "function"}, {"from_module": "stutter", "import": "second_stutter", "type": "internal", "type_element": "function"}, {"from_module": "switch_pairs", "import": "first_switch_pairs", "type": "internal", "type_element": "function"}, {"from_module": "switch_pairs", "import": "second_switch_pairs", "type": "internal", "type_element": "function"}, {"from_module": "valid_parenthesis", "import": "is_valid", "type": "internal", "type_element": "function"}, {"from_module": "simplify_path", "import": "simplify_path", "type": "internal", "type_element": "function"}, {"from_module": "stack", "import": "AbstractStack", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "ArrayStack", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "StackNode", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "LinkedListStack", "type": "internal", "type_element": "class"}, {"from_module": "ordered_stack", "import": "OrderedStack", "type": "internal", "type_element": "class"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/ordered_stack.py", "fileNameBase": "ordered_stack", "extension": "py"}, "classes": {"OrderedStack": {"min_max_lineno": {"min_lineno": 5, "max_lineno": 37}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 8}, "source_code": "def __init__(self):\n    self.items = []"}, "is_empty": {"args": ["self"], "returns": ["self.items == []"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 11}, "source_code": "def is_empty(self):\n    return self.items == []"}, "push_t": {"args": ["self", "item"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 14}, "calls": ["ordered_stack.OrderedStack.items.append"], "source_code": "def push_t(self, item):\n    self.items.append(item)"}, "push": {"args": ["self", "item"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 26}, "calls": ["ordered_stack.OrderedStack.is_empty", "ordered_stack.OrderedStack.push_t", "ordered_stack.OrderedStack.peek", "ordered_stack.OrderedStack.push_t", "ordered_stack.OrderedStack.is_empty", "ordered_stack.OrderedStack.pop", "ordered_stack.OrderedStack.pop"], "store_vars_calls": {"temp_stack": "OrderedStack"}, "source_code": "def push(self, item):\n    temp_stack = OrderedStack()\n    if self.is_empty() or item > self.peek():\n        self.push_t(item)\n    else:\n        while item < self.peek() and (not self.is_empty()):\n            temp_stack.push_t(self.pop())\n        self.push_t(item)\n        while not temp_stack.is_empty():\n            self.push_t(temp_stack.pop())"}, "pop": {"args": ["self"], "returns": ["self.items.pop()"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 31}, "calls": ["ordered_stack.OrderedStack.is_empty", "ordered_stack.OrderedStack.items.pop", "IndexError"], "source_code": "def pop(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    return self.items.pop()"}, "peek": {"args": ["self"], "returns": ["self.items[len(self.items) - 1]"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 34}, "calls": ["len"], "source_code": "def peek(self):\n    return self.items[len(self.items) - 1]"}, "size": {"args": ["self"], "returns": ["len(self.items)"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 37}, "calls": ["len"], "source_code": "def size(self):\n    return len(self.items)"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/is_sorted.py", "fileNameBase": "is_sorted", "extension": "py", "doc": {"long_description": "true if the elements in the stack occur in ascending increasing order from\nbottom, and false otherwise. That is, the smallest element should be at bottom\n\nFor example:\nbottom [6, 3, 5, 1, 2, 4] top\nThe function should return false\nbottom [1, 2, 3, 4, 5, 6] top\nThe function should return true", "short_description": "Given a stack, a function is_sorted accepts a stack as a parameter and returns", "full": "Given a stack, a function is_sorted accepts a stack as a parameter and returns\ntrue if the elements in the stack occur in ascending increasing order from\nbottom, and false otherwise. That is, the smallest element should be at bottom\n\nFor example:\nbottom [6, 3, 5, 1, 2, 4] top\nThe function should return false\nbottom [1, 2, 3, 4, 5, 6] top\nThe function should return true"}}, "functions": {"is_sorted": {"args": ["stack"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 33}, "calls": ["range", "len", "stack.pop", "storage_stack.append", "stack.append", "storage_stack.pop"], "store_vars_calls": {"first_val": "stack.pop", "second_val": "stack.pop"}, "source_code": "def is_sorted(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        if len(stack) == 0:\n            break\n        first_val = stack.pop()\n        if len(stack) == 0:\n            break\n        second_val = stack.pop()\n        if first_val < second_val:\n            return False\n        storage_stack.append(first_val)\n        stack.append(second_val)\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/is_consecutive.py", "fileNameBase": "is_consecutive", "extension": "py", "doc": {"long_description": "returns whether or not the stack contains a sequence of consecutive integers\nstarting from the bottom of the stack (returning true if it does, returning\nfalse if it does not).\n\nFor example:\nbottom [3, 4, 5, 6, 7] top\nThen the call of is_consecutive(s) should return true.\nbottom [3, 4, 6, 7] top\nThen the call of is_consecutive(s) should return false.\nbottom [3, 2, 1] top\nThe function should return false due to reverse order.\n\nNote: There are 2 solutions:\nfirst_is_consecutive: it uses a single stack as auxiliary storage\nsecond_is_consecutive: it uses a single queue as auxiliary storage", "short_description": "Given a stack, a function is_consecutive takes a stack as a parameter and that", "full": "Given a stack, a function is_consecutive takes a stack as a parameter and that\nreturns whether or not the stack contains a sequence of consecutive integers\nstarting from the bottom of the stack (returning true if it does, returning\nfalse if it does not).\n\nFor example:\nbottom [3, 4, 5, 6, 7] top\nThen the call of is_consecutive(s) should return true.\nbottom [3, 4, 6, 7] top\nThen the call of is_consecutive(s) should return false.\nbottom [3, 2, 1] top\nThe function should return false due to reverse order.\n\nNote: There are 2 solutions:\nfirst_is_consecutive: it uses a single stack as auxiliary storage\nsecond_is_consecutive: it uses a single queue as auxiliary storage"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"first_is_consecutive": {"args": ["stack"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 38}, "calls": ["range", "len", "stack.pop", "stack.append", "storage_stack.append", "storage_stack.pop"], "store_vars_calls": {"first_value": "stack.pop", "second_value": "stack.pop"}, "source_code": "def first_is_consecutive(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        storage_stack.append(first_value)\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True"}, "second_is_consecutive": {"args": ["stack"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 61}, "calls": ["collections.deque", "range", "len", "stack.pop", "stack.append", "collections.deque.append", "collections.deque.pop"], "store_vars_calls": {"q": "collections.deque", "first_value": "stack.pop", "second_value": "stack.pop"}, "source_code": "def second_is_consecutive(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        q.append(first_value)\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/stack/longest_abs_path.py", "fileNameBase": "longest_abs_path", "extension": "py"}, "functions": {"length_longest_path": {"args": ["input"], "returns": ["max_len"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 59}, "calls": ["input.split", "print", "s.count", "stack.append", "len", "stack.pop", "max", "s.strip"], "store_vars_calls": {"depth": "s.count", "max_len": "max"}, "source_code": "def length_longest_path(input):\n    \"\"\"\n    :type input: str\n    :rtype: int\n    \"\"\"\n    (curr_len, max_len) = (0, 0)\n    stack = []\n    for s in input.split('\\n'):\n        print('---------')\n        print('<path>:', s)\n        depth = s.count('\\t')\n        print('depth: ', depth)\n        print('stack: ', stack)\n        print('curlen: ', curr_len)\n        while len(stack) > depth:\n            curr_len -= stack.pop()\n        stack.append(len(s.strip('\\t')) + 1)\n        curr_len += stack[-1]\n        print('stack: ', stack)\n        print('curlen: ', curr_len)\n        if '.' in s:\n            max_len = max(max_len, curr_len - 1)\n    return max_len"}}, "body": {"calls": ["print", "longest_abs_path.length_longest_path"], "source_code": ["print('path:', st2)", "print('answer:', length_longest_path(st2))", "length_longest_path(st2)"]}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/linkedlist": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/merge_two_list.py", "fileNameBase": "merge_two_list", "extension": "py", "doc": {"long_description": "be made by splicing together the nodes of the first two lists.\n\nFor example:\nInput: 1->2->4, 1->3->4\nOutput: 1->1->2->3->4->4", "short_description": "Merge two sorted linked lists and return it as a new list. The new list should", "full": "Merge two sorted linked lists and return it as a new list. The new list should\nbe made by splicing together the nodes of the first two lists.\n\nFor example:\nInput: 1->2->4, 1->3->4\nOutput: 1->1->2->3->4->4"}}, "classes": {"Node": {"min_max_lineno": {"min_lineno": 9, "max_lineno": 14}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 14}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.next = None"}}}}, "functions": {"merge_two_list": {"args": ["l1", "l2"], "returns": ["ret.next"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 27}, "store_vars_calls": {"ret": "Node", "cur": "Node"}, "source_code": "def merge_two_list(l1, l2):\n    ret = cur = Node(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            cur.next = l1\n            l1 = l1.next\n        else:\n            cur.next = l2\n            l2 = l2.next\n        cur = cur.next\n    cur.next = l1 or l2\n    return ret.next"}, "merge_two_list_recur": {"args": ["l1", "l2"], "returns": ["l1 or l2", "l1", "l2"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 38}, "calls": ["merge_two_list.merge_two_list_recur"], "store_vars_calls": {"l1.next": "merge_two_list_recur", "l2.next": "merge_two_list_recur"}, "source_code": "def merge_two_list_recur(l1, l2):\n    if not l1 or not l2:\n        return l1 or l2\n    if l1.val < l2.val:\n        l1.next = merge_two_list_recur(l1.next, l2)\n        return l1\n    else:\n        l2.next = merge_two_list_recur(l1, l2.next)\n        return l2"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/first_cyclic_node.py", "fileNameBase": "first_cyclic_node", "extension": "py", "doc": {"long_description": "1 -> 2 -> 3 -> 4 -> 5 -> 1  => 1\nA -> B -> C -> D -> E -> C  => C\n\nNote: The solution is a direct implementation\n      Floyd's cycle-finding algorithm (Floyd's Tortoise and Hare).", "short_description": "Given a linked list, find the first node of a cycle in it.", "full": "Given a linked list, find the first node of a cycle in it.\n1 -> 2 -> 3 -> 4 -> 5 -> 1  => 1\nA -> B -> C -> D -> E -> C  => C\n\nNote: The solution is a direct implementation\n      Floyd's cycle-finding algorithm (Floyd's Tortoise and Hare)."}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"Node": {"min_max_lineno": {"min_lineno": 12, "max_lineno": 17}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 17}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.next = None"}}}, "TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 60}, "methods": {"test_first_cyclic_node": {"args": ["self"], "min_max_lineno": {"min_lineno": 42, "max_lineno": 60}, "calls": ["first_cyclic_node.Node", "first_cyclic_node.TestSuite.assertEqual", "first_cyclic_node.first_cyclic_node"], "store_vars_calls": {"head": "Node", "head.next": "Node", "cyclic_node": "Node", "curr.next": "Node"}, "source_code": "def test_first_cyclic_node(self):\n    head = Node('A')\n    head.next = Node('B')\n    curr = head.next\n    cyclic_node = Node('C')\n    curr.next = cyclic_node\n    curr = curr.next\n    curr.next = Node('D')\n    curr = curr.next\n    curr.next = Node('E')\n    curr = curr.next\n    curr.next = cyclic_node\n    self.assertEqual('C', first_cyclic_node(head).val)"}}}}, "functions": {"first_cyclic_node": {"args": ["head"], "returns": ["runner", "None"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 38}, "source_code": "def first_cyclic_node(head):\n    \"\"\"\n    :type head: Node\n    :rtype: Node\n    \"\"\"\n    runner = walker = head\n    while runner and runner.next:\n        runner = runner.next.next\n        walker = walker.next\n        if runner is walker:\n            break\n    if runner is None or runner.next is None:\n        return None\n    walker = head\n    while runner is not walker:\n        (runner, walker) = (runner.next, walker.next)\n    return runner"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "first_cyclic_node.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/swap_in_pairs.py", "fileNameBase": "swap_in_pairs", "extension": "py", "doc": {"long_description": "and return its head.\n\nFor example,\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\n\nYour algorithm should use only constant space.\nYou may not modify the values in the list,\nonly nodes itself can be changed.", "short_description": "Given a linked list, swap every two adjacent nodes", "full": "Given a linked list, swap every two adjacent nodes\nand return its head.\n\nFor example,\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\n\nYour algorithm should use only constant space.\nYou may not modify the values in the list,\nonly nodes itself can be changed."}}, "classes": {"Node": {"extend": ["object"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 16}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 16}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.next = None"}}}}, "functions": {"swap_pairs": {"args": ["head"], "returns": ["start.next", "head"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 31}, "store_vars_calls": {"start": "Node"}, "source_code": "def swap_pairs(head):\n    if not head:\n        return head\n    start = Node(0)\n    start.next = head\n    current = start\n    while current.next and current.next.next:\n        first = current.next\n        second = current.next.next\n        first.next = second.next\n        current.next = second\n        current.next.next = first\n        current = current.next.next\n    return start.next"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/is_cyclic.py", "fileNameBase": "is_cyclic", "extension": "py", "doc": {"long_description": "Follow up:\nCan you solve it without using extra space?", "short_description": "Given a linked list, determine if it has a cycle in it.", "full": "Given a linked list, determine if it has a cycle in it.\n\nFollow up:\nCan you solve it without using extra space?"}}, "classes": {"Node": {"min_max_lineno": {"min_lineno": 7, "max_lineno": 12}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 12}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.next = None"}}}}, "functions": {"is_cyclic": {"args": ["head"], "returns": ["False", "False", "True"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 28}, "source_code": "def is_cyclic(head):\n    \"\"\"\n    :type head: Node\n    :rtype: bool\n    \"\"\"\n    if not head:\n        return False\n    runner = head\n    walker = head\n    while runner.next and runner.next.next:\n        runner = runner.next.next\n        walker = walker.next\n        if runner == walker:\n            return True\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/reverse.py", "fileNameBase": "reverse", "extension": "py", "doc": {"long_description": "1 --> 2 --> 3 --> 4\nAfter reverse:\n4 --> 3 --> 2 --> 1", "short_description": "Reverse a singly linked list. For example:", "full": "Reverse a singly linked list. For example:\n\n1 --> 2 --> 3 --> 4\nAfter reverse:\n4 --> 3 --> 2 --> 1"}}, "functions": {"reverse_list": {"args": ["head"], "returns": ["prev", "head"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 26}, "source_code": "def reverse_list(head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n    if not head or not head.next:\n        return head\n    prev = None\n    while head:\n        current = head\n        head = head.next\n        current.next = prev\n        prev = current\n    return prev"}, "reverse_list_recursive": {"args": ["head"], "returns": ["revrest", "head"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 44}, "calls": ["reverse.reverse_list_recursive"], "store_vars_calls": {"revrest": "reverse_list_recursive"}, "source_code": "def reverse_list_recursive(head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n    if head is None or head.next is None:\n        return head\n    p = head.next\n    head.next = None\n    revrest = reverse_list_recursive(p)\n    p.next = head\n    return revrest"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/is_palindrome.py", "fileNameBase": "is_palindrome", "extension": "py"}, "functions": {"is_palindrome": {"args": ["head"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 26}, "source_code": "def is_palindrome(head):\n    if not head:\n        return True\n    (fast, slow) = (head.next, head)\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True"}, "is_palindrome_stack": {"args": ["head"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 50}, "calls": ["stack.append", "stack.pop"], "source_code": "def is_palindrome_stack(head):\n    if not head or not head.next:\n        return True\n    slow = fast = cur = head\n    while fast and fast.next:\n        (fast, slow) = (fast.next.next, slow.next)\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n    return True"}, "is_palindrome_dict": {"doc": {"long_description": "and the values are the positions at which these values occur in the list.\nWe then iterate over the dict and if there is more than one key with an odd\nnumber of occurrences, bail out and return False.\nOtherwise, we want to ensure that the positions of occurrence sum to the\nvalue of the length of the list - 1, working from the outside of the list inward.\nFor example:\nInput: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1\nd = {1: [0,1,5,6], 2: [2,4], 3: [3]}\n'3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.", "short_description": "This function builds up a dictionary where the keys are the values of the list,"}, "args": ["head"], "returns": ["True", "True", "False", "False"], "min_max_lineno": {"min_lineno": 52, "max_lineno": 90}, "calls": ["d.values", "d.keys", "d[].append", "range", "len"], "source_code": "def is_palindrome_dict(head):\n    \"\"\"\n    This function builds up a dictionary where the keys are the values of the list,\n    and the values are the positions at which these values occur in the list.\n    We then iterate over the dict and if there is more than one key with an odd\n    number of occurrences, bail out and return False.\n    Otherwise, we want to ensure that the positions of occurrence sum to the\n    value of the length of the list - 1, working from the outside of the list inward.\n    For example:\n    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1\n    d = {1: [0,1,5,6], 2: [2,4], 3: [3]}\n    '3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.\n    \"\"\"\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/intersection.py", "fileNameBase": "intersection", "extension": "py", "doc": {"long_description": "In this example:\n1 -> 3 -> 5\n                            7 -> 9 -> 11\n            /\n2 -> 4 -> 6\n...we would return 7.\nNote that the node itself is the unique identifier, not the value of the node.", "short_description": "This function takes two lists and returns the node they have in common, if any.", "full": "This function takes two lists and returns the node they have in common, if any.\nIn this example:\n1 -> 3 -> 5\n                            7 -> 9 -> 11\n            /\n2 -> 4 -> 6\n...we would return 7.\nNote that the node itself is the unique identifier, not the value of the node."}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"Node": {"extend": ["object"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 19}, "methods": {"__init__": {"args": ["self", "val"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 19}, "source_code": "def __init__(self, val=None):\n    self.val = val\n    self.next = None"}}}, "TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 97}, "methods": {"test_intersection": {"args": ["self"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 97}, "calls": ["intersection.Node", "intersection.TestSuite.assertEqual", "intersection.intersection"], "store_vars_calls": {"a1": "Node", "b1": "Node", "c1": "Node", "d": "Node", "a2": "Node", "b2": "Node", "c2": "Node", "e": "Node", "f": "Node"}, "source_code": "def test_intersection(self):\n    a1 = Node(1)\n    b1 = Node(3)\n    c1 = Node(5)\n    d = Node(7)\n    a2 = Node(2)\n    b2 = Node(4)\n    c2 = Node(6)\n    e = Node(9)\n    f = Node(11)\n    a1.next = b1\n    b1.next = c1\n    c1.next = d\n    a2.next = b2\n    b2.next = c2\n    c2.next = d\n    d.next = e\n    e.next = f\n    self.assertEqual(7, intersection(a1, a2).val)"}}}}, "functions": {"intersection": {"args": ["h1", "h2"], "returns": ["None", "longer"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 65}, "source_code": "def intersection(h1, h2):\n    count = 0\n    flag = None\n    h1_orig = h1\n    h2_orig = h2\n    while h1 or h2:\n        count += 1\n        if not flag and (h1.next is None or h2.next is None):\n            flag = (count, h1.next, h2.next)\n        if h1:\n            h1 = h1.next\n        if h2:\n            h2 = h2.next\n    long_len = count\n    short_len = flag[0]\n    if flag[1] is None:\n        shorter = h1_orig\n        longer = h2_orig\n    elif flag[2] is None:\n        shorter = h2_orig\n        longer = h1_orig\n    while longer and shorter:\n        while long_len > short_len:\n            longer = longer.next\n            long_len -= 1\n        if longer == shorter:\n            return longer\n        else:\n            longer = longer.next\n            shorter = shorter.next\n    return None"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "intersection.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/copy_random_pointer.py", "fileNameBase": "copy_random_pointer", "extension": "py", "doc": {"long_description": "pointer which could point to any node in the list or null.\n\nReturn a deep copy of the list.", "short_description": "A linked list is given such that each node contains an additional random", "full": "A linked list is given such that each node contains an additional random\npointer which could point to any node in the list or null.\n\nReturn a deep copy of the list."}}, "dependencies": [{"from_module": "collections", "import": "defaultdict", "type": "external", "type_element": "module"}], "classes": {"RandomListNode": {"extend": ["object"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 15}, "methods": {"__init__": {"args": ["self", "label"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 15}, "source_code": "def __init__(self, label):\n    self.label = label\n    self.next = None\n    self.random = None"}}}}, "functions": {"copy_random_pointer_v1": {"args": ["head"], "returns": ["dic.get(head)"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 32}, "calls": ["dict", "dict.get"], "store_vars_calls": {"dic": "dict", "dic[].next": "dic.get", "dic[].random": "dic.get"}, "source_code": "def copy_random_pointer_v1(head):\n    \"\"\"\n    :type head: RandomListNode\n    :rtype: RandomListNode\n    \"\"\"\n    dic = dict()\n    m = n = head\n    while m:\n        dic[m] = RandomListNode(m.label)\n        m = m.next\n    while n:\n        dic[n].next = dic.get(n.next)\n        dic[n].random = dic.get(n.random)\n        n = n.next\n    return dic.get(head)"}, "copy_random_pointer_v2": {"args": ["head"], "returns": ["copy[head]"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 49}, "calls": ["collections.defaultdict"], "store_vars_calls": {"copy": "defaultdict"}, "source_code": "def copy_random_pointer_v2(head):\n    \"\"\"\n    :type head: RandomListNode\n    :rtype: RandomListNode\n    \"\"\"\n    copy = defaultdict(lambda : RandomListNode(0))\n    copy[None] = None\n    node = head\n    while node:\n        copy[node].label = node.label\n        copy[node].next = copy[node.next]\n        copy[node].random = copy[node.random]\n        node = node.next\n    return copy[head]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "reverse", "import": "reverse_list", "type": "internal", "type_element": "function"}, {"from_module": "reverse", "import": "reverse_list_recursive", "type": "internal", "type_element": "function"}, {"from_module": "is_sorted", "import": "is_sorted", "type": "internal", "type_element": "function"}, {"from_module": "remove_range", "import": "remove_range", "type": "internal", "type_element": "function"}, {"from_module": "swap_in_pairs", "import": "swap_pairs", "type": "internal", "type_element": "function"}, {"from_module": "swap_in_pairs", "import": "Node", "type": "internal", "type_element": "class"}, {"from_module": "rotate_list", "import": "rotate_right", "type": "internal", "type_element": "function"}, {"from_module": "is_cyclic", "import": "is_cyclic", "type": "internal", "type_element": "function"}, {"from_module": "is_cyclic", "import": "Node", "type": "internal", "type_element": "class"}, {"from_module": "merge_two_list", "import": "merge_two_list", "type": "internal", "type_element": "function"}, {"from_module": "merge_two_list", "import": "merge_two_list_recur", "type": "internal", "type_element": "function"}, {"from_module": "merge_two_list", "import": "Node", "type": "internal", "type_element": "class"}, {"from_module": "is_palindrome", "import": "is_palindrome", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_stack", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_dict", "type": "internal", "type_element": "function"}, {"from_module": "copy_random_pointer", "import": "copy_random_pointer_v1", "type": "internal", "type_element": "function"}, {"from_module": "copy_random_pointer", "import": "copy_random_pointer_v2", "type": "internal", "type_element": "function"}, {"from_module": "copy_random_pointer", "import": "RandomListNode", "type": "internal", "type_element": "class"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/remove_range.py", "fileNameBase": "remove_range", "extension": "py", "doc": {"long_description": "as parameters and removes the elements at those indexes (inclusive) from the list\n\nFor example:\nList: [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92]\nremove_range(list, 3, 8);\nList becomes: [8, 13, 17, 23, 0, 92]\n\nlegal range of the list (0 < start index < end index < size of list).", "short_description": "Given a linked list, remove_range function accepts a starting and ending index", "full": "Given a linked list, remove_range function accepts a starting and ending index\nas parameters and removes the elements at those indexes (inclusive) from the list\n\nFor example:\nList: [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92]\nremove_range(list, 3, 8);\nList becomes: [8, 13, 17, 23, 0, 92]\n\nlegal range of the list (0 < start index < end index < size of list)."}}, "functions": {"remove_range": {"args": ["head", "start", "end"], "returns": ["head"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 29}, "calls": ["range"], "source_code": "def remove_range(head, start, end):\n    assert start <= end\n    if start == 0:\n        for i in range(0, end + 1):\n            if head != None:\n                head = head.next\n    else:\n        current = head\n        for i in range(0, start - 1):\n            current = current.next\n        for i in range(0, end - start + 1):\n            if current != None and current.next != None:\n                current.next = current.next.next\n    return head"}}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/rotate_list.py", "fileNameBase": "rotate_list", "extension": "py", "doc": {"long_description": "where k is non-negative.\n\nFor example:\nGiven 1->2->3->4->5->NULL and k = 2,\nreturn 4->5->1->2->3->NULL.", "short_description": "Given a list, rotate the list to the right by k places,", "full": "Given a list, rotate the list to the right by k places,\nwhere k is non-negative.\n\nFor example:\nGiven 1->2->3->4->5->NULL and k = 2,\nreturn 4->5->1->2->3->NULL."}}, "functions": {"rotate_right": {"args": ["head", "k"], "returns": ["head", "head"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 40}, "calls": ["range"], "source_code": "def rotate_right(head, k):\n    \"\"\"\n    :type head: ListNode\n    :type k: int\n    :rtype: ListNode\n    \"\"\"\n    if not head or not head.next:\n        return head\n    current = head\n    length = 1\n    while current.next:\n        current = current.next\n        length += 1\n    current.next = head\n    k = k % length\n    for i in range(length - k):\n        current = current.next\n    head = current.next\n    current.next = None\n    return head"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/partition.py", "fileNameBase": "partition", "extension": "py", "doc": {"long_description": "than x come before all nodes greater than or equal to x.  If x is contained\nwithin the list, the values of x only need to be after the elements less than x.\nThe partition element x can appear anywhere in the \"right partition\";\nit does not need to appear between the left and right partitions.\n\n3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 [partition=5]\n3 -> 1 -> 2 -> 10 -> 5 -> 5 -> 8\n\nWe assume the values of all linked list nodes are int and that x in an int.", "short_description": "Write code to partition a linked list around a value x, such that all nodes less", "full": "Write code to partition a linked list around a value x, such that all nodes less\nthan x come before all nodes greater than or equal to x.  If x is contained\nwithin the list, the values of x only need to be after the elements less than x.\nThe partition element x can appear anywhere in the \"right partition\";\nit does not need to appear between the left and right partitions.\n\n3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 [partition=5]\n3 -> 1 -> 2 -> 10 -> 5 -> 5 -> 8\n\nWe assume the values of all linked list nodes are int and that x in an int."}}, "classes": {"Node": {"min_max_lineno": {"min_lineno": 15, "max_lineno": 19}, "methods": {"__init__": {"args": ["self", "val"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 19}, "calls": ["int"], "store_vars_calls": {"self.val": "int"}, "source_code": "def __init__(self, val=None):\n    self.val = int(val)\n    self.next = None"}}}}, "functions": {"print_linked_list": {"args": ["head"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 28}, "calls": ["str", "print"], "source_code": "def print_linked_list(head):\n    string = ''\n    while head.next:\n        string += str(head.val) + ' -> '\n        head = head.next\n    string += str(head.val)\n    print(string)"}, "partition": {"args": ["head", "x"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 52}, "calls": ["int"], "source_code": "def partition(head, x):\n    left = None\n    right = None\n    prev = None\n    current = head\n    while current:\n        if int(current.val) >= x:\n            if not right:\n                right = current\n        elif not left:\n            left = current\n        else:\n            prev.next = current.next\n            left.next = current\n            left = current\n            left.next = right\n        if prev and prev.next is None:\n            break\n        prev = current\n        current = current.next"}, "test": {"min_max_lineno": {"min_lineno": 54, "max_lineno": 73}, "calls": ["partition.Node", "partition.print_linked_list", "partition.partition"], "store_vars_calls": {"a": "Node", "b": "Node", "c": "Node", "d": "Node", "e": "Node", "f": "Node", "g": "Node"}, "source_code": "def test():\n    a = Node('3')\n    b = Node('5')\n    c = Node('8')\n    d = Node('5')\n    e = Node('10')\n    f = Node('2')\n    g = Node('1')\n    a.next = b\n    b.next = c\n    c.next = d\n    d.next = e\n    e.next = f\n    f.next = g\n    print_linked_list(a)\n    partition(a, 5)\n    print_linked_list(a)"}}, "body": {"calls": ["partition.test"], "source_code": ["test()"]}, "main_info": {"main_flag": 1, "main_function": "partition.test", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/linkedlist.py", "fileNameBase": "linkedlist", "extension": "py"}, "classes": {"DoublyLinkedListNode": {"extend": ["object"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 19}, "methods": {"__init__": {"args": ["self", "value"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 19}, "source_code": "def __init__(self, value):\n    self.value = value\n    self.next = None\n    self.prev = None"}}}, "SinglyLinkedListNode": {"extend": ["object"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 25}, "methods": {"__init__": {"args": ["self", "value"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 25}, "source_code": "def __init__(self, value):\n    self.value = value\n    self.next = None"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/add_two_numbers.py", "fileNameBase": "add_two_numbers", "extension": "py", "doc": {"long_description": "two non-negative integers. The digits are stored in reverse order\nand each of their nodes contain a single digit.\nAdd the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero,\nexcept the number 0 itself.\n\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8", "short_description": "You are given two non-empty linked lists representing", "full": "You are given two non-empty linked lists representing\ntwo non-negative integers. The digits are stored in reverse order\nand each of their nodes contain a single digit.\nAdd the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero,\nexcept the number 0 itself.\n\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"Node": {"min_max_lineno": {"min_lineno": 17, "max_lineno": 21}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 21}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.next = None"}}}, "TestSuite": {"doc": {"long_description": "the adding function, above.", "short_description": "testsuite for the linked list structure and", "full": "testsuite for the linked list structure and\nthe adding function, above."}, "extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 129}, "methods": {"test_convert_to_str": {"args": ["self"], "min_max_lineno": {"min_lineno": 83, "max_lineno": 88}, "calls": ["add_two_numbers.Node", "add_two_numbers.TestSuite.assertEqual", "add_two_numbers.convert_to_str"], "store_vars_calls": {"number1": "Node", "number1.next": "Node", "number1.next.next": "Node"}, "source_code": "def test_convert_to_str(self):\n    number1 = Node(2)\n    number1.next = Node(4)\n    number1.next.next = Node(3)\n    self.assertEqual('243', convert_to_str(number1))"}, "test_add_two_numbers": {"args": ["self"], "min_max_lineno": {"min_lineno": 89, "max_lineno": 125}, "calls": ["add_two_numbers.Node", "add_two_numbers.convert_to_str", "add_two_numbers.TestSuite.assertEqual", "add_two_numbers.add_two_numbers"], "store_vars_calls": {"number1": "Node", "number1.next": "Node", "number1.next.next": "Node", "number2": "Node", "number2.next": "Node", "number2.next.next": "Node", "result": "convert_to_str", "number3": "Node", "number3.next": "Node", "number3.next.next": "Node", "number4": "Node", "number4.next": "Node", "number4.next.next": "Node", "number5": "Node", "number6": "Node", "number7": "Node", "number7.next": "Node", "number7.next.next": "Node", "number8": "Node", "number8.next": "Node", "number8.next.next": "Node"}, "source_code": "def test_add_two_numbers(self):\n    number1 = Node(2)\n    number1.next = Node(4)\n    number1.next.next = Node(3)\n    number2 = Node(5)\n    number2.next = Node(6)\n    number2.next.next = Node(4)\n    result = convert_to_str(add_two_numbers(number1, number2))\n    self.assertEqual('708', result)\n    number3 = Node(1)\n    number3.next = Node(1)\n    number3.next.next = Node(9)\n    number4 = Node(1)\n    number4.next = Node(0)\n    number4.next.next = Node(1)\n    result = convert_to_str(add_two_numbers(number3, number4))\n    self.assertEqual('2101', result)\n    number5 = Node(1)\n    number6 = Node(0)\n    result = convert_to_str(add_two_numbers(number5, number6))\n    self.assertEqual('1', result)\n    number7 = Node(9)\n    number7.next = Node(1)\n    number7.next.next = Node(1)\n    number8 = Node(1)\n    number8.next = Node(0)\n    number8.next.next = Node(1)\n    result = convert_to_str(add_two_numbers(number7, number8))\n    self.assertEqual('022', result)"}, "test_convert_to_list": {"args": ["self"], "min_max_lineno": {"min_lineno": 126, "max_lineno": 129}, "calls": ["add_two_numbers.convert_to_str", "add_two_numbers.TestSuite.assertEqual", "add_two_numbers.convert_to_list"], "store_vars_calls": {"result": "convert_to_str"}, "source_code": "def test_convert_to_list(self):\n    result = convert_to_str(convert_to_list(112))\n    self.assertEqual('211', result)"}}}}, "functions": {"add_two_numbers": {"args": ["left", "right"], "annotated_arg_types": {"left": "Node", "right": "Node"}, "annotated_return_type": "Node", "returns": ["head.next"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 41}, "calls": ["print", "add_two_numbers.Node"], "store_vars_calls": {"head": "Node", "current.next": "Node"}, "source_code": "def add_two_numbers(left: Node, right: Node) -> Node:\n    head = Node(0)\n    current = head\n    sum = 0\n    while left or right:\n        print('adding: ', left.val, right.val)\n        sum //= 10\n        if left:\n            sum += left.val\n            left = left.next\n        if right:\n            sum += right.val\n            right = right.next\n        current.next = Node(sum % 10)\n        current = current.next\n    if sum // 10 == 1:\n        current.next = Node(1)\n    return head.next"}, "convert_to_list": {"doc": {"long_description": "for example: give 112\nresult 2 -> 1 -> 1", "short_description": "converts a positive integer into a (reversed) linked list."}, "args": ["number"], "annotated_arg_types": {"number": "int"}, "annotated_return_type": "Node", "returns": ["head.next"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 64}, "calls": ["add_two_numbers.Node", "print"], "store_vars_calls": {"head": "Node", "current.next": "Node"}, "source_code": "def convert_to_list(number: int) -> Node:\n    \"\"\"\n        converts a positive integer into a (reversed) linked list.\n        for example: give 112\n        result 2 -> 1 -> 1\n    \"\"\"\n    if number >= 0:\n        head = Node(0)\n        current = head\n        remainder = number % 10\n        quotient = number // 10\n        while quotient != 0:\n            current.next = Node(remainder)\n            current = current.next\n            remainder = quotient % 10\n            quotient //= 10\n        current.next = Node(remainder)\n        return head.next\n    else:\n        print('number must be positive!')"}, "convert_to_str": {"doc": {"short_description": "converts the non-negative number list into a string."}, "args": ["l"], "annotated_arg_types": {"l": "Node"}, "annotated_return_type": "str", "returns": ["result"], "min_max_lineno": {"min_lineno": 66, "max_lineno": 75}, "calls": ["str"], "source_code": "def convert_to_str(l: Node) -> str:\n    \"\"\"\n        converts the non-negative number list into a string.\n    \"\"\"\n    result = ''\n    while l:\n        result += str(l.val)\n        l = l.next\n    return result"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "add_two_numbers.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/is_sorted.py", "fileNameBase": "is_sorted", "extension": "py", "doc": {"long_description": "(increasing) order and return false otherwise. An empty list is considered\nto be sorted.\n\nFor example:\nNull :List is sorted\n1 2 3 4 :List is sorted\n1 2 -1 3 :List is not sorted", "short_description": "Given a linked list, is_sort function returns true if the list is in sorted", "full": "Given a linked list, is_sort function returns true if the list is in sorted\n(increasing) order and return false otherwise. An empty list is considered\nto be sorted.\n\nFor example:\nNull :List is sorted\n1 2 3 4 :List is sorted\n1 2 -1 3 :List is not sorted"}}, "functions": {"is_sorted": {"args": ["head"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 20}, "source_code": "def is_sorted(head):\n    if not head:\n        return True\n    current = head\n    while current.next:\n        if current.val > current.next.val:\n            return False\n        current = current.next\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/remove_duplicates.py", "fileNameBase": "remove_duplicates", "extension": "py"}, "classes": {"Node": {"min_max_lineno": {"min_lineno": 1, "max_lineno": 5}, "methods": {"__init__": {"args": ["self", "val"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 5}, "source_code": "def __init__(self, val=None):\n    self.val = val\n    self.next = None"}}}}, "functions": {"remove_dups": {"doc": {"long_description": "Space Complexity: O(N)", "short_description": "Time Complexity: O(N)"}, "args": ["head"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 20}, "calls": ["set", "set.add"], "store_vars_calls": {"hashset": "set", "prev": "Node"}, "source_code": "def remove_dups(head):\n    \"\"\"\n    Time Complexity: O(N)\n    Space Complexity: O(N)\n    \"\"\"\n    hashset = set()\n    prev = Node()\n    while head:\n        if head.val in hashset:\n            prev.next = head.next\n        else:\n            hashset.add(head.val)\n            prev = head\n        head = head.next"}, "remove_dups_wothout_set": {"doc": {"long_description": "Space Complexity: O(1)", "short_description": "Time Complexity: O(N^2)"}, "args": ["head"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 35}, "source_code": "def remove_dups_wothout_set(head):\n    \"\"\"\n    Time Complexity: O(N^2)\n    Space Complexity: O(1)\n    \"\"\"\n    current = head\n    while current:\n        runner = current\n        while runner.next:\n            if runner.next.val == current.val:\n                runner.next = runner.next.next\n            else:\n                runner = runner.next\n        current = current.next"}, "print_linked_list": {"args": ["head"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 43}, "calls": ["print"], "source_code": "def print_linked_list(head):\n    string = ''\n    while head.next:\n        string += head.val + ' -> '\n        head = head.next\n    string += head.val\n    print(string)"}}, "body": {"calls": ["remove_duplicates.Node", "remove_duplicates.remove_dups", "remove_duplicates.print_linked_list", "remove_duplicates.remove_dups_wothout_set"], "store_vars_calls": {"a1": "Node", "a2": "Node", "b": "Node", "c1": "Node", "d": "Node", "c2": "Node", "f": "Node", "g": "Node"}, "source_code": ["Node('A')", "Node('A')", "Node('B')", "Node('C')", "Node('D')", "Node('C')", "Node('F')", "Node('G')", "remove_dups(a1)", "print_linked_list(a1)", "remove_dups_wothout_set(a1)", "print_linked_list(a1)"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/delete_node.py", "fileNameBase": "delete_node", "extension": "py", "doc": {"long_description": "in a singly linked list, given only access to that node.\n\nSupposed the linked list is 1 -> 2 -> 3 -> 4 and\nyou are given the third node with value 3,\nthe linked list should become 1 -> 2 -> 4 after calling your function.", "short_description": "Write a function to delete a node (except the tail)", "full": "Write a function to delete a node (except the tail)\nin a singly linked list, given only access to that node.\n\nSupposed the linked list is 1 -> 2 -> 3 -> 4 and\nyou are given the third node with value 3,\nthe linked list should become 1 -> 2 -> 4 after calling your function."}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"Node": {"min_max_lineno": {"min_lineno": 12, "max_lineno": 16}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 16}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.next = None"}}}, "TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 59}, "methods": {"test_delete_node": {"args": ["self"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 59}, "calls": ["range", "delete_node.delete_node", "delete_node.TestSuite.assertEqual", "delete_node.TestSuite.assertIsNone", "delete_node.TestSuite.assertRaises", "delete_node.Node"], "store_vars_calls": {"head": "Node", "curr.next": "Node"}, "source_code": "def test_delete_node(self):\n    head = Node(1)\n    curr = head\n    for i in range(2, 6):\n        curr.next = Node(i)\n        curr = curr.next\n    node3 = head.next.next\n    delete_node(node3)\n    curr = head\n    self.assertEqual(1, curr.val)\n    curr = curr.next\n    self.assertEqual(2, curr.val)\n    curr = curr.next\n    self.assertEqual(4, curr.val)\n    curr = curr.next\n    self.assertEqual(5, curr.val)\n    tail = curr\n    self.assertIsNone(tail.next)\n    self.assertRaises(ValueError, delete_node, tail)\n    self.assertRaises(ValueError, delete_node, tail.next)"}}}}, "functions": {"delete_node": {"args": ["node"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 23}, "source_code": "def delete_node(node):\n    if node is None or node.next is None:\n        raise ValueError\n    node.val = node.next.val\n    node.next = node.next.next"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "delete_node.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/linkedlist/kth_to_last.py", "fileNameBase": "kth_to_last", "extension": "py"}, "classes": {"Node": {"min_max_lineno": {"min_lineno": 1, "max_lineno": 5}, "methods": {"__init__": {"args": ["self", "val"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 5}, "source_code": "def __init__(self, val=None):\n    self.val = val\n    self.next = None"}}}}, "functions": {"kth_to_last_eval": {"doc": {"long_description": "safe for user input. We guard against danger by ensuring k in an int", "short_description": "This is a suboptimal, hacky method using eval(), which is not"}, "args": ["head", "k"], "returns": ["False", "False", "head"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 25}, "calls": ["str", "isinstance", "eval", "range"], "store_vars_calls": {"seeker": "str"}, "source_code": "def kth_to_last_eval(head, k):\n    \"\"\"\n    This is a suboptimal, hacky method using eval(), which is not\n     safe for user input. We guard against danger by ensuring k in an int\n    \"\"\"\n    if not isinstance(k, int) or not head.val:\n        return False\n    nexts = '.'.join(['next' for n in range(1, k + 1)])\n    seeker = str('.'.join(['head', nexts]))\n    while head:\n        if eval(seeker) is None:\n            return head\n        else:\n            head = head.next\n    return False"}, "kth_to_last_dict": {"doc": {"long_description": "Then we check it for the value we need. If the key is not in the dict,\nour and statement will short circuit and return False", "short_description": "This is a brute force method where we keep a dict the size of the list"}, "args": ["head", "k"], "returns": ["len(d) - k in d and d[len(d) - k]", "False"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 42}, "calls": ["dict", "len"], "store_vars_calls": {"d": "dict"}, "source_code": "def kth_to_last_dict(head, k):\n    \"\"\"\n    This is a brute force method where we keep a dict the size of the list\n    Then we check it for the value we need. If the key is not in the dict,\n    our and statement will short circuit and return False\n    \"\"\"\n    if not (head and k > -1):\n        return False\n    d = dict()\n    count = 0\n    while head:\n        d[count] = head\n        head = head.next\n        count += 1\n    return len(d) - k in d and d[len(d) - k]"}, "kth_to_last": {"doc": {"long_description": "We move p1 k steps ahead into the list.\nThen we move p1 and p2 together until p1 hits the end.", "short_description": "This is an optimal method using iteration."}, "args": ["head", "k"], "returns": ["p2", "False"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 63}, "calls": ["range"], "source_code": "def kth_to_last(head, k):\n    \"\"\"\n    This is an optimal method using iteration.\n    We move p1 k steps ahead into the list.\n    Then we move p1 and p2 together until p1 hits the end.\n    \"\"\"\n    if not (head or k > -1):\n        return False\n    p1 = head\n    p2 = head\n    for i in range(1, k + 1):\n        if p1 is None:\n            raise IndexError\n        p1 = p1.next\n    while p1:\n        p1 = p1.next\n        p2 = p2.next\n    return p2"}, "print_linked_list": {"args": ["head"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 72}, "calls": ["print"], "source_code": "def print_linked_list(head):\n    string = ''\n    while head.next:\n        string += head.val + ' -> '\n        head = head.next\n    string += head.val\n    print(string)"}, "test": {"min_max_lineno": {"min_lineno": 74, "max_lineno": 118}, "calls": ["kth_to_last.Node", "kth_to_last.print_linked_list", "kth_to_last.kth_to_last_eval", "kth_to_last.kth_to_last_dict", "kth_to_last.kth_to_last", "print"], "store_vars_calls": {"a1": "Node", "a2": "Node", "b": "Node", "c1": "Node", "d": "Node", "c2": "Node", "f": "Node", "g": "Node", "kth": "kth_to_last"}, "source_code": "def test():\n    a1 = Node('A')\n    a2 = Node('A')\n    b = Node('B')\n    c1 = Node('C')\n    d = Node('D')\n    c2 = Node('C')\n    f = Node('F')\n    g = Node('G')\n    a1.next = a2\n    a2.next = b\n    b.next = c1\n    c1.next = d\n    d.next = c2\n    c2.next = f\n    f.next = g\n    print_linked_list(a1)\n    kth = kth_to_last_eval(a1, 4)\n    try:\n        assert kth.val == 'D'\n    except AssertionError as e:\n        e.args += ('Expecting D, got %s' % kth.val,)\n        raise\n    kth = kth_to_last_dict(a1, 4)\n    try:\n        assert kth.val == 'D'\n    except AssertionError as e:\n        e.args += ('Expecting D, got %s' % kth.val,)\n        raise\n    kth = kth_to_last(a1, 4)\n    try:\n        assert kth.val == 'D'\n    except AssertionError as e:\n        e.args += ('Expecting D, got %s' % kth.val,)\n        raise\n    print('all passed.')"}}, "body": {"calls": ["kth_to_last.test"], "source_code": ["test()"]}, "main_info": {"main_flag": 1, "main_function": "kth_to_last.test", "type": "script"}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/ml": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/ml/nearest_neighbor.py", "fileNameBase": "nearest_neighbor", "extension": "py"}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"distance": {"args": ["x", "y"], "returns": ["math.sqrt(sum)"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 20}, "calls": ["range", "math.sqrt", "len"], "source_code": "def distance(x, y):\n    \"\"\"[summary]\n    HELPER-FUNCTION\n    calculates the (eulidean) distance between vector x and y.\n\n    Arguments:\n        x {[tuple]} -- [vector]\n        y {[tuple]} -- [vector]\n    \"\"\"\n    assert len(x) == len(y), 'The vector must have same length'\n    result = ()\n    sum = 0\n    for i in range(len(x)):\n        result += (x[i] - y[i],)\n    for component in result:\n        sum += component ** 2\n    return math.sqrt(sum)"}, "nearest_neighbor": {"args": ["x", "tSet"], "returns": ["tSet[current_key]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 42}, "calls": ["float", "isinstance", "nearest_neighbor.distance"], "store_vars_calls": {"min_d": "float", "d": "distance"}, "source_code": "def nearest_neighbor(x, tSet):\n    \"\"\"[summary]\n    Implements the nearest neighbor algorithm\n\n    Arguments:\n        x {[tupel]} -- [vector]\n        tSet {[dict]} -- [training set]\n\n    Returns:\n        [type] -- [result of the AND-function]\n    \"\"\"\n    assert isinstance(x, tuple) and isinstance(tSet, dict)\n    current_key = ()\n    min_d = float('inf')\n    for key in tSet:\n        d = distance(x, key)\n        if d < min_d:\n            min_d = d\n            current_key = key\n    return tSet[current_key]"}}, "is_test": true}], "output/keon/algorithms/algorithms/algorithms/backtrack": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/anagram.py", "fileNameBase": "anagram", "extension": "py", "doc": {"long_description": "Examples:\n\"apple\", \"pleap\"  -> True\n\"apple\", \"cherry\" -> False", "short_description": "Given two strings, determine if they are equal after reordering.", "full": "Given two strings, determine if they are equal after reordering.\n\nExamples:\n\"apple\", \"pleap\"  -> True\n\"apple\", \"cherry\" -> False"}}, "functions": {"anagram": {"args": ["s1", "s2"], "returns": ["c1 == c2"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 23}, "calls": ["ord"], "source_code": "def anagram(s1, s2):\n    c1 = [0] * 26\n    c2 = [0] * 26\n    for c in s1:\n        pos = ord(c) - ord('a')\n        c1[pos] = c1[pos] + 1\n    for c in s2:\n        pos = ord(c) - ord('a')\n        c2[pos] = c2[pos] + 1\n    return c1 == c2"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/factor_combinations.py", "fileNameBase": "factor_combinations", "extension": "py", "doc": {"long_description": "8 = 2 x 2 x 2;\n  = 2 x 4.\nWrite a function that takes an integer n\nand return all possible combinations of its factors.\n\nNote:\nYou may assume that n is always positive.\nFactors should be greater than 1 and less than n.\nExamples:\ninput: 1\noutput:\n[]\ninput: 37\noutput:\n[]\ninput: 12\noutput:\n[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]", "short_description": "Numbers can be regarded as product of its factors. For example,", "full": "Numbers can be regarded as product of its factors. For example,\n\n8 = 2 x 2 x 2;\n  = 2 x 4.\nWrite a function that takes an integer n\nand return all possible combinations of its factors.\n\nNote:\nYou may assume that n is always positive.\nFactors should be greater than 1 and less than n.\nExamples:\ninput: 1\noutput:\n[]\ninput: 37\noutput:\n[]\ninput: 12\noutput:\n[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]"}}, "functions": {"get_factors": {"args": ["n"], "returns": ["combis"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 50}, "calls": ["todo.pop", "combis.append", "todo.append"], "source_code": "def get_factors(n):\n    (todo, combis) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                combis.append(combi + [i, n // i])\n                todo.append((n // i, i, combi + [i]))\n            i += 1\n    return combis"}, "recursive_get_factors": {"args": ["n"], "returns": ["factor(n, 2, [], [])", "combis"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 64}, "calls": ["factor_combinations.recursive_get_factors.factor"], "functions": {"factor": {"args": ["n", "i", "combi", "combis"], "returns": ["combis"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 62}, "calls": ["factor", "combis.append"], "source_code": "def factor(n, i, combi, combis):\n    while i * i <= n:\n        if n % i == 0:\n            (combis.append(combi + [i, n // i]),)\n            factor(n // i, i, combi + [i], combis)\n        i += 1\n    return combis"}}, "source_code": "def recursive_get_factors(n):\n\n    def factor(n, i, combi, combis):\n        while i * i <= n:\n            if n % i == 0:\n                (combis.append(combi + [i, n // i]),)\n                factor(n // i, i, combi + [i], combis)\n            i += 1\n        return combis\n    return factor(n, 2, [], [])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/subsets_unique.py", "fileNameBase": "subsets_unique", "extension": "py", "doc": {"long_description": "return all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,2], a solution is:\n\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]", "short_description": "Given a collection of integers that might contain duplicates, nums,", "full": "Given a collection of integers that might contain duplicates, nums,\nreturn all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,2], a solution is:\n\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]"}}, "functions": {"subsets_unique": {"args": ["nums"], "returns": ["list(res)"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 38}, "calls": ["set", "subsets_unique.subsets_unique.backtrack"], "store_vars_calls": {"res": "set"}, "functions": {"backtrack": {"args": ["res", "nums", "stack", "pos"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 34}, "calls": ["len", "res.add", "stack.append", "backtrack", "stack.pop", "tuple"], "source_code": "def backtrack(res, nums, stack, pos):\n    if pos == len(nums):\n        res.add(tuple(stack))\n    else:\n        stack.append(nums[pos])\n        backtrack(res, nums, stack, pos + 1)\n        stack.pop()\n        backtrack(res, nums, stack, pos + 1)"}}, "source_code": "def subsets_unique(nums):\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.add(tuple(stack))\n        else:\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos + 1)\n            stack.pop()\n            backtrack(res, nums, stack, pos + 1)\n    res = set()\n    backtrack(res, nums, [], 0)\n    return list(res)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/permute.py", "fileNameBase": "permute", "extension": "py", "doc": {"long_description": "For example,\n[1,2,3] have the following permutations:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]", "short_description": "Given a collection of distinct numbers, return all possible permutations.", "full": "Given a collection of distinct numbers, return all possible permutations.\n\nFor example,\n[1,2,3] have the following permutations:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]"}}, "functions": {"permute": {"doc": {"short_description": "returns a list with the permuations."}, "args": ["elements"], "returns": ["[elements]", "tmp"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 29}, "calls": ["len", "permute.permute", "range", "tmp.append"], "source_code": "def permute(elements):\n    \"\"\"\n        returns a list with the permuations.\n    \"\"\"\n    if len(elements) <= 1:\n        return [elements]\n    else:\n        tmp = []\n        for perm in permute(elements[1:]):\n            for i in range(len(elements)):\n                tmp.append(perm[:i] + elements[0:1] + perm[i:])\n        return tmp"}, "permute_iter": {"doc": {"short_description": "iterator: returns a perumation by each call."}, "args": ["elements"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 41}, "calls": ["len", "permute.permute_iter", "range"], "source_code": "def permute_iter(elements):\n    \"\"\"\n        iterator: returns a perumation by each call.\n    \"\"\"\n    if len(elements) <= 1:\n        yield elements\n    else:\n        for perm in permute_iter(elements[1:]):\n            for i in range(len(elements)):\n                yield (perm[:i] + elements[0:1] + perm[i:])"}, "permute_recursive": {"args": ["nums"], "returns": ["res"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 55}, "calls": ["permute.permute_recursive.dfs"], "functions": {"dfs": {"args": ["res", "nums", "path"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 51}, "calls": ["range", "res.append", "len", "print", "dfs"], "source_code": "def dfs(res, nums, path):\n    if not nums:\n        res.append(path)\n    for i in range(len(nums)):\n        print(nums[:i] + nums[i + 1:])\n        dfs(res, nums[:i] + nums[i + 1:], path + [nums[i]])"}}, "source_code": "def permute_recursive(nums):\n\n    def dfs(res, nums, path):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            print(nums[:i] + nums[i + 1:])\n            dfs(res, nums[:i] + nums[i + 1:], path + [nums[i]])\n    res = []\n    dfs(res, nums, [])\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/permute_unique.py", "fileNameBase": "permute_unique", "extension": "py", "doc": {"long_description": "return all possible unique permutations.\n\nFor example,\n[1,1,2] have the following unique permutations:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]", "short_description": "Given a collection of numbers that might contain duplicates,", "full": "Given a collection of numbers that might contain duplicates,\nreturn all possible unique permutations.\n\nFor example,\n[1,1,2] have the following unique permutations:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]"}}, "functions": {"permute_unique": {"args": ["nums"], "returns": ["perms"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 26}, "calls": ["range", "new_perms.append", "len"], "source_code": "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l) + 1):\n                new_perms.append(l[:i] + [n] + l[i:])\n                if i < len(l) and l[i] == n:\n                    break\n        perms = new_perms\n    return perms"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "add_operators", "import": "add_operators", "type": "internal", "type_element": "function"}, {"from_module": "anagram", "import": "anagram", "type": "internal", "type_element": "function"}, {"from_module": "array_sum_combinations", "import": "array_sum_combinations", "type": "internal", "type_element": "function"}, {"from_module": "array_sum_combinations", "import": "unique_array_sum_combinations", "type": "internal", "type_element": "function"}, {"from_module": "combination_sum", "import": "combination_sum", "type": "internal", "type_element": "function"}, {"from_module": "factor_combinations", "import": "get_factors", "type": "internal", "type_element": "function"}, {"from_module": "factor_combinations", "import": "recursive_get_factors", "type": "internal", "type_element": "function"}, {"from_module": "find_words", "import": "find_words", "type": "internal", "type_element": "function"}, {"from_module": "generate_abbreviations", "import": "generate_abbreviations", "type": "internal", "type_element": "function"}, {"from_module": "generate_parenthesis", "import": "generate_parenthesis_v1", "type": "internal", "type_element": "function"}, {"from_module": "generate_parenthesis", "import": "generate_parenthesis_v2", "type": "internal", "type_element": "function"}, {"from_module": "letter_combination", "import": "letter_combinations", "type": "internal", "type_element": "function"}, {"from_module": "palindrome_partitioning", "import": "palindromic_substrings", "type": "internal", "type_element": "function"}, {"from_module": "palindrome_partitioning", "import": "palindromic_substrings_iter", "type": "internal", "type_element": "function"}, {"from_module": "pattern_match", "import": "pattern_match", "type": "internal", "type_element": "function"}, {"from_module": "permute_unique", "import": "permute_unique", "type": "internal", "type_element": "function"}, {"from_module": "permute", "import": "permute", "type": "internal", "type_element": "function"}, {"from_module": "permute", "import": "permute_iter", "type": "internal", "type_element": "function"}, {"from_module": "permute", "import": "permute_recursive", "type": "internal", "type_element": "function"}, {"from_module": "subsets_unique", "import": "subsets_unique", "type": "internal", "type_element": "function"}, {"from_module": "subsets", "import": "subsets", "type": "internal", "type_element": "function"}, {"from_module": "subsets", "import": "subsets_v2", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/subsets.py", "fileNameBase": "subsets", "extension": "py", "doc": {"long_description": "Note: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]", "short_description": "Given a set of distinct integers, nums, return all possible subsets.", "full": "Given a set of distinct integers, nums, return all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]"}}, "functions": {"subsets": {"doc": {"short_description": "O(2**n)"}, "args": ["nums"], "returns": ["res"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 40}, "calls": ["subsets.subsets.backtrack"], "functions": {"backtrack": {"args": ["res", "nums", "stack", "pos"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 36}, "calls": ["len", "res.append", "stack.append", "backtrack", "stack.pop", "list"], "source_code": "def backtrack(res, nums, stack, pos):\n    if pos == len(nums):\n        res.append(list(stack))\n    else:\n        stack.append(nums[pos])\n        backtrack(res, nums, stack, pos + 1)\n        stack.pop()\n        backtrack(res, nums, stack, pos + 1)"}}, "source_code": "def subsets(nums):\n    \"\"\"\n    O(2**n)\n    \"\"\"\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.append(list(stack))\n        else:\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos + 1)\n            stack.pop()\n            backtrack(res, nums, stack, pos + 1)\n    res = []\n    backtrack(res, nums, [], 0)\n    return res"}, "subsets_v2": {"args": ["nums"], "returns": ["res"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 60}, "calls": ["sorted"], "source_code": "def subsets_v2(nums):\n    res = [[]]\n    for num in sorted(nums):\n        res += [item + [num] for item in res]\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/letter_combination.py", "fileNameBase": "letter_combination", "extension": "py", "doc": {"long_description": "combinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below:\n2: \"abc\"\n3: \"def\"\n4: \"ghi\"\n5: \"jkl\"\n6: \"mno\"\n7: \"pqrs\"\n8: \"tuv\"\n9: \"wxyz\"\n\nInput:Digit string \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].", "short_description": "Given a digit string, return all possible letter", "full": "Given a digit string, return all possible letter\ncombinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below:\n2: \"abc\"\n3: \"def\"\n4: \"ghi\"\n5: \"jkl\"\n6: \"mno\"\n7: \"pqrs\"\n8: \"tuv\"\n9: \"wxyz\"\n\nInput:Digit string \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]."}}, "functions": {"letter_combinations": {"args": ["digits"], "returns": ["ans", "[]"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 41}, "calls": ["tmp.append"], "source_code": "def letter_combinations(digits):\n    if digits == '':\n        return []\n    kmaps = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    ans = ['']\n    for num in digits:\n        tmp = []\n        for an in ans:\n            for char in kmaps[num]:\n                tmp.append(an + char)\n        ans = tmp\n    return ans"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/algorithms/backtrack/pattern_match.py", "fileNameBase": "pattern_match", "extension": "py", "doc": {"long_description": "find if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between\na letter in pattern and a non-empty substring in str.\n\nExamples:\npattern = \"abab\", str = \"redblueredblue\" should return true.\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters.", "short_description": "Given a pattern and a string str,", "full": "Given a pattern and a string str,\nfind if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between\na letter in pattern and a non-empty substring in str.\n\nExamples:\npattern = \"abab\", str = \"redblueredblue\" should return true.\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters."}}, "functions": {"pattern_match": {"args": ["pattern", "string"], "returns": ["backtrack(pattern, string, {})", "False", "False", "True", "True", "True"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 43}, "calls": ["pattern_match.pattern_match.backtrack"], "functions": {"backtrack": {"args": ["pattern", "string", "dic"], "returns": ["False", "False", "True", "True", "True"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 41}, "calls": ["range", "len", "backtrack", "dic.values"], "source_code": "def backtrack(pattern, string, dic):\n    if len(pattern) == 0 and len(string) > 0:\n        return False\n    if len(pattern) == len(string) == 0:\n        return True\n    for end in range(1, len(string) - len(pattern) + 2):\n        if pattern[0] not in dic and string[:end] not in dic.values():\n            dic[pattern[0]] = string[:end]\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n            del dic[pattern[0]]\n        elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n    return False"}}, "source_code": "def pattern_match(pattern, string):\n    \"\"\"\n    :type pattern: str\n    :type string: str\n    :rtype: bool\n    \"\"\"\n\n    def backtrack(pattern, string, dic):\n        if len(pattern) == 0 and len(string) > 0:\n            return False\n        if len(pattern) == len(string) == 0:\n            return True\n        for end in range(1, len(string) - len(pattern) + 2):\n            if pattern[0] not in dic and string[:end] not in dic.values():\n                dic[pattern[0]] = string[:end]\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n                del dic[pattern[0]]\n            elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n        return False\n    return backtrack(pattern, string, {})"}}, "is_test": false}], "output/keon/algorithms/algorithms/tests": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_backtrack.py", "fileNameBase": "test_backtrack", "extension": "py"}, "dependencies": [{"from_module": "algorithms.backtrack", "import": "add_operators", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "permute_iter", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "anagram", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "array_sum_combinations", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "unique_array_sum_combinations", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "combination_sum", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "get_factors", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "recursive_get_factors", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "find_words", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "generate_abbreviations", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "generate_parenthesis_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "generate_parenthesis_v2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "letter_combinations", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "palindromic_substrings", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "pattern_match", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "permute_unique", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "permute", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "permute_recursive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "subsets_unique", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "subsets", "type": "external", "type_element": "module"}, {"from_module": "algorithms.backtrack", "import": "subsets_v2", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestAddOperator": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 54}, "methods": {"test_add_operators": {"args": ["self"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 54}, "calls": ["test_backtrack.TestAddOperator.assertEqual", "algorithms.backtrack.add_operators"], "source_code": "def test_add_operators(self):\n    s = '123'\n    target = 6\n    self.assertEqual(add_operators(s, target), ['1+2+3', '1*2*3'])\n    s = '232'\n    target = 8\n    self.assertEqual(add_operators(s, target), ['2+3*2', '2*3+2'])\n    s = '123045'\n    target = 3\n    answer = ['1+2+3*0*4*5', '1+2+3*0*45', '1+2-3*0*4*5', '1+2-3*0*45', '1-2+3+0-4+5', '1-2+3-0-4+5', '1*2+3*0-4+5', '1*2-3*0-4+5', '1*23+0-4*5', '1*23-0-4*5', '12+3*0-4-5', '12-3*0-4-5']\n    self.assertEqual(add_operators(s, target), answer)"}}}, "TestPermuteAndAnagram": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 71}, "methods": {"test_permute": {"args": ["self"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 61}, "calls": ["test_backtrack.TestPermuteAndAnagram.assertEqual", "algorithms.backtrack.permute"], "source_code": "def test_permute(self):\n    perms = ['abc', 'bac', 'bca', 'acb', 'cab', 'cba']\n    self.assertEqual(perms, permute('abc'))"}, "test_permute_iter": {"args": ["self"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 67}, "calls": ["algorithms.backtrack.permute_iter", "range", "len", "test_backtrack.TestPermuteAndAnagram.assertEqual", "next"], "store_vars_calls": {"it": "permute_iter"}, "source_code": "def test_permute_iter(self):\n    it = permute_iter('abc')\n    perms = ['abc', 'bac', 'bca', 'acb', 'cab', 'cba']\n    for i in range(len(perms)):\n        self.assertEqual(perms[i], next(it))"}, "test_angram": {"args": ["self"], "min_max_lineno": {"min_lineno": 68, "max_lineno": 71}, "calls": ["test_backtrack.TestPermuteAndAnagram.assertTrue", "test_backtrack.TestPermuteAndAnagram.assertFalse", "algorithms.backtrack.anagram"], "source_code": "def test_angram(self):\n    self.assertTrue(anagram('apple', 'pleap'))\n    self.assertFalse(anagram('apple', 'cherry'))"}}}, "TestArrayCombinationSum": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 98}, "methods": {"test_array_sum_combinations": {"args": ["self"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 86}, "calls": ["answer.sort", "test_backtrack.TestArrayCombinationSum.assertListEqual", "sorted", "algorithms.backtrack.array_sum_combinations"], "source_code": "def test_array_sum_combinations(self):\n    A = [1, 2, 3, 3]\n    B = [2, 3, 3, 4]\n    C = [2, 3, 3, 4]\n    target = 7\n    answer = [[1, 2, 4], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 3, 3], [1, 4, 2], [2, 2, 3], [2, 2, 3], [2, 3, 2], [2, 3, 2], [3, 2, 2], [3, 2, 2]]\n    answer.sort()\n    self.assertListEqual(sorted(array_sum_combinations(A, B, C, target)), answer)"}, "test_unique_array_sum_combinations": {"args": ["self"], "min_max_lineno": {"min_lineno": 87, "max_lineno": 98}, "calls": ["answer.sort", "test_backtrack.TestArrayCombinationSum.assertListEqual", "sorted", "algorithms.backtrack.unique_array_sum_combinations"], "source_code": "def test_unique_array_sum_combinations(self):\n    A = [1, 2, 3, 3]\n    B = [2, 3, 3, 4]\n    C = [2, 3, 3, 4]\n    target = 7\n    answer = [(2, 3, 2), (3, 2, 2), (1, 2, 4), (1, 4, 2), (2, 2, 3), (1, 3, 3)]\n    answer.sort()\n    self.assertListEqual(sorted(unique_array_sum_combinations(A, B, C, target)), answer)"}}}, "TestCombinationSum": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 100, "max_lineno": 125}, "methods": {"check_sum": {"args": ["self", "nums", "target"], "returns": [["True", "nums"], ["False", "nums"]], "min_max_lineno": {"min_lineno": 102, "max_lineno": 107}, "calls": ["sum"], "source_code": "def check_sum(self, nums, target):\n    if sum(nums) == target:\n        return (True, nums)\n    else:\n        return (False, nums)"}, "test_combination_sum": {"args": ["self"], "min_max_lineno": {"min_lineno": 108, "max_lineno": 125}, "calls": ["test_backtrack.TestCombinationSum.assertEqual", "algorithms.backtrack.combination_sum"], "source_code": "def test_combination_sum(self):\n    candidates1 = [2, 3, 6, 7]\n    target1 = 7\n    answer1 = [[2, 2, 3], [7]]\n    self.assertEqual(combination_sum(candidates1, target1), answer1)\n    candidates2 = [2, 3, 5]\n    target2 = 8\n    answer2 = [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    self.assertEqual(combination_sum(candidates2, target2), answer2)"}}}, "TestFactorCombinations": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 127, "max_lineno": 174}, "methods": {"test_get_factors": {"args": ["self"], "min_max_lineno": {"min_lineno": 129, "max_lineno": 150}, "calls": ["test_backtrack.TestFactorCombinations.assertEqual", "sorted", "algorithms.backtrack.get_factors"], "source_code": "def test_get_factors(self):\n    target1 = 32\n    answer1 = [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]]\n    self.assertEqual(sorted(get_factors(target1)), sorted(answer1))\n    target2 = 12\n    answer2 = [[2, 6], [2, 2, 3], [3, 4]]\n    self.assertEqual(sorted(get_factors(target2)), sorted(answer2))\n    self.assertEqual(sorted(get_factors(1)), [])\n    self.assertEqual(sorted(get_factors(37)), [])"}, "test_recursive_get_factors": {"args": ["self"], "min_max_lineno": {"min_lineno": 151, "max_lineno": 174}, "calls": ["test_backtrack.TestFactorCombinations.assertEqual", "sorted", "algorithms.backtrack.recursive_get_factors"], "source_code": "def test_recursive_get_factors(self):\n    target1 = 32\n    answer1 = [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]]\n    self.assertEqual(sorted(recursive_get_factors(target1)), sorted(answer1))\n    target2 = 12\n    answer2 = [[2, 6], [2, 2, 3], [3, 4]]\n    self.assertEqual(sorted(recursive_get_factors(target2)), sorted(answer2))\n    self.assertEqual(sorted(recursive_get_factors(1)), [])\n    self.assertEqual(sorted(recursive_get_factors(37)), [])"}}}, "TestFindWords": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 176, "max_lineno": 223}, "methods": {"test_normal": {"args": ["self"], "min_max_lineno": {"min_lineno": 178, "max_lineno": 190}, "calls": ["algorithms.backtrack.find_words", "test_backtrack.TestFindWords.assertEqual", "sorted"], "store_vars_calls": {"result": "find_words"}, "source_code": "def test_normal(self):\n    board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']]\n    words = ['oath', 'pea', 'eat', 'rain']\n    result = find_words(board, words)\n    test_result = ['oath', 'eat']\n    self.assertEqual(sorted(result), sorted(test_result))"}, "test_none": {"args": ["self"], "min_max_lineno": {"min_lineno": 191, "max_lineno": 201}, "calls": ["test_backtrack.TestFindWords.assertEqual", "algorithms.backtrack.find_words"], "source_code": "def test_none(self):\n    board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']]\n    words = ['chicken', 'nugget', 'hello', 'world']\n    self.assertEqual(find_words(board, words), [])"}, "test_empty": {"args": ["self"], "min_max_lineno": {"min_lineno": 202, "max_lineno": 206}, "calls": ["test_backtrack.TestFindWords.assertEqual", "algorithms.backtrack.find_words"], "source_code": "def test_empty(self):\n    board = []\n    words = []\n    self.assertEqual(find_words(board, words), [])"}, "test_uneven": {"args": ["self"], "min_max_lineno": {"min_lineno": 207, "max_lineno": 214}, "calls": ["test_backtrack.TestFindWords.assertEqual", "algorithms.backtrack.find_words"], "source_code": "def test_uneven(self):\n    board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e']]\n    words = ['oath', 'pea', 'eat', 'rain']\n    self.assertEqual(find_words(board, words), ['eat'])"}, "test_repeat": {"args": ["self"], "min_max_lineno": {"min_lineno": 215, "max_lineno": 223}, "calls": ["test_backtrack.TestFindWords.assertTrue", "len", "algorithms.backtrack.find_words"], "source_code": "def test_repeat(self):\n    board = [['a', 'a', 'a'], ['a', 'a', 'a'], ['a', 'a', 'a']]\n    words = ['a', 'aa', 'aaa', 'aaaa', 'aaaaa']\n    self.assertTrue(len(find_words(board, words)) == 5)"}}}, "TestGenerateAbbreviations": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 225, "max_lineno": 241}, "methods": {"test_generate_abbreviations": {"args": ["self"], "min_max_lineno": {"min_lineno": 226, "max_lineno": 241}, "calls": ["test_backtrack.TestGenerateAbbreviations.assertEqual", "sorted", "algorithms.backtrack.generate_abbreviations"], "source_code": "def test_generate_abbreviations(self):\n    word1 = 'word'\n    answer1 = ['word', 'wor1', 'wo1d', 'wo2', 'w1rd', 'w1r1', 'w2d', 'w3', '1ord', '1or1', '1o1d', '1o2', '2rd', '2r1', '3d', '4']\n    self.assertEqual(sorted(generate_abbreviations(word1)), sorted(answer1))\n    word2 = 'hello'\n    answer2 = ['hello', 'hell1', 'hel1o', 'hel2', 'he1lo', 'he1l1', 'he2o', 'he3', 'h1llo', 'h1ll1', 'h1l1o', 'h1l2', 'h2lo', 'h2l1', 'h3o', 'h4', '1ello', '1ell1', '1el1o', '1el2', '1e1lo', '1e1l1', '1e2o', '1e3', '2llo', '2ll1', '2l1o', '2l2', '3lo', '3l1', '4o', '5']\n    self.assertEqual(sorted(generate_abbreviations(word2)), sorted(answer2))"}}}, "TestPatternMatch": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 243, "max_lineno": 256}, "methods": {"test_pattern_match": {"args": ["self"], "min_max_lineno": {"min_lineno": 245, "max_lineno": 256}, "calls": ["test_backtrack.TestPatternMatch.assertTrue", "test_backtrack.TestPatternMatch.assertFalse", "algorithms.backtrack.pattern_match"], "source_code": "def test_pattern_match(self):\n    pattern1 = 'abab'\n    string1 = 'redblueredblue'\n    pattern2 = 'aaaa'\n    string2 = 'asdasdasdasd'\n    pattern3 = 'aabb'\n    string3 = 'xyzabcxzyabc'\n    self.assertTrue(pattern_match(pattern1, string1))\n    self.assertTrue(pattern_match(pattern2, string2))\n    self.assertFalse(pattern_match(pattern3, string3))"}}}, "TestGenerateParenthesis": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 258, "max_lineno": 267}, "methods": {"test_generate_parenthesis": {"args": ["self"], "min_max_lineno": {"min_lineno": 260, "max_lineno": 267}, "calls": ["test_backtrack.TestGenerateParenthesis.assertEqual", "algorithms.backtrack.generate_parenthesis_v1", "algorithms.backtrack.generate_parenthesis_v2"], "source_code": "def test_generate_parenthesis(self):\n    self.assertEqual(generate_parenthesis_v1(2), ['()()', '(())'])\n    self.assertEqual(generate_parenthesis_v1(3), ['()()()', '()(())', '(())()', '(()())', '((()))'])\n    self.assertEqual(generate_parenthesis_v2(2), ['(())', '()()'])\n    self.assertEqual(generate_parenthesis_v2(3), ['((()))', '(()())', '(())()', '()(())', '()()()'])"}}}, "TestLetterCombinations": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 269, "max_lineno": 279}, "methods": {"test_letter_combinations": {"args": ["self"], "min_max_lineno": {"min_lineno": 271, "max_lineno": 279}, "calls": ["test_backtrack.TestLetterCombinations.assertEqual", "sorted", "algorithms.backtrack.letter_combinations"], "source_code": "def test_letter_combinations(self):\n    digit1 = '23'\n    answer1 = ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n    self.assertEqual(sorted(letter_combinations(digit1)), sorted(answer1))\n    digit2 = '34'\n    answer2 = ['dg', 'dh', 'di', 'eg', 'eh', 'ei', 'fg', 'fh', 'fi']\n    self.assertEqual(sorted(letter_combinations(digit2)), sorted(answer2))"}}}, "TestPalindromicSubstrings": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 281, "max_lineno": 301}, "methods": {"test_palindromic_substrings": {"args": ["self"], "min_max_lineno": {"min_lineno": 283, "max_lineno": 301}, "calls": ["test_backtrack.TestPalindromicSubstrings.assertEqual", "algorithms.backtrack.palindromic_substrings", "sorted"], "source_code": "def test_palindromic_substrings(self):\n    string1 = 'abc'\n    answer1 = [['a', 'b', 'c']]\n    self.assertEqual(palindromic_substrings(string1), sorted(answer1))\n    string2 = 'abcba'\n    answer2 = [['abcba'], ['a', 'bcb', 'a'], ['a', 'b', 'c', 'b', 'a']]\n    self.assertEqual(sorted(palindromic_substrings(string2)), sorted(answer2))\n    string3 = 'abcccba'\n    answer3 = [['abcccba'], ['a', 'bcccb', 'a'], ['a', 'b', 'ccc', 'b', 'a'], ['a', 'b', 'cc', 'c', 'b', 'a'], ['a', 'b', 'c', 'cc', 'b', 'a'], ['a', 'b', 'c', 'c', 'c', 'b', 'a']]\n    self.assertEqual(sorted(palindromic_substrings(string3)), sorted(answer3))"}}}, "TestPermuteUnique": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 303, "max_lineno": 320}, "methods": {"test_permute_unique": {"args": ["self"], "min_max_lineno": {"min_lineno": 305, "max_lineno": 320}, "calls": ["test_backtrack.TestPermuteUnique.assertEqual", "sorted", "algorithms.backtrack.permute_unique"], "source_code": "def test_permute_unique(self):\n    nums1 = [1, 1, 2]\n    answer1 = [[2, 1, 1], [1, 2, 1], [1, 1, 2]]\n    self.assertEqual(sorted(permute_unique(nums1)), sorted(answer1))\n    nums2 = [1, 2, 1, 3]\n    answer2 = [[3, 1, 2, 1], [1, 3, 2, 1], [1, 2, 3, 1], [1, 2, 1, 3], [3, 2, 1, 1], [2, 3, 1, 1], [2, 1, 3, 1], [2, 1, 1, 3], [3, 1, 1, 2], [1, 3, 1, 2], [1, 1, 3, 2], [1, 1, 2, 3]]\n    self.assertEqual(sorted(permute_unique(nums2)), sorted(answer2))\n    nums3 = [1, 2, 3]\n    answer3 = [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]]\n    self.assertEqual(sorted(permute_unique(nums3)), sorted(answer3))"}}}, "TestPermute": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 322, "max_lineno": 353}, "methods": {"test_permute": {"args": ["self"], "min_max_lineno": {"min_lineno": 324, "max_lineno": 338}, "calls": ["test_backtrack.TestPermute.assertEqual", "sorted", "algorithms.backtrack.permute"], "source_code": "def test_permute(self):\n    nums1 = [1, 2, 3, 4]\n    answer1 = [[1, 2, 3, 4], [2, 1, 3, 4], [2, 3, 1, 4], [2, 3, 4, 1], [1, 3, 2, 4], [3, 1, 2, 4], [3, 2, 1, 4], [3, 2, 4, 1], [1, 3, 4, 2], [3, 1, 4, 2], [3, 4, 1, 2], [3, 4, 2, 1], [1, 2, 4, 3], [2, 1, 4, 3], [2, 4, 1, 3], [2, 4, 3, 1], [1, 4, 2, 3], [4, 1, 2, 3], [4, 2, 1, 3], [4, 2, 3, 1], [1, 4, 3, 2], [4, 1, 3, 2], [4, 3, 1, 2], [4, 3, 2, 1]]\n    self.assertEqual(sorted(permute(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3]\n    answer2 = [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]]\n    self.assertEqual(sorted(permute(nums2)), sorted(answer2))"}, "test_permute_recursive": {"args": ["self"], "min_max_lineno": {"min_lineno": 339, "max_lineno": 353}, "calls": ["test_backtrack.TestPermute.assertEqual", "sorted", "algorithms.backtrack.permute_recursive"], "source_code": "def test_permute_recursive(self):\n    nums1 = [1, 2, 3, 4]\n    answer1 = [[1, 2, 3, 4], [2, 1, 3, 4], [2, 3, 1, 4], [2, 3, 4, 1], [1, 3, 2, 4], [3, 1, 2, 4], [3, 2, 1, 4], [3, 2, 4, 1], [1, 3, 4, 2], [3, 1, 4, 2], [3, 4, 1, 2], [3, 4, 2, 1], [1, 2, 4, 3], [2, 1, 4, 3], [2, 4, 1, 3], [2, 4, 3, 1], [1, 4, 2, 3], [4, 1, 2, 3], [4, 2, 1, 3], [4, 2, 3, 1], [1, 4, 3, 2], [4, 1, 3, 2], [4, 3, 1, 2], [4, 3, 2, 1]]\n    self.assertEqual(sorted(permute_recursive(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3]\n    answer2 = [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]]\n    self.assertEqual(sorted(permute_recursive(nums2)), sorted(answer2))"}}}, "TestSubsetsUnique": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 355, "max_lineno": 367}, "methods": {"test_subsets_unique": {"args": ["self"], "min_max_lineno": {"min_lineno": 357, "max_lineno": 367}, "calls": ["test_backtrack.TestSubsetsUnique.assertEqual", "sorted", "algorithms.backtrack.subsets_unique"], "source_code": "def test_subsets_unique(self):\n    nums1 = [1, 2, 2]\n    answer1 = [(1, 2), (1,), (1, 2, 2), (2,), (), (2, 2)]\n    self.assertEqual(sorted(subsets_unique(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3, 4]\n    answer2 = [(1, 2), (1, 3), (1, 2, 3, 4), (1,), (2,), (3,), (1, 4), (1, 2, 3), (4,), (), (2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 4), (2, 4)]\n    self.assertEqual(sorted(subsets_unique(nums2)), sorted(answer2))"}}}, "TestSubsets": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 369, "max_lineno": 392}, "methods": {"test_subsets": {"args": ["self"], "min_max_lineno": {"min_lineno": 371, "max_lineno": 381}, "calls": ["test_backtrack.TestSubsets.assertEqual", "sorted", "algorithms.backtrack.subsets"], "source_code": "def test_subsets(self):\n    nums1 = [1, 2, 3]\n    answer1 = [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]\n    self.assertEqual(sorted(subsets(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3, 4]\n    answer2 = [[1, 2, 3, 4], [1, 2, 3], [1, 2, 4], [1, 2], [1, 3, 4], [1, 3], [1, 4], [1], [2, 3, 4], [2, 3], [2, 4], [2], [3, 4], [3], [4], []]\n    self.assertEqual(sorted(subsets(nums2)), sorted(answer2))"}, "test_subsets_v2": {"args": ["self"], "min_max_lineno": {"min_lineno": 382, "max_lineno": 392}, "calls": ["test_backtrack.TestSubsets.assertEqual", "sorted", "algorithms.backtrack.subsets_v2"], "source_code": "def test_subsets_v2(self):\n    nums1 = [1, 2, 3]\n    answer1 = [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]\n    self.assertEqual(sorted(subsets_v2(nums1)), sorted(answer1))\n    nums2 = [1, 2, 3, 4]\n    answer2 = [[1, 2, 3, 4], [1, 2, 3], [1, 2, 4], [1, 2], [1, 3, 4], [1, 3], [1, 4], [1], [2, 3, 4], [2, 3], [2, 4], [2], [3, 4], [3], [4], []]\n    self.assertEqual(sorted(subsets_v2(nums2)), sorted(answer2))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_backtrack.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_set.py", "fileNameBase": "test_set", "extension": "py"}, "dependencies": [{"from_module": "algorithms.set", "import": "find_keyboard_row", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestFindKeyboardRow": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 13}, "methods": {"test_find_keyboard_row": {"args": ["self"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 13}, "calls": ["test_set.TestFindKeyboardRow.assertEqual", "algorithms.set.find_keyboard_row"], "source_code": "def test_find_keyboard_row(self):\n    self.assertEqual(['Alaska', 'Dad'], find_keyboard_row(['Hello', 'Alaska', 'Dad', 'Peace']))"}}}}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_map.py", "fileNameBase": "test_map", "extension": "py"}, "dependencies": [{"from_module": "algorithms.map", "import": "HashTable", "type": "external", "type_element": "module"}, {"from_module": "algorithms.map", "import": "ResizableHashTable", "type": "external", "type_element": "module"}, {"from_module": "algorithms.map", "import": "SeparateChainingHashTable", "type": "external", "type_element": "module"}, {"from_module": "algorithms.map", "import": "word_pattern", "type": "external", "type_element": "module"}, {"from_module": "algorithms.map", "import": "is_isomorphic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.map", "import": "is_anagram", "type": "external", "type_element": "module"}, {"from_module": "algorithms.map", "import": "longest_palindromic_subsequence", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestHashTable": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 98}, "methods": {"test_one_entry": {"args": ["self"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 18}, "calls": ["algorithms.map.HashTable", "algorithms.map.HashTable.put", "test_map.TestHashTable.assertEqual", "algorithms.map.HashTable.get"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_one_entry(self):\n    m = HashTable(10)\n    m.put(1, '1')\n    self.assertEqual('1', m.get(1))"}, "test_add_entry_bigger_than_table_size": {"args": ["self"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 23}, "calls": ["algorithms.map.HashTable", "algorithms.map.HashTable.put", "test_map.TestHashTable.assertEqual", "algorithms.map.HashTable.get"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_add_entry_bigger_than_table_size(self):\n    m = HashTable(10)\n    m.put(11, '1')\n    self.assertEqual('1', m.get(11))"}, "test_get_none_if_key_missing_and_hash_collision": {"args": ["self"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 28}, "calls": ["algorithms.map.HashTable", "algorithms.map.HashTable.put", "test_map.TestHashTable.assertEqual", "algorithms.map.HashTable.get"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_get_none_if_key_missing_and_hash_collision(self):\n    m = HashTable(10)\n    m.put(1, '1')\n    self.assertEqual(None, m.get(11))"}, "test_two_entries_with_same_hash": {"args": ["self"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 35}, "calls": ["algorithms.map.HashTable", "algorithms.map.HashTable.put", "test_map.TestHashTable.assertEqual", "algorithms.map.HashTable.get"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_two_entries_with_same_hash(self):\n    m = HashTable(10)\n    m.put(1, '1')\n    m.put(11, '11')\n    self.assertEqual('1', m.get(1))\n    self.assertEqual('11', m.get(11))"}, "test_get_on_full_table_does_halts": {"args": ["self"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 42}, "calls": ["algorithms.map.HashTable", "range", "test_map.TestHashTable.assertEqual", "algorithms.map.HashTable.put", "algorithms.map.HashTable.get"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_get_on_full_table_does_halts(self):\n    m = HashTable(10)\n    for i in range(10, 20):\n        m.put(i, i)\n    self.assertEqual(None, m.get(1))"}, "test_delete_key": {"args": ["self"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 50}, "calls": ["algorithms.map.HashTable", "range", "algorithms.map.HashTable.del_", "test_map.TestHashTable.assertEqual", "algorithms.map.HashTable.put", "algorithms.map.HashTable.get"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_delete_key(self):\n    m = HashTable(10)\n    for i in range(5):\n        m.put(i, i ** 2)\n    m.del_(1)\n    self.assertEqual(None, m.get(1))\n    self.assertEqual(4, m.get(2))"}, "test_delete_key_and_reassign": {"args": ["self"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 57}, "calls": ["algorithms.map.HashTable", "algorithms.map.HashTable.put", "test_map.TestHashTable.assertEqual", "algorithms.map.HashTable.get"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_delete_key_and_reassign(self):\n    m = HashTable(10)\n    m.put(1, 1)\n    del m[1]\n    m.put(1, 2)\n    self.assertEqual(2, m.get(1))"}, "test_assigning_to_full_table_throws_error": {"args": ["self"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 65}, "calls": ["algorithms.map.HashTable", "algorithms.map.HashTable.put", "test_map.TestHashTable.assertRaises"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_assigning_to_full_table_throws_error(self):\n    m = HashTable(3)\n    m.put(1, 1)\n    m.put(2, 2)\n    m.put(3, 3)\n    with self.assertRaises(ValueError):\n        m.put(4, 4)"}, "test_len_trivial": {"args": ["self"], "min_max_lineno": {"min_lineno": 66, "max_lineno": 72}, "calls": ["algorithms.map.HashTable", "test_map.TestHashTable.assertEqual", "range", "len", "algorithms.map.HashTable.put"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_len_trivial(self):\n    m = HashTable(10)\n    self.assertEqual(0, len(m))\n    for i in range(10):\n        m.put(i, i)\n        self.assertEqual(i + 1, len(m))"}, "test_len_after_deletions": {"args": ["self"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 81}, "calls": ["algorithms.map.HashTable", "algorithms.map.HashTable.put", "test_map.TestHashTable.assertEqual", "algorithms.map.HashTable.del_", "len"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_len_after_deletions(self):\n    m = HashTable(10)\n    m.put(1, 1)\n    self.assertEqual(1, len(m))\n    m.del_(1)\n    self.assertEqual(0, len(m))\n    m.put(11, 42)\n    self.assertEqual(1, len(m))"}, "test_resizable_hash_table": {"args": ["self"], "min_max_lineno": {"min_lineno": 82, "max_lineno": 91}, "calls": ["algorithms.map.ResizableHashTable", "test_map.TestHashTable.assertEqual", "range", "algorithms.map.ResizableHashTable.put", "algorithms.map.ResizableHashTable.get"], "store_vars_calls": {"m": "ResizableHashTable"}, "source_code": "def test_resizable_hash_table(self):\n    m = ResizableHashTable()\n    self.assertEqual(ResizableHashTable.MIN_SIZE, m.size)\n    for i in range(ResizableHashTable.MIN_SIZE):\n        m.put(i, 'foo')\n    self.assertEqual(ResizableHashTable.MIN_SIZE * 2, m.size)\n    self.assertEqual('foo', m.get(1))\n    self.assertEqual('foo', m.get(3))\n    self.assertEqual('foo', m.get(ResizableHashTable.MIN_SIZE - 1))"}, "test_fill_up_the_limit": {"args": ["self"], "min_max_lineno": {"min_lineno": 92, "max_lineno": 98}, "calls": ["algorithms.map.HashTable", "range", "algorithms.map.HashTable.put", "test_map.TestHashTable.assertEqual", "algorithms.map.HashTable.get"], "store_vars_calls": {"m": "HashTable"}, "source_code": "def test_fill_up_the_limit(self):\n    m = HashTable(10)\n    for i in range(10):\n        m.put(i, i ** 2)\n    for i in range(10):\n        self.assertEqual(i ** 2, m.get(i))"}}}, "TestSeparateChainingHashTable": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 100, "max_lineno": 153}, "methods": {"test_one_entry": {"args": ["self"], "min_max_lineno": {"min_lineno": 101, "max_lineno": 105}, "calls": ["algorithms.map.SeparateChainingHashTable", "algorithms.map.SeparateChainingHashTable.put", "test_map.TestSeparateChainingHashTable.assertEqual", "algorithms.map.SeparateChainingHashTable.get"], "store_vars_calls": {"m": "SeparateChainingHashTable"}, "source_code": "def test_one_entry(self):\n    m = SeparateChainingHashTable(10)\n    m.put(1, '1')\n    self.assertEqual('1', m.get(1))"}, "test_two_entries_with_same_hash": {"args": ["self"], "min_max_lineno": {"min_lineno": 106, "max_lineno": 112}, "calls": ["algorithms.map.SeparateChainingHashTable", "algorithms.map.SeparateChainingHashTable.put", "test_map.TestSeparateChainingHashTable.assertEqual", "algorithms.map.SeparateChainingHashTable.get"], "store_vars_calls": {"m": "SeparateChainingHashTable"}, "source_code": "def test_two_entries_with_same_hash(self):\n    m = SeparateChainingHashTable(10)\n    m.put(1, '1')\n    m.put(11, '11')\n    self.assertEqual('1', m.get(1))\n    self.assertEqual('11', m.get(11))"}, "test_len_trivial": {"args": ["self"], "min_max_lineno": {"min_lineno": 113, "max_lineno": 119}, "calls": ["algorithms.map.SeparateChainingHashTable", "test_map.TestSeparateChainingHashTable.assertEqual", "range", "len", "algorithms.map.SeparateChainingHashTable.put"], "store_vars_calls": {"m": "SeparateChainingHashTable"}, "source_code": "def test_len_trivial(self):\n    m = SeparateChainingHashTable(10)\n    self.assertEqual(0, len(m))\n    for i in range(10):\n        m.put(i, i)\n        self.assertEqual(i + 1, len(m))"}, "test_len_after_deletions": {"args": ["self"], "min_max_lineno": {"min_lineno": 120, "max_lineno": 128}, "calls": ["algorithms.map.SeparateChainingHashTable", "algorithms.map.SeparateChainingHashTable.put", "test_map.TestSeparateChainingHashTable.assertEqual", "algorithms.map.SeparateChainingHashTable.del_", "len"], "store_vars_calls": {"m": "SeparateChainingHashTable"}, "source_code": "def test_len_after_deletions(self):\n    m = SeparateChainingHashTable(10)\n    m.put(1, 1)\n    self.assertEqual(1, len(m))\n    m.del_(1)\n    self.assertEqual(0, len(m))\n    m.put(11, 42)\n    self.assertEqual(1, len(m))"}, "test_delete_key": {"args": ["self"], "min_max_lineno": {"min_lineno": 129, "max_lineno": 136}, "calls": ["algorithms.map.SeparateChainingHashTable", "range", "algorithms.map.SeparateChainingHashTable.del_", "test_map.TestSeparateChainingHashTable.assertEqual", "algorithms.map.SeparateChainingHashTable.put", "algorithms.map.SeparateChainingHashTable.get"], "store_vars_calls": {"m": "SeparateChainingHashTable"}, "source_code": "def test_delete_key(self):\n    m = SeparateChainingHashTable(10)\n    for i in range(5):\n        m.put(i, i ** 2)\n    m.del_(1)\n    self.assertEqual(None, m.get(1))\n    self.assertEqual(4, m.get(2))"}, "test_delete_key_and_reassign": {"args": ["self"], "min_max_lineno": {"min_lineno": 137, "max_lineno": 143}, "calls": ["algorithms.map.SeparateChainingHashTable", "algorithms.map.SeparateChainingHashTable.put", "test_map.TestSeparateChainingHashTable.assertEqual", "algorithms.map.SeparateChainingHashTable.get"], "store_vars_calls": {"m": "SeparateChainingHashTable"}, "source_code": "def test_delete_key_and_reassign(self):\n    m = SeparateChainingHashTable(10)\n    m.put(1, 1)\n    del m[1]\n    m.put(1, 2)\n    self.assertEqual(2, m.get(1))"}, "test_add_entry_bigger_than_table_size": {"args": ["self"], "min_max_lineno": {"min_lineno": 144, "max_lineno": 148}, "calls": ["algorithms.map.SeparateChainingHashTable", "algorithms.map.SeparateChainingHashTable.put", "test_map.TestSeparateChainingHashTable.assertEqual", "algorithms.map.SeparateChainingHashTable.get"], "store_vars_calls": {"m": "SeparateChainingHashTable"}, "source_code": "def test_add_entry_bigger_than_table_size(self):\n    m = SeparateChainingHashTable(10)\n    m.put(11, '1')\n    self.assertEqual('1', m.get(11))"}, "test_get_none_if_key_missing_and_hash_collision": {"args": ["self"], "min_max_lineno": {"min_lineno": 149, "max_lineno": 153}, "calls": ["algorithms.map.SeparateChainingHashTable", "algorithms.map.SeparateChainingHashTable.put", "test_map.TestSeparateChainingHashTable.assertEqual", "algorithms.map.SeparateChainingHashTable.get"], "store_vars_calls": {"m": "SeparateChainingHashTable"}, "source_code": "def test_get_none_if_key_missing_and_hash_collision(self):\n    m = SeparateChainingHashTable(10)\n    m.put(1, '1')\n    self.assertEqual(None, m.get(11))"}}}, "TestWordPattern": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 155, "max_lineno": 161}, "methods": {"test_word_pattern": {"args": ["self"], "min_max_lineno": {"min_lineno": 156, "max_lineno": 161}, "calls": ["test_map.TestWordPattern.assertTrue", "test_map.TestWordPattern.assertFalse", "algorithms.map.word_pattern"], "source_code": "def test_word_pattern(self):\n    self.assertTrue(word_pattern('abba', 'dog cat cat dog'))\n    self.assertFalse(word_pattern('abba', 'dog cat cat fish'))\n    self.assertFalse(word_pattern('abba', 'dog dog dog dog'))\n    self.assertFalse(word_pattern('aaaa', 'dog cat cat dog'))"}}}, "TestIsSomorphic": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 163, "max_lineno": 168}, "methods": {"test_is_isomorphic": {"args": ["self"], "min_max_lineno": {"min_lineno": 164, "max_lineno": 168}, "calls": ["test_map.TestIsSomorphic.assertTrue", "test_map.TestIsSomorphic.assertFalse", "algorithms.map.is_isomorphic"], "source_code": "def test_is_isomorphic(self):\n    self.assertTrue(is_isomorphic('egg', 'add'))\n    self.assertFalse(is_isomorphic('foo', 'bar'))\n    self.assertTrue(is_isomorphic('paper', 'title'))"}}}, "TestLongestPalindromicSubsequence": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 170, "max_lineno": 182}, "methods": {"test_longest_palindromic_subsequence_is_correct": {"args": ["self"], "min_max_lineno": {"min_lineno": 171, "max_lineno": 176}, "calls": ["test_map.TestLongestPalindromicSubsequence.assertEqual", "algorithms.map.longest_palindromic_subsequence"], "source_code": "def test_longest_palindromic_subsequence_is_correct(self):\n    self.assertEqual(3, longest_palindromic_subsequence('BBABCBCAB'))\n    self.assertEqual(4, longest_palindromic_subsequence('abbaeae'))\n    self.assertEqual(7, longest_palindromic_subsequence('babbbababaa'))\n    self.assertEqual(4, longest_palindromic_subsequence('daccandeeja'))"}, "test_longest_palindromic_subsequence_is_incorrect": {"args": ["self"], "min_max_lineno": {"min_lineno": 177, "max_lineno": 182}, "calls": ["test_map.TestLongestPalindromicSubsequence.assertNotEqual", "algorithms.map.longest_palindromic_subsequence"], "source_code": "def test_longest_palindromic_subsequence_is_incorrect(self):\n    self.assertNotEqual(4, longest_palindromic_subsequence('BBABCBCAB'))\n    self.assertNotEqual(5, longest_palindromic_subsequence('abbaeae'))\n    self.assertNotEqual(2, longest_palindromic_subsequence('babbbababaa'))\n    self.assertNotEqual(1, longest_palindromic_subsequence('daccandeeja'))"}}}, "TestIsAnagram": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 184, "max_lineno": 188}, "methods": {"test_is_anagram": {"args": ["self"], "min_max_lineno": {"min_lineno": 185, "max_lineno": 188}, "calls": ["test_map.TestIsAnagram.assertTrue", "test_map.TestIsAnagram.assertFalse", "algorithms.map.is_anagram"], "source_code": "def test_is_anagram(self):\n    self.assertTrue(is_anagram('anagram', 'nagaram'))\n    self.assertFalse(is_anagram('rat', 'car'))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_map.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_queues.py", "fileNameBase": "test_queues", "extension": "py"}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "algorithms.queues", "import": "ArrayQueue", "type": "external", "type_element": "module"}, {"from_module": "algorithms.queues", "import": "LinkedListQueue", "type": "external", "type_element": "module"}, {"from_module": "algorithms.queues", "import": "max_sliding_window", "type": "external", "type_element": "module"}, {"from_module": "algorithms.queues", "import": "reconstruct_queue", "type": "external", "type_element": "module"}, {"from_module": "algorithms.queues", "import": "PriorityQueue", "type": "external", "type_element": "module"}], "classes": {"TestQueue": {"doc": {"short_description": "Test suite for the Queue data structures.", "full": "Test suite for the Queue data structures."}, "extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 73}, "methods": {"test_ArrayQueue": {"args": ["self"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 44}, "calls": ["algorithms.queues.ArrayQueue", "algorithms.queues.ArrayQueue.enqueue", "iter", "test_queues.TestQueue.assertEqual", "test_queues.TestQueue.assertRaises", "test_queues.TestQueue.assertFalse", "test_queues.TestQueue.assertTrue", "next", "len", "algorithms.queues.ArrayQueue.is_empty", "algorithms.queues.ArrayQueue.peek", "algorithms.queues.ArrayQueue.dequeue"], "store_vars_calls": {"queue": "ArrayQueue", "it": "iter"}, "source_code": "def test_ArrayQueue(self):\n    queue = ArrayQueue()\n    queue.enqueue(1)\n    queue.enqueue(2)\n    queue.enqueue(3)\n    it = iter(queue)\n    self.assertEqual(1, next(it))\n    self.assertEqual(2, next(it))\n    self.assertEqual(3, next(it))\n    self.assertRaises(StopIteration, next, it)\n    self.assertEqual(3, len(queue))\n    self.assertFalse(queue.is_empty())\n    self.assertEqual(1, queue.peek())\n    self.assertEqual(1, queue.dequeue())\n    self.assertEqual(2, queue.dequeue())\n    self.assertEqual(3, queue.dequeue())\n    self.assertTrue(queue.is_empty())"}, "test_LinkedListQueue": {"args": ["self"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 73}, "calls": ["algorithms.queues.LinkedListQueue", "algorithms.queues.LinkedListQueue.enqueue", "iter", "test_queues.TestQueue.assertEqual", "test_queues.TestQueue.assertRaises", "test_queues.TestQueue.assertFalse", "test_queues.TestQueue.assertTrue", "next", "len", "algorithms.queues.LinkedListQueue.is_empty", "algorithms.queues.LinkedListQueue.peek", "algorithms.queues.LinkedListQueue.dequeue"], "store_vars_calls": {"queue": "LinkedListQueue", "it": "iter"}, "source_code": "def test_LinkedListQueue(self):\n    queue = LinkedListQueue()\n    queue.enqueue(1)\n    queue.enqueue(2)\n    queue.enqueue(3)\n    it = iter(queue)\n    self.assertEqual(1, next(it))\n    self.assertEqual(2, next(it))\n    self.assertEqual(3, next(it))\n    self.assertRaises(StopIteration, next, it)\n    self.assertEqual(3, len(queue))\n    self.assertFalse(queue.is_empty())\n    self.assertEqual(1, queue.peek())\n    self.assertEqual(1, queue.dequeue())\n    self.assertEqual(2, queue.dequeue())\n    self.assertEqual(3, queue.dequeue())\n    self.assertTrue(queue.is_empty())"}}}, "TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 93}, "methods": {"test_max_sliding_window": {"args": ["self"], "min_max_lineno": {"min_lineno": 76, "max_lineno": 88}, "calls": ["test_queues.TestSuite.assertEqual", "algorithms.queues.max_sliding_window"], "source_code": "def test_max_sliding_window(self):\n    array = [1, 3, -1, -3, 5, 3, 6, 7]\n    self.assertEqual(max_sliding_window(array, k=5), [5, 5, 6, 7])\n    self.assertEqual(max_sliding_window(array, k=3), [3, 3, 5, 5, 6, 7])\n    self.assertEqual(max_sliding_window(array, k=7), [6, 7])\n    array = [8, 5, 10, 7, 9, 4, 15, 12, 90, 13]\n    self.assertEqual(max_sliding_window(array, k=4), [10, 10, 10, 15, 15, 90, 90])\n    self.assertEqual(max_sliding_window(array, k=7), [15, 15, 90, 90])\n    self.assertEqual(max_sliding_window(array, k=2), [8, 10, 10, 9, 9, 15, 15, 90, 90])"}, "test_reconstruct_queue": {"args": ["self"], "min_max_lineno": {"min_lineno": 89, "max_lineno": 93}, "calls": ["test_queues.TestSuite.assertEqual", "algorithms.queues.reconstruct_queue"], "source_code": "def test_reconstruct_queue(self):\n    self.assertEqual([[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]], reconstruct_queue([[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]))"}}}, "TestPriorityQueue": {"doc": {"short_description": "Test suite for the PriorityQueue data structures.", "full": "Test suite for the PriorityQueue data structures.\n    "}, "extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 95, "max_lineno": 107}, "methods": {"test_PriorityQueue": {"args": ["self"], "min_max_lineno": {"min_lineno": 99, "max_lineno": 107}, "calls": ["algorithms.queues.PriorityQueue", "test_queues.TestPriorityQueue.assertEqual", "algorithms.queues.PriorityQueue.push", "algorithms.queues.PriorityQueue.size", "algorithms.queues.PriorityQueue.pop"], "store_vars_calls": {"queue": "PriorityQueue"}, "source_code": "def test_PriorityQueue(self):\n    queue = PriorityQueue([3, 4, 1, 6])\n    self.assertEqual(4, queue.size())\n    self.assertEqual(1, queue.pop())\n    self.assertEqual(3, queue.size())\n    queue.push(2)\n    self.assertEqual(4, queue.size())\n    self.assertEqual(2, queue.pop())"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_queues.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_compression.py", "fileNameBase": "test_compression", "extension": "py"}, "dependencies": [{"from_module": "algorithms.compression.huffman_coding", "import": "HuffmanCoding", "type": "external", "type_element": "module"}, {"from_module": "algorithms.compression.rle_compression", "import": "decode_rle", "type": "external", "type_element": "module"}, {"from_module": "algorithms.compression.rle_compression", "import": "encode_rle", "type": "external", "type_element": "module"}, {"from_module": "algorithms.compression.elias", "import": "elias_gamma", "type": "external", "type_element": "module"}, {"from_module": "algorithms.compression.elias", "import": "elias_delta", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestHuffmanCoding": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 37}, "methods": {"setUpClass": {"args": ["cls"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 14}, "source_code": "@classmethod\ndef setUpClass(cls):\n    cls.file_in_name = 'huffman_coding_in.txt'\n    cls.file_out_bin_name = 'huffman_coding_out.bin'\n    cls.file_out_name = 'huffman_coding_out.txt'"}, "setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 21}, "calls": ["random.seed", "open", "range", "file_in.write", "bytes", "random.randrange"], "source_code": "def setUp(self):\n    import random\n    random.seed(1951)\n    with open(self.file_in_name, 'wb') as file_in:\n        for i in range(10000):\n            file_in.write(bytes([random.randrange(0, 256)]))"}, "test_huffman_coding": {"args": ["self"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 31}, "calls": ["algorithms.compression.huffman_coding.HuffmanCoding.encode_file", "algorithms.compression.huffman_coding.HuffmanCoding.decode_file", "open", "file_1.read", "file_2.read", "test_compression.TestHuffmanCoding.assertEqual"], "store_vars_calls": {"content_1": "file_1.read", "content_2": "file_2.read"}, "source_code": "def test_huffman_coding(self):\n    HuffmanCoding.encode_file(self.file_in_name, self.file_out_bin_name)\n    HuffmanCoding.decode_file(self.file_out_bin_name, self.file_out_name)\n    with open(self.file_in_name, 'rb') as file_1, open(self.file_out_name, 'rb') as file_2:\n        content_1 = file_1.read()\n        content_2 = file_2.read()\n        self.assertEqual(content_1, content_2)"}, "tearDown": {"args": ["self"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 37}, "calls": ["os.remove"], "source_code": "def tearDown(self):\n    import os\n    os.remove(self.file_in_name)\n    os.remove(self.file_out_bin_name)\n    os.remove(self.file_out_name)"}}}, "TestRLECompression": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 48}, "methods": {"test_encode_rle": {"args": ["self"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 44}, "calls": ["test_compression.TestRLECompression.assertEqual", "algorithms.compression.rle_compression.encode_rle"], "source_code": "def test_encode_rle(self):\n    self.assertEqual('12W1B12W3B24W1B14W', encode_rle('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'))"}, "test_decode_rle": {"args": ["self"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 48}, "calls": ["test_compression.TestRLECompression.assertEqual", "algorithms.compression.rle_compression.decode_rle"], "source_code": "def test_decode_rle(self):\n    self.assertEqual('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW', decode_rle('12W1B12W3B24W1B14W'))"}}}, "TestEliasCoding": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 71}, "methods": {"test_elias_gamma": {"args": ["self"], "min_max_lineno": {"min_lineno": 52, "max_lineno": 61}, "calls": ["range", "test_compression.TestEliasCoding.assertEqual", "result.append", "algorithms.compression.elias.elias_gamma"], "source_code": "def test_elias_gamma(self):\n    correct_result = ['0', '00', '100', '101', '11000', '11001', '11010', '11011', '1110000', '1110001', '1110010']\n    result = []\n    for i in range(11):\n        result.append(elias_gamma(i))\n    self.assertEqual(correct_result, result)"}, "test_elias_delta": {"args": ["self"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 71}, "calls": ["range", "test_compression.TestEliasCoding.assertEqual", "result.append", "algorithms.compression.elias.elias_delta"], "source_code": "def test_elias_delta(self):\n    correct_result = ['0', '000', '1000', '1001', '10100', '10101', '10110', '10111', '11000000', '11000001', '11000010']\n    result = []\n    for i in range(11):\n        result.append(elias_delta(i))\n    self.assertEqual(correct_result, result)"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_compression.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_dp.py", "fileNameBase": "test_dp", "extension": "py"}, "dependencies": [{"from_module": "algorithms.dp", "import": "max_profit_naive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "max_profit_optimized", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "climb_stairs", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "climb_stairs_optimized", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "count", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "combination_sum_topdown", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "combination_sum_bottom_up", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "edit_distance", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "egg_drop", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "fib_recursive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "fib_list", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "fib_iter", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "hosoya_testing", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "house_robber", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "Job", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "schedule", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "Item", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "get_maximum_value", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "longest_increasing_subsequence", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "longest_increasing_subsequence_optimized", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "longest_increasing_subsequence_optimized2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "int_divide", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "find_k_factor", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "planting_trees", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dp", "import": "regex_matching", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestBuySellStock": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 32}, "methods": {"test_max_profit_naive": {"args": ["self"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 28}, "calls": ["test_dp.TestBuySellStock.assertEqual", "algorithms.dp.max_profit_naive"], "source_code": "def test_max_profit_naive(self):\n    self.assertEqual(max_profit_naive([7, 1, 5, 3, 6, 4]), 5)\n    self.assertEqual(max_profit_naive([7, 6, 4, 3, 1]), 0)"}, "test_max_profit_optimized": {"args": ["self"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 32}, "calls": ["test_dp.TestBuySellStock.assertEqual", "algorithms.dp.max_profit_optimized"], "source_code": "def test_max_profit_optimized(self):\n    self.assertEqual(max_profit_optimized([7, 1, 5, 3, 6, 4]), 5)\n    self.assertEqual(max_profit_optimized([7, 6, 4, 3, 1]), 0)"}}}, "TestClimbingStairs": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 42}, "methods": {"test_climb_stairs": {"args": ["self"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 38}, "calls": ["test_dp.TestClimbingStairs.assertEqual", "algorithms.dp.climb_stairs"], "source_code": "def test_climb_stairs(self):\n    self.assertEqual(climb_stairs(2), 2)\n    self.assertEqual(climb_stairs(10), 89)"}, "test_climb_stairs_optimized": {"args": ["self"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 42}, "calls": ["test_dp.TestClimbingStairs.assertEqual", "algorithms.dp.climb_stairs_optimized"], "source_code": "def test_climb_stairs_optimized(self):\n    self.assertEqual(climb_stairs_optimized(2), 2)\n    self.assertEqual(climb_stairs_optimized(10), 89)"}}}, "TestCoinChange": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 48}, "methods": {"test_count": {"args": ["self"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 48}, "calls": ["test_dp.TestCoinChange.assertEqual", "algorithms.dp.count"], "source_code": "def test_count(self):\n    self.assertEqual(count([1, 2, 3], 4), 4)\n    self.assertEqual(count([2, 5, 3, 6], 10), 5)"}}}, "TestCombinationSum": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 56}, "methods": {"test_combination_sum_topdown": {"args": ["self"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 53}, "calls": ["test_dp.TestCombinationSum.assertEqual", "algorithms.dp.combination_sum_topdown"], "source_code": "def test_combination_sum_topdown(self):\n    self.assertEqual(combination_sum_topdown([1, 2, 3], 4), 7)"}, "test_combination_sum_bottom_up": {"args": ["self"], "min_max_lineno": {"min_lineno": 54, "max_lineno": 56}, "calls": ["test_dp.TestCombinationSum.assertEqual", "algorithms.dp.combination_sum_bottom_up"], "source_code": "def test_combination_sum_bottom_up(self):\n    self.assertEqual(combination_sum_bottom_up([1, 2, 3], 4), 7)"}}}, "TestEditDistance": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 62}, "methods": {"test_edit_distance": {"args": ["self"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 62}, "calls": ["test_dp.TestEditDistance.assertEqual", "algorithms.dp.edit_distance"], "source_code": "def test_edit_distance(self):\n    self.assertEqual(edit_distance('food', 'money'), 4)\n    self.assertEqual(edit_distance('horse', 'ros'), 3)"}}}, "TestEggDrop": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 64, "max_lineno": 69}, "methods": {"test_egg_drop": {"args": ["self"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 69}, "calls": ["test_dp.TestEggDrop.assertEqual", "algorithms.dp.egg_drop"], "source_code": "def test_egg_drop(self):\n    self.assertEqual(egg_drop(1, 2), 2)\n    self.assertEqual(egg_drop(2, 6), 3)\n    self.assertEqual(egg_drop(3, 14), 4)"}}}, "TestFib": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 71, "max_lineno": 83}, "methods": {"test_fib_recursive": {"args": ["self"], "min_max_lineno": {"min_lineno": 72, "max_lineno": 75}, "calls": ["test_dp.TestFib.assertEqual", "algorithms.dp.fib_recursive"], "source_code": "def test_fib_recursive(self):\n    self.assertEqual(fib_recursive(10), 55)\n    self.assertEqual(fib_recursive(30), 832040)"}, "test_fib_list": {"args": ["self"], "min_max_lineno": {"min_lineno": 76, "max_lineno": 79}, "calls": ["test_dp.TestFib.assertEqual", "algorithms.dp.fib_list"], "source_code": "def test_fib_list(self):\n    self.assertEqual(fib_list(10), 55)\n    self.assertEqual(fib_list(30), 832040)"}, "test_fib_iter": {"args": ["self"], "min_max_lineno": {"min_lineno": 80, "max_lineno": 83}, "calls": ["test_dp.TestFib.assertEqual", "algorithms.dp.fib_iter"], "source_code": "def test_fib_iter(self):\n    self.assertEqual(fib_iter(10), 55)\n    self.assertEqual(fib_iter(30), 832040)"}}}, "TestHosoyaTriangle": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 85, "max_lineno": 113}, "methods": {"test_hosoya": {"args": ["self"], "min_max_lineno": {"min_lineno": 93, "max_lineno": 113}, "calls": ["test_dp.TestHosoyaTriangle.assertEqual", "algorithms.dp.hosoya_testing"], "source_code": "def test_hosoya(self):\n    self.assertEqual([1], hosoya_testing(1))\n    self.assertEqual([1, 1, 1, 2, 1, 2, 3, 2, 2, 3, 5, 3, 4, 3, 5, 8, 5, 6, 6, 5, 8], hosoya_testing(6))\n    self.assertEqual([1, 1, 1, 2, 1, 2, 3, 2, 2, 3, 5, 3, 4, 3, 5, 8, 5, 6, 6, 5, 8, 13, 8, 10, 9, 10, 8, 13, 21, 13, 16, 15, 15, 16, 13, 21, 34, 21, 26, 24, 25, 24, 26, 21, 34, 55, 34, 42, 39, 40, 40, 39, 42, 34, 55], hosoya_testing(10))"}}}, "TestHouseRobber": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 115, "max_lineno": 118}, "methods": {"test_house_robber": {"args": ["self"], "min_max_lineno": {"min_lineno": 116, "max_lineno": 118}, "calls": ["test_dp.TestHouseRobber.assertEqual", "algorithms.dp.house_robber"], "source_code": "def test_house_robber(self):\n    self.assertEqual(44, house_robber([1, 2, 16, 3, 15, 3, 12, 1]))"}}}, "TestJobScheduling": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 120, "max_lineno": 124}, "methods": {"test_job_scheduling": {"args": ["self"], "min_max_lineno": {"min_lineno": 121, "max_lineno": 124}, "calls": ["test_dp.TestJobScheduling.assertEqual", "algorithms.dp.Job", "algorithms.dp.schedule"], "source_code": "def test_job_scheduling(self):\n    (job1, job2) = (Job(1, 3, 2), Job(2, 3, 4))\n    self.assertEqual(4, schedule([job1, job2]))"}}}, "TestKnapsack": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 126, "max_lineno": 134}, "methods": {"test_get_maximum_value": {"args": ["self"], "min_max_lineno": {"min_lineno": 127, "max_lineno": 134}, "calls": ["test_dp.TestKnapsack.assertEqual", "algorithms.dp.Item", "algorithms.dp.get_maximum_value"], "source_code": "def test_get_maximum_value(self):\n    (item1, item2, item3) = (Item(60, 10), Item(100, 20), Item(120, 30))\n    self.assertEqual(220, get_maximum_value([item1, item2, item3], 50))\n    (item1, item2, item3, item4) = (Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2))\n    self.assertEqual(80, get_maximum_value([item1, item2, item3, item4], 5))"}}}, "TestLongestIncreasingSubsequence": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 136, "max_lineno": 140}, "methods": {"test_longest_increasing_subsequence": {"args": ["self"], "min_max_lineno": {"min_lineno": 137, "max_lineno": 140}, "calls": ["test_dp.TestLongestIncreasingSubsequence.assertEqual", "algorithms.dp.longest_increasing_subsequence"], "source_code": "def test_longest_increasing_subsequence(self):\n    sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n    self.assertEqual(5, longest_increasing_subsequence(sequence))"}}}, "TestLongestIncreasingSubsequenceOptimized": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 142, "max_lineno": 146}, "methods": {"test_longest_increasing_subsequence_optimized": {"args": ["self"], "min_max_lineno": {"min_lineno": 143, "max_lineno": 146}, "calls": ["test_dp.TestLongestIncreasingSubsequenceOptimized.assertEqual", "algorithms.dp.longest_increasing_subsequence"], "source_code": "def test_longest_increasing_subsequence_optimized(self):\n    sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n    self.assertEqual(5, longest_increasing_subsequence(sequence))"}}}, "TestLongestIncreasingSubsequenceOptimized2": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 148, "max_lineno": 152}, "methods": {"test_longest_increasing_subsequence_optimized2": {"args": ["self"], "min_max_lineno": {"min_lineno": 149, "max_lineno": 152}, "calls": ["test_dp.TestLongestIncreasingSubsequenceOptimized2.assertEqual", "algorithms.dp.longest_increasing_subsequence"], "source_code": "def test_longest_increasing_subsequence_optimized2(self):\n    sequence = [1, 101, 10, 2, 3, 100, 4, 6, 2]\n    self.assertEqual(5, longest_increasing_subsequence(sequence))"}}}, "TestIntDivide": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 154, "max_lineno": 159}, "methods": {"test_int_divide": {"args": ["self"], "min_max_lineno": {"min_lineno": 155, "max_lineno": 159}, "calls": ["test_dp.TestIntDivide.assertEqual", "algorithms.dp.int_divide"], "source_code": "def test_int_divide(self):\n    self.assertEqual(5, int_divide(4))\n    self.assertEqual(42, int_divide(10))\n    self.assertEqual(204226, int_divide(50))"}}}, "Test_dp_K_Factor": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 161, "max_lineno": 187}, "methods": {"test_kfactor": {"args": ["self"], "min_max_lineno": {"min_lineno": 162, "max_lineno": 187}, "calls": ["test_dp.Test_dp_K_Factor.assertEqual", "algorithms.dp.find_k_factor"], "source_code": "def test_kfactor(self):\n    n1 = 4\n    k1 = 1\n    self.assertEqual(find_k_factor(n1, k1), 1)\n    n2 = 7\n    k2 = 1\n    self.assertEqual(find_k_factor(n2, k2), 70302)\n    n3 = 10\n    k3 = 2\n    self.assertEqual(find_k_factor(n3, k3), 74357)\n    n4 = 8\n    k4 = 2\n    self.assertEqual(find_k_factor(n4, k4), 53)\n    n5 = 9\n    k5 = 1\n    self.assertEqual(find_k_factor(n5, k5), 71284044)"}}}, "TestPlantingTrees": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 189, "max_lineno": 213}, "methods": {"test_simple": {"args": ["self"], "min_max_lineno": {"min_lineno": 190, "max_lineno": 201}, "calls": ["algorithms.dp.planting_trees", "test_dp.TestPlantingTrees.assertEqual"], "store_vars_calls": {"res": "planting_trees"}, "source_code": "def test_simple(self):\n    trees = [0, 1, 10, 10]\n    L = 10\n    W = 1\n    res = planting_trees(trees, L, W)\n    self.assertEqual(res, 2.414213562373095)"}, "test_simple2": {"args": ["self"], "min_max_lineno": {"min_lineno": 202, "max_lineno": 213}, "calls": ["algorithms.dp.planting_trees", "test_dp.TestPlantingTrees.assertEqual"], "store_vars_calls": {"res": "planting_trees"}, "source_code": "def test_simple2(self):\n    trees = [0, 3, 5, 5, 6, 9]\n    L = 10\n    W = 1\n    res = planting_trees(trees, L, W)\n    self.assertEqual(res, 9.28538328578604)"}}}, "TestRegexMatching": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 214, "max_lineno": 260}, "methods": {"test_none_0": {"args": ["self"], "min_max_lineno": {"min_lineno": 215, "max_lineno": 219}, "calls": ["test_dp.TestRegexMatching.assertTrue", "algorithms.dp.regex_matching.is_match"], "source_code": "def test_none_0(self):\n    s = ''\n    p = ''\n    self.assertTrue(regex_matching.is_match(s, p))"}, "test_none_1": {"args": ["self"], "min_max_lineno": {"min_lineno": 220, "max_lineno": 224}, "calls": ["test_dp.TestRegexMatching.assertFalse", "algorithms.dp.regex_matching.is_match"], "source_code": "def test_none_1(self):\n    s = ''\n    p = 'a'\n    self.assertFalse(regex_matching.is_match(s, p))"}, "test_no_symbol_equal": {"args": ["self"], "min_max_lineno": {"min_lineno": 225, "max_lineno": 229}, "calls": ["test_dp.TestRegexMatching.assertTrue", "algorithms.dp.regex_matching.is_match"], "source_code": "def test_no_symbol_equal(self):\n    s = 'abcd'\n    p = 'abcd'\n    self.assertTrue(regex_matching.is_match(s, p))"}, "test_no_symbol_not_equal_0": {"args": ["self"], "min_max_lineno": {"min_lineno": 230, "max_lineno": 234}, "calls": ["test_dp.TestRegexMatching.assertFalse", "algorithms.dp.regex_matching.is_match"], "source_code": "def test_no_symbol_not_equal_0(self):\n    s = 'abcd'\n    p = 'efgh'\n    self.assertFalse(regex_matching.is_match(s, p))"}, "test_no_symbol_not_equal_1": {"args": ["self"], "min_max_lineno": {"min_lineno": 235, "max_lineno": 239}, "calls": ["test_dp.TestRegexMatching.assertFalse", "algorithms.dp.regex_matching.is_match"], "source_code": "def test_no_symbol_not_equal_1(self):\n    s = 'ab'\n    p = 'abb'\n    self.assertFalse(regex_matching.is_match(s, p))"}, "test_symbol_0": {"args": ["self"], "min_max_lineno": {"min_lineno": 240, "max_lineno": 244}, "calls": ["test_dp.TestRegexMatching.assertTrue", "algorithms.dp.regex_matching.is_match"], "source_code": "def test_symbol_0(self):\n    s = ''\n    p = 'a*'\n    self.assertTrue(regex_matching.is_match(s, p))"}, "test_symbol_1": {"args": ["self"], "min_max_lineno": {"min_lineno": 245, "max_lineno": 249}, "calls": ["test_dp.TestRegexMatching.assertTrue", "algorithms.dp.regex_matching.is_match"], "source_code": "def test_symbol_1(self):\n    s = 'a'\n    p = 'ab*'\n    self.assertTrue(regex_matching.is_match(s, p))"}, "test_symbol_2": {"args": ["self"], "min_max_lineno": {"min_lineno": 250, "max_lineno": 260}, "calls": ["test_dp.TestRegexMatching.assertTrue", "algorithms.dp.regex_matching.is_match"], "source_code": "def test_symbol_2(self):\n    s = 'abb'\n    p = 'ab*'\n    self.assertTrue(regex_matching.is_match(s, p))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_dp.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_heap.py", "fileNameBase": "test_heap", "extension": "py"}, "dependencies": [{"from_module": "algorithms.heap", "import": "BinaryHeap", "type": "external", "type_element": "module"}, {"from_module": "algorithms.heap", "import": "get_skyline", "type": "external", "type_element": "module"}, {"from_module": "algorithms.heap", "import": "max_sliding_window", "type": "external", "type_element": "module"}, {"from_module": "algorithms.heap", "import": "k_closest", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestBinaryHeap": {"doc": {"short_description": "Test suite for the binary_heap data structures", "full": "Test suite for the binary_heap data structures"}, "extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 42}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 24}, "calls": ["algorithms.heap.BinaryHeap", "test_heap.TestBinaryHeap.min_heap.insert"], "store_vars_calls": {"self.min_heap": "BinaryHeap"}, "source_code": "def setUp(self):\n    self.min_heap = BinaryHeap()\n    self.min_heap.insert(4)\n    self.min_heap.insert(50)\n    self.min_heap.insert(7)\n    self.min_heap.insert(55)\n    self.min_heap.insert(90)\n    self.min_heap.insert(87)"}, "test_insert": {"args": ["self"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 32}, "calls": ["test_heap.TestBinaryHeap.min_heap.insert", "test_heap.TestBinaryHeap.assertEqual"], "source_code": "def test_insert(self):\n    self.min_heap.insert(2)\n    self.assertEqual([0, 2, 50, 4, 55, 90, 87, 7], self.min_heap.heap)\n    self.assertEqual(7, self.min_heap.current_size)"}, "test_remove_min": {"args": ["self"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 42}, "calls": ["test_heap.TestBinaryHeap.min_heap.remove_min", "test_heap.TestBinaryHeap.assertEqual"], "store_vars_calls": {"ret": "self.min_heap.remove_min"}, "source_code": "def test_remove_min(self):\n    ret = self.min_heap.remove_min()\n    self.assertEqual(4, ret)\n    self.assertEqual([0, 7, 50, 87, 55, 90], self.min_heap.heap)\n    self.assertEqual(5, self.min_heap.current_size)"}}}, "TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 66}, "methods": {"test_get_skyline": {"args": ["self"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 52}, "calls": ["test_heap.TestSuite.assertEqual", "algorithms.heap.get_skyline"], "source_code": "def test_get_skyline(self):\n    buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]\n    output = [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]\n    self.assertEqual(output, get_skyline(buildings))"}, "test_max_sliding_window": {"args": ["self"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 56}, "calls": ["test_heap.TestSuite.assertEqual", "algorithms.heap.max_sliding_window"], "source_code": "def test_max_sliding_window(self):\n    nums = [1, 3, -1, -3, 5, 3, 6, 7]\n    self.assertEqual([3, 3, 5, 5, 6, 7], max_sliding_window(nums, 3))"}, "test_k_closest_points": {"args": ["self"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 66}, "calls": ["test_heap.TestSuite.assertEqual", "algorithms.heap.k_closest"], "source_code": "def test_k_closest_points(self):\n    points = [(1, 0), (2, 3), (5, 2), (1, 1), (2, 8), (10, 2), (-1, 0), (-2, -2)]\n    self.assertEqual([(-1, 0), (1, 0)], k_closest(points, 2))\n    self.assertEqual([(1, 1), (-1, 0), (1, 0)], k_closest(points, 3))\n    self.assertEqual([(-2, -2), (1, 1), (1, 0), (-1, 0)], k_closest(points, 4))\n    self.assertEqual([(10, 2), (2, 8), (5, 2), (-2, -2), (2, 3), (1, 0), (-1, 0), (1, 1)], k_closest(points, 8))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_heap.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_dfs.py", "fileNameBase": "test_dfs", "extension": "py"}, "dependencies": [{"from_module": "algorithms.dfs", "import": "get_factors", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dfs", "import": "get_factors_iterative1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dfs", "import": "get_factors_iterative2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dfs", "import": "num_islands", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dfs", "import": "pacific_atlantic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dfs", "import": "Sudoku", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dfs", "import": "walls_and_gates", "type": "external", "type_element": "module"}, {"from_module": "algorithms.dfs", "import": "find_path", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestAllFactors": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 25}, "methods": {"test_get_factors": {"args": ["self"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 17}, "calls": ["test_dfs.TestAllFactors.assertEqual", "algorithms.dfs.get_factors"], "source_code": "def test_get_factors(self):\n    self.assertEqual([[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]], get_factors(32))"}, "test_get_factors_iterative1": {"args": ["self"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 21}, "calls": ["test_dfs.TestAllFactors.assertEqual", "algorithms.dfs.get_factors_iterative1"], "source_code": "def test_get_factors_iterative1(self):\n    self.assertEqual([[2, 16], [4, 8], [2, 2, 8], [2, 4, 4], [2, 2, 2, 4], [2, 2, 2, 2, 2]], get_factors_iterative1(32))"}, "test_get_factors_iterative2": {"args": ["self"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 25}, "calls": ["test_dfs.TestAllFactors.assertEqual", "algorithms.dfs.get_factors_iterative2"], "source_code": "def test_get_factors_iterative2(self):\n    self.assertEqual([[2, 2, 2, 2, 2], [2, 2, 2, 4], [2, 2, 8], [2, 4, 4], [2, 16], [4, 8]], get_factors_iterative2(32))"}}}, "TestCountIslands": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 33}, "methods": {"test_num_islands": {"args": ["self"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 33}, "calls": ["test_dfs.TestCountIslands.assertEqual", "algorithms.dfs.num_islands"], "source_code": "def test_num_islands(self):\n    self.assertEqual(1, num_islands([[1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]]))\n    self.assertEqual(3, num_islands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]))"}}}, "TestPacificAtlantic": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 43}, "methods": {"test_pacific_atlantic": {"args": ["self"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 43}, "calls": ["test_dfs.TestPacificAtlantic.assertEqual", "algorithms.dfs.pacific_atlantic"], "source_code": "def test_pacific_atlantic(self):\n    self.assertEqual([[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]], pacific_atlantic([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]))"}}}, "TestSudoku": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 52}, "methods": {"test_sudoku_solver": {"args": ["self"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 52}, "calls": ["algorithms.dfs.Sudoku", "algorithms.dfs.Sudoku.solve", "test_dfs.TestSudoku.assertEqual"], "store_vars_calls": {"test_obj": "Sudoku"}, "source_code": "def test_sudoku_solver(self):\n    board = [['5', '3', '.'], ['6', '.', '.'], ['.', '9', '8']]\n    test_obj = Sudoku(board, 3, 3)\n    test_obj.solve()\n    self.assertEqual([['5', '3', '1'], ['6', '1', '2'], ['1', '9', '8']], test_obj.board)"}}}, "TestWallsAndGates": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 54, "max_lineno": 63}, "methods": {"test_walls_and_gates": {"args": ["self"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 63}, "calls": ["algorithms.dfs.walls_and_gates", "test_dfs.TestWallsAndGates.assertEqual", "float"], "source_code": "def test_walls_and_gates(self):\n    rooms = [[float('inf'), -1, 0, float('inf')], [float('inf'), float('inf'), float('inf'), -1], [float('inf'), -1, float('inf'), -1], [0, -1, float('inf'), float('inf')]]\n    walls_and_gates(rooms)\n    self.assertEqual([[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]], rooms)"}}}, "TestMazeSearch": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 77}, "methods": {"test_maze_search": {"args": ["self"], "min_max_lineno": {"min_lineno": 66, "max_lineno": 77}, "calls": ["test_dfs.TestMazeSearch.assertEqual", "algorithms.dfs.find_path"], "source_code": "def test_maze_search(self):\n    maze_1 = [[1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1]]\n    self.assertEqual(37, find_path(maze_1))\n    maze_2 = [[1, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1]]\n    self.assertEqual(14, find_path(maze_2))\n    maze_3 = [[1, 0, 0], [0, 1, 1], [0, 1, 1]]\n    self.assertEqual(-1, find_path(maze_3))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_dfs.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_stack.py", "fileNameBase": "test_stack", "extension": "py"}, "dependencies": [{"from_module": "algorithms.stack", "import": "first_is_consecutive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "second_is_consecutive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "is_sorted", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "remove_min", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "first_stutter", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "second_stutter", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "first_switch_pairs", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "second_switch_pairs", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "is_valid", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "simplify_path", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "ArrayStack", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "LinkedListStack", "type": "external", "type_element": "module"}, {"from_module": "algorithms.stack", "import": "OrderedStack", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 70}, "methods": {"test_is_consecutive": {"args": ["self"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 25}, "calls": ["test_stack.TestSuite.assertTrue", "test_stack.TestSuite.assertFalse", "algorithms.stack.first_is_consecutive", "algorithms.stack.second_is_consecutive"], "source_code": "def test_is_consecutive(self):\n    self.assertTrue(first_is_consecutive([3, 4, 5, 6, 7]))\n    self.assertFalse(first_is_consecutive([3, 4, 6, 7]))\n    self.assertFalse(first_is_consecutive([3, 2, 1]))\n    self.assertTrue(second_is_consecutive([3, 4, 5, 6, 7]))\n    self.assertFalse(second_is_consecutive([3, 4, 6, 7]))\n    self.assertFalse(second_is_consecutive([3, 2, 1]))"}, "test_is_sorted": {"args": ["self"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 31}, "calls": ["test_stack.TestSuite.assertFalse", "test_stack.TestSuite.assertTrue", "algorithms.stack.is_sorted"], "source_code": "def test_is_sorted(self):\n    self.assertFalse(is_sorted([6, 3, 5, 1, 2, 4]))\n    self.assertTrue(is_sorted([1, 2, 3, 4, 5, 6]))\n    self.assertFalse(is_sorted([3, 4, 7, 8, 5, 6]))"}, "test_remove_min": {"args": ["self"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 37}, "calls": ["test_stack.TestSuite.assertEqual", "algorithms.stack.remove_min"], "source_code": "def test_remove_min(self):\n    self.assertEqual([2, 8, 3, 7, 3], remove_min([2, 8, 3, -6, 7, 3]))\n    self.assertEqual([4, 8, 7], remove_min([4, 8, 3, 7, 3]))"}, "test_stutter": {"args": ["self"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 44}, "calls": ["test_stack.TestSuite.assertEqual", "algorithms.stack.first_stutter", "algorithms.stack.second_stutter"], "source_code": "def test_stutter(self):\n    self.assertEqual([3, 3, 7, 7, 1, 1, 14, 14, 9, 9], first_stutter([3, 7, 1, 14, 9]))\n    self.assertEqual([3, 3, 7, 7, 1, 1, 14, 14, 9, 9], second_stutter([3, 7, 1, 14, 9]))"}, "test_switch_pairs": {"args": ["self"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 58}, "calls": ["test_stack.TestSuite.assertEqual", "algorithms.stack.first_switch_pairs", "algorithms.stack.second_switch_pairs"], "source_code": "def test_switch_pairs(self):\n    self.assertEqual([8, 3, 9, 17, 10, 1], first_switch_pairs([3, 8, 17, 9, 1, 10]))\n    self.assertEqual([8, 3, 9, 17, 10, 1], second_switch_pairs([3, 8, 17, 9, 1, 10]))\n    self.assertEqual([8, 3, 9, 17, 1], first_switch_pairs([3, 8, 17, 9, 1]))\n    self.assertEqual([8, 3, 9, 17, 1], second_switch_pairs([3, 8, 17, 9, 1]))"}, "test_is_valid_parenthesis": {"args": ["self"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 66}, "calls": ["test_stack.TestSuite.assertTrue", "test_stack.TestSuite.assertFalse", "algorithms.stack.is_valid"], "source_code": "def test_is_valid_parenthesis(self):\n    self.assertTrue(is_valid('[]'))\n    self.assertTrue(is_valid('[]()[]'))\n    self.assertFalse(is_valid('[[[]]'))\n    self.assertTrue(is_valid('{([])}'))\n    self.assertFalse(is_valid('(}'))"}, "test_simplify_path": {"args": ["self"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 70}, "calls": ["test_stack.TestSuite.assertEqual", "algorithms.stack.simplify_path"], "source_code": "def test_simplify_path(self):\n    p = '/my/name/is/..//keon'\n    self.assertEqual('/my/name/keon', simplify_path(p))"}}}, "TestStack": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 72, "max_lineno": 137}, "methods": {"test_ArrayStack": {"args": ["self"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 104}, "calls": ["algorithms.stack.ArrayStack", "algorithms.stack.ArrayStack.push", "iter", "test_stack.TestStack.assertEqual", "test_stack.TestStack.assertRaises", "test_stack.TestStack.assertFalse", "test_stack.TestStack.assertTrue", "next", "len", "str", "algorithms.stack.ArrayStack.is_empty", "algorithms.stack.ArrayStack.peek", "algorithms.stack.ArrayStack.pop"], "store_vars_calls": {"stack": "ArrayStack", "it": "iter"}, "source_code": "def test_ArrayStack(self):\n    stack = ArrayStack()\n    stack.push(1)\n    stack.push(2)\n    stack.push(3)\n    it = iter(stack)\n    self.assertEqual(3, next(it))\n    self.assertEqual(2, next(it))\n    self.assertEqual(1, next(it))\n    self.assertRaises(StopIteration, next, it)\n    self.assertEqual(3, len(stack))\n    self.assertEqual(str(stack), 'Top-> 3 2 1')\n    self.assertFalse(stack.is_empty())\n    self.assertEqual(3, stack.peek())\n    self.assertEqual(3, stack.pop())\n    self.assertEqual(2, stack.pop())\n    self.assertEqual(1, stack.pop())\n    self.assertTrue(stack.is_empty())"}, "test_LinkedListStack": {"args": ["self"], "min_max_lineno": {"min_lineno": 105, "max_lineno": 137}, "calls": ["algorithms.stack.LinkedListStack", "algorithms.stack.LinkedListStack.push", "iter", "test_stack.TestStack.assertEqual", "test_stack.TestStack.assertRaises", "test_stack.TestStack.assertFalse", "test_stack.TestStack.assertTrue", "next", "len", "str", "algorithms.stack.LinkedListStack.is_empty", "algorithms.stack.LinkedListStack.peek", "algorithms.stack.LinkedListStack.pop"], "store_vars_calls": {"stack": "LinkedListStack", "it": "iter"}, "source_code": "def test_LinkedListStack(self):\n    stack = LinkedListStack()\n    stack.push(1)\n    stack.push(2)\n    stack.push(3)\n    it = iter(stack)\n    self.assertEqual(3, next(it))\n    self.assertEqual(2, next(it))\n    self.assertEqual(1, next(it))\n    self.assertRaises(StopIteration, next, it)\n    self.assertEqual(3, len(stack))\n    self.assertEqual(str(stack), 'Top-> 3 2 1')\n    self.assertFalse(stack.is_empty())\n    self.assertEqual(3, stack.peek())\n    self.assertEqual(3, stack.pop())\n    self.assertEqual(2, stack.pop())\n    self.assertEqual(1, stack.pop())\n    self.assertTrue(stack.is_empty())"}}}, "TestOrderedStack": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 139, "max_lineno": 151}, "methods": {"test_OrderedStack": {"args": ["self"], "min_max_lineno": {"min_lineno": 140, "max_lineno": 151}, "calls": ["algorithms.stack.OrderedStack", "test_stack.TestOrderedStack.assertTrue", "algorithms.stack.OrderedStack.push", "test_stack.TestOrderedStack.assertEqual", "algorithms.stack.OrderedStack.is_empty", "algorithms.stack.OrderedStack.pop", "algorithms.stack.OrderedStack.peek", "algorithms.stack.OrderedStack.size"], "store_vars_calls": {"stack": "OrderedStack"}, "source_code": "def test_OrderedStack(self):\n    stack = OrderedStack()\n    self.assertTrue(stack.is_empty())\n    stack.push(1)\n    stack.push(4)\n    stack.push(3)\n    stack.push(6)\n    'bottom - > 1 3 4 6 '\n    self.assertEqual(6, stack.pop())\n    self.assertEqual(4, stack.peek())\n    self.assertEqual(3, stack.size())"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_stack.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_bfs.py", "fileNameBase": "test_bfs", "extension": "py"}, "dependencies": [{"from_module": "algorithms.bfs", "import": "count_islands", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bfs", "import": "maze_search", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bfs", "import": "ladder_length", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestCountIslands": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 25}, "methods": {"test_count_islands": {"args": ["self"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 25}, "calls": ["test_bfs.TestCountIslands.assertEqual", "algorithms.bfs.count_islands"], "source_code": "def test_count_islands(self):\n    grid_1 = [[1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]]\n    self.assertEqual(1, count_islands(grid_1))\n    grid_2 = [[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]\n    self.assertEqual(3, count_islands(grid_2))\n    grid_3 = [[1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0]]\n    self.assertEqual(3, count_islands(grid_3))\n    grid_4 = [[1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0]]\n    self.assertEqual(5, count_islands(grid_4))"}}}, "TestMazeSearch": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 35}, "methods": {"test_maze_search": {"args": ["self"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 35}, "calls": ["test_bfs.TestMazeSearch.assertEqual", "algorithms.bfs.maze_search"], "source_code": "def test_maze_search(self):\n    grid_1 = [[1, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1]]\n    self.assertEqual(14, maze_search(grid_1))\n    grid_2 = [[1, 0, 0], [0, 1, 1], [0, 1, 1]]\n    self.assertEqual(-1, maze_search(grid_2))"}}}, "TestWordLadder": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 59}, "methods": {"test_ladder_length": {"args": ["self"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 59}, "calls": ["test_bfs.TestWordLadder.assertEqual", "algorithms.bfs.ladder_length"], "source_code": "def test_ladder_length(self):\n    self.assertEqual(5, ladder_length('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log']))\n    self.assertEqual(5, ladder_length('pick', 'tank', ['tock', 'tick', 'sank', 'sink', 'sick']))\n    self.assertEqual(1, ladder_length('live', 'life', ['hoho', 'luck']))\n    self.assertEqual(0, ladder_length('ate', 'ate', []))\n    self.assertEqual(-1, ladder_length('rahul', 'coder', ['blahh', 'blhah']))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_bfs.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_bit.py", "fileNameBase": "test_bit", "extension": "py"}, "dependencies": [{"from_module": "algorithms.bit", "import": "add_bitwise_operator", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "count_ones_iter", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "count_ones_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "count_flips_to_convert", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "find_missing_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "find_missing_number2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "flip_bit_longest_seq", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "is_power_of_two", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "reverse_bits", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "single_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "single_number2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "single_number3", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "subsets", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "get_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "set_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "clear_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "update_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "int_to_bytes_big_endian", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "int_to_bytes_little_endian", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "bytes_big_endian_to_int", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "bytes_little_endian_to_int", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "swap_pair", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "find_difference", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "has_alternative_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "has_alternative_bit_fast", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "insert_one_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "insert_mult_bits", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "remove_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.bit", "import": "binary_gap", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}, {"import": "random", "type": "external", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 271}, "methods": {"setUp": {"doc": {"short_description": "Initialize seed."}, "args": ["self"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 33}, "calls": ["random.seed"], "source_code": "def setUp(self):\n    \"\"\"Initialize seed.\"\"\"\n    random.seed('test')"}, "test_add_bitwise_operator": {"args": ["self"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 39}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.add_bitwise_operator"], "source_code": "def test_add_bitwise_operator(self):\n    self.assertEqual(5432 + 97823, add_bitwise_operator(5432, 97823))\n    self.assertEqual(0, add_bitwise_operator(0, 0))\n    self.assertEqual(10, add_bitwise_operator(10, 0))\n    self.assertEqual(10, add_bitwise_operator(0, 10))"}, "test_count_ones_recur": {"args": ["self"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 53}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.count_ones_recur"], "source_code": "def test_count_ones_recur(self):\n    self.assertEqual(1, count_ones_recur(8))\n    self.assertEqual(5, count_ones_recur(109))\n    self.assertEqual(6, count_ones_recur(63))\n    self.assertEqual(0, count_ones_recur(0))"}, "test_count_ones_iter": {"args": ["self"], "min_max_lineno": {"min_lineno": 54, "max_lineno": 67}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.count_ones_iter"], "source_code": "def test_count_ones_iter(self):\n    self.assertEqual(1, count_ones_iter(8))\n    self.assertEqual(5, count_ones_iter(109))\n    self.assertEqual(6, count_ones_iter(63))\n    self.assertEqual(0, count_ones_iter(0))"}, "test_count_flips_to_convert": {"args": ["self"], "min_max_lineno": {"min_lineno": 68, "max_lineno": 77}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.count_flips_to_convert"], "source_code": "def test_count_flips_to_convert(self):\n    self.assertEqual(2, count_flips_to_convert(29, 15))\n    self.assertEqual(8, count_flips_to_convert(45, 987))\n    self.assertEqual(0, count_flips_to_convert(34, 34))\n    self.assertEqual(4, count_flips_to_convert(34, 53))"}, "test_find_missing_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 78, "max_lineno": 87}, "calls": ["test_bit.TestSuite.assertEqual", "random.shuffle", "algorithms.bit.find_missing_number", "range"], "source_code": "def test_find_missing_number(self):\n    self.assertEqual(7, find_missing_number([4, 1, 3, 0, 6, 5, 2]))\n    self.assertEqual(0, find_missing_number([1]))\n    self.assertEqual(1, find_missing_number([0]))\n    nums = [i for i in range(100000) if i != 12345]\n    random.shuffle(nums)\n    self.assertEqual(12345, find_missing_number(nums))"}, "test_find_missing_number2": {"args": ["self"], "min_max_lineno": {"min_lineno": 88, "max_lineno": 97}, "calls": ["test_bit.TestSuite.assertEqual", "random.shuffle", "algorithms.bit.find_missing_number2", "range"], "source_code": "def test_find_missing_number2(self):\n    self.assertEqual(7, find_missing_number2([4, 1, 3, 0, 6, 5, 2]))\n    self.assertEqual(0, find_missing_number2([1]))\n    self.assertEqual(1, find_missing_number2([0]))\n    nums = [i for i in range(100000) if i != 12345]\n    random.shuffle(nums)\n    self.assertEqual(12345, find_missing_number2(nums))"}, "test_flip_bit_longest_seq": {"args": ["self"], "min_max_lineno": {"min_lineno": 98, "max_lineno": 107}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.flip_bit_longest_seq"], "source_code": "def test_flip_bit_longest_seq(self):\n    self.assertEqual(8, flip_bit_longest_seq(1775))\n    self.assertEqual(3, flip_bit_longest_seq(5))\n    self.assertEqual(4, flip_bit_longest_seq(71))\n    self.assertEqual(1, flip_bit_longest_seq(0))"}, "test_is_power_of_two": {"args": ["self"], "min_max_lineno": {"min_lineno": 108, "max_lineno": 115}, "calls": ["test_bit.TestSuite.assertTrue", "test_bit.TestSuite.assertFalse", "algorithms.bit.is_power_of_two"], "source_code": "def test_is_power_of_two(self):\n    self.assertTrue(is_power_of_two(64))\n    self.assertFalse(is_power_of_two(91))\n    self.assertTrue(is_power_of_two(2 ** 1001))\n    self.assertTrue(is_power_of_two(1))\n    self.assertFalse(is_power_of_two(0))"}, "test_reverse_bits": {"args": ["self"], "min_max_lineno": {"min_lineno": 116, "max_lineno": 127}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.reverse_bits"], "source_code": "def test_reverse_bits(self):\n    self.assertEqual(43261596, reverse_bits(964176192))\n    self.assertEqual(964176192, reverse_bits(43261596))\n    self.assertEqual(1, reverse_bits(2147483648))\n    self.assertEqual(0, reverse_bits(0))\n    self.assertEqual(2 ** 32 - 1, reverse_bits(2 ** 32 - 1))"}, "test_single_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 128, "max_lineno": 142}, "calls": ["random.seed", "test_bit.TestSuite.assertEqual", "random.randint", "nums.append", "random.shuffle", "algorithms.bit.single_number", "range"], "store_vars_calls": {"single": "random.randint"}, "source_code": "def test_single_number(self):\n    random.seed('test')\n    self.assertEqual(0, single_number([1, 0, 2, 1, 2, 3, 3]))\n    self.assertEqual(101, single_number([101]))\n    single = random.randint(1, 100000)\n    nums = [random.randint(1, 100000) for _ in range(1000)]\n    nums *= 2\n    nums.append(single)\n    random.shuffle(nums)\n    self.assertEqual(single, single_number(nums))"}, "test_single_number2": {"args": ["self"], "min_max_lineno": {"min_lineno": 143, "max_lineno": 152}, "calls": ["test_bit.TestSuite.assertEqual", "random.randint", "nums.append", "random.shuffle", "algorithms.bit.single_number2", "range"], "store_vars_calls": {"single": "random.randint"}, "source_code": "def test_single_number2(self):\n    self.assertEqual(3, single_number2([4, 2, 3, 2, 1, 1, 4, 2, 4, 1]))\n    single = random.randint(1, 100000)\n    nums = [random.randint(1, 100000) for _ in range(1000)]\n    nums *= 3\n    nums.append(single)\n    random.shuffle(nums)\n    self.assertEqual(single, single_number2(nums))"}, "test_single_number3": {"args": ["self"], "min_max_lineno": {"min_lineno": 153, "max_lineno": 158}, "calls": ["test_bit.TestSuite.assertEqual", "sorted", "algorithms.bit.single_number3"], "source_code": "def test_single_number3(self):\n    self.assertEqual(sorted([2, 5]), sorted(single_number3([2, 1, 5, 6, 6, 1])))\n    self.assertEqual(sorted([4, 3]), sorted(single_number3([9, 9, 4, 3])))"}, "test_subsets": {"args": ["self"], "min_max_lineno": {"min_lineno": 159, "max_lineno": 172}, "calls": ["test_bit.TestSuite.assertSetEqual", "algorithms.bit.subsets"], "source_code": "def test_subsets(self):\n    self.assertSetEqual(subsets([1, 2, 3]), {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)})\n    self.assertSetEqual(subsets([10, 20, 30, 40]), {(10, 40), (10, 20, 40), (10, 30), (10, 20, 30, 40), (40,), (10, 30, 40), (30,), (20, 30), (30, 40), (10,), (), (10, 20), (20, 40), (20, 30, 40), (10, 20, 30), (20,)})"}, "test_get_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 173, "max_lineno": 177}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.get_bit"], "source_code": "def test_get_bit(self):\n    self.assertEqual(1, get_bit(22, 2))\n    self.assertEqual(0, get_bit(22, 3))"}, "test_set_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 178, "max_lineno": 181}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.set_bit"], "source_code": "def test_set_bit(self):\n    self.assertEqual(30, set_bit(22, 3))"}, "test_clear_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 182, "max_lineno": 185}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.clear_bit"], "source_code": "def test_clear_bit(self):\n    self.assertEqual(18, clear_bit(22, 2))"}, "test_update_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 186, "max_lineno": 193}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.update_bit"], "source_code": "def test_update_bit(self):\n    self.assertEqual(30, update_bit(22, 3, 1))\n    self.assertEqual(18, update_bit(22, 2, 0))"}, "test_int_to_bytes_big_endian": {"args": ["self"], "min_max_lineno": {"min_lineno": 194, "max_lineno": 196}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.int_to_bytes_big_endian"], "source_code": "def test_int_to_bytes_big_endian(self):\n    self.assertEqual(b'\\x11', int_to_bytes_big_endian(17))"}, "test_int_to_bytes_little_endian": {"args": ["self"], "min_max_lineno": {"min_lineno": 197, "max_lineno": 199}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.int_to_bytes_little_endian"], "source_code": "def test_int_to_bytes_little_endian(self):\n    self.assertEqual(b'\\x11', int_to_bytes_little_endian(17))"}, "test_bytes_big_endian_to_int": {"args": ["self"], "min_max_lineno": {"min_lineno": 200, "max_lineno": 202}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.bytes_big_endian_to_int"], "source_code": "def test_bytes_big_endian_to_int(self):\n    self.assertEqual(17, bytes_big_endian_to_int(b'\\x11'))"}, "test_bytes_little_endian_to_int": {"args": ["self"], "min_max_lineno": {"min_lineno": 203, "max_lineno": 205}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.bytes_little_endian_to_int"], "source_code": "def test_bytes_little_endian_to_int(self):\n    self.assertEqual(17, bytes_little_endian_to_int(b'\\x11'))"}, "test_swap_pair": {"args": ["self"], "min_max_lineno": {"min_lineno": 206, "max_lineno": 211}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.swap_pair"], "source_code": "def test_swap_pair(self):\n    self.assertEqual(41, swap_pair(22))\n    self.assertEqual(5, swap_pair(10))"}, "test_find_difference": {"args": ["self"], "min_max_lineno": {"min_lineno": 212, "max_lineno": 214}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.find_difference"], "source_code": "def test_find_difference(self):\n    self.assertEqual('e', find_difference('abcd', 'abecd'))"}, "test_has_alternative_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 215, "max_lineno": 220}, "calls": ["test_bit.TestSuite.assertTrue", "test_bit.TestSuite.assertFalse", "algorithms.bit.has_alternative_bit"], "source_code": "def test_has_alternative_bit(self):\n    self.assertTrue(has_alternative_bit(5))\n    self.assertFalse(has_alternative_bit(7))\n    self.assertFalse(has_alternative_bit(11))\n    self.assertTrue(has_alternative_bit(10))"}, "test_has_alternative_bit_fast": {"args": ["self"], "min_max_lineno": {"min_lineno": 221, "max_lineno": 226}, "calls": ["test_bit.TestSuite.assertTrue", "test_bit.TestSuite.assertFalse", "algorithms.bit.has_alternative_bit_fast"], "source_code": "def test_has_alternative_bit_fast(self):\n    self.assertTrue(has_alternative_bit_fast(5))\n    self.assertFalse(has_alternative_bit_fast(7))\n    self.assertFalse(has_alternative_bit_fast(11))\n    self.assertTrue(has_alternative_bit_fast(10))"}, "test_insert_one_bit": {"doc": {"long_description": "insert_one_bit(num, 1, 2): 101101 (45)\ninsert_one_bit(num, 0 ,2): 101001 (41)\ninsert_one_bit(num, 1, 5): 110101 (53)\ninsert_one_bit(num, 1, 0): 101010 (42)", "short_description": "Input: num = 10101 (21)"}, "args": ["self"], "min_max_lineno": {"min_lineno": 227, "max_lineno": 239}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.insert_one_bit"], "source_code": "def test_insert_one_bit(self):\n    \"\"\"\n        Input: num = 10101 (21)\n        insert_one_bit(num, 1, 2): 101101 (45)\n        insert_one_bit(num, 0 ,2): 101001 (41)\n        insert_one_bit(num, 1, 5): 110101 (53)\n        insert_one_bit(num, 1, 0): 101010 (42)\n        \"\"\"\n    self.assertEqual(45, insert_one_bit(21, 1, 2))\n    self.assertEqual(41, insert_one_bit(21, 0, 2))\n    self.assertEqual(53, insert_one_bit(21, 1, 5))\n    self.assertEqual(43, insert_one_bit(21, 1, 0))"}, "test_insert_mult_bits": {"doc": {"long_description": "insert_mult_bits(num, 7, 3, 1): 101111 (47)\ninsert_mult_bits(num, 7, 3, 0): 101111 (47)\ninsert_mult_bits(num, 7, 3, 3): 111101 (61)", "short_description": "Input: num = 101 (5)"}, "args": ["self"], "min_max_lineno": {"min_lineno": 240, "max_lineno": 250}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.insert_mult_bits"], "source_code": "def test_insert_mult_bits(self):\n    \"\"\"\n        Input: num = 101 (5)\n        insert_mult_bits(num, 7, 3, 1): 101111 (47)\n        insert_mult_bits(num, 7, 3, 0): 101111 (47)\n        insert_mult_bits(num, 7, 3, 3): 111101 (61)\n        \"\"\"\n    self.assertEqual(47, insert_mult_bits(5, 7, 3, 1))\n    self.assertEqual(47, insert_mult_bits(5, 7, 3, 0))\n    self.assertEqual(61, insert_mult_bits(5, 7, 3, 3))"}, "test_remove_bit": {"doc": {"long_description": "remove_bit(num, 2): output = 1001 (9)\nremove_bit(num, 4): output = 101 (5)\nremove_bit(num, 0): output = 1010 (10)", "short_description": "Input: num = 10101 (21)"}, "args": ["self"], "min_max_lineno": {"min_lineno": 251, "max_lineno": 261}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.remove_bit"], "source_code": "def test_remove_bit(self):\n    \"\"\"\n        Input: num = 10101 (21)\n        remove_bit(num, 2): output = 1001 (9)\n        remove_bit(num, 4): output = 101 (5)\n        remove_bit(num, 0): output = 1010 (10)\n        \"\"\"\n    self.assertEqual(9, remove_bit(21, 2))\n    self.assertEqual(5, remove_bit(21, 4))\n    self.assertEqual(10, remove_bit(21, 0))"}, "test_binary_gap": {"args": ["self"], "min_max_lineno": {"min_lineno": 262, "max_lineno": 271}, "calls": ["test_bit.TestSuite.assertEqual", "algorithms.bit.binary_gap"], "source_code": "def test_binary_gap(self):\n    self.assertEqual(2, binary_gap(22))\n    self.assertEqual(1, binary_gap(6))\n    self.assertEqual(0, binary_gap(8))\n    self.assertEqual(4, binary_gap(145))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_bit.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_iterative_segment_tree.py", "fileNameBase": "test_iterative_segment_tree", "extension": "py"}, "dependencies": [{"from_module": "algorithms.tree.segment_tree.iterative_segment_tree", "import": "SegmentTree", "type": "external", "type_element": "module"}, {"from_module": "functools", "import": "reduce", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestSegmentTree": {"doc": {"short_description": "Test for the Iterative Segment Tree data structure", "full": "Test for the Iterative Segment Tree data structure"}, "extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 100}, "methods": {"test_segment_tree_creation": {"args": ["self"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 32}, "calls": ["algorithms.tree.segment_tree.iterative_segment_tree.SegmentTree", "test_iterative_segment_tree.TestSegmentTree.assertEqual"], "store_vars_calls": {"max_segment_tree": "SegmentTree", "min_segment_tree": "SegmentTree", "sum_segment_tree": "SegmentTree", "gcd_segment_tree": "SegmentTree"}, "source_code": "def test_segment_tree_creation(self):\n    arr = [2, 4, 3, 6, 8, 9, 3]\n    max_segment_tree = SegmentTree(arr, max)\n    min_segment_tree = SegmentTree(arr, min)\n    sum_segment_tree = SegmentTree(arr, lambda a, b: a + b)\n    gcd_segment_tree = SegmentTree(arr, gcd)\n    self.assertEqual(max_segment_tree.tree, [None, 9, 8, 9, 4, 8, 9, 2, 4, 3, 6, 8, 9, 3])\n    self.assertEqual(min_segment_tree.tree, [None, 2, 3, 2, 3, 6, 3, 2, 4, 3, 6, 8, 9, 3])\n    self.assertEqual(sum_segment_tree.tree, [None, 35, 21, 14, 7, 14, 12, 2, 4, 3, 6, 8, 9, 3])\n    self.assertEqual(gcd_segment_tree.tree, [None, 1, 1, 1, 1, 2, 3, 2, 4, 3, 6, 8, 9, 3])"}, "test_max_segment_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 36}, "calls": ["test_iterative_segment_tree.TestSegmentTree.__test_all_segments"], "source_code": "def test_max_segment_tree(self):\n    arr = [-1, 1, 10, 2, 9, -3, 8, 4, 7, 5, 6, 0]\n    self.__test_all_segments(arr, max)"}, "test_min_segment_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 40}, "calls": ["test_iterative_segment_tree.TestSegmentTree.__test_all_segments"], "source_code": "def test_min_segment_tree(self):\n    arr = [1, 10, -2, 9, -3, 8, 4, -7, 5, 6, 11, -12]\n    self.__test_all_segments(arr, min)"}, "test_sum_segment_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 44}, "calls": ["test_iterative_segment_tree.TestSegmentTree.__test_all_segments"], "source_code": "def test_sum_segment_tree(self):\n    arr = [1, 10, 2, 9, 3, 8, 4, 7, 5, 6, -11, -12]\n    self.__test_all_segments(arr, lambda a, b: a + b)"}, "test_gcd_segment_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 48}, "calls": ["test_iterative_segment_tree.TestSegmentTree.__test_all_segments"], "source_code": "def test_gcd_segment_tree(self):\n    arr = [1, 10, 2, 9, 3, 8, 4, 7, 5, 6, 11, 12, 14]\n    self.__test_all_segments(arr, gcd)"}, "test_max_segment_tree_with_updates": {"args": ["self"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 54}, "calls": ["test_iterative_segment_tree.TestSegmentTree.__test_all_segments_with_updates"], "source_code": "def test_max_segment_tree_with_updates(self):\n    arr = [-1, 1, 10, 2, 9, -3, 8, 4, 7, 5, 6, 0]\n    updates = {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10, 10: 11, 11: 12}\n    self.__test_all_segments_with_updates(arr, max, updates)"}, "test_min_segment_tree_with_updates": {"args": ["self"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 60}, "calls": ["test_iterative_segment_tree.TestSegmentTree.__test_all_segments_with_updates"], "source_code": "def test_min_segment_tree_with_updates(self):\n    arr = [1, 10, -2, 9, -3, 8, 4, -7, 5, 6, 11, -12]\n    updates = {0: 7, 1: 2, 2: 6, 3: -14, 4: 5, 5: 4, 6: 7, 7: -10, 8: 9, 9: 10, 10: 12, 11: 1}\n    self.__test_all_segments_with_updates(arr, min, updates)"}, "test_sum_segment_tree_with_updates": {"args": ["self"], "min_max_lineno": {"min_lineno": 61, "max_lineno": 66}, "calls": ["test_iterative_segment_tree.TestSegmentTree.__test_all_segments_with_updates"], "source_code": "def test_sum_segment_tree_with_updates(self):\n    arr = [1, 10, 2, 9, 3, 8, 4, 7, 5, 6, -11, -12]\n    updates = {0: 12, 1: 11, 2: 10, 3: 9, 4: 8, 5: 7, 6: 6, 7: 5, 8: 4, 9: 3, 10: 2, 11: 1}\n    self.__test_all_segments_with_updates(arr, lambda a, b: a + b, updates)"}, "test_gcd_segment_tree_with_updates": {"args": ["self"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 72}, "calls": ["test_iterative_segment_tree.TestSegmentTree.__test_all_segments_with_updates"], "source_code": "def test_gcd_segment_tree_with_updates(self):\n    arr = [1, 10, 2, 9, 3, 8, 4, 7, 5, 6, 11, 12, 14]\n    updates = {0: 4, 1: 2, 2: 3, 3: 9, 4: 21, 5: 7, 6: 4, 7: 4, 8: 2, 9: 5, 10: 17, 11: 12, 12: 3}\n    self.__test_all_segments_with_updates(arr, gcd, updates)"}, "__test_all_segments": {"doc": {"short_description": "Test all possible segments in the tree", "args": {"arr": {"description": "array to test"}, "fnc": {"description": "function of the segment tpree"}}}, "args": ["self", "arr", "fnc"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 81}, "calls": ["algorithms.tree.segment_tree.iterative_segment_tree.SegmentTree", "test_iterative_segment_tree.TestSegmentTree.__test_segments_helper"], "store_vars_calls": {"segment_tree": "SegmentTree"}, "source_code": "def __test_all_segments(self, arr, fnc):\n    \"\"\"\n        Test all possible segments in the tree\n        :param arr: array to test\n        :param fnc: function of the segment tpree\n        \"\"\"\n    segment_tree = SegmentTree(arr, fnc)\n    self.__test_segments_helper(segment_tree, fnc, arr)"}, "__test_all_segments_with_updates": {"doc": {"short_description": "Test all possible segments in the tree with updates", "args": {"arr": {"description": "array to test"}, "fnc": {"description": "function of the segment tree"}, "upd": {"description": "updates to test"}}}, "args": ["self", "arr", "fnc", "upd"], "min_max_lineno": {"min_lineno": 82, "max_lineno": 94}, "calls": ["algorithms.tree.segment_tree.iterative_segment_tree.SegmentTree", "upd.items", "algorithms.tree.segment_tree.iterative_segment_tree.SegmentTree.update", "test_iterative_segment_tree.TestSegmentTree.__test_segments_helper"], "store_vars_calls": {"segment_tree": "SegmentTree"}, "source_code": "def __test_all_segments_with_updates(self, arr, fnc, upd):\n    \"\"\"\n        Test all possible segments in the tree with updates\n        :param arr: array to test\n        :param fnc: function of the segment tree\n        :param upd: updates to test\n        \"\"\"\n    segment_tree = SegmentTree(arr, fnc)\n    for (index, value) in upd.items():\n        arr[index] = value\n        segment_tree.update(index, value)\n        self.__test_segments_helper(segment_tree, fnc, arr)"}, "__test_segments_helper": {"args": ["self", "seg_tree", "fnc", "arr"], "min_max_lineno": {"min_lineno": 95, "max_lineno": 100}, "calls": ["range", "len", "functools.reduce", "test_iterative_segment_tree.TestSegmentTree.assertEqual", "seg_tree.query"], "store_vars_calls": {"range_value": "reduce"}, "source_code": "def __test_segments_helper(self, seg_tree, fnc, arr):\n    for i in range(0, len(arr)):\n        for j in range(i, len(arr)):\n            range_value = reduce(fnc, arr[i:j + 1])\n            self.assertEqual(seg_tree.query(i, j), range_value)"}}}}, "functions": {"gcd": {"args": ["a", "b"], "returns": ["gcd(b, a % b)", "a"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 11}, "calls": ["test_iterative_segment_tree.gcd"], "source_code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)"}}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_greedy.py", "fileNameBase": "test_greedy", "extension": "py"}, "dependencies": [{"from_module": "algorithms.greedy", "import": "max_contiguous_subsequence_sum", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestMaxContiguousSubsequenceSum": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 18}, "methods": {"test_max_contiguous_subsequence_sum": {"args": ["self"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 18}, "calls": ["test_greedy.TestMaxContiguousSubsequenceSum.assertEqual", "algorithms.greedy.max_contiguous_subsequence_sum"], "source_code": "def test_max_contiguous_subsequence_sum(self):\n    arr1 = [-2, 3, 8, -1, 4]\n    arr2 = [-1, 1, 0]\n    arr3 = [-1, -3, -4]\n    arr4 = [-2, 3, 8, -12, 8, 4]\n    self.assertEqual(max_contiguous_subsequence_sum(arr1), 14)\n    self.assertEqual(max_contiguous_subsequence_sum(arr2), 1)\n    self.assertEqual(max_contiguous_subsequence_sum(arr3), -1)\n    self.assertEqual(max_contiguous_subsequence_sum(arr4), 12)"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_greedy.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_matrix.py", "fileNameBase": "test_matrix", "extension": "py"}, "dependencies": [{"from_module": "algorithms.matrix", "import": "bomb_enemy", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "copy_transform", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "crout_matrix_decomposition", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "cholesky_matrix_decomposition", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "matrix_exponentiation", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "matrix_inversion", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "multiply", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "rotate_image", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "sparse_dot_vector", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "spiral_traversal", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "sudoku_validator", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "sum_sub_squares", "type": "external", "type_element": "module"}, {"from_module": "algorithms.matrix", "import": "sort_matrix_diagonally", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestBombEnemy": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 42}, "methods": {"test_3x4": {"args": ["self"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 42}, "calls": ["test_matrix.TestBombEnemy.assertEqual", "algorithms.matrix.bomb_enemy.max_killed_enemies"], "source_code": "def test_3x4(self):\n    grid1 = [['0', 'E', '0', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    self.assertEqual(3, bomb_enemy.max_killed_enemies(grid1))\n    grid1 = [['0', 'E', '0', 'E'], ['E', 'E', 'E', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    grid2 = [['0', '0', '0', 'E'], ['E', '0', '0', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    self.assertEqual(5, bomb_enemy.max_killed_enemies(grid1))\n    self.assertEqual(3, bomb_enemy.max_killed_enemies(grid2))"}}}, "TestCopyTransform": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 68}, "methods": {"test_copy_transform": {"args": ["self"], "min_max_lineno": {"min_lineno": 52, "max_lineno": 68}, "calls": ["test_matrix.TestCopyTransform.assertEqual", "algorithms.matrix.copy_transform.rotate_clockwise", "algorithms.matrix.copy_transform.rotate_counterclockwise", "algorithms.matrix.copy_transform.top_left_invert", "algorithms.matrix.copy_transform.bottom_left_invert"], "source_code": "def test_copy_transform(self):\n    self.assertEqual(copy_transform.rotate_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\n    self.assertEqual(copy_transform.rotate_counterclockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[3, 6, 9], [2, 5, 8], [1, 4, 7]])\n    self.assertEqual(copy_transform.top_left_invert([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n    self.assertEqual(copy_transform.bottom_left_invert([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[9, 6, 3], [8, 5, 2], [7, 4, 1]])"}}}, "TestCroutMatrixDecomposition": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 70, "max_lineno": 104}, "methods": {"test_crout_matrix_decomposition": {"args": ["self"], "min_max_lineno": {"min_lineno": 78, "max_lineno": 104}, "calls": ["test_matrix.TestCroutMatrixDecomposition.assertEqual", "algorithms.matrix.crout_matrix_decomposition.crout_matrix_decomposition"], "source_code": "def test_crout_matrix_decomposition(self):\n    self.assertEqual(([[9.0, 0.0], [7.0, 0.0]], [[1.0, 1.0], [0.0, 1.0]]), crout_matrix_decomposition.crout_matrix_decomposition([[9, 9], [7, 7]]))\n    self.assertEqual(([[1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0]], [[1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0]]), crout_matrix_decomposition.crout_matrix_decomposition([[1, 2, 3], [3, 4, 5], [6, 7, 8]]))\n    self.assertEqual(([[2.0, 0, 0, 0], [4.0, -1.0, 0, 0], [6.0, -2.0, 2.0, 0], [8.0, -3.0, 3.0, 0.0]], [[1.0, 0.5, 1.5, 0.5], [0, 1.0, 2.0, 1.0], [0, 0, 1.0, 0.0], [0, 0, 0, 1.0]]), crout_matrix_decomposition.crout_matrix_decomposition([[2, 1, 3, 1], [4, 1, 4, 1], [6, 1, 7, 1], [8, 1, 9, 1]]))"}}}, "TestCholeskyMatrixDecomposition": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 106, "max_lineno": 140}, "methods": {"test_cholesky_matrix_decomposition": {"args": ["self"], "min_max_lineno": {"min_lineno": 114, "max_lineno": 140}, "calls": ["test_matrix.TestCholeskyMatrixDecomposition.assertEqual", "algorithms.matrix.cholesky_matrix_decomposition.cholesky_decomposition"], "source_code": "def test_cholesky_matrix_decomposition(self):\n    self.assertEqual([[2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0]], cholesky_matrix_decomposition.cholesky_decomposition([[4, 12, -16], [12, 37, -43], [-16, -43, 98]]))\n    self.assertEqual(None, cholesky_matrix_decomposition.cholesky_decomposition([[4, 12, -8], [12, 4, -43], [-16, -1, 32]]))\n    self.assertEqual(None, cholesky_matrix_decomposition.cholesky_decomposition([[4, 12, -16], [12, 37, -43], [-16, -43, 98], [1, 2, 3]]))\n    self.assertEqual([[2.23606797749979, 0.0, 0.0, 0.0], [0.5366563145999494, 2.389979079406345, 0.0, 0.0], [0.13416407864998736, -0.19749126846635062, 2.818332343581848, 0.0], [-0.2683281572999747, 0.43682390737048743, 0.64657701271919, 3.052723872310221]], cholesky_matrix_decomposition.cholesky_decomposition([[5, 1.2, 0.3, -0.6], [1.2, 6, -0.4, 0.9], [0.3, -0.4, 8, 1.7], [-0.6, 0.9, 1.7, 10]]))"}}}, "TestInversion": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 142, "max_lineno": 180}, "methods": {"test_inversion": {"args": ["self"], "min_max_lineno": {"min_lineno": 150, "max_lineno": 180}, "calls": ["test_matrix.TestInversion.assertEqual", "algorithms.matrix.matrix_inversion.invert_matrix", "Fraction"], "source_code": "def test_inversion(self):\n    from fractions import Fraction\n    m1 = [[1, 1], [1, 2]]\n    self.assertEqual(matrix_inversion.invert_matrix(m1), [[2, -1], [-1, 1]])\n    m2 = [[1, 2], [3, 4, 5]]\n    self.assertEqual(matrix_inversion.invert_matrix(m2), [[-1]])\n    m3 = [[1, 1, 1, 1], [2, 2, 2, 2]]\n    self.assertEqual(matrix_inversion.invert_matrix(m3), [[-2]])\n    m4 = [[1]]\n    self.assertEqual(matrix_inversion.invert_matrix(m4), [[-3]])\n    m5 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    self.assertEqual(matrix_inversion.invert_matrix(m5), [[-4]])\n    m6 = [[3, 5, 1], [2, 5, 0], [1, 9, 8]]\n    self.assertEqual(matrix_inversion.invert_matrix(m6), [[Fraction(40, 53), Fraction(-31, 53), Fraction(-5, 53)], [Fraction(-16, 53), Fraction(23, 53), Fraction(2, 53)], [Fraction(13, 53), Fraction(-22, 53), Fraction(5, 53)]])"}}}, "TestMatrixExponentiation": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 182, "max_lineno": 204}, "methods": {"test_matrix_exponentiation": {"args": ["self"], "min_max_lineno": {"min_lineno": 190, "max_lineno": 204}, "calls": ["test_matrix.TestMatrixExponentiation.assertEqual", "algorithms.matrix.matrix_exponentiation.matrix_exponentiation"], "source_code": "def test_matrix_exponentiation(self):\n    mat = [[1, 0, 2], [2, 1, 0], [0, 2, 1]]\n    self.assertEqual(matrix_exponentiation.matrix_exponentiation(mat, 0), [[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    self.assertEqual(matrix_exponentiation.matrix_exponentiation(mat, 1), [[1, 0, 2], [2, 1, 0], [0, 2, 1]])\n    self.assertEqual(matrix_exponentiation.matrix_exponentiation(mat, 2), [[1, 4, 4], [4, 1, 4], [4, 4, 1]])\n    self.assertEqual(matrix_exponentiation.matrix_exponentiation(mat, 5), [[81, 72, 90], [90, 81, 72], [72, 90, 81]])"}}}, "TestMultiply": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 206, "max_lineno": 217}, "methods": {"test_multiply": {"args": ["self"], "min_max_lineno": {"min_lineno": 214, "max_lineno": 217}, "calls": ["test_matrix.TestMultiply.assertEqual", "algorithms.matrix.multiply.multiply"], "source_code": "def test_multiply(self):\n    self.assertEqual(multiply.multiply([[1, 2, 3], [2, 1, 1]], [[1], [2], [3]]), [[14], [7]])"}}}, "TestRotateImage": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 219, "max_lineno": 231}, "methods": {"test_rotate_image": {"args": ["self"], "min_max_lineno": {"min_lineno": 227, "max_lineno": 231}, "calls": ["test_matrix.TestRotateImage.assertEqual", "algorithms.matrix.rotate_image.rotate"], "source_code": "def test_rotate_image(self):\n    self.assertEqual(rotate_image.rotate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[7, 4, 1], [8, 5, 2], [9, 6, 3]])"}}}, "TestSparseDotVector": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 233, "max_lineno": 248}, "methods": {"test_sparse_dot_vector": {"args": ["self"], "min_max_lineno": {"min_lineno": 241, "max_lineno": 248}, "calls": ["test_matrix.TestSparseDotVector.assertEqual", "algorithms.matrix.sparse_dot_vector.dot_product", "algorithms.matrix.sparse_dot_vector.vector_to_index_value_list"], "source_code": "def test_sparse_dot_vector(self):\n    self.assertEqual(sparse_dot_vector.dot_product(sparse_dot_vector.vector_to_index_value_list([1.0, 2.0, 3.0]), sparse_dot_vector.vector_to_index_value_list([0.0, 2.0, 2.0])), 10)"}}}, "TestSpiralTraversal": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 250, "max_lineno": 261}, "methods": {"test_spiral_traversal": {"args": ["self"], "min_max_lineno": {"min_lineno": 258, "max_lineno": 261}, "calls": ["test_matrix.TestSpiralTraversal.assertEqual", "algorithms.matrix.spiral_traversal.spiral_traversal"], "source_code": "def test_spiral_traversal(self):\n    self.assertEqual(spiral_traversal.spiral_traversal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [1, 2, 3, 6, 9, 8, 7, 4, 5])"}}}, "TestSudokuValidator": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 263, "max_lineno": 354}, "methods": {"test_sudoku_validator": {"args": ["self"], "min_max_lineno": {"min_lineno": 271, "max_lineno": 354}, "calls": ["test_matrix.TestSudokuValidator.assertTrue", "test_matrix.TestSudokuValidator.assertFalse", "algorithms.matrix.sudoku_validator.valid_solution", "algorithms.matrix.sudoku_validator.valid_solution_hashtable", "algorithms.matrix.sudoku_validator.valid_solution_set"], "source_code": "def test_sudoku_validator(self):\n    self.assertTrue(sudoku_validator.valid_solution([[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]))\n    self.assertTrue(sudoku_validator.valid_solution_hashtable([[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]))\n    self.assertTrue(sudoku_validator.valid_solution_set([[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]))\n    self.assertFalse(sudoku_validator.valid_solution([[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 0, 3, 4, 9], [1, 0, 0, 3, 4, 2, 5, 6, 0], [8, 5, 9, 7, 6, 1, 0, 2, 0], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 0, 1, 5, 3, 7, 2, 1, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 0, 0, 4, 8, 1, 1, 7, 9]]))\n    self.assertFalse(sudoku_validator.valid_solution_hashtable([[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 0, 3, 4, 9], [1, 0, 0, 3, 4, 2, 5, 6, 0], [8, 5, 9, 7, 6, 1, 0, 2, 0], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 0, 1, 5, 3, 7, 2, 1, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 0, 0, 4, 8, 1, 1, 7, 9]]))\n    self.assertFalse(sudoku_validator.valid_solution_set([[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 0, 3, 4, 9], [1, 0, 0, 3, 4, 2, 5, 6, 0], [8, 5, 9, 7, 6, 1, 0, 2, 0], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 0, 1, 5, 3, 7, 2, 1, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 0, 0, 4, 8, 1, 1, 7, 9]]))"}}}, "TestSumSubSquares": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 357, "max_lineno": 373}, "methods": {"test_sum_sub_squares": {"args": ["self"], "min_max_lineno": {"min_lineno": 365, "max_lineno": 373}, "calls": ["test_matrix.TestSumSubSquares.assertEqual", "algorithms.matrix.sum_sub_squares.sum_sub_squares"], "source_code": "def test_sum_sub_squares(self):\n    mat = [[1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4], [5, 5, 5, 5, 5]]\n    self.assertEqual(sum_sub_squares.sum_sub_squares(mat, 3), [[18, 18, 18], [27, 27, 27], [36, 36, 36]])"}}}, "TestSortMatrixDiagonally": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 375, "max_lineno": 387}, "methods": {"test_sort_diagonally": {"args": ["self"], "min_max_lineno": {"min_lineno": 376, "max_lineno": 387}, "calls": ["test_matrix.TestSortMatrixDiagonally.assertEqual", "algorithms.matrix.sort_matrix_diagonally.sort_diagonally"], "source_code": "def test_sort_diagonally(self):\n    mat = [[3, 3, 1, 1], [2, 2, 1, 2], [1, 1, 1, 2]]\n    self.assertEqual(sort_matrix_diagonally.sort_diagonally(mat), [[1, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3]])"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_matrix.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_linkedlist.py", "fileNameBase": "test_linkedlist", "extension": "py"}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "reverse_list", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "reverse_list_recursive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "is_sorted", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "remove_range", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "swap_pairs", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "rotate_right", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "is_cyclic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "merge_two_list", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "merge_two_list_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "is_palindrome", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "is_palindrome_stack", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "is_palindrome_dict", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "RandomListNode", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "copy_random_pointer_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.linkedlist", "import": "copy_random_pointer_v2", "type": "external", "type_element": "module"}], "classes": {"Node": {"extend": ["object"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 20}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 20}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.next = None"}}}, "TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 212}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 46}, "calls": ["test_linkedlist.Node"], "store_vars_calls": {"self.l": "Node", "self.l.next": "Node", "self.l.next.next": "Node", "self.l.next.next.next": "Node", "self.l.next.next.next.next": "Node", "self.l1": "Node", "self.l1.next": "Node", "self.l1.next.next": "Node", "self.l1.next.next.next": "Node"}, "source_code": "def setUp(self):\n    self.l = Node('A')\n    self.l.next = Node('B')\n    self.l.next.next = Node('C')\n    self.l.next.next.next = Node('B')\n    self.l.next.next.next.next = Node('A')\n    self.l1 = Node('A')\n    self.l1.next = Node('B')\n    self.l1.next.next = Node('C')\n    self.l1.next.next.next = Node('B')"}, "test_reverse_list": {"args": ["self"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 58}, "calls": ["test_linkedlist.Node", "test_linkedlist.TestSuite.assertEqual", "test_linkedlist.convert", "algorithms.linkedlist.reverse_list", "algorithms.linkedlist.reverse_list_recursive"], "store_vars_calls": {"head": "Node", "head.next": "Node", "head.next.next": "Node", "head.next.next.next": "Node"}, "source_code": "def test_reverse_list(self):\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    self.assertEqual([4, 3, 2, 1], convert(reverse_list(head)))\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    self.assertEqual([4, 3, 2, 1], convert(reverse_list_recursive(head)))"}, "test_is_sorted": {"args": ["self"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 74}, "calls": ["test_linkedlist.Node", "test_linkedlist.TestSuite.assertTrue", "test_linkedlist.TestSuite.assertFalse", "algorithms.linkedlist.is_sorted"], "store_vars_calls": {"head": "Node", "head.next": "Node", "head.next.next": "Node", "head.next.next.next": "Node", "head.next.next.next.next": "Node"}, "source_code": "def test_is_sorted(self):\n    head = Node(-2)\n    head.next = Node(2)\n    head.next.next = Node(2)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(9)\n    self.assertTrue(is_sorted(head))\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(8)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(6)\n    self.assertFalse(is_sorted(head))"}, "test_remove_range": {"args": ["self"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 101}, "calls": ["test_linkedlist.Node", "test_linkedlist.TestSuite.assertEqual", "test_linkedlist.convert", "algorithms.linkedlist.remove_range"], "store_vars_calls": {"head": "Node", "head.next": "Node", "head.next.next": "Node", "head.next.next.next": "Node", "head.next.next.next.next": "Node"}, "source_code": "def test_remove_range(self):\n    head = Node(0)\n    head.next = Node(1)\n    head.next.next = Node(2)\n    head.next.next.next = Node(3)\n    head.next.next.next.next = Node(4)\n    self.assertEqual([0, 4], convert(remove_range(head, 1, 3)))\n    head = Node(0)\n    head.next = Node(1)\n    head.next.next = Node(2)\n    head.next.next.next = Node(3)\n    head.next.next.next.next = Node(4)\n    self.assertEqual([2, 3, 4], convert(remove_range(head, 0, 1)))\n    head = Node(0)\n    head.next = Node(1)\n    head.next.next = Node(2)\n    head.next.next.next = Node(3)\n    head.next.next.next.next = Node(4)\n    self.assertEqual([], convert(remove_range(head, 0, 7)))"}, "test_swap_in_pairs": {"args": ["self"], "min_max_lineno": {"min_lineno": 102, "max_lineno": 109}, "calls": ["test_linkedlist.Node", "test_linkedlist.TestSuite.assertEqual", "test_linkedlist.convert", "algorithms.linkedlist.swap_pairs"], "store_vars_calls": {"head": "Node", "head.next": "Node", "head.next.next": "Node", "head.next.next.next": "Node"}, "source_code": "def test_swap_in_pairs(self):\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    self.assertEqual([2, 1, 4, 3], convert(swap_pairs(head)))"}, "test_rotate_right": {"args": ["self"], "min_max_lineno": {"min_lineno": 110, "max_lineno": 119}, "calls": ["test_linkedlist.Node", "test_linkedlist.TestSuite.assertEqual", "test_linkedlist.convert", "algorithms.linkedlist.rotate_right"], "store_vars_calls": {"head": "Node", "head.next": "Node", "head.next.next": "Node", "head.next.next.next": "Node", "head.next.next.next.next": "Node"}, "source_code": "def test_rotate_right(self):\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    self.assertEqual([4, 5, 1, 2, 3], convert(rotate_right(head, 2)))"}, "test_is_cyclic": {"args": ["self"], "min_max_lineno": {"min_lineno": 120, "max_lineno": 142}, "calls": ["test_linkedlist.Node", "test_linkedlist.TestSuite.assertTrue", "range", "test_linkedlist.TestSuite.assertFalse", "algorithms.linkedlist.is_cyclic"], "store_vars_calls": {"head": "Node", "head.next": "Node", "cyclic_node": "Node", "curr.next": "Node"}, "source_code": "def test_is_cyclic(self):\n    head = Node('A')\n    head.next = Node('B')\n    curr = head.next\n    cyclic_node = Node('C')\n    curr.next = cyclic_node\n    curr = curr.next\n    curr.next = Node('D')\n    curr = curr.next\n    curr.next = Node('E')\n    curr = curr.next\n    curr.next = cyclic_node\n    self.assertTrue(is_cyclic(head))\n    head = Node(1)\n    curr = head\n    for i in range(2, 6):\n        curr.next = Node(i)\n        curr = curr.next\n    self.assertFalse(is_cyclic(head))"}, "test_merge_two_list": {"doc": {"long_description": "Output: 1->1->2->3->4->4", "short_description": "Input: head1:1->2->4, head2: 1->3->4"}, "args": ["self"], "min_max_lineno": {"min_lineno": 143, "max_lineno": 165}, "calls": ["test_linkedlist.Node", "test_linkedlist.TestSuite.assertEqual", "test_linkedlist.convert", "algorithms.linkedlist.merge_two_list", "algorithms.linkedlist.merge_two_list_recur"], "store_vars_calls": {"head1": "Node", "head1.next": "Node", "head1.next.next": "Node", "head2": "Node", "head2.next": "Node", "head2.next.next": "Node"}, "source_code": "def test_merge_two_list(self):\n    \"\"\"\n        Input: head1:1->2->4, head2: 1->3->4\n        Output: 1->1->2->3->4->4\n        \"\"\"\n    head1 = Node(1)\n    head1.next = Node(2)\n    head1.next.next = Node(4)\n    head2 = Node(1)\n    head2.next = Node(3)\n    head2.next.next = Node(4)\n    self.assertEqual([1, 1, 2, 3, 4, 4], convert(merge_two_list(head1, head2)))\n    head1 = Node(1)\n    head1.next = Node(2)\n    head1.next.next = Node(4)\n    head2 = Node(1)\n    head2.next = Node(3)\n    head2.next.next = Node(4)\n    self.assertEqual([1, 1, 2, 3, 4, 4], convert(merge_two_list_recur(head1, head2)))"}, "test_is_palindrome": {"args": ["self"], "min_max_lineno": {"min_lineno": 166, "max_lineno": 169}, "calls": ["test_linkedlist.TestSuite.assertTrue", "test_linkedlist.TestSuite.assertFalse", "algorithms.linkedlist.is_palindrome"], "source_code": "def test_is_palindrome(self):\n    self.assertTrue(is_palindrome(self.l))\n    self.assertFalse(is_palindrome(self.l1))"}, "test_is_palindrome_stack": {"args": ["self"], "min_max_lineno": {"min_lineno": 170, "max_lineno": 173}, "calls": ["test_linkedlist.TestSuite.assertTrue", "test_linkedlist.TestSuite.assertFalse", "algorithms.linkedlist.is_palindrome_stack"], "source_code": "def test_is_palindrome_stack(self):\n    self.assertTrue(is_palindrome_stack(self.l))\n    self.assertFalse(is_palindrome_stack(self.l1))"}, "test_is_palindrome_dict": {"args": ["self"], "min_max_lineno": {"min_lineno": 174, "max_lineno": 177}, "calls": ["test_linkedlist.TestSuite.assertTrue", "test_linkedlist.TestSuite.assertFalse", "algorithms.linkedlist.is_palindrome_dict"], "source_code": "def test_is_palindrome_dict(self):\n    self.assertTrue(is_palindrome_dict(self.l))\n    self.assertFalse(is_palindrome_dict(self.l1))"}, "test_solution_0": {"args": ["self"], "min_max_lineno": {"min_lineno": 178, "max_lineno": 182}, "calls": ["test_linkedlist.TestSuite._init_random_list_nodes", "algorithms.linkedlist.copy_random_pointer_v1", "test_linkedlist.TestSuite._assert_is_a_copy"], "store_vars_calls": {"result": "copy_random_pointer_v1"}, "source_code": "def test_solution_0(self):\n    self._init_random_list_nodes()\n    result = copy_random_pointer_v1(self.random_list_node1)\n    self._assert_is_a_copy(result)"}, "test_solution_1": {"args": ["self"], "min_max_lineno": {"min_lineno": 183, "max_lineno": 187}, "calls": ["test_linkedlist.TestSuite._init_random_list_nodes", "algorithms.linkedlist.copy_random_pointer_v2", "test_linkedlist.TestSuite._assert_is_a_copy"], "store_vars_calls": {"result": "copy_random_pointer_v2"}, "source_code": "def test_solution_1(self):\n    self._init_random_list_nodes()\n    result = copy_random_pointer_v2(self.random_list_node1)\n    self._assert_is_a_copy(result)"}, "_assert_is_a_copy": {"args": ["self", "result"], "min_max_lineno": {"min_lineno": 188, "max_lineno": 199}, "calls": ["test_linkedlist.TestSuite.assertEqual", "test_linkedlist.TestSuite.assertIsNone"], "source_code": "def _assert_is_a_copy(self, result):\n    self.assertEqual(5, result.next.next.next.next.label)\n    self.assertEqual(4, result.next.next.next.label)\n    self.assertEqual(3, result.next.next.label)\n    self.assertEqual(2, result.next.label)\n    self.assertEqual(1, result.label)\n    self.assertEqual(3, result.next.next.next.next.random.label)\n    self.assertIsNone(result.next.next.next.random)\n    self.assertEqual(2, result.next.next.random.label)\n    self.assertEqual(5, result.next.random.label)\n    self.assertEqual(4, result.random.label)"}, "_init_random_list_nodes": {"args": ["self"], "min_max_lineno": {"min_lineno": 200, "max_lineno": 212}, "calls": ["algorithms.linkedlist.RandomListNode"], "store_vars_calls": {"self.random_list_node1": "RandomListNode", "random_list_node2": "RandomListNode", "random_list_node3": "RandomListNode", "random_list_node4": "RandomListNode", "random_list_node5": "RandomListNode"}, "source_code": "def _init_random_list_nodes(self):\n    self.random_list_node1 = RandomListNode(1)\n    random_list_node2 = RandomListNode(2)\n    random_list_node3 = RandomListNode(3)\n    random_list_node4 = RandomListNode(4)\n    random_list_node5 = RandomListNode(5)\n    (self.random_list_node1.next, self.random_list_node1.random) = (random_list_node2, random_list_node4)\n    (random_list_node2.next, random_list_node2.random) = (random_list_node3, random_list_node5)\n    (random_list_node3.next, random_list_node3.random) = (random_list_node4, random_list_node2)\n    random_list_node4.next = random_list_node5\n    random_list_node5.random = random_list_node3"}}}}, "functions": {"convert": {"args": ["head"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 31}, "calls": ["ret.append"], "source_code": "def convert(head):\n    ret = []\n    if head:\n        current = head\n        while current:\n            ret.append(current.val)\n            current = current.next\n    return ret"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_linkedlist.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_search.py", "fileNameBase": "test_search", "extension": "py"}, "dependencies": [{"from_module": "algorithms.search", "import": "binary_search", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "binary_search_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "ternary_search", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "first_occurrence", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "last_occurrence", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "linear_search", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "search_insert", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "two_sum", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "two_sum1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "two_sum2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "search_range", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "find_min_rotate", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "find_min_rotate_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "search_rotate", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "search_rotate_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "jump_search", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "next_greatest_letter", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "next_greatest_letter_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "next_greatest_letter_v2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.search", "import": "interpolation_search", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 149}, "methods": {"test_first_occurrence": {"args": ["self"], "returns": ["idx"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 33}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.first_occurrence", "test_search.TestSuite.test_first_occurrence.helper"], "functions": {"helper": {"args": ["array", "query"], "returns": ["idx"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 26}, "calls": ["array.index"], "source_code": "def helper(array, query):\n    idx = array.index(query) if query in array else None\n    return idx"}}, "source_code": "def test_first_occurrence(self):\n\n    def helper(array, query):\n        idx = array.index(query) if query in array else None\n        return idx\n    array = [1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6, 6, 6]\n    self.assertEqual(first_occurrence(array, 1), helper(array, 1))\n    self.assertEqual(first_occurrence(array, 3), helper(array, 3))\n    self.assertEqual(first_occurrence(array, 5), helper(array, 5))\n    self.assertEqual(first_occurrence(array, 6), helper(array, 6))\n    self.assertEqual(first_occurrence(array, 7), helper(array, 7))\n    self.assertEqual(first_occurrence(array, -1), helper(array, -1))"}, "test_binary_search": {"args": ["self"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 45}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.binary_search", "algorithms.search.binary_search_recur"], "source_code": "def test_binary_search(self):\n    array = [1, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6]\n    self.assertEqual(10, binary_search(array, 5))\n    self.assertEqual(11, binary_search(array, 6))\n    self.assertEqual(None, binary_search(array, 7))\n    self.assertEqual(None, binary_search(array, -1))\n    self.assertEqual(10, binary_search_recur(array, 0, 11, 5))\n    self.assertEqual(11, binary_search_recur(array, 0, 11, 6))\n    self.assertEqual(-1, binary_search_recur(array, 0, 11, 7))\n    self.assertEqual(-1, binary_search_recur(array, 0, 11, -1))"}, "test_ternary_search": {"args": ["self"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 53}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.ternary_search"], "source_code": "def test_ternary_search(self):\n    array = [1, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6]\n    self.assertEqual(10, ternary_search(0, 11, 5, array))\n    self.assertEqual(3, ternary_search(0, 10, 3, array))\n    self.assertEqual(-1, ternary_search(0, 10, 5, array))\n    self.assertEqual(-1, ternary_search(0, 11, 7, array))\n    self.assertEqual(-1, ternary_search(0, 11, -1, array))"}, "test_last_occurrence": {"args": ["self"], "min_max_lineno": {"min_lineno": 54, "max_lineno": 61}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.last_occurrence"], "source_code": "def test_last_occurrence(self):\n    array = [1, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6, 6, 6]\n    self.assertEqual(5, last_occurrence(array, 3))\n    self.assertEqual(10, last_occurrence(array, 5))\n    self.assertEqual(None, last_occurrence(array, 7))\n    self.assertEqual(0, last_occurrence(array, 1))\n    self.assertEqual(13, last_occurrence(array, 6))"}, "test_linear_search": {"args": ["self"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 68}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.linear_search"], "source_code": "def test_linear_search(self):\n    array = [1, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6, 6, 6]\n    self.assertEqual(6, linear_search(array, 4))\n    self.assertEqual(10, linear_search(array, 5))\n    self.assertEqual(-1, linear_search(array, 7))\n    self.assertEqual(-1, linear_search(array, -1))"}, "test_search_insert": {"args": ["self"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 75}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.search_insert"], "source_code": "def test_search_insert(self):\n    array = [1, 3, 5, 6]\n    self.assertEqual(2, search_insert(array, 5))\n    self.assertEqual(1, search_insert(array, 2))\n    self.assertEqual(4, search_insert(array, 7))\n    self.assertEqual(0, search_insert(array, 0))"}, "test_two_sum": {"args": ["self"], "min_max_lineno": {"min_lineno": 76, "max_lineno": 87}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.two_sum", "algorithms.search.two_sum1", "algorithms.search.two_sum2"], "source_code": "def test_two_sum(self):\n    array = [2, 7, 11, 15]\n    self.assertEqual([1, 2], two_sum(array, 9))\n    self.assertEqual([2, 4], two_sum(array, 22))\n    self.assertEqual([1, 2], two_sum1(array, 9))\n    self.assertEqual([2, 4], two_sum1(array, 22))\n    self.assertEqual([1, 2], two_sum2(array, 9))\n    self.assertEqual([2, 4], two_sum2(array, 22))"}, "test_search_range": {"args": ["self"], "min_max_lineno": {"min_lineno": 88, "max_lineno": 98}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.search_range"], "source_code": "def test_search_range(self):\n    array = [5, 7, 7, 8, 8, 8, 10]\n    self.assertEqual([3, 5], search_range(array, 8))\n    self.assertEqual([1, 2], search_range(array, 7))\n    self.assertEqual([-1, -1], search_range(array, 11))\n    array = [5, 7, 7, 7, 7, 8, 8, 8, 8, 10]\n    self.assertEqual([5, 8], search_range(array, 8))\n    self.assertEqual([1, 4], search_range(array, 7))\n    self.assertEqual([-1, -1], search_range(array, 11))"}, "test_find_min_rotate": {"args": ["self"], "min_max_lineno": {"min_lineno": 99, "max_lineno": 109}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.find_min_rotate", "algorithms.search.find_min_rotate_recur"], "source_code": "def test_find_min_rotate(self):\n    array = [4, 5, 6, 7, 0, 1, 2]\n    self.assertEqual(0, find_min_rotate(array))\n    array = [10, 20, -1, 0, 1, 2, 3, 4, 5]\n    self.assertEqual(-1, find_min_rotate(array))\n    array = [4, 5, 6, 7, 0, 1, 2]\n    self.assertEqual(0, find_min_rotate_recur(array, 0, 6))\n    array = [10, 20, -1, 0, 1, 2, 3, 4, 5]\n    self.assertEqual(-1, find_min_rotate_recur(array, 0, 8))"}, "test_search_rotate": {"args": ["self"], "min_max_lineno": {"min_lineno": 110, "max_lineno": 116}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.search_rotate", "algorithms.search.search_rotate_recur"], "source_code": "def test_search_rotate(self):\n    array = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14]\n    self.assertEqual(8, search_rotate(array, 5))\n    self.assertEqual(-1, search_rotate(array, 9))\n    self.assertEqual(8, search_rotate_recur(array, 0, 11, 5))\n    self.assertEqual(-1, search_rotate_recur(array, 0, 11, 9))"}, "test_jump_search": {"args": ["self"], "min_max_lineno": {"min_lineno": 117, "max_lineno": 123}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.jump_search"], "source_code": "def test_jump_search(self):\n    array = [1, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6]\n    self.assertEqual(10, jump_search(array, 5))\n    self.assertEqual(2, jump_search(array, 3))\n    self.assertEqual(-1, jump_search(array, 7))\n    self.assertEqual(-1, jump_search(array, -1))"}, "test_next_greatest_letter": {"args": ["self"], "min_max_lineno": {"min_lineno": 124, "max_lineno": 140}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.next_greatest_letter", "algorithms.search.next_greatest_letter_v1", "algorithms.search.next_greatest_letter_v2"], "source_code": "def test_next_greatest_letter(self):\n    letters = ['c', 'f', 'j']\n    target = 'a'\n    self.assertEqual('c', next_greatest_letter(letters, target))\n    self.assertEqual('c', next_greatest_letter_v1(letters, target))\n    self.assertEqual('c', next_greatest_letter_v2(letters, target))\n    letters = ['c', 'f', 'j']\n    target = 'd'\n    self.assertEqual('f', next_greatest_letter(letters, target))\n    self.assertEqual('f', next_greatest_letter_v1(letters, target))\n    self.assertEqual('f', next_greatest_letter_v2(letters, target))\n    letters = ['c', 'f', 'j']\n    target = 'j'\n    self.assertEqual('c', next_greatest_letter(letters, target))\n    self.assertEqual('c', next_greatest_letter_v1(letters, target))\n    self.assertEqual('c', next_greatest_letter_v2(letters, target))"}, "test_interpolation_search": {"args": ["self"], "min_max_lineno": {"min_lineno": 141, "max_lineno": 149}, "calls": ["test_search.TestSuite.assertEqual", "algorithms.search.interpolation_search"], "source_code": "def test_interpolation_search(self):\n    array = [0, 3, 5, 5, 9, 12, 12, 15, 16, 19, 20]\n    self.assertEqual(1, interpolation_search(array, 3))\n    self.assertEqual(2, interpolation_search(array, 5))\n    self.assertEqual(6, interpolation_search(array, 12))\n    self.assertEqual(-1, interpolation_search(array, 22))\n    self.assertEqual(-1, interpolation_search(array, -10))\n    self.assertEqual(10, interpolation_search(array, 20))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_search.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_histogram.py", "fileNameBase": "test_histogram", "extension": "py"}, "dependencies": [{"from_module": "algorithms.distribution.histogram", "import": "get_histogram", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestListsInHistogram": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 14}, "methods": {"test_histogram": {"args": ["self"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 14}, "calls": ["test_histogram.TestListsInHistogram.assertEqual", "algorithms.distribution.histogram.get_histogram"], "source_code": "def test_histogram(self):\n    list_1 = [3, 3, 2, 1]\n    list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7]\n    self.assertEqual(get_histogram(list_1), {1: 1, 2: 1, 3: 2})\n    self.assertEqual(get_histogram(list_2), {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1})"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_histogram.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_automata.py", "fileNameBase": "test_automata", "extension": "py"}, "dependencies": [{"from_module": "algorithms.automata", "import": "DFA", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestDFA": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 45}, "methods": {"test_DFA": {"args": ["self"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 45}, "calls": ["test_automata.TestDFA.assertEqual", "algorithms.automata.DFA"], "source_code": "def test_DFA(self):\n    transitions = {'a': {'1': 'a', '0': 'b'}, 'b': {'1': 'b', '0': 'a'}}\n    final = ['a']\n    start = 'a'\n    self.assertEqual(False, DFA(transitions, start, final, '000111100'))\n    self.assertEqual(True, DFA(transitions, start, final, '111000011'))\n    transitions1 = {'0': {'0': '1', '1': '0'}, '1': {'0': '2', '1': '0'}, '2': {'0': '2', '1': '3'}, '3': {'0': '3', '1': '3'}}\n    final1 = ['0', '1', '2']\n    start1 = '0'\n    self.assertEqual(False, DFA(transitions1, start1, final1, '0001111'))\n    self.assertEqual(True, DFA(transitions1, start1, final1, '01010101'))\n    transitions2 = {'0': {'a': '0', 'b': '1'}, '1': {'a': '0', 'b': '2'}, '2': {'a': '3', 'b': '2'}, '3': {'a': '3', 'b': '3'}}\n    final2 = ['3']\n    start2 = '0'\n    self.assertEqual(False, DFA(transitions2, start2, final2, 'aaabbb'))\n    self.assertEqual(True, DFA(transitions2, start2, final2, 'baabba'))"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_automata.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_graph.py", "fileNameBase": "test_graph", "extension": "py"}, "dependencies": [{"from_module": "algorithms.graph", "import": "Tarjan", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "check_bipartite", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph.dijkstra", "import": "Dijkstra", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "ford_fulkerson", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "edmonds_karp", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "dinic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "maximum_flow_bfs", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "maximum_flow_dfs", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "all_pairs_shortest_path", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "bellman_ford", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "count_connected_number_of_component", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "prims_minimum_spanning", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "check_digraph_strongly_connected", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "cycle_detection", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "find_path", "type": "external", "type_element": "module"}, {"from_module": "algorithms.graph", "import": "path_between_two_vertices_in_digraph", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestTarjan": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 62}, "methods": {"test_tarjan_example_1": {"args": ["self"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 45}, "calls": ["algorithms.graph.Tarjan", "test_graph.TestTarjan.assertEqual"], "store_vars_calls": {"g": "Tarjan"}, "source_code": "def test_tarjan_example_1(self):\n    example = {'A': ['B'], 'B': ['C', 'E', 'F'], 'C': ['D', 'G'], 'D': ['C', 'H'], 'E': ['A', 'F'], 'F': ['G'], 'G': ['F'], 'H': ['D', 'G']}\n    g = Tarjan(example)\n    self.assertEqual(g.sccs, [['F', 'G'], ['C', 'D', 'H'], ['A', 'B', 'E']])"}, "test_tarjan_example_2": {"args": ["self"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 62}, "calls": ["algorithms.graph.Tarjan", "test_graph.TestTarjan.assertEqual"], "store_vars_calls": {"g": "Tarjan"}, "source_code": "def test_tarjan_example_2(self):\n    example = {'A': ['E'], 'B': ['A'], 'C': ['B', 'D'], 'D': ['C'], 'E': ['B'], 'F': ['B', 'E', 'G'], 'G': ['F', 'C'], 'H': ['G', 'H', 'D']}\n    g = Tarjan(example)\n    self.assertEqual(g.sccs, [['A', 'B', 'E'], ['C', 'D'], ['F', 'G'], ['H']])"}}}, "TestCheckBipartite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 64, "max_lineno": 72}, "methods": {"test_check_bipartite": {"args": ["self"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 72}, "calls": ["test_graph.TestCheckBipartite.assertEqual", "algorithms.graph.check_bipartite"], "source_code": "def test_check_bipartite(self):\n    adj_list_1 = [[0, 0, 1], [0, 0, 1], [1, 1, 0]]\n    self.assertEqual(True, check_bipartite(adj_list_1))\n    adj_list_2 = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\n    self.assertEqual(True, check_bipartite(adj_list_2))\n    adj_list_3 = [[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]]\n    self.assertEqual(False, check_bipartite(adj_list_3))"}}}, "TestDijkstra": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 74, "max_lineno": 88}, "methods": {"test_dijkstra": {"args": ["self"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 88}, "calls": ["algorithms.graph.dijkstra.Dijkstra", "test_graph.TestDijkstra.assertEqual", "algorithms.graph.dijkstra.Dijkstra.dijkstra"], "store_vars_calls": {"g": "Dijkstra"}, "source_code": "def test_dijkstra(self):\n    g = Dijkstra(9)\n    g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0], [4, 0, 8, 0, 0, 0, 0, 11, 0], [0, 8, 0, 7, 0, 4, 0, 0, 2], [0, 0, 7, 0, 9, 14, 0, 0, 0], [0, 0, 0, 9, 0, 10, 0, 0, 0], [0, 0, 4, 14, 10, 0, 2, 0, 0], [0, 0, 0, 0, 0, 2, 0, 1, 6], [8, 11, 0, 0, 0, 0, 1, 0, 7], [0, 0, 2, 0, 0, 0, 6, 7, 0]]\n    self.assertEqual(g.dijkstra(0), [0, 4, 12, 19, 21, 11, 9, 8, 14])"}}}, "TestMaximumFlow": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 90, "max_lineno": 132}, "methods": {"test_ford_fulkerson": {"args": ["self"], "min_max_lineno": {"min_lineno": 97, "max_lineno": 108}, "calls": ["test_graph.TestMaximumFlow.assertEqual", "algorithms.graph.ford_fulkerson"], "source_code": "def test_ford_fulkerson(self):\n    capacity = [[0, 10, 10, 0, 0, 0, 0], [0, 0, 2, 0, 4, 8, 0], [0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 10], [0, 0, 0, 0, 6, 0, 10], [0, 0, 0, 0, 0, 0, 0]]\n    self.assertEqual(19, ford_fulkerson(capacity, 0, 6))"}, "test_edmonds_karp": {"args": ["self"], "min_max_lineno": {"min_lineno": 109, "max_lineno": 120}, "calls": ["test_graph.TestMaximumFlow.assertEqual", "algorithms.graph.edmonds_karp"], "source_code": "def test_edmonds_karp(self):\n    capacity = [[0, 10, 10, 0, 0, 0, 0], [0, 0, 2, 0, 4, 8, 0], [0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 10], [0, 0, 0, 0, 6, 0, 10], [0, 0, 0, 0, 0, 0, 0]]\n    self.assertEqual(19, edmonds_karp(capacity, 0, 6))"}, "dinic": {"args": ["self"], "min_max_lineno": {"min_lineno": 121, "max_lineno": 132}, "calls": ["test_graph.TestMaximumFlow.assertEqual", "algorithms.graph.dinic"], "source_code": "def dinic(self):\n    capacity = [[0, 10, 10, 0, 0, 0, 0], [0, 0, 2, 0, 4, 8, 0], [0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 10], [0, 0, 0, 0, 6, 0, 10], [0, 0, 0, 0, 0, 0, 0]]\n    self.assertEqual(19, dinic(capacity, 0, 6))"}}}, "TestMaximum_Flow_Bfs": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 134, "max_lineno": 153}, "methods": {"test_maximum_flow_bfs": {"args": ["self"], "min_max_lineno": {"min_lineno": 141, "max_lineno": 153}, "calls": ["algorithms.graph.maximum_flow_bfs", "test_graph.TestMaximum_Flow_Bfs.assertEqual"], "store_vars_calls": {"maximum_flow": "maximum_flow_bfs"}, "source_code": "def test_maximum_flow_bfs(self):\n    graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]]\n    maximum_flow = maximum_flow_bfs(graph)\n    self.assertEqual(maximum_flow, 23)"}}}, "TestMaximum_Flow_Dfs": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 155, "max_lineno": 174}, "methods": {"test_maximum_flow_dfs": {"args": ["self"], "min_max_lineno": {"min_lineno": 162, "max_lineno": 174}, "calls": ["algorithms.graph.maximum_flow_dfs", "test_graph.TestMaximum_Flow_Dfs.assertEqual"], "store_vars_calls": {"maximum_flow": "maximum_flow_dfs"}, "source_code": "def test_maximum_flow_dfs(self):\n    graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]]\n    maximum_flow = maximum_flow_dfs(graph)\n    self.assertEqual(maximum_flow, 23)"}}}, "TestAll_Pairs_Shortest_Path": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 176, "max_lineno": 194}, "methods": {"test_all_pairs_shortest_path": {"args": ["self"], "min_max_lineno": {"min_lineno": 177, "max_lineno": 194}, "calls": ["algorithms.graph.all_pairs_shortest_path", "test_graph.TestAll_Pairs_Shortest_Path.assertEqual"], "store_vars_calls": {"result": "all_pairs_shortest_path"}, "source_code": "def test_all_pairs_shortest_path(self):\n    graph = [[0, 0.1, 0.101, 0.142, 0.277], [0.465, 0, 0.191, 0.192, 0.587], [0.245, 0.554, 0, 0.333, 0.931], [1.032, 0.668, 0.656, 0, 0.151], [0.867, 0.119, 0.352, 0.398, 0]]\n    result = all_pairs_shortest_path(graph)\n    self.assertEqual(result, [[0, 0.1, 0.101, 0.142, 0.277], [0.436, 0, 0.191, 0.192, 0.34299999999999997], [0.245, 0.345, 0, 0.333, 0.484], [0.706, 0.27, 0.46099999999999997, 0, 0.151], [0.5549999999999999, 0.119, 0.31, 0.311, 0]])"}}}, "TestBellmanFord": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 197, "max_lineno": 215}, "methods": {"test_bellman_ford": {"args": ["self"], "min_max_lineno": {"min_lineno": 198, "max_lineno": 215}, "calls": ["test_graph.TestBellmanFord.assertEqual", "algorithms.graph.bellman_ford"], "source_code": "def test_bellman_ford(self):\n    graph1 = {'a': {'b': 6, 'e': 7}, 'b': {'c': 5, 'd': -4, 'e': 8}, 'c': {'b': -2}, 'd': {'a': 2, 'c': 7}, 'e': {'b': -3}}\n    self.assertEqual(True, bellman_ford(graph1, 'a'))\n    graph2 = {'a': {'d': 3, 'e': 4}, 'b': {'a': 7, 'e': 2}, 'c': {'a': 12, 'd': 9, 'e': 11}, 'd': {'c': 5, 'e': 11}, 'e': {'a': 7, 'b': 5, 'd': 1}}\n    self.assertEqual(True, bellman_ford(graph2, 'a'))"}}}, "TestConnectedComponentInGraph": {"doc": {"short_description": "Class for testing different cases for connected components in graph", "full": "Class for testing different cases for connected components in graph"}, "extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 217, "max_lineno": 266}, "methods": {"test_count_connected_components": {"doc": {"long_description": "components\n 2----------0    1--------5      3\n |\n |\n 4\n     output = 3", "short_description": "Test Function that test the different cases of count connected"}, "args": ["self"], "min_max_lineno": {"min_lineno": 221, "max_lineno": 243}, "calls": ["algorithms.graph.count_connected_number_of_component.count_components", "test_graph.TestConnectedComponentInGraph.assertEqual"], "store_vars_calls": {"result": "count_connected_number_of_component.count_components"}, "source_code": "def test_count_connected_components(self):\n    \"\"\"\n           Test Function that test the different cases of count connected\n           components\n            2----------0    1--------5      3\n            |\n            |\n            4\n                output = 3\n        \"\"\"\n    expected_result = 3\n    l = [[2], [5], [0, 4], [], [2], [1]]\n    size = 5\n    result = count_connected_number_of_component.count_components(l, size)\n    self.assertEqual(result, expected_result)"}, "test_connected_components_with_empty_graph": {"doc": {"long_description": "output : 0", "short_description": "input :"}, "args": ["self"], "min_max_lineno": {"min_lineno": 244, "max_lineno": 255}, "calls": ["algorithms.graph.count_connected_number_of_component.count_components", "test_graph.TestConnectedComponentInGraph.assertEqual"], "store_vars_calls": {"result": "count_connected_number_of_component.count_components"}, "source_code": "def test_connected_components_with_empty_graph(self):\n    \"\"\"\n            input :\n            output : 0\n        \"\"\"\n    l = [[]]\n    expected_result = 0\n    size = 0\n    result = count_connected_number_of_component.count_components(l, size)\n    self.assertEqual(result, expected_result)"}, "test_connected_components_without_edges_graph": {"doc": {"long_description": "output : 4", "short_description": "input : 0          2             3          4"}, "args": ["self"], "min_max_lineno": {"min_lineno": 256, "max_lineno": 266}, "calls": ["algorithms.graph.count_connected_number_of_component.count_components", "test_graph.TestConnectedComponentInGraph.assertEqual"], "store_vars_calls": {"result": "count_connected_number_of_component.count_components"}, "source_code": "def test_connected_components_without_edges_graph(self):\n    \"\"\"\n          input : 0          2             3          4\n          output : 4\n        \"\"\"\n    l = [[0], [], [2], [3], [4]]\n    size = 4\n    expected_result = 4\n    result = count_connected_number_of_component.count_components(l, size)\n    self.assertEqual(result, expected_result)"}}}, "PrimsMinimumSpanning": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 268, "max_lineno": 285}, "methods": {"test_prim_spanning": {"args": ["self"], "min_max_lineno": {"min_lineno": 269, "max_lineno": 285}, "calls": ["test_graph.PrimsMinimumSpanning.assertEqual", "algorithms.graph.prims_minimum_spanning"], "source_code": "def test_prim_spanning(self):\n    graph1 = {1: [[3, 2], [8, 3]], 2: [[3, 1], [5, 4]], 3: [[8, 1], [2, 4], [4, 5]], 4: [[5, 2], [2, 3], [6, 5]], 5: [[4, 3], [6, 4]]}\n    self.assertEqual(14, prims_minimum_spanning(graph1))\n    graph2 = {1: [[7, 2], [6, 4]], 2: [[7, 1], [9, 4], [6, 3]], 3: [[8, 4], [6, 2]], 4: [[6, 1], [9, 2], [8, 3]]}\n    self.assertEqual(19, prims_minimum_spanning(graph2))"}}}, "TestDigraphStronglyConnected": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 286, "max_lineno": 302}, "methods": {"test_digraph_strongly_connected": {"args": ["self"], "min_max_lineno": {"min_lineno": 287, "max_lineno": 302}, "calls": ["algorithms.graph.check_digraph_strongly_connected.Graph", "algorithms.graph.check_digraph_strongly_connected.Graph.add_edge", "test_graph.TestDigraphStronglyConnected.assertTrue", "algorithms.graph.check_digraph_strongly_connected.Graph.add_edge", "test_graph.TestDigraphStronglyConnected.assertFalse", "algorithms.graph.check_digraph_strongly_connected.Graph.is_strongly_connected", "algorithms.graph.check_digraph_strongly_connected.Graph.is_strongly_connected"], "store_vars_calls": {"g1": "check_digraph_strongly_connected.Graph", "g2": "check_digraph_strongly_connected.Graph"}, "source_code": "def test_digraph_strongly_connected(self):\n    g1 = check_digraph_strongly_connected.Graph(5)\n    g1.add_edge(0, 1)\n    g1.add_edge(1, 2)\n    g1.add_edge(2, 3)\n    g1.add_edge(3, 0)\n    g1.add_edge(2, 4)\n    g1.add_edge(4, 2)\n    self.assertTrue(g1.is_strongly_connected())\n    g2 = check_digraph_strongly_connected.Graph(4)\n    g2.add_edge(0, 1)\n    g2.add_edge(1, 2)\n    g2.add_edge(2, 3)\n    self.assertFalse(g2.is_strongly_connected())"}}}, "TestCycleDetection": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 303, "max_lineno": 321}, "methods": {"test_cycle_detection_with_cycle": {"args": ["self"], "min_max_lineno": {"min_lineno": 304, "max_lineno": 312}, "calls": ["test_graph.TestCycleDetection.assertTrue", "algorithms.graph.cycle_detection.contains_cycle"], "source_code": "def test_cycle_detection_with_cycle(self):\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['F'], 'D': ['E', 'F'], 'E': ['B'], 'F': []}\n    self.assertTrue(cycle_detection.contains_cycle(graph))"}, "test_cycle_detection_with_no_cycle": {"args": ["self"], "min_max_lineno": {"min_lineno": 313, "max_lineno": 321}, "calls": ["test_graph.TestCycleDetection.assertFalse", "algorithms.graph.cycle_detection.contains_cycle"], "source_code": "def test_cycle_detection_with_no_cycle(self):\n    graph = {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': ['E'], 'E': [], 'F': []}\n    self.assertFalse(cycle_detection.contains_cycle(graph))"}}}, "TestFindPath": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 322, "max_lineno": 337}, "methods": {"test_find_all_paths": {"args": ["self"], "min_max_lineno": {"min_lineno": 323, "max_lineno": 337}, "calls": ["algorithms.graph.find_path.find_all_path", "print", "test_graph.TestFindPath.assertEqual", "sorted"], "store_vars_calls": {"paths": "find_path.find_all_path"}, "source_code": "def test_find_all_paths(self):\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D', 'F'], 'D': ['C'], 'E': ['F'], 'F': ['C']}\n    paths = find_path.find_all_path(graph, 'A', 'F')\n    print(paths)\n    self.assertEqual(sorted(paths), sorted([['A', 'C', 'F'], ['A', 'B', 'C', 'F'], ['A', 'B', 'D', 'C', 'F']]))"}}}, "TestPathBetweenTwoVertices": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 339, "max_lineno": 351}, "methods": {"test_node_is_reachable": {"args": ["self"], "min_max_lineno": {"min_lineno": 340, "max_lineno": 351}, "calls": ["algorithms.graph.path_between_two_vertices_in_digraph.Graph", "algorithms.graph.path_between_two_vertices_in_digraph.Graph.add_edge", "test_graph.TestPathBetweenTwoVertices.assertTrue", "test_graph.TestPathBetweenTwoVertices.assertFalse", "algorithms.graph.path_between_two_vertices_in_digraph.Graph.is_reachable"], "store_vars_calls": {"g": "path_between_two_vertices_in_digraph.Graph"}, "source_code": "def test_node_is_reachable(self):\n    g = path_between_two_vertices_in_digraph.Graph(4)\n    g.add_edge(0, 1)\n    g.add_edge(0, 2)\n    g.add_edge(1, 2)\n    g.add_edge(2, 0)\n    g.add_edge(2, 3)\n    g.add_edge(3, 3)\n    self.assertTrue(g.is_reachable(1, 3))\n    self.assertFalse(g.is_reachable(3, 1))"}}}}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_unix.py", "fileNameBase": "test_unix", "extension": "py"}, "dependencies": [{"from_module": "algorithms.unix", "import": "join_with_slash", "type": "external", "type_element": "module"}, {"from_module": "algorithms.unix", "import": "full_path", "type": "external", "type_element": "module"}, {"from_module": "algorithms.unix", "import": "split", "type": "external", "type_element": "module"}, {"from_module": "algorithms.unix", "import": "simplify_path_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.unix", "import": "simplify_path_v2", "type": "external", "type_element": "module"}, {"import": "os", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestUnixPath": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 49}, "methods": {"test_join_with_slash": {"args": ["self"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 21}, "calls": ["test_unix.TestUnixPath.assertEqual", "algorithms.unix.join_with_slash"], "source_code": "def test_join_with_slash(self):\n    self.assertEqual('path/to/dir/file', join_with_slash('path/to/dir/', 'file'))\n    self.assertEqual('path/to/dir/file', join_with_slash('path/to/dir', 'file'))\n    self.assertEqual('http://algorithms/part', join_with_slash('http://algorithms', 'part'))\n    self.assertEqual('http://algorithms/part', join_with_slash('http://algorithms/', 'part'))"}, "test_full_path": {"args": ["self"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 31}, "calls": ["test_unix.TestUnixPath.assertEqual", "os.getcwd", "algorithms.unix.full_path", "os.path.expanduser"], "source_code": "def test_full_path(self):\n    file_name = 'file_name'\n    expect_path = '{}/{}'.format(os.getcwd(), file_name)\n    self.assertEqual(expect_path, full_path(file_name))\n    expect_path = '{}/{}'.format(os.path.expanduser('~'), file_name)\n    self.assertEqual(expect_path, full_path('~/{}'.format(file_name)))"}, "test_split": {"args": ["self"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 43}, "calls": ["algorithms.unix.split", "test_unix.TestUnixPath.assertEqual"], "store_vars_calls": {"expect_result": "split"}, "source_code": "def test_split(self):\n    path = 'https://algorithms/unix/test.py'\n    expect_result = split(path)\n    self.assertEqual('https://algorithms/unix', expect_result[0])\n    self.assertEqual('test.py', expect_result[1])\n    path = 'algorithms/unix/test.py'\n    expect_result = split(path)\n    self.assertEqual('algorithms/unix', expect_result[0])\n    self.assertEqual('test.py', expect_result[1])"}, "test_simplify_path": {"args": ["self"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 49}, "calls": ["test_unix.TestUnixPath.assertEqual", "algorithms.unix.simplify_path_v1", "algorithms.unix.simplify_path_v2"], "source_code": "def test_simplify_path(self):\n    self.assertEqual('/', simplify_path_v1('/../'))\n    self.assertEqual('/home/foo', simplify_path_v1('/home//foo/'))\n    self.assertEqual('/', simplify_path_v2('/../'))\n    self.assertEqual('/home/foo', simplify_path_v2('/home//foo/'))"}}}}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_maths.py", "fileNameBase": "test_maths", "extension": "py"}, "dependencies": [{"from_module": "algorithms.maths", "import": "power", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "power_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "int_to_base", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "base_to_int", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "decimal_to_binary_ip", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "euler_totient", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "extended_gcd", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "factorial", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "factorial_recur", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "gcd", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "lcm", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "trailing_zero", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "gcd_bit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "gen_strobogrammatic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "strobogrammatic_in_range", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "is_strobogrammatic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "is_strobogrammatic2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "modular_inverse", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "modular_exponential", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "find_next_square", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "find_next_square2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "prime_check", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "get_primes", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "pythagoras", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "is_prime", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "encrypt", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "decrypt", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "combination", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "combination_memo", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "hailstone", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "cosine_similarity", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "magic_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "find_order", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "find_primitive_root", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "num_digits", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "diffie_hellman_key_exchange", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "krishnamurthy_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "num_perfect_squares", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "chinese_remainder_theorem", "type": "external", "type_element": "module"}, {"from_module": "algorithms.maths", "import": "fft", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}, {"import": "pytest", "type": "external", "type_element": "module"}], "classes": {"TestPower": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 55}, "methods": {"test_power": {"args": ["self"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 49}, "calls": ["test_maths.TestPower.assertEqual", "algorithms.maths.power"], "source_code": "def test_power(self):\n    self.assertEqual(8, power(2, 3))\n    self.assertEqual(1, power(5, 0))\n    self.assertEqual(0, power(10, 3, 5))\n    self.assertEqual(280380, power(2265, 1664, 465465))"}, "test_power_recur": {"args": ["self"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 55}, "calls": ["test_maths.TestPower.assertEqual", "algorithms.maths.power_recur"], "source_code": "def test_power_recur(self):\n    self.assertEqual(8, power_recur(2, 3))\n    self.assertEqual(1, power_recur(5, 0))\n    self.assertEqual(0, power_recur(10, 3, 5))\n    self.assertEqual(280380, power_recur(2265, 1664, 465465))"}}}, "TestBaseConversion": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 74}, "methods": {"test_int_to_base": {"args": ["self"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 69}, "calls": ["test_maths.TestBaseConversion.assertEqual", "algorithms.maths.int_to_base"], "source_code": "def test_int_to_base(self):\n    self.assertEqual('101', int_to_base(5, 2))\n    self.assertEqual('0', int_to_base(0, 2))\n    self.assertEqual('FF', int_to_base(255, 16))"}, "test_base_to_int": {"args": ["self"], "min_max_lineno": {"min_lineno": 70, "max_lineno": 74}, "calls": ["test_maths.TestBaseConversion.assertEqual", "algorithms.maths.base_to_int"], "source_code": "def test_base_to_int(self):\n    self.assertEqual(5, base_to_int('101', 2))\n    self.assertEqual(0, base_to_int('0', 2))\n    self.assertEqual(255, base_to_int('FF', 16))"}}}, "TestDecimalToBinaryIP": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 76, "max_lineno": 91}, "methods": {"test_decimal_to_binary_ip": {"args": ["self"], "min_max_lineno": {"min_lineno": 84, "max_lineno": 91}, "calls": ["test_maths.TestDecimalToBinaryIP.assertEqual", "algorithms.maths.decimal_to_binary_ip"], "source_code": "def test_decimal_to_binary_ip(self):\n    self.assertEqual('00000000.00000000.00000000.00000000', decimal_to_binary_ip('0.0.0.0'))\n    self.assertEqual('11111111.11111111.11111111.11111111', decimal_to_binary_ip('255.255.255.255'))\n    self.assertEqual('11000000.10101000.00000000.00000001', decimal_to_binary_ip('192.168.0.1'))"}}}, "TestEulerTotient": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 93, "max_lineno": 106}, "methods": {"test_euler_totient": {"args": ["self"], "min_max_lineno": {"min_lineno": 101, "max_lineno": 106}, "calls": ["test_maths.TestEulerTotient.assertEqual", "algorithms.maths.euler_totient"], "source_code": "def test_euler_totient(self):\n    self.assertEqual(4, euler_totient(8))\n    self.assertEqual(12, euler_totient(21))\n    self.assertEqual(311040, euler_totient(674614))\n    self.assertEqual(2354352, euler_totient(3435145))"}}}, "TestExtendedGcd": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 108, "max_lineno": 119}, "methods": {"test_extended_gcd": {"args": ["self"], "min_max_lineno": {"min_lineno": 116, "max_lineno": 119}, "calls": ["test_maths.TestExtendedGcd.assertEqual", "algorithms.maths.extended_gcd"], "source_code": "def test_extended_gcd(self):\n    self.assertEqual((0, 1, 2), extended_gcd(8, 2))\n    self.assertEqual((0, 1, 17), extended_gcd(13, 17))"}}}, "TestGcd": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 121, "max_lineno": 175}, "methods": {"test_gcd": {"args": ["self"], "min_max_lineno": {"min_lineno": 129, "max_lineno": 132}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.gcd"], "source_code": "def test_gcd(self):\n    self.assertEqual(4, gcd(8, 12))\n    self.assertEqual(1, gcd(13, 17))"}, "test_gcd_non_integer_input": {"args": ["self"], "min_max_lineno": {"min_lineno": 133, "max_lineno": 139}, "calls": ["pytest.raises", "algorithms.maths.gcd"], "source_code": "def test_gcd_non_integer_input(self):\n    with pytest.raises(ValueError, match='Input arguments are not integers'):\n        gcd(1.0, 5)\n        gcd(5, 6.7)\n        gcd(33.8649, 6.12312312)"}, "test_gcd_zero_input": {"args": ["self"], "min_max_lineno": {"min_lineno": 140, "max_lineno": 146}, "calls": ["pytest.raises", "algorithms.maths.gcd"], "source_code": "def test_gcd_zero_input(self):\n    with pytest.raises(ValueError, match='One or more input arguments equals zero'):\n        gcd(0, 12)\n        gcd(12, 0)\n        gcd(0, 0)"}, "test_gcd_negative_input": {"args": ["self"], "min_max_lineno": {"min_lineno": 147, "max_lineno": 151}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.gcd"], "source_code": "def test_gcd_negative_input(self):\n    self.assertEqual(1, gcd(-13, -17))\n    self.assertEqual(4, gcd(-8, 12))\n    self.assertEqual(8, gcd(24, -16))"}, "test_lcm": {"args": ["self"], "min_max_lineno": {"min_lineno": 152, "max_lineno": 155}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.lcm"], "source_code": "def test_lcm(self):\n    self.assertEqual(24, lcm(8, 12))\n    self.assertEqual(5767, lcm(73, 79))"}, "test_lcm_negative_numbers": {"args": ["self"], "min_max_lineno": {"min_lineno": 156, "max_lineno": 160}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.lcm"], "source_code": "def test_lcm_negative_numbers(self):\n    self.assertEqual(24, lcm(-8, -12))\n    self.assertEqual(5767, lcm(73, -79))\n    self.assertEqual(1, lcm(-1, 1))"}, "test_lcm_zero_input": {"args": ["self"], "min_max_lineno": {"min_lineno": 161, "max_lineno": 167}, "calls": ["pytest.raises", "algorithms.maths.lcm"], "source_code": "def test_lcm_zero_input(self):\n    with pytest.raises(ValueError, match='One or more input arguments equals zero'):\n        lcm(0, 12)\n        lcm(12, 0)\n        lcm(0, 0)"}, "test_trailing_zero": {"args": ["self"], "min_max_lineno": {"min_lineno": 168, "max_lineno": 171}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.trailing_zero"], "source_code": "def test_trailing_zero(self):\n    self.assertEqual(1, trailing_zero(34))\n    self.assertEqual(3, trailing_zero(40))"}, "test_gcd_bit": {"args": ["self"], "min_max_lineno": {"min_lineno": 172, "max_lineno": 175}, "calls": ["test_maths.TestGcd.assertEqual", "algorithms.maths.gcd_bit", "algorithms.maths.gcd"], "source_code": "def test_gcd_bit(self):\n    self.assertEqual(4, gcd_bit(8, 12))\n    self.assertEqual(1, gcd(13, 17))"}}}, "TestGenerateStroboGrammatic": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 177, "max_lineno": 190}, "methods": {"test_gen_strobomatic": {"args": ["self"], "min_max_lineno": {"min_lineno": 185, "max_lineno": 187}, "calls": ["test_maths.TestGenerateStroboGrammatic.assertEqual", "algorithms.maths.gen_strobogrammatic"], "source_code": "def test_gen_strobomatic(self):\n    self.assertEqual(['88', '11', '96', '69'], gen_strobogrammatic(2))"}, "test_strobogrammatic_in_range": {"args": ["self"], "min_max_lineno": {"min_lineno": 188, "max_lineno": 190}, "calls": ["test_maths.TestGenerateStroboGrammatic.assertEqual", "algorithms.maths.strobogrammatic_in_range"], "source_code": "def test_strobogrammatic_in_range(self):\n    self.assertEqual(4, strobogrammatic_in_range('10', '100'))"}}}, "TestIsStrobogrammatic": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 192, "max_lineno": 207}, "methods": {"test_is_strobogrammatic": {"args": ["self"], "min_max_lineno": {"min_lineno": 200, "max_lineno": 203}, "calls": ["test_maths.TestIsStrobogrammatic.assertTrue", "test_maths.TestIsStrobogrammatic.assertFalse", "algorithms.maths.is_strobogrammatic"], "source_code": "def test_is_strobogrammatic(self):\n    self.assertTrue(is_strobogrammatic('69'))\n    self.assertFalse(is_strobogrammatic('14'))"}, "test_is_strobogrammatic2": {"args": ["self"], "min_max_lineno": {"min_lineno": 204, "max_lineno": 207}, "calls": ["test_maths.TestIsStrobogrammatic.assertTrue", "test_maths.TestIsStrobogrammatic.assertFalse", "algorithms.maths.is_strobogrammatic2"], "source_code": "def test_is_strobogrammatic2(self):\n    self.assertTrue(is_strobogrammatic2('69'))\n    self.assertFalse(is_strobogrammatic2('14'))"}}}, "TestModularInverse": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 209, "max_lineno": 224}, "methods": {"test_modular_inverse": {"args": ["self"], "min_max_lineno": {"min_lineno": 217, "max_lineno": 224}, "calls": ["test_maths.TestModularInverse.assertEqual", "test_maths.TestModularInverse.assertRaises", "algorithms.maths.modular_inverse.modular_inverse"], "source_code": "def test_modular_inverse(self):\n    self.assertEqual(1, 2 * modular_inverse.modular_inverse(2, 19) % 19)\n    self.assertEqual(1, 53 * modular_inverse.modular_inverse(53, 91) % 91)\n    self.assertEqual(1, 2 * modular_inverse.modular_inverse(2, 1000000007) % 1000000007)\n    self.assertRaises(ValueError, modular_inverse.modular_inverse, 2, 20)"}}}, "TestModularExponential": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 226, "max_lineno": 240}, "methods": {"test_modular_exponential": {"args": ["self"], "min_max_lineno": {"min_lineno": 234, "max_lineno": 240}, "calls": ["test_maths.TestModularExponential.assertEqual", "test_maths.TestModularExponential.assertRaises", "algorithms.maths.modular_exponential", "pow"], "source_code": "def test_modular_exponential(self):\n    self.assertEqual(1, modular_exponential(5, 117, 19))\n    self.assertEqual(pow(1243, 65321, 10 ** 9 + 7), modular_exponential(1243, 65321, 10 ** 9 + 7))\n    self.assertEqual(1, modular_exponential(12, 0, 78))\n    self.assertRaises(ValueError, modular_exponential, 12, -2, 455)"}}}, "TestNextPerfectSquare": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 242, "max_lineno": 257}, "methods": {"test_find_next_square": {"args": ["self"], "min_max_lineno": {"min_lineno": 250, "max_lineno": 253}, "calls": ["test_maths.TestNextPerfectSquare.assertEqual", "algorithms.maths.find_next_square"], "source_code": "def test_find_next_square(self):\n    self.assertEqual(36, find_next_square(25))\n    self.assertEqual(1, find_next_square(0))"}, "test_find_next_square2": {"args": ["self"], "min_max_lineno": {"min_lineno": 254, "max_lineno": 257}, "calls": ["test_maths.TestNextPerfectSquare.assertEqual", "algorithms.maths.find_next_square2"], "source_code": "def test_find_next_square2(self):\n    self.assertEqual(36, find_next_square2(25))\n    self.assertEqual(1, find_next_square2(0))"}}}, "TestPrimesSieveOfEratosthenes": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 259, "max_lineno": 270}, "methods": {"test_primes": {"args": ["self"], "min_max_lineno": {"min_lineno": 267, "max_lineno": 270}, "calls": ["test_maths.TestPrimesSieveOfEratosthenes.assertListEqual", "test_maths.TestPrimesSieveOfEratosthenes.assertRaises", "algorithms.maths.get_primes"], "source_code": "def test_primes(self):\n    self.assertListEqual([2, 3, 5, 7], get_primes(7))\n    self.assertRaises(ValueError, get_primes, -42)"}}}, "TestPrimeTest": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 272, "max_lineno": 290}, "methods": {"test_prime_test": {"doc": {"long_description": "Between 2 up to 100 exists 25 prime numbers!", "short_description": "checks all prime numbers between 2 up to 100."}, "args": ["self"], "min_max_lineno": {"min_lineno": 280, "max_lineno": 290}, "calls": ["range", "test_maths.TestPrimeTest.assertEqual", "algorithms.maths.prime_check"], "source_code": "def test_prime_test(self):\n    \"\"\"\n            checks all prime numbers between 2 up to 100.\n            Between 2 up to 100 exists 25 prime numbers!\n        \"\"\"\n    counter = 0\n    for i in range(2, 101):\n        if prime_check(i):\n            counter += 1\n    self.assertEqual(25, counter)"}}}, "TestPythagoras": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 292, "max_lineno": 303}, "methods": {"test_pythagoras": {"args": ["self"], "min_max_lineno": {"min_lineno": 300, "max_lineno": 303}, "calls": ["test_maths.TestPythagoras.assertEqual", "algorithms.maths.pythagoras"], "source_code": "def test_pythagoras(self):\n    self.assertEqual('Hypotenuse = 3.605551275463989', pythagoras(3, 2, '?'))"}}}, "TestRabinMiller": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 305, "max_lineno": 317}, "methods": {"test_is_prime": {"args": ["self"], "min_max_lineno": {"min_lineno": 313, "max_lineno": 317}, "calls": ["test_maths.TestRabinMiller.assertTrue", "test_maths.TestRabinMiller.assertFalse", "algorithms.maths.is_prime"], "source_code": "def test_is_prime(self):\n    self.assertTrue(is_prime(7, 2))\n    self.assertTrue(is_prime(13, 11))\n    self.assertFalse(is_prime(6, 2))"}}}, "TestRSA": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 319, "max_lineno": 329}, "methods": {"test_encrypt_decrypt": {"args": ["self"], "min_max_lineno": {"min_lineno": 327, "max_lineno": 329}, "calls": ["test_maths.TestRSA.assertEqual", "algorithms.maths.decrypt", "algorithms.maths.encrypt"], "source_code": "def test_encrypt_decrypt(self):\n    self.assertEqual(7, decrypt(encrypt(7, 23, 143), 47, 143))"}}}, "TestCombination": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 340, "max_lineno": 355}, "methods": {"test_combination": {"args": ["self"], "min_max_lineno": {"min_lineno": 348, "max_lineno": 351}, "calls": ["test_maths.TestCombination.assertEqual", "algorithms.maths.combination"], "source_code": "def test_combination(self):\n    self.assertEqual(10, combination(5, 2))\n    self.assertEqual(252, combination(10, 5))"}, "test_combination_memo": {"args": ["self"], "min_max_lineno": {"min_lineno": 352, "max_lineno": 355}, "calls": ["test_maths.TestCombination.assertEqual", "algorithms.maths.combination_memo"], "source_code": "def test_combination_memo(self):\n    self.assertEqual(10272278170, combination_memo(50, 10))\n    self.assertEqual(847660528, combination_memo(40, 10))"}}}, "TestFactorial": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 357, "max_lineno": 380}, "methods": {"test_factorial": {"args": ["self"], "min_max_lineno": {"min_lineno": 365, "max_lineno": 372}, "calls": ["test_maths.TestFactorial.assertEqual", "test_maths.TestFactorial.assertRaises", "algorithms.maths.factorial"], "source_code": "def test_factorial(self):\n    self.assertEqual(1, factorial(0))\n    self.assertEqual(120, factorial(5))\n    self.assertEqual(3628800, factorial(10))\n    self.assertEqual(637816310, factorial(34521, 10 ** 9 + 7))\n    self.assertRaises(ValueError, factorial, -42)\n    self.assertRaises(ValueError, factorial, 42, -1)"}, "test_factorial_recur": {"args": ["self"], "min_max_lineno": {"min_lineno": 373, "max_lineno": 380}, "calls": ["test_maths.TestFactorial.assertEqual", "test_maths.TestFactorial.assertRaises", "algorithms.maths.factorial_recur"], "source_code": "def test_factorial_recur(self):\n    self.assertEqual(1, factorial_recur(0))\n    self.assertEqual(120, factorial_recur(5))\n    self.assertEqual(3628800, factorial_recur(10))\n    self.assertEqual(637816310, factorial_recur(34521, 10 ** 9 + 7))\n    self.assertRaises(ValueError, factorial_recur, -42)\n    self.assertRaises(ValueError, factorial_recur, 42, -1)"}}}, "TestHailstone": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 382, "max_lineno": 393}, "methods": {"test_hailstone": {"args": ["self"], "min_max_lineno": {"min_lineno": 390, "max_lineno": 393}, "calls": ["test_maths.TestHailstone.assertEqual", "algorithms.maths.hailstone.hailstone"], "source_code": "def test_hailstone(self):\n    self.assertEqual([8, 4, 2, 1], hailstone.hailstone(8))\n    self.assertEqual([10, 5, 16, 8, 4, 2, 1], hailstone.hailstone(10))"}}}, "TestCosineSimilarity": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 395, "max_lineno": 410}, "methods": {"test_cosine_similarity": {"args": ["self"], "min_max_lineno": {"min_lineno": 403, "max_lineno": 410}, "calls": ["test_maths.TestCosineSimilarity.assertAlmostEqual", "algorithms.maths.cosine_similarity"], "source_code": "def test_cosine_similarity(self):\n    vec_a = [1, 1, 1]\n    vec_b = [-1, -1, -1]\n    vec_c = [1, 2, -1]\n    self.assertAlmostEqual(cosine_similarity(vec_a, vec_a), 1)\n    self.assertAlmostEqual(cosine_similarity(vec_a, vec_b), -1)\n    self.assertAlmostEqual(cosine_similarity(vec_a, vec_c), 0.4714045208)"}}}, "TestFindPrimitiveRoot": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 412, "max_lineno": 426}, "methods": {"test_find_primitive_root_simple": {"args": ["self"], "min_max_lineno": {"min_lineno": 420, "max_lineno": 426}, "calls": ["test_maths.TestFindPrimitiveRoot.assertListEqual", "algorithms.maths.find_primitive_root"], "source_code": "def test_find_primitive_root_simple(self):\n    self.assertListEqual([0], find_primitive_root(1))\n    self.assertListEqual([2, 3], find_primitive_root(5))\n    self.assertListEqual([], find_primitive_root(24))\n    self.assertListEqual([2, 5, 13, 15, 17, 18, 19, 20, 22, 24, 32, 35], find_primitive_root(37))"}}}, "TestFindOrder": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 428, "max_lineno": 441}, "methods": {"test_find_order_simple": {"args": ["self"], "min_max_lineno": {"min_lineno": 436, "max_lineno": 441}, "calls": ["test_maths.TestFindOrder.assertEqual", "algorithms.maths.find_order"], "source_code": "def test_find_order_simple(self):\n    self.assertEqual(1, find_order(1, 1))\n    self.assertEqual(6, find_order(3, 7))\n    self.assertEqual(-1, find_order(128, 256))\n    self.assertEqual(352, find_order(3, 353))"}}}, "TestKrishnamurthyNumber": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 443, "max_lineno": 457}, "methods": {"test_krishnamurthy_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 451, "max_lineno": 457}, "calls": ["test_maths.TestKrishnamurthyNumber.assertFalse", "test_maths.TestKrishnamurthyNumber.assertTrue", "algorithms.maths.krishnamurthy_number"], "source_code": "def test_krishnamurthy_number(self):\n    self.assertFalse(krishnamurthy_number(0))\n    self.assertTrue(krishnamurthy_number(2))\n    self.assertTrue(krishnamurthy_number(1))\n    self.assertTrue(krishnamurthy_number(145))\n    self.assertTrue(krishnamurthy_number(40585))"}}}, "TestMagicNumber": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 459, "max_lineno": 474}, "methods": {"test_magic_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 467, "max_lineno": 474}, "calls": ["test_maths.TestMagicNumber.assertTrue", "test_maths.TestMagicNumber.assertFalse", "algorithms.maths.magic_number"], "source_code": "def test_magic_number(self):\n    self.assertTrue(magic_number(50113))\n    self.assertTrue(magic_number(1234))\n    self.assertTrue(magic_number(100))\n    self.assertTrue(magic_number(199))\n    self.assertFalse(magic_number(2000))\n    self.assertFalse(magic_number(500000))"}}}, "TestDiffieHellmanKeyExchange": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 476, "max_lineno": 489}, "methods": {"test_find_order_simple": {"args": ["self"], "min_max_lineno": {"min_lineno": 484, "max_lineno": 489}, "calls": ["test_maths.TestDiffieHellmanKeyExchange.assertFalse", "test_maths.TestDiffieHellmanKeyExchange.assertTrue", "algorithms.maths.diffie_hellman_key_exchange"], "source_code": "def test_find_order_simple(self):\n    self.assertFalse(diffie_hellman_key_exchange(3, 6))\n    self.assertTrue(diffie_hellman_key_exchange(3, 353))\n    self.assertFalse(diffie_hellman_key_exchange(5, 211))\n    self.assertTrue(diffie_hellman_key_exchange(11, 971))"}}}, "TestNumberOfDigits": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 491, "max_lineno": 505}, "methods": {"test_num_digits": {"args": ["self"], "min_max_lineno": {"min_lineno": 498, "max_lineno": 505}, "calls": ["test_maths.TestNumberOfDigits.assertEqual", "algorithms.maths.num_digits"], "source_code": "def test_num_digits(self):\n    self.assertEqual(2, num_digits(12))\n    self.assertEqual(5, num_digits(99999))\n    self.assertEqual(1, num_digits(8))\n    self.assertEqual(1, num_digits(0))\n    self.assertEqual(1, num_digits(-5))\n    self.assertEqual(3, num_digits(-254))"}}}, "TestNumberOfPerfectSquares": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 508, "max_lineno": 524}, "methods": {"test_num_perfect_squares": {"args": ["self"], "min_max_lineno": {"min_lineno": 515, "max_lineno": 524}, "calls": ["test_maths.TestNumberOfPerfectSquares.assertEqual", "algorithms.maths.num_perfect_squares"], "source_code": "def test_num_perfect_squares(self):\n    self.assertEqual(4, num_perfect_squares(31))\n    self.assertEqual(3, num_perfect_squares(12))\n    self.assertEqual(2, num_perfect_squares(13))\n    self.assertEqual(2, num_perfect_squares(10))\n    self.assertEqual(4, num_perfect_squares(1500))\n    self.assertEqual(2, num_perfect_squares(1548524521))\n    self.assertEqual(3, num_perfect_squares(9999999993))\n    self.assertEqual(1, num_perfect_squares(9))"}}}, "TestChineseRemainderSolver": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 526, "max_lineno": 558}, "methods": {"test_k_three": {"args": ["self"], "min_max_lineno": {"min_lineno": 527, "max_lineno": 535}, "calls": ["test_maths.TestChineseRemainderSolver.assertEqual", "algorithms.maths.chinese_remainder_theorem.solve_chinese_remainder"], "source_code": "def test_k_three(self):\n    num = [3, 7, 10]\n    rem = [2, 3, 3]\n    self.assertEqual(chinese_remainder_theorem.solve_chinese_remainder(num, rem), 143)"}, "test_k_five": {"args": ["self"], "min_max_lineno": {"min_lineno": 536, "max_lineno": 544}, "calls": ["test_maths.TestChineseRemainderSolver.assertEqual", "algorithms.maths.chinese_remainder_theorem.solve_chinese_remainder"], "source_code": "def test_k_five(self):\n    num = [3, 5, 7, 11, 26]\n    rem = [2, 3, 2, 6, 3]\n    self.assertEqual(chinese_remainder_theorem.solve_chinese_remainder(num, rem), 3383)"}, "test_exception_non_coprime": {"args": ["self"], "min_max_lineno": {"min_lineno": 545, "max_lineno": 552}, "calls": ["test_maths.TestChineseRemainderSolver.assertRaises", "algorithms.maths.chinese_remainder_theorem.solve_chinese_remainder"], "source_code": "def test_exception_non_coprime(self):\n    num = [3, 7, 10, 14]\n    rem = [2, 3, 3, 1]\n    with self.assertRaises(Exception):\n        chinese_remainder_theorem.solve_chinese_remainder(num, rem)"}, "test_empty_lists": {"args": ["self"], "min_max_lineno": {"min_lineno": 553, "max_lineno": 558}, "calls": ["test_maths.TestChineseRemainderSolver.assertRaises", "algorithms.maths.chinese_remainder_theorem.solve_chinese_remainder"], "source_code": "def test_empty_lists(self):\n    num = []\n    rem = []\n    with self.assertRaises(Exception):\n        chinese_remainder_theorem.solve_chinese_remainder(num, rem)"}}}, "TestFFT": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 560, "max_lineno": 594}, "methods": {"test_real_numbers": {"args": ["self"], "min_max_lineno": {"min_lineno": 567, "max_lineno": 573}, "calls": ["test_maths.TestFFT.assertEqual", "float", "algorithms.maths.fft.fft", "abs"], "source_code": "def test_real_numbers(self):\n    x = [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n    y = [4.0, 2.613, 0.0, 1.082, 0.0, 1.082, 0.0, 2.613]\n    result = [float('%.3f' % abs(f)) for f in fft.fft(x)]\n    self.assertEqual(result, y)"}, "test_all_zero": {"args": ["self"], "min_max_lineno": {"min_lineno": 574, "max_lineno": 579}, "calls": ["test_maths.TestFFT.assertEqual", "float", "algorithms.maths.fft.fft", "abs"], "source_code": "def test_all_zero(self):\n    x = [0.0, 0.0, 0.0, 0.0]\n    y = [0.0, 0.0, 0.0, 0.0]\n    result = [float('%.1f' % abs(f)) for f in fft.fft(x)]\n    self.assertEqual(result, y)"}, "test_all_ones": {"args": ["self"], "min_max_lineno": {"min_lineno": 580, "max_lineno": 585}, "calls": ["test_maths.TestFFT.assertEqual", "float", "algorithms.maths.fft.fft", "abs"], "source_code": "def test_all_ones(self):\n    x = [1.0, 1.0, 1.0, 1.0]\n    y = [4.0, 0.0, 0.0, 0.0]\n    result = [float('%.1f' % abs(f)) for f in fft.fft(x)]\n    self.assertEqual(result, y)"}, "test_complex_numbers": {"args": ["self"], "min_max_lineno": {"min_lineno": 586, "max_lineno": 594}, "calls": ["test_maths.TestFFT.assertEqual", "float", "algorithms.maths.fft.fft"], "source_code": "def test_complex_numbers(self):\n    x = [2.0 + 2j, 1.0 + 3j, 3.0 + 1j, 2.0 + 2j]\n    real = [8.0, 0.0, 2.0, -2.0]\n    imag = [8.0, 2.0, -2.0, 0.0]\n    realResult = [float('%.1f' % f.real) for f in fft.fft(x)]\n    imagResult = [float('%.1f' % f.imag) for f in fft.fft(x)]\n    self.assertEqual(real, realResult)\n    self.assertEqual(imag, imagResult)"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_maths.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_ml.py", "fileNameBase": "test_ml", "extension": "py"}, "dependencies": [{"from_module": "algorithms.ml.nearest_neighbor", "import": "distance", "type": "external", "type_element": "module"}, {"from_module": "algorithms.ml.nearest_neighbor", "import": "nearest_neighbor", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestML": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 37}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 21}, "source_code": "def setUp(self):\n    self.trainSetAND = {(0, 0): 0, (0, 1): 0, (1, 0): 0, (1, 1): 1}\n    self.trainSetLight = {(11, 98, 237): 'L', (3, 39, 96): 'D', (242, 226, 12): 'L', (99, 93, 4): 'D', (232, 62, 32): 'L', (119, 28, 11): 'D', (25, 214, 47): 'L', (89, 136, 247): 'L', (21, 34, 63): 'D', (237, 99, 120): 'L', (73, 33, 39): 'D'}"}, "test_nearest_neighbor": {"args": ["self"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 34}, "calls": ["test_ml.TestML.assertEqual", "algorithms.ml.nearest_neighbor.nearest_neighbor"], "source_code": "def test_nearest_neighbor(self):\n    self.assertEqual(nearest_neighbor((1, 1), self.trainSetAND), 1)\n    self.assertEqual(nearest_neighbor((0, 1), self.trainSetAND), 0)\n    self.assertEqual(nearest_neighbor((31, 242, 164), self.trainSetLight), 'L')\n    self.assertEqual(nearest_neighbor((13, 94, 64), self.trainSetLight), 'D')\n    self.assertEqual(nearest_neighbor((230, 52, 239), self.trainSetLight), 'L')"}, "test_distance": {"args": ["self"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 37}, "calls": ["test_ml.TestML.assertAlmostEqual", "algorithms.ml.nearest_neighbor.distance"], "source_code": "def test_distance(self):\n    self.assertAlmostEqual(distance((1, 2, 3), (1, 0, -1)), 4.47, 2)"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_ml.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_strings.py", "fileNameBase": "test_strings", "extension": "py"}, "dependencies": [{"from_module": "algorithms.strings", "import": "add_binary", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "match_symbol", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "match_symbol_1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "bracket", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "decode_string", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "delete_reoccurring_characters", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "domain_name_1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "domain_name_2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "encode", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "decode", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "group_anagrams", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "int_to_roman", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome_reverse", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome_two_pointer", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome_stack", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_palindrome_deque", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_rotated", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_rotated_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "license_number", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "make_sentence", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_merge_recursive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_merge_iterative", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "multiply", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_one_edit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_one_edit2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "rabin_karp", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "ultra_pythonic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "iterative", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "recursive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "pythonic", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "reverse_vowel", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "reverse_words", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "roman_to_int", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "is_valid_coordinates_0", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "word_squares", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "convert_morse_word", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "unique_morse", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "judge_circle", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "strong_password", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "caesar_cipher", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "check_pangram", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "contain_string", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "count_binary_substring", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "repeat_string", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "text_justification", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "min_distance", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "min_distance_dp", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "longest_common_prefix_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "longest_common_prefix_v2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "longest_common_prefix_v3", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "rotate", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "rotate_alt", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "first_unique_char", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "repeat_substring", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "atbash", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "longest_palindrome", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "knuth_morris_pratt", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "panagram", "type": "external", "type_element": "module"}, {"from_module": "algorithms.strings", "import": "fizzbuzz", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestAddBinary": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 63}, "methods": {"test_add_binary": {"args": ["self"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 63}, "calls": ["test_strings.TestAddBinary.assertEqual", "algorithms.strings.add_binary"], "source_code": "def test_add_binary(self):\n    self.assertEqual('100', add_binary('11', '1'))\n    self.assertEqual('101', add_binary('100', '1'))\n    self.assertEqual('10', add_binary('1', '1'))"}}}, "TestBreakingBad": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 92}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 77}, "source_code": "def setUp(self):\n    self.words = ['Amazon', 'Microsoft', 'Google']\n    self.symbols = ['i', 'Am', 'cro', 'le', 'abc']\n    self.result = ['M[i]crosoft', '[Am]azon', 'Mi[cro]soft', 'Goog[le]']"}, "test_match_symbol": {"args": ["self"], "min_max_lineno": {"min_lineno": 78, "max_lineno": 80}, "calls": ["test_strings.TestBreakingBad.assertEqual", "algorithms.strings.match_symbol"], "source_code": "def test_match_symbol(self):\n    self.assertEqual(self.result, match_symbol(self.words, self.symbols))"}, "test_match_symbol_1": {"args": ["self"], "min_max_lineno": {"min_lineno": 81, "max_lineno": 84}, "calls": ["test_strings.TestBreakingBad.assertEqual", "algorithms.strings.match_symbol_1"], "source_code": "def test_match_symbol_1(self):\n    self.assertEqual(['[Am]azon', 'Mi[cro]soft', 'Goog[le]'], match_symbol_1(self.words, self.symbols))"}, "test_bracket": {"args": ["self"], "min_max_lineno": {"min_lineno": 85, "max_lineno": 92}, "calls": ["test_strings.TestBreakingBad.assertEqual", "algorithms.strings.bracket"], "source_code": "def test_bracket(self):\n    self.assertEqual(('[Am]azon', 'Mi[cro]soft', 'Goog[le]'), bracket(self.words, self.symbols))\n    self.assertEqual(('Amazon', 'Microsoft', 'Google'), bracket(self.words, ['thisshouldnotmatch']))\n    self.assertEqual(('Amazon', 'M[i]crosoft', 'Google'), bracket(self.words, ['i', 'i']))"}}}, "TestDecodeString": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 94, "max_lineno": 105}, "methods": {"test_decode_string": {"args": ["self"], "min_max_lineno": {"min_lineno": 102, "max_lineno": 105}, "calls": ["test_strings.TestDecodeString.assertEqual", "algorithms.strings.decode_string"], "source_code": "def test_decode_string(self):\n    self.assertEqual('aaabcbc', decode_string('3[a]2[bc]'))\n    self.assertEqual('accaccacc', decode_string('3[a2[c]]'))"}}}, "TestDeleteReoccurring": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 107, "max_lineno": 117}, "methods": {"test_delete_reoccurring_characters": {"args": ["self"], "min_max_lineno": {"min_lineno": 115, "max_lineno": 117}, "calls": ["test_strings.TestDeleteReoccurring.assertEqual", "algorithms.strings.delete_reoccurring_characters"], "source_code": "def test_delete_reoccurring_characters(self):\n    self.assertEqual('abc', delete_reoccurring_characters('aaabcccc'))"}}}, "TestDomainExtractor": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 119, "max_lineno": 133}, "methods": {"test_valid": {"args": ["self"], "min_max_lineno": {"min_lineno": 127, "max_lineno": 130}, "calls": ["test_strings.TestDomainExtractor.assertEqual", "algorithms.strings.domain_name_1"], "source_code": "def test_valid(self):\n    self.assertEqual(domain_name_1('https://github.com/SaadBenn'), 'github')"}, "test_invalid": {"args": ["self"], "min_max_lineno": {"min_lineno": 131, "max_lineno": 133}, "calls": ["test_strings.TestDomainExtractor.assertEqual", "algorithms.strings.domain_name_2"], "source_code": "def test_invalid(self):\n    self.assertEqual(domain_name_2('http://google.com'), 'google')"}}}, "TestEncodeDecode": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 135, "max_lineno": 149}, "methods": {"test_encode": {"args": ["self"], "min_max_lineno": {"min_lineno": 143, "max_lineno": 145}, "calls": ["test_strings.TestEncodeDecode.assertEqual", "algorithms.strings.encode"], "source_code": "def test_encode(self):\n    self.assertEqual('4:keon2:is7:awesome', encode('keon is awesome'))"}, "test_decode": {"args": ["self"], "min_max_lineno": {"min_lineno": 146, "max_lineno": 149}, "calls": ["test_strings.TestEncodeDecode.assertEqual", "algorithms.strings.decode"], "source_code": "def test_decode(self):\n    self.assertEqual(['keon', 'is', 'awesome'], decode('4:keon2:is7:awesome'))"}}}, "TestGroupAnagrams": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 151, "max_lineno": 163}, "methods": {"test_group_anagrams": {"args": ["self"], "min_max_lineno": {"min_lineno": 159, "max_lineno": 163}, "calls": ["test_strings.TestGroupAnagrams.assertEqual", "algorithms.strings.group_anagrams"], "source_code": "def test_group_anagrams(self):\n    self.assertEqual([['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']], group_anagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']))"}}}, "TestIntToRoman": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 165, "max_lineno": 177}, "methods": {"test_int_to_roman": {"args": ["self"], "min_max_lineno": {"min_lineno": 173, "max_lineno": 177}, "calls": ["test_strings.TestIntToRoman.assertEqual", "algorithms.strings.int_to_roman"], "source_code": "def test_int_to_roman(self):\n    self.assertEqual('DCXLIV', int_to_roman(644))\n    self.assertEqual('I', int_to_roman(1))\n    self.assertEqual('MMMCMXCIX', int_to_roman(3999))"}}}, "TestIsPalindrome": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 179, "max_lineno": 211}, "methods": {"test_is_palindrome": {"args": ["self"], "min_max_lineno": {"min_lineno": 187, "max_lineno": 191}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome"], "source_code": "def test_is_palindrome(self):\n    self.assertTrue(is_palindrome('Otto'))\n    self.assertFalse(is_palindrome('house'))"}, "test_is_palindrome_reverse": {"args": ["self"], "min_max_lineno": {"min_lineno": 192, "max_lineno": 196}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome_reverse"], "source_code": "def test_is_palindrome_reverse(self):\n    self.assertTrue(is_palindrome_reverse('Otto'))\n    self.assertFalse(is_palindrome_reverse('house'))"}, "test_is_palindrome_two_pointer": {"args": ["self"], "min_max_lineno": {"min_lineno": 197, "max_lineno": 201}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome_two_pointer"], "source_code": "def test_is_palindrome_two_pointer(self):\n    self.assertTrue(is_palindrome_two_pointer('Otto'))\n    self.assertFalse(is_palindrome_two_pointer('house'))"}, "test_is_palindrome_stack": {"args": ["self"], "min_max_lineno": {"min_lineno": 202, "max_lineno": 206}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome_stack"], "source_code": "def test_is_palindrome_stack(self):\n    self.assertTrue(is_palindrome_stack('Otto'))\n    self.assertFalse(is_palindrome_stack('house'))"}, "test_is_palindrome_deque": {"args": ["self"], "min_max_lineno": {"min_lineno": 207, "max_lineno": 211}, "calls": ["test_strings.TestIsPalindrome.assertTrue", "test_strings.TestIsPalindrome.assertFalse", "algorithms.strings.is_palindrome_deque"], "source_code": "def test_is_palindrome_deque(self):\n    self.assertTrue(is_palindrome_deque('Otto'))\n    self.assertFalse(is_palindrome_deque('house'))"}}}, "TestIsRotated": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 213, "max_lineno": 234}, "methods": {"test_is_rotated": {"args": ["self"], "min_max_lineno": {"min_lineno": 221, "max_lineno": 227}, "calls": ["test_strings.TestIsRotated.assertTrue", "test_strings.TestIsRotated.assertFalse", "algorithms.strings.is_rotated"], "source_code": "def test_is_rotated(self):\n    self.assertTrue(is_rotated('hello', 'hello'))\n    self.assertTrue(is_rotated('hello', 'llohe'))\n    self.assertFalse(is_rotated('hello', 'helol'))\n    self.assertFalse(is_rotated('hello', 'lloh'))\n    self.assertTrue(is_rotated('', ''))"}, "test_is_rotated_v1": {"args": ["self"], "min_max_lineno": {"min_lineno": 228, "max_lineno": 234}, "calls": ["test_strings.TestIsRotated.assertTrue", "test_strings.TestIsRotated.assertFalse", "algorithms.strings.is_rotated_v1"], "source_code": "def test_is_rotated_v1(self):\n    self.assertTrue(is_rotated_v1('hello', 'hello'))\n    self.assertTrue(is_rotated_v1('hello', 'llohe'))\n    self.assertFalse(is_rotated_v1('hello', 'helol'))\n    self.assertFalse(is_rotated_v1('hello', 'lloh'))\n    self.assertTrue(is_rotated_v1('', ''))"}}}, "TestRotated": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 236, "max_lineno": 248}, "methods": {"test_rotate": {"args": ["self"], "min_max_lineno": {"min_lineno": 237, "max_lineno": 242}, "calls": ["test_strings.TestRotated.assertEqual", "algorithms.strings.rotate"], "source_code": "def test_rotate(self):\n    self.assertEqual('llohe', rotate('hello', 2))\n    self.assertEqual('hello', rotate('hello', 5))\n    self.assertEqual('elloh', rotate('hello', 6))\n    self.assertEqual('llohe', rotate('hello', 7))"}, "test_rotate_alt": {"args": ["self"], "min_max_lineno": {"min_lineno": 243, "max_lineno": 248}, "calls": ["test_strings.TestRotated.assertEqual", "algorithms.strings.rotate_alt"], "source_code": "def test_rotate_alt(self):\n    self.assertEqual('llohe', rotate_alt('hello', 2))\n    self.assertEqual('hello', rotate_alt('hello', 5))\n    self.assertEqual('elloh', rotate_alt('hello', 6))\n    self.assertEqual('llohe', rotate_alt('hello', 7))"}}}, "TestLicenseNumber": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 250, "max_lineno": 264}, "methods": {"test_license_number": {"args": ["self"], "min_max_lineno": {"min_lineno": 258, "max_lineno": 264}, "calls": ["test_strings.TestLicenseNumber.assertEqual", "algorithms.strings.license_number"], "source_code": "def test_license_number(self):\n    self.assertEqual('a-b-c-d-f-d-d-f', license_number('a-bc-dfd-df', 1))\n    self.assertEqual('ab-cd-fd-df', license_number('a-bc-dfd-df', 2))\n    self.assertEqual('ab-cdf-ddf', license_number('a-bc-dfd-df', 3))\n    self.assertEqual('abcd-fddf', license_number('a-bc-dfd-df', 4))\n    self.assertEqual('abc-dfddf', license_number('a-bc-dfd-df', 5))"}}}, "TestMakeSentence": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 266, "max_lineno": 278}, "methods": {"test_make_sentence": {"args": ["self"], "min_max_lineno": {"min_lineno": 274, "max_lineno": 278}, "calls": ["test_strings.TestMakeSentence.assertTrue", "algorithms.strings.make_sentence"], "source_code": "def test_make_sentence(self):\n    dictionarys = ['', 'app', 'let', 't', 'apple', 'applet']\n    word = 'applet'\n    self.assertTrue(make_sentence(word, dictionarys))"}}}, "TestMergeStringChecker": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 280, "max_lineno": 293}, "methods": {"test_is_merge_recursive": {"args": ["self"], "min_max_lineno": {"min_lineno": 288, "max_lineno": 290}, "calls": ["test_strings.TestMergeStringChecker.assertTrue", "algorithms.strings.is_merge_recursive"], "source_code": "def test_is_merge_recursive(self):\n    self.assertTrue(is_merge_recursive('codewars', 'cdw', 'oears'))"}, "test_is_merge_iterative": {"args": ["self"], "min_max_lineno": {"min_lineno": 291, "max_lineno": 293}, "calls": ["test_strings.TestMergeStringChecker.assertTrue", "algorithms.strings.is_merge_iterative"], "source_code": "def test_is_merge_iterative(self):\n    self.assertTrue(is_merge_iterative('codewars', 'cdw', 'oears'))"}}}, "TestMultiplyStrings": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 295, "max_lineno": 308}, "methods": {"test_multiply": {"args": ["self"], "min_max_lineno": {"min_lineno": 303, "max_lineno": 308}, "calls": ["test_strings.TestMultiplyStrings.assertEqual", "algorithms.strings.multiply"], "source_code": "def test_multiply(self):\n    self.assertEqual('23', multiply('1', '23'))\n    self.assertEqual('529', multiply('23', '23'))\n    self.assertEqual('0', multiply('0', '23'))\n    self.assertEqual('1000000', multiply('100', '10000'))"}}}, "TestOneEditDistance": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 310, "max_lineno": 327}, "methods": {"test_is_one_edit": {"args": ["self"], "min_max_lineno": {"min_lineno": 318, "max_lineno": 322}, "calls": ["test_strings.TestOneEditDistance.assertTrue", "test_strings.TestOneEditDistance.assertFalse", "algorithms.strings.is_one_edit"], "source_code": "def test_is_one_edit(self):\n    self.assertTrue(is_one_edit('abc', 'abd'))\n    self.assertFalse(is_one_edit('abc', 'aed'))\n    self.assertFalse(is_one_edit('abcd', 'abcd'))"}, "test_is_one_edit2": {"args": ["self"], "min_max_lineno": {"min_lineno": 323, "max_lineno": 327}, "calls": ["test_strings.TestOneEditDistance.assertTrue", "test_strings.TestOneEditDistance.assertFalse", "algorithms.strings.is_one_edit2"], "source_code": "def test_is_one_edit2(self):\n    self.assertTrue(is_one_edit2('abc', 'abd'))\n    self.assertFalse(is_one_edit2('abc', 'aed'))\n    self.assertFalse(is_one_edit2('abcd', 'abcd'))"}}}, "TestRabinKarp": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 329, "max_lineno": 340}, "methods": {"test_rabin_karp": {"args": ["self"], "min_max_lineno": {"min_lineno": 337, "max_lineno": 340}, "calls": ["test_strings.TestRabinKarp.assertEqual", "algorithms.strings.rabin_karp"], "source_code": "def test_rabin_karp(self):\n    self.assertEqual(3, rabin_karp('abc', 'zsnabckfkd'))\n    self.assertEqual(None, rabin_karp('abc', 'zsnajkskfkd'))"}}}, "TestReverseString": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 342, "max_lineno": 361}, "methods": {"test_recursive": {"args": ["self"], "min_max_lineno": {"min_lineno": 350, "max_lineno": 352}, "calls": ["test_strings.TestReverseString.assertEqual", "algorithms.strings.recursive"], "source_code": "def test_recursive(self):\n    self.assertEqual('ereht olleh', recursive('hello there'))"}, "test_iterative": {"args": ["self"], "min_max_lineno": {"min_lineno": 353, "max_lineno": 355}, "calls": ["test_strings.TestReverseString.assertEqual", "algorithms.strings.iterative"], "source_code": "def test_iterative(self):\n    self.assertEqual('ereht olleh', iterative('hello there'))"}, "test_pythonic": {"args": ["self"], "min_max_lineno": {"min_lineno": 356, "max_lineno": 358}, "calls": ["test_strings.TestReverseString.assertEqual", "algorithms.strings.pythonic"], "source_code": "def test_pythonic(self):\n    self.assertEqual('ereht olleh', pythonic('hello there'))"}, "test_ultra_pythonic": {"args": ["self"], "min_max_lineno": {"min_lineno": 359, "max_lineno": 361}, "calls": ["test_strings.TestReverseString.assertEqual", "algorithms.strings.ultra_pythonic"], "source_code": "def test_ultra_pythonic(self):\n    self.assertEqual('ereht olleh', ultra_pythonic('hello there'))"}}}, "TestReverseVowel": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 363, "max_lineno": 373}, "methods": {"test_reverse_vowel": {"args": ["self"], "min_max_lineno": {"min_lineno": 371, "max_lineno": 373}, "calls": ["test_strings.TestReverseVowel.assertEqual", "algorithms.strings.reverse_vowel"], "source_code": "def test_reverse_vowel(self):\n    self.assertEqual('holle', reverse_vowel('hello'))"}}}, "TestReverseWords": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 375, "max_lineno": 386}, "methods": {"test_reverse_words": {"args": ["self"], "min_max_lineno": {"min_lineno": 383, "max_lineno": 386}, "calls": ["test_strings.TestReverseWords.assertEqual", "algorithms.strings.reverse_words"], "source_code": "def test_reverse_words(self):\n    self.assertEqual('pizza like I and kim keon am I', reverse_words('I am keon kim and I like pizza'))"}}}, "TestRomanToInt": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 388, "max_lineno": 400}, "methods": {"test_roman_to_int": {"args": ["self"], "min_max_lineno": {"min_lineno": 396, "max_lineno": 400}, "calls": ["test_strings.TestRomanToInt.assertEqual", "algorithms.strings.roman_to_int"], "source_code": "def test_roman_to_int(self):\n    self.assertEqual(621, roman_to_int('DCXXI'))\n    self.assertEqual(1, roman_to_int('I'))\n    self.assertEqual(3999, roman_to_int('MMMCMXCIX'))"}}}, "TestValidateCoordinates": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 427, "max_lineno": 446}, "methods": {"test_valid": {"args": ["self"], "min_max_lineno": {"min_lineno": 435, "max_lineno": 439}, "calls": ["test_strings.TestValidateCoordinates.assertTrue", "algorithms.strings.is_valid_coordinates_0"], "source_code": "def test_valid(self):\n    valid_coordinates = ['-23, 25', '4, -3', '90, 180', '-90, -180']\n    for coordinate in valid_coordinates:\n        self.assertTrue(is_valid_coordinates_0(coordinate))"}, "test_invalid": {"args": ["self"], "min_max_lineno": {"min_lineno": 440, "max_lineno": 446}, "calls": ["test_strings.TestValidateCoordinates.assertFalse", "algorithms.strings.is_valid_coordinates_0"], "source_code": "def test_invalid(self):\n    invalid_coordinates = ['23.234, - 23.4234', '99.234, 12.324', '6.325624, 43.34345.345', '0, 1,2', '23.245, 1e1']\n    for coordinate in invalid_coordinates:\n        self.assertFalse(is_valid_coordinates_0(coordinate))"}}}, "TestWordSquares": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 448, "max_lineno": 461}, "methods": {"test_word_squares": {"args": ["self"], "min_max_lineno": {"min_lineno": 456, "max_lineno": 461}, "calls": ["test_strings.TestWordSquares.assertEqual", "algorithms.strings.word_squares"], "source_code": "def test_word_squares(self):\n    self.assertEqual([['wall', 'area', 'lead', 'lady'], ['ball', 'area', 'lead', 'lady']], word_squares(['area', 'lead', 'wall', 'lady', 'ball']))"}}}, "TestUniqueMorse": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 463, "max_lineno": 470}, "methods": {"test_convert_morse_word": {"args": ["self"], "min_max_lineno": {"min_lineno": 464, "max_lineno": 467}, "calls": ["test_strings.TestUniqueMorse.assertEqual", "algorithms.strings.convert_morse_word"], "source_code": "def test_convert_morse_word(self):\n    self.assertEqual('--...-.', convert_morse_word('gin'))\n    self.assertEqual('--...--.', convert_morse_word('msg'))"}, "test_unique_morse": {"args": ["self"], "min_max_lineno": {"min_lineno": 468, "max_lineno": 470}, "calls": ["test_strings.TestUniqueMorse.assertEqual", "algorithms.strings.unique_morse"], "source_code": "def test_unique_morse(self):\n    self.assertEqual(2, unique_morse(['gin', 'zen', 'gig', 'msg']))"}}}, "TestJudgeCircle": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 472, "max_lineno": 476}, "methods": {"test_judge_circle": {"args": ["self"], "min_max_lineno": {"min_lineno": 473, "max_lineno": 476}, "calls": ["test_strings.TestJudgeCircle.assertTrue", "test_strings.TestJudgeCircle.assertFalse", "algorithms.strings.judge_circle"], "source_code": "def test_judge_circle(self):\n    self.assertTrue(judge_circle('UDLRUD'))\n    self.assertFalse(judge_circle('LLRU'))"}}}, "TestStrongPassword": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 478, "max_lineno": 482}, "methods": {"test_strong_password": {"args": ["self"], "min_max_lineno": {"min_lineno": 479, "max_lineno": 482}, "calls": ["test_strings.TestStrongPassword.assertEqual", "algorithms.strings.strong_password"], "source_code": "def test_strong_password(self):\n    self.assertEqual(3, strong_password(3, 'Ab1'))\n    self.assertEqual(1, strong_password(11, '#Algorithms'))"}}}, "TestCaesarCipher": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 484, "max_lineno": 488}, "methods": {"test_caesar_cipher": {"args": ["self"], "min_max_lineno": {"min_lineno": 485, "max_lineno": 488}, "calls": ["test_strings.TestCaesarCipher.assertEqual", "algorithms.strings.caesar_cipher"], "source_code": "def test_caesar_cipher(self):\n    self.assertEqual('Lipps_Asvph!', caesar_cipher('Hello_World!', 4))\n    self.assertEqual('okffng-Qwvb', caesar_cipher('middle-Outz', 2))"}}}, "TestCheckPangram": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 490, "max_lineno": 494}, "methods": {"test_check_pangram": {"args": ["self"], "min_max_lineno": {"min_lineno": 491, "max_lineno": 494}, "calls": ["test_strings.TestCheckPangram.assertTrue", "test_strings.TestCheckPangram.assertFalse", "algorithms.strings.check_pangram"], "source_code": "def test_check_pangram(self):\n    self.assertTrue(check_pangram('The quick brown fox jumps over the lazy dog'))\n    self.assertFalse(check_pangram('The quick brown fox'))"}}}, "TestContainString": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 496, "max_lineno": 501}, "methods": {"test_contain_string": {"args": ["self"], "min_max_lineno": {"min_lineno": 497, "max_lineno": 501}, "calls": ["test_strings.TestContainString.assertEqual", "algorithms.strings.contain_string"], "source_code": "def test_contain_string(self):\n    self.assertEqual(-1, contain_string('mississippi', 'issipi'))\n    self.assertEqual(0, contain_string('Hello World', ''))\n    self.assertEqual(2, contain_string('hello', 'll'))"}}}, "TestCountBinarySubstring": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 510, "max_lineno": 514}, "methods": {"test_repeat_string": {"args": ["self"], "min_max_lineno": {"min_lineno": 511, "max_lineno": 514}, "calls": ["test_strings.TestCountBinarySubstring.assertEqual", "algorithms.strings.repeat_string"], "source_code": "def test_repeat_string(self):\n    self.assertEqual(3, repeat_string('abcd', 'cdabcdab'))\n    self.assertEqual(4, repeat_string('bb', 'bbbbbbb'))"}}}, "TestTextJustification": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 516, "max_lineno": 532}, "methods": {"test_text_justification": {"args": ["self"], "min_max_lineno": {"min_lineno": 517, "max_lineno": 532}, "calls": ["test_strings.TestTextJustification.assertEqual", "algorithms.strings.text_justification"], "source_code": "def test_text_justification(self):\n    self.assertEqual(['This    is    an', 'example  of text', 'justification.  '], text_justification(['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 16))\n    self.assertEqual(['What   must   be', 'acknowledgment  ', 'shall be        '], text_justification(['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 16))"}}}, "TestMinDistance": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 535, "max_lineno": 540}, "methods": {"test_min_distance": {"args": ["self"], "min_max_lineno": {"min_lineno": 536, "max_lineno": 540}, "calls": ["test_strings.TestMinDistance.assertEqual", "algorithms.strings.min_distance"], "source_code": "def test_min_distance(self):\n    self.assertEqual(2, min_distance('sea', 'eat'))\n    self.assertEqual(6, min_distance('abAlgocrithmf', 'Algorithmmd'))\n    self.assertEqual(4, min_distance('acbbd', 'aabcd'))"}}}, "TestMinDistanceDP": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 541, "max_lineno": 546}, "methods": {"test_min_distance": {"args": ["self"], "min_max_lineno": {"min_lineno": 542, "max_lineno": 546}, "calls": ["test_strings.TestMinDistanceDP.assertEqual", "algorithms.strings.min_distance_dp", "algorithms.strings.min_distance"], "source_code": "def test_min_distance(self):\n    self.assertEqual(2, min_distance_dp('sea', 'eat'))\n    self.assertEqual(6, min_distance_dp('abAlgocrithmf', 'Algorithmmd'))\n    self.assertEqual(4, min_distance('acbbd', 'aabcd'))"}}}, "TestLongestCommonPrefix": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 548, "max_lineno": 565}, "methods": {"test_longest_common_prefix": {"args": ["self"], "min_max_lineno": {"min_lineno": 549, "max_lineno": 565}, "calls": ["test_strings.TestLongestCommonPrefix.assertEqual", "algorithms.strings.longest_common_prefix_v1", "algorithms.strings.longest_common_prefix_v2", "algorithms.strings.longest_common_prefix_v3"], "source_code": "def test_longest_common_prefix(self):\n    self.assertEqual('fl', longest_common_prefix_v1(['flower', 'flow', 'flight']))\n    self.assertEqual('', longest_common_prefix_v1(['dog', 'racecar', 'car']))\n    self.assertEqual('fl', longest_common_prefix_v2(['flower', 'flow', 'flight']))\n    self.assertEqual('', longest_common_prefix_v2(['dog', 'racecar', 'car']))\n    self.assertEqual('fl', longest_common_prefix_v3(['flower', 'flow', 'flight']))\n    self.assertEqual('', longest_common_prefix_v3(['dog', 'racecar', 'car']))"}}}, "TestFirstUniqueChar": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 567, "max_lineno": 571}, "methods": {"test_first_unique_char": {"args": ["self"], "min_max_lineno": {"min_lineno": 568, "max_lineno": 571}, "calls": ["test_strings.TestFirstUniqueChar.assertEqual", "algorithms.strings.first_unique_char"], "source_code": "def test_first_unique_char(self):\n    self.assertEqual(0, first_unique_char('leetcode'))\n    self.assertEqual(2, first_unique_char('loveleetcode'))"}}}, "TestRepeatSubstring": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 573, "max_lineno": 578}, "methods": {"test_repeat_substring": {"args": ["self"], "min_max_lineno": {"min_lineno": 574, "max_lineno": 578}, "calls": ["test_strings.TestRepeatSubstring.assertTrue", "test_strings.TestRepeatSubstring.assertFalse", "algorithms.strings.repeat_substring"], "source_code": "def test_repeat_substring(self):\n    self.assertTrue(repeat_substring('abab'))\n    self.assertFalse(repeat_substring('aba'))\n    self.assertTrue(repeat_substring('abcabcabcabc'))"}}}, "TestAtbashCipher": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 580, "max_lineno": 593}, "methods": {"test_atbash_cipher": {"args": ["self"], "min_max_lineno": {"min_lineno": 588, "max_lineno": 593}, "calls": ["test_strings.TestAtbashCipher.assertEqual", "algorithms.strings.atbash"], "source_code": "def test_atbash_cipher(self):\n    self.assertEqual('zyxwvutsrqponml', atbash('abcdefghijklmno'))\n    self.assertEqual('KbgslM', atbash('PythoN'))\n    self.assertEqual('AttaCK at DawN', atbash('ZggzXP zg WzdM'))\n    self.assertEqual('ZggzXP zg WzdM', atbash('AttaCK at DawN'))"}}}, "TestLongestPalindromicSubstring": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 595, "max_lineno": 606}, "methods": {"test_longest_palindromic_substring": {"args": ["self"], "min_max_lineno": {"min_lineno": 601, "max_lineno": 606}, "calls": ["test_strings.TestLongestPalindromicSubstring.assertEqual", "algorithms.strings.longest_palindrome"], "source_code": "def test_longest_palindromic_substring(self):\n    self.assertEqual('bb', longest_palindrome('cbbd'))\n    self.assertEqual('abba', longest_palindrome('abba'))\n    self.assertEqual('asdadsa', longest_palindrome('dasdasdasdasdasdadsa'))\n    self.assertEqual('abba', longest_palindrome('cabba'))"}}}, "TestKnuthMorrisPratt": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 608, "max_lineno": 622}, "methods": {"test_knuth_morris_pratt": {"args": ["self"], "min_max_lineno": {"min_lineno": 617, "max_lineno": 622}, "calls": ["test_strings.TestKnuthMorrisPratt.assertEqual", "algorithms.strings.knuth_morris_pratt"], "source_code": "def test_knuth_morris_pratt(self):\n    self.assertEqual([0, 1, 2, 3, 4], knuth_morris_pratt('aaaaaaa', 'aaa'))\n    self.assertEqual([0, 4], knuth_morris_pratt('abcdabc', 'abc'))\n    self.assertEqual([], knuth_morris_pratt('aabcdaab', 'aba'))\n    self.assertEqual([0, 4], knuth_morris_pratt([0, 0, 1, 1, 0, 0, 1, 0], [0, 0]))"}}}, "TestPanagram": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 624, "max_lineno": 701}, "methods": {"test_empty_string": {"args": ["self"], "min_max_lineno": {"min_lineno": 632, "max_lineno": 641}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_empty_string(self):\n    string = ''\n    res = panagram(string)\n    self.assertEqual(False, res)"}, "test_single_word_non_panagram": {"args": ["self"], "min_max_lineno": {"min_lineno": 642, "max_lineno": 651}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_single_word_non_panagram(self):\n    string = 'sentence'\n    res = panagram(string)\n    self.assertEqual(False, res)"}, "test_fox_panagram_no_spaces": {"args": ["self"], "min_max_lineno": {"min_lineno": 652, "max_lineno": 661}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_fox_panagram_no_spaces(self):\n    string = 'thequickbrownfoxjumpsoverthelazydog'\n    res = panagram(string)\n    self.assertEqual(True, res)"}, "test_fox_panagram_mixed_case": {"args": ["self"], "min_max_lineno": {"min_lineno": 662, "max_lineno": 671}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_fox_panagram_mixed_case(self):\n    string = 'theqUiCkbrOwnfOxjUMPSOVErThELAzYDog'\n    res = panagram(string)\n    self.assertEqual(True, res)"}, "test_whitespace_punctuation": {"args": ["self"], "min_max_lineno": {"min_lineno": 672, "max_lineno": 681}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_whitespace_punctuation(self):\n    string = '\\n\\t\\r,.-_!?'\n    res = panagram(string)\n    self.assertEqual(False, res)"}, "test_fox_panagram": {"args": ["self"], "min_max_lineno": {"min_lineno": 682, "max_lineno": 691}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_fox_panagram(self):\n    string = 'the quick brown fox jumps over the lazy dog'\n    res = panagram(string)\n    self.assertEqual(True, res)"}, "test_swedish_panagram": {"args": ["self"], "min_max_lineno": {"min_lineno": 692, "max_lineno": 701}, "calls": ["algorithms.strings.panagram", "test_strings.TestPanagram.assertEqual"], "store_vars_calls": {"res": "panagram"}, "source_code": "def test_swedish_panagram(self):\n    string = 'Yxm\u00f6rdaren Julia Blomqvist p\u00e5 f\u00e4ktning i Schweiz'\n    res = panagram(string)\n    self.assertEqual(True, res)"}}}, "TestFizzbuzz": {"doc": {"long_description": "Tests for the fizzbuzz method in file fizzbuzz.py", "short_description": "[summary]", "full": "[summary]\nTests for the fizzbuzz method in file fizzbuzz.py"}, "extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 703, "max_lineno": 729}, "methods": {"test_fizzbuzz": {"args": ["self"], "min_max_lineno": {"min_lineno": 707, "max_lineno": 729}, "calls": ["test_strings.TestFizzbuzz.assertRaises", "algorithms.strings.fizzbuzz.fizzbuzz", "test_strings.TestFizzbuzz.assertEqual"], "store_vars_calls": {"result": "fizzbuzz.fizzbuzz"}, "source_code": "def test_fizzbuzz(self):\n    self.assertRaises(ValueError, fizzbuzz.fizzbuzz, -2)\n    self.assertRaises(TypeError, fizzbuzz.fizzbuzz, 'hello')\n    result = fizzbuzz.fizzbuzz(3)\n    expected = [1, 2, 'Fizz']\n    self.assertEqual(result, expected)\n    result = fizzbuzz.fizzbuzz(5)\n    expected = [1, 2, 'Fizz', 4, 'Buzz']\n    self.assertEqual(result, expected)\n    result = fizzbuzz.fizzbuzz(15)\n    expected = [1, 2, 'Fizz', 4, 'Buzz', 'Fizz', 7, 8, 'Fizz', 'Buzz', 11, 'Fizz', 13, 14, 'FizzBuzz']\n    self.assertEqual(result, expected)"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_strings.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_streaming.py", "fileNameBase": "test_streaming", "extension": "py"}, "dependencies": [{"from_module": "algorithms.streaming.misra_gries", "import": "misras_gries", "type": "external", "type_element": "module"}, {"from_module": "algorithms.streaming", "import": "one_sparse", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestMisraGreis": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 21}, "methods": {"test_misra_correct": {"args": ["self"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 16}, "calls": ["test_streaming.TestMisraGreis.assertEqual", "algorithms.streaming.misra_gries.misras_gries"], "source_code": "def test_misra_correct(self):\n    self.assertEqual({'4': 5}, misras_gries([1, 4, 4, 4, 5, 4, 4]))\n    self.assertEqual({'1': 4}, misras_gries([0, 0, 0, 1, 1, 1, 1]))\n    self.assertEqual({'0': 4, '1': 3}, misras_gries([0, 0, 0, 0, 1, 1, 1, 2, 2], 3))"}, "test_misra_incorrect": {"args": ["self"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 21}, "calls": ["test_streaming.TestMisraGreis.assertEqual", "algorithms.streaming.misra_gries.misras_gries"], "source_code": "def test_misra_incorrect(self):\n    self.assertEqual(None, misras_gries([1, 2, 5, 4, 5, 4, 4, 5, 4, 4, 5]))\n    self.assertEqual(None, misras_gries([0, 0, 0, 2, 1, 1, 1]))\n    self.assertEqual(None, misras_gries([0, 0, 0, 1, 1, 1]))"}}}, "TestOneSparse": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 42}, "methods": {"test_one_sparse_correct": {"args": ["self"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 30}, "calls": ["test_streaming.TestOneSparse.assertEqual", "algorithms.streaming.one_sparse"], "source_code": "def test_one_sparse_correct(self):\n    self.assertEqual(4, one_sparse([(4, '+'), (2, '+'), (2, '-'), (4, '+'), (3, '+'), (3, '-')]))\n    self.assertEqual(2, one_sparse([(2, '+'), (2, '+'), (2, '+'), (2, '+'), (2, '+'), (2, '+'), (2, '+')]))"}, "test_one_sparse_incorrect": {"args": ["self"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 42}, "calls": ["test_streaming.TestOneSparse.assertEqual", "algorithms.streaming.one_sparse"], "source_code": "def test_one_sparse_incorrect(self):\n    self.assertEqual(None, one_sparse([(2, '+'), (2, '+'), (2, '+'), (2, '+'), (2, '+'), (2, '+'), (1, '+')]))\n    self.assertEqual(None, one_sparse([(2, '+'), (2, '+'), (2, '+'), (2, '+'), (2, '-'), (2, '-'), (2, '-'), (2, '-')]))\n    self.assertEqual(None, one_sparse([(2, '+'), (2, '+'), (4, '+'), (4, '+')]))"}}}}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_sort.py", "fileNameBase": "test_sort", "extension": "py"}, "dependencies": [{"from_module": "algorithms.sort", "import": "bitonic_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "bogo_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "bubble_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "comb_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "counting_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "cycle_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "exchange_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "max_heap_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "min_heap_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "merge_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "pancake_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "pigeonhole_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "quick_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "selection_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "bucket_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "shell_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "radix_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "gnome_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "cocktail_shaker_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "top_sort", "type": "external", "type_element": "module"}, {"from_module": "algorithms.sort", "import": "top_sort_recursive", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 107}, "methods": {"test_bogo_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 42}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.bogo_sort"], "source_code": "def test_bogo_sort(self):\n    self.assertTrue(is_sorted(bogo_sort([1, 23, 5])))"}, "test_bitonic_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 46}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.bitonic_sort"], "source_code": "def test_bitonic_sort(self):\n    self.assertTrue(is_sorted(bitonic_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_bubble_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 49}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.bubble_sort"], "source_code": "def test_bubble_sort(self):\n    self.assertTrue(is_sorted(bubble_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_comb_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 52}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.comb_sort"], "source_code": "def test_comb_sort(self):\n    self.assertTrue(is_sorted(comb_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_counting_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 56}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.counting_sort"], "source_code": "def test_counting_sort(self):\n    self.assertTrue(is_sorted(counting_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_cycle_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 59}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.cycle_sort"], "source_code": "def test_cycle_sort(self):\n    self.assertTrue(is_sorted(cycle_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_exchange_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 60, "max_lineno": 63}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.exchange_sort"], "source_code": "def test_exchange_sort(self):\n    self.assertTrue(is_sorted(exchange_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_heap_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 64, "max_lineno": 70}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.max_heap_sort", "algorithms.sort.min_heap_sort"], "source_code": "def test_heap_sort(self):\n    self.assertTrue(is_sorted(max_heap_sort([1, 3, 2, 5, 65, 23, 57, 1232])))\n    self.assertTrue(is_sorted(min_heap_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_insertion_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 71, "max_lineno": 74}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.bitonic_sort"], "source_code": "def test_insertion_sort(self):\n    self.assertTrue(is_sorted(bitonic_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_merge_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 75, "max_lineno": 77}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.merge_sort"], "source_code": "def test_merge_sort(self):\n    self.assertTrue(is_sorted(merge_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_pancake_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 78, "max_lineno": 81}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.pancake_sort"], "source_code": "def test_pancake_sort(self):\n    self.assertTrue(is_sorted(pancake_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_pigeonhole_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 82, "max_lineno": 84}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.pigeonhole_sort"], "source_code": "def test_pigeonhole_sort(self):\n    self.assertTrue(is_sorted(pigeonhole_sort([1, 5, 65, 23, 57, 1232])))"}, "test_quick_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 85, "max_lineno": 87}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.quick_sort"], "source_code": "def test_quick_sort(self):\n    self.assertTrue(is_sorted(quick_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_selection_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 88, "max_lineno": 91}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.selection_sort"], "source_code": "def test_selection_sort(self):\n    self.assertTrue(is_sorted(selection_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_bucket_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 92, "max_lineno": 94}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.bucket_sort"], "source_code": "def test_bucket_sort(self):\n    self.assertTrue(is_sorted(bucket_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_shell_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 95, "max_lineno": 97}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.shell_sort"], "source_code": "def test_shell_sort(self):\n    self.assertTrue(is_sorted(shell_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_radix_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 98, "max_lineno": 100}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.radix_sort"], "source_code": "def test_radix_sort(self):\n    self.assertTrue(is_sorted(radix_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_gnome_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 101, "max_lineno": 103}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.gnome_sort"], "source_code": "def test_gnome_sort(self):\n    self.assertTrue(is_sorted(gnome_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}, "test_cocktail_shaker_sort": {"args": ["self"], "min_max_lineno": {"min_lineno": 104, "max_lineno": 107}, "calls": ["test_sort.TestSuite.assertTrue", "test_sort.is_sorted", "algorithms.sort.cocktail_shaker_sort"], "source_code": "def test_cocktail_shaker_sort(self):\n    self.assertTrue(is_sorted(cocktail_shaker_sort([1, 3, 2, 5, 65, 23, 57, 1232])))"}}}, "TestTopSort": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 109, "max_lineno": 127}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 110, "max_lineno": 119}, "source_code": "def setUp(self):\n    self.depGraph = {'a': ['b'], 'b': ['c'], 'c': ['e'], 'e': ['g'], 'd': [], 'f': ['e', 'd'], 'g': []}"}, "test_topsort": {"args": ["self"], "min_max_lineno": {"min_lineno": 121, "max_lineno": 127}, "calls": ["algorithms.sort.top_sort_recursive", "test_sort.TestTopSort.assertTrue", "algorithms.sort.top_sort", "algorithms.sort.top_sort.index"], "store_vars_calls": {"res": "top_sort"}, "source_code": "def test_topsort(self):\n    res = top_sort_recursive(self.depGraph)\n    self.assertTrue(res.index('g') < res.index('e'))\n    res = top_sort(self.depGraph)\n    self.assertTrue(res.index('g') < res.index('e'))"}}}}, "functions": {"is_sorted": {"doc": {"short_description": "Helper function to check if the given array is sorted.", "args": {"array": {"description": "Array to check if sorted"}}, "returns": {"description": "True if sorted in ascending order, else False", "is_generator": false}}, "args": ["array"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 37}, "calls": ["range", "len"], "source_code": "def is_sorted(array):\n    \"\"\"\n    Helper function to check if the given array is sorted.\n    :param array: Array to check if sorted\n    :return: True if sorted in ascending order, else False\n    \"\"\"\n    for i in range(len(array) - 1):\n        if array[i] > array[i + 1]:\n            return False\n    return True"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_sort.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_tree.py", "fileNameBase": "test_tree", "extension": "py"}, "dependencies": [{"from_module": "algorithms.tree.traversal", "import": "preorder", "type": "external", "type_element": "module"}, {"from_module": "algorithms.tree.traversal", "import": "preorder_rec", "type": "external", "type_element": "module"}, {"from_module": "algorithms.tree.traversal", "import": "postorder", "type": "external", "type_element": "module"}, {"from_module": "algorithms.tree.traversal", "import": "postorder_rec", "type": "external", "type_element": "module"}, {"from_module": "algorithms.tree.traversal", "import": "inorder", "type": "external", "type_element": "module"}, {"from_module": "algorithms.tree.traversal", "import": "inorder_rec", "type": "external", "type_element": "module"}, {"from_module": "algorithms.tree.b_tree", "import": "BTree", "type": "external", "type_element": "module"}, {"from_module": "algorithms.tree", "import": "construct_tree_postorder_preorder", "alias": "ctpp", "type": "external", "type_element": "module"}, {"from_module": "algorithms.tree.fenwick_tree.fenwick_tree", "import": "Fenwick_Tree", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"Node": {"min_max_lineno": {"min_lineno": 18, "max_lineno": 24}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 24}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}, "TestTraversal": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 42}, "methods": {"test_preorder": {"args": ["self"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 32}, "calls": ["test_tree.create_tree", "test_tree.TestTraversal.assertEqual", "algorithms.tree.traversal.preorder", "algorithms.tree.traversal.preorder_rec"], "store_vars_calls": {"tree": "create_tree"}, "source_code": "def test_preorder(self):\n    tree = create_tree()\n    self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder(tree))\n    self.assertEqual([100, 50, 25, 75, 150, 125, 175], preorder_rec(tree))"}, "test_postorder": {"args": ["self"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 37}, "calls": ["test_tree.create_tree", "test_tree.TestTraversal.assertEqual", "algorithms.tree.traversal.postorder", "algorithms.tree.traversal.postorder_rec"], "store_vars_calls": {"tree": "create_tree"}, "source_code": "def test_postorder(self):\n    tree = create_tree()\n    self.assertEqual([25, 75, 50, 125, 175, 150, 100], postorder(tree))\n    self.assertEqual([25, 75, 50, 125, 175, 150, 100], postorder_rec(tree))"}, "test_inorder": {"args": ["self"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 42}, "calls": ["test_tree.create_tree", "test_tree.TestTraversal.assertEqual", "algorithms.tree.traversal.inorder", "algorithms.tree.traversal.inorder_rec"], "store_vars_calls": {"tree": "create_tree"}, "source_code": "def test_inorder(self):\n    tree = create_tree()\n    self.assertEqual([25, 50, 75, 100, 125, 150, 175], inorder(tree))\n    self.assertEqual([25, 50, 75, 100, 125, 150, 175], inorder_rec(tree))"}}}, "TestBTree": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 114}, "methods": {"setUpClass": {"args": ["cls"], "min_max_lineno": {"min_lineno": 60, "max_lineno": 66}, "calls": ["random.seed"], "source_code": "@classmethod\ndef setUpClass(cls):\n    import random\n    random.seed(18719)\n    cls.random = random\n    cls.range = 10000"}, "setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 70}, "calls": ["test_tree.TestBTree.random.randrange", "range"], "source_code": "def setUp(self):\n    self.keys_to_insert = [self.random.randrange(-self.range, self.range) for i in range(self.range)]"}, "test_insertion_and_find_even_degree": {"args": ["self"], "min_max_lineno": {"min_lineno": 71, "max_lineno": 79}, "calls": ["algorithms.tree.b_tree.BTree", "range", "algorithms.tree.b_tree.BTree.insert_key", "test_tree.TestBTree.random.choice", "test_tree.TestBTree.assertTrue", "algorithms.tree.b_tree.BTree.find"], "store_vars_calls": {"btree": "BTree", "key": "self.random.choice"}, "source_code": "def test_insertion_and_find_even_degree(self):\n    btree = BTree(4)\n    for i in self.keys_to_insert:\n        btree.insert_key(i)\n    for i in range(100):\n        key = self.random.choice(self.keys_to_insert)\n        self.assertTrue(btree.find(key))"}, "test_insertion_and_find_odd_degree": {"args": ["self"], "min_max_lineno": {"min_lineno": 80, "max_lineno": 88}, "calls": ["algorithms.tree.b_tree.BTree", "range", "algorithms.tree.b_tree.BTree.insert_key", "test_tree.TestBTree.random.choice", "test_tree.TestBTree.assertTrue", "algorithms.tree.b_tree.BTree.find"], "store_vars_calls": {"btree": "BTree", "key": "self.random.choice"}, "source_code": "def test_insertion_and_find_odd_degree(self):\n    btree = BTree(3)\n    for i in self.keys_to_insert:\n        btree.insert_key(i)\n    for i in range(100):\n        key = self.random.choice(self.keys_to_insert)\n        self.assertTrue(btree.find(key))"}, "test_deletion_even_degree": {"args": ["self"], "min_max_lineno": {"min_lineno": 89, "max_lineno": 101}, "calls": ["algorithms.tree.b_tree.BTree", "set", "test_tree.TestBTree.assertEqual", "algorithms.tree.b_tree.BTree.insert_key", "algorithms.tree.b_tree.BTree.remove_key", "test_tree.TestBTree.assertFalse", "algorithms.tree.b_tree.BTree.find"], "store_vars_calls": {"btree": "BTree", "key_list": "set"}, "source_code": "def test_deletion_even_degree(self):\n    btree = BTree(4)\n    key_list = set(self.keys_to_insert)\n    for i in key_list:\n        btree.insert_key(i)\n    for key in key_list:\n        btree.remove_key(key)\n        self.assertFalse(btree.find(key))\n    self.assertEqual(btree.root.keys, [])\n    self.assertEqual(btree.root.children, [])"}, "test_deletion_odd_degree": {"args": ["self"], "min_max_lineno": {"min_lineno": 102, "max_lineno": 114}, "calls": ["algorithms.tree.b_tree.BTree", "set", "test_tree.TestBTree.assertEqual", "algorithms.tree.b_tree.BTree.insert_key", "algorithms.tree.b_tree.BTree.remove_key", "test_tree.TestBTree.assertFalse", "algorithms.tree.b_tree.BTree.find"], "store_vars_calls": {"btree": "BTree", "key_list": "set"}, "source_code": "def test_deletion_odd_degree(self):\n    btree = BTree(3)\n    key_list = set(self.keys_to_insert)\n    for i in key_list:\n        btree.insert_key(i)\n    for key in key_list:\n        btree.remove_key(key)\n        self.assertFalse(btree.find(key))\n    self.assertEqual(btree.root.keys, [])\n    self.assertEqual(btree.root.children, [])"}}}, "TestConstructTreePreorderPostorder": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 116, "max_lineno": 145}, "methods": {"test_construct_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 117, "max_lineno": 145}, "calls": ["len", "test_tree.TestConstructTreePreorderPostorder.assertEqual", "algorithms.tree.construct_tree_postorder_preorder.construct_tree"], "store_vars_calls": {"size1": "len", "size2": "len", "size3": "len"}, "source_code": "def test_construct_tree(self):\n    ctpp.pre_index = 0\n    pre1 = [1, 2, 4, 8, 9, 5, 3, 6, 7]\n    post1 = [8, 9, 4, 5, 2, 6, 7, 3, 1]\n    size1 = len(pre1)\n    self.assertEqual(ctpp.construct_tree(pre1, post1, size1), [8, 4, 9, 2, 5, 1, 6, 3, 7])\n    ctpp.pre_index = 0\n    pre2 = [1, 2, 4, 5, 3, 6, 7]\n    post2 = [4, 5, 2, 6, 7, 3, 1]\n    size2 = len(pre2)\n    self.assertEqual(ctpp.construct_tree(pre2, post2, size2), [4, 2, 5, 1, 6, 3, 7])\n    ctpp.pre_index = 0\n    pre3 = [12, 7, 16, 21, 5, 1, 9]\n    post3 = [16, 21, 7, 1, 9, 5, 12]\n    size3 = len(pre3)\n    self.assertEqual(ctpp.construct_tree(pre3, post3, size3), [16, 7, 21, 12, 1, 5, 9])"}}}, "TestFenwickTree": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 147, "max_lineno": 177}, "methods": {"test_construct_tree_with_update_1": {"args": ["self"], "min_max_lineno": {"min_lineno": 148, "max_lineno": 157}, "calls": ["algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree", "algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree.construct", "test_tree.TestFenwickTree.assertEqual", "algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree.update_bit", "algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree.get_sum"], "store_vars_calls": {"ft": "Fenwick_Tree", "bit_tree": "ft.construct"}, "source_code": "def test_construct_tree_with_update_1(self):\n    freq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9]\n    ft = Fenwick_Tree(freq)\n    bit_tree = ft.construct()\n    self.assertEqual(12, ft.get_sum(bit_tree, 5))\n    freq[3] += 6\n    ft.update_bit(bit_tree, 3, 6)\n    self.assertEqual(18, ft.get_sum(bit_tree, 5))"}, "test_construct_tree_with_update_2": {"args": ["self"], "min_max_lineno": {"min_lineno": 158, "max_lineno": 167}, "calls": ["algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree", "algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree.construct", "test_tree.TestFenwickTree.assertEqual", "algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree.update_bit", "algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree.get_sum"], "store_vars_calls": {"ft": "Fenwick_Tree", "bit_tree": "ft.construct"}, "source_code": "def test_construct_tree_with_update_2(self):\n    freq = [1, 2, 3, 4, 5]\n    ft = Fenwick_Tree(freq)\n    bit_tree = ft.construct()\n    self.assertEqual(10, ft.get_sum(bit_tree, 3))\n    freq[3] -= 5\n    ft.update_bit(bit_tree, 3, -5)\n    self.assertEqual(5, ft.get_sum(bit_tree, 3))"}, "test_construct_tree_with_update_3": {"args": ["self"], "min_max_lineno": {"min_lineno": 168, "max_lineno": 177}, "calls": ["algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree", "algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree.construct", "test_tree.TestFenwickTree.assertEqual", "algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree.update_bit", "algorithms.tree.fenwick_tree.fenwick_tree.Fenwick_Tree.get_sum"], "store_vars_calls": {"ft": "Fenwick_Tree", "bit_tree": "ft.construct"}, "source_code": "def test_construct_tree_with_update_3(self):\n    freq = [2, 1, 4, 6, -1, 5, -32, 0, 1]\n    ft = Fenwick_Tree(freq)\n    bit_tree = ft.construct()\n    self.assertEqual(12, ft.get_sum(bit_tree, 4))\n    freq[2] += 11\n    ft.update_bit(bit_tree, 2, 11)\n    self.assertEqual(23, ft.get_sum(bit_tree, 4))"}}}}, "functions": {"create_tree": {"returns": ["n1"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 56}, "calls": ["test_tree.Node"], "store_vars_calls": {"n1": "Node", "n2": "Node", "n3": "Node", "n4": "Node", "n5": "Node", "n6": "Node", "n7": "Node"}, "source_code": "def create_tree():\n    n1 = Node(100)\n    n2 = Node(50)\n    n3 = Node(150)\n    n4 = Node(25)\n    n5 = Node(75)\n    n6 = Node(125)\n    n7 = Node(175)\n    (n1.left, n1.right) = (n2, n3)\n    (n2.left, n2.right) = (n4, n5)\n    (n3.left, n3.right) = (n6, n7)\n    return n1"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_tree.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/tests/test_array.py", "fileNameBase": "test_array", "extension": "py"}, "dependencies": [{"from_module": "algorithms.arrays", "import": "delete_nth", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "delete_nth_naive", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "flatten_iter", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "flatten", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "garage", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "josephus", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "longest_non_repeat_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "longest_non_repeat_v2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "get_longest_non_repeat_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "get_longest_non_repeat_v2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "Interval", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "merge_intervals", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "missing_ranges", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "move_zeros", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "plus_one_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "plus_one_v2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "plus_one_v3", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "rotate_v1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "rotate_v2", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "rotate_v3", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "summarize_ranges", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "three_sum", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "two_sum", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "max_ones_index", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "trimmean", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "top_1", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "limit", "type": "external", "type_element": "module"}, {"from_module": "algorithms.arrays", "import": "n_sum", "type": "external", "type_element": "module"}, {"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"TestJosephus": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 42}, "methods": {"test_josephus": {"args": ["self"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 42}, "calls": ["algorithms.arrays.josephus", "test_array.TestJosephus.assertEqual", "test_array.TestJosephus.assertRaises", "next"], "store_vars_calls": {"josephus_generator": "josephus"}, "source_code": "def test_josephus(self):\n    a = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    josephus_generator = josephus(a, 3)\n    self.assertEqual(next(josephus_generator), '3')\n    self.assertEqual(next(josephus_generator), '6')\n    self.assertEqual(next(josephus_generator), '9')\n    self.assertEqual(next(josephus_generator), '4')\n    self.assertEqual(next(josephus_generator), '8')\n    self.assertEqual(next(josephus_generator), '5')\n    self.assertEqual(next(josephus_generator), '2')\n    self.assertEqual(next(josephus_generator), '7')\n    self.assertEqual(next(josephus_generator), '1')\n    self.assertRaises(StopIteration, next, josephus_generator)"}}}, "TestDeleteNth": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 79}, "methods": {"test_delete_nth_naive": {"args": ["self"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 64}, "calls": ["test_array.TestDeleteNth.assertListEqual", "algorithms.arrays.delete_nth_naive"], "source_code": "def test_delete_nth_naive(self):\n    self.assertListEqual(delete_nth_naive([20, 37, 20, 21, 37, 21, 21], n=1), [20, 37, 21])\n    self.assertListEqual(delete_nth_naive([1, 1, 3, 3, 7, 2, 2, 2, 2], n=3), [1, 1, 3, 3, 7, 2, 2, 2])\n    self.assertListEqual(delete_nth_naive([1, 2, 3, 1, 1, 2, 1, 2, 3, 3, 2, 4, 5, 3, 1], n=3), [1, 2, 3, 1, 1, 2, 2, 3, 3, 4, 5])\n    self.assertListEqual(delete_nth_naive([], n=5), [])\n    self.assertListEqual(delete_nth_naive([1, 2, 3, 1, 1, 2, 1, 2, 3, 3, 2, 4, 5, 3, 1], n=0), [])"}, "test_delete_nth": {"args": ["self"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 79}, "calls": ["test_array.TestDeleteNth.assertListEqual", "algorithms.arrays.delete_nth"], "source_code": "def test_delete_nth(self):\n    self.assertListEqual(delete_nth([20, 37, 20, 21, 37, 21, 21], n=1), [20, 37, 21])\n    self.assertListEqual(delete_nth([1, 1, 3, 3, 7, 2, 2, 2, 2], n=3), [1, 1, 3, 3, 7, 2, 2, 2])\n    self.assertListEqual(delete_nth([1, 2, 3, 1, 1, 2, 1, 2, 3, 3, 2, 4, 5, 3, 1], n=3), [1, 2, 3, 1, 1, 2, 2, 3, 3, 4, 5])\n    self.assertListEqual(delete_nth([], n=5), [])\n    self.assertListEqual(delete_nth([1, 2, 3, 1, 1, 2, 1, 2, 3, 3, 2, 4, 5, 3, 1], n=0), [])"}}}, "TestFlatten": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 81, "max_lineno": 125}, "methods": {"test_flatten": {"args": ["self"], "min_max_lineno": {"min_lineno": 83, "max_lineno": 96}, "calls": ["algorithms.arrays.flatten", "test_array.TestFlatten.assertEqual"], "store_vars_calls": {"flattened": "flatten"}, "source_code": "def test_flatten(self):\n    nested_list = [2, 1, [3, [4, 5], 6], 7, [8]]\n    flattened = flatten(nested_list)\n    self.assertEqual(flattened, [2, 1, 3, 4, 5, 6, 7, 8])\n    nested_list = [[3, [4, 5], 6], 7, [8]]\n    flattened = flatten(nested_list)\n    self.assertEqual(flattened, [3, 4, 5, 6, 7, 8])\n    nested_list = [[], [8]]\n    flattened = flatten(nested_list)\n    self.assertEqual(flattened, [8])"}, "test_flatten_iter": {"args": ["self"], "min_max_lineno": {"min_lineno": 97, "max_lineno": 125}, "calls": ["algorithms.arrays.flatten_iter", "test_array.TestFlatten.assertEqual", "test_array.TestFlatten.assertRaises", "next"], "store_vars_calls": {"flattened": "flatten_iter"}, "source_code": "def test_flatten_iter(self):\n    nested_list = [2, 1, [3, [4, 5], 6], 7, [8]]\n    flattened = flatten_iter(nested_list)\n    self.assertEqual(next(flattened), 2)\n    self.assertEqual(next(flattened), 1)\n    self.assertEqual(next(flattened), 3)\n    self.assertEqual(next(flattened), 4)\n    self.assertEqual(next(flattened), 5)\n    self.assertEqual(next(flattened), 6)\n    self.assertEqual(next(flattened), 7)\n    self.assertEqual(next(flattened), 8)\n    self.assertRaises(StopIteration, next, flattened)\n    nested_list = [[3, [4, 5], 6], 7, [8]]\n    flattened = flatten_iter(nested_list)\n    self.assertEqual(next(flattened), 3)\n    self.assertEqual(next(flattened), 4)\n    self.assertEqual(next(flattened), 5)\n    self.assertEqual(next(flattened), 6)\n    self.assertEqual(next(flattened), 7)\n    self.assertEqual(next(flattened), 8)\n    self.assertRaises(StopIteration, next, flattened)\n    nested_list = [[], [8]]\n    flattened = flatten_iter(nested_list)\n    self.assertEqual(next(flattened), 8)\n    self.assertRaises(StopIteration, next, flattened)"}}}, "TestGarage": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 127, "max_lineno": 140}, "methods": {"test_garage": {"args": ["self"], "min_max_lineno": {"min_lineno": 129, "max_lineno": 140}, "calls": ["algorithms.arrays.garage", "test_array.TestGarage.assertEqual", "test_array.TestGarage.assertListEqual"], "source_code": "def test_garage(self):\n    initial = [1, 2, 3, 0, 4]\n    final = [0, 3, 2, 1, 4]\n    (steps, seq) = garage(initial, final)\n    self.assertEqual(steps, 4)\n    self.assertListEqual(seq, [[0, 2, 3, 1, 4], [2, 0, 3, 1, 4], [2, 3, 0, 1, 4], [0, 3, 2, 1, 4]])"}}}, "TestLongestNonRepeat": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 142, "max_lineno": 209}, "methods": {"test_longest_non_repeat_v1": {"args": ["self"], "min_max_lineno": {"min_lineno": 144, "max_lineno": 160}, "calls": ["test_array.TestLongestNonRepeat.assertEqual", "algorithms.arrays.longest_non_repeat_v1"], "source_code": "def test_longest_non_repeat_v1(self):\n    string = 'abcabcbb'\n    self.assertEqual(longest_non_repeat_v1(string), 3)\n    string = 'bbbbb'\n    self.assertEqual(longest_non_repeat_v1(string), 1)\n    string = 'pwwkew'\n    self.assertEqual(longest_non_repeat_v1(string), 3)\n    string = 'dvdf'\n    self.assertEqual(longest_non_repeat_v1(string), 3)\n    string = 'asjrgapa'\n    self.assertEqual(longest_non_repeat_v1(string), 6)"}, "test_longest_non_repeat_v2": {"args": ["self"], "min_max_lineno": {"min_lineno": 161, "max_lineno": 177}, "calls": ["test_array.TestLongestNonRepeat.assertEqual", "algorithms.arrays.longest_non_repeat_v2"], "source_code": "def test_longest_non_repeat_v2(self):\n    string = 'abcabcbb'\n    self.assertEqual(longest_non_repeat_v2(string), 3)\n    string = 'bbbbb'\n    self.assertEqual(longest_non_repeat_v2(string), 1)\n    string = 'pwwkew'\n    self.assertEqual(longest_non_repeat_v2(string), 3)\n    string = 'dvdf'\n    self.assertEqual(longest_non_repeat_v2(string), 3)\n    string = 'asjrgapa'\n    self.assertEqual(longest_non_repeat_v2(string), 6)"}, "test_get_longest_non_repeat_v1": {"args": ["self"], "min_max_lineno": {"min_lineno": 178, "max_lineno": 193}, "calls": ["test_array.TestLongestNonRepeat.assertEqual", "algorithms.arrays.get_longest_non_repeat_v1"], "source_code": "def test_get_longest_non_repeat_v1(self):\n    string = 'abcabcbb'\n    self.assertEqual(get_longest_non_repeat_v1(string), (3, 'abc'))\n    string = 'bbbbb'\n    self.assertEqual(get_longest_non_repeat_v1(string), (1, 'b'))\n    string = 'pwwkew'\n    self.assertEqual(get_longest_non_repeat_v1(string), (3, 'wke'))\n    string = 'dvdf'\n    self.assertEqual(get_longest_non_repeat_v1(string), (3, 'vdf'))\n    string = 'asjrgapa'\n    self.assertEqual(get_longest_non_repeat_v1(string), (6, 'sjrgap'))"}, "test_get_longest_non_repeat_v2": {"args": ["self"], "min_max_lineno": {"min_lineno": 194, "max_lineno": 209}, "calls": ["test_array.TestLongestNonRepeat.assertEqual", "algorithms.arrays.get_longest_non_repeat_v2"], "source_code": "def test_get_longest_non_repeat_v2(self):\n    string = 'abcabcbb'\n    self.assertEqual(get_longest_non_repeat_v2(string), (3, 'abc'))\n    string = 'bbbbb'\n    self.assertEqual(get_longest_non_repeat_v2(string), (1, 'b'))\n    string = 'pwwkew'\n    self.assertEqual(get_longest_non_repeat_v2(string), (3, 'wke'))\n    string = 'dvdf'\n    self.assertEqual(get_longest_non_repeat_v2(string), (3, 'vdf'))\n    string = 'asjrgapa'\n    self.assertEqual(get_longest_non_repeat_v2(string), (6, 'sjrgap'))"}}}, "TestMaxOnesIndex": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 211, "max_lineno": 221}, "methods": {"test_max_ones_index": {"args": ["self"], "min_max_lineno": {"min_lineno": 213, "max_lineno": 221}, "calls": ["test_array.TestMaxOnesIndex.assertEqual", "algorithms.arrays.max_ones_index"], "source_code": "def test_max_ones_index(self):\n    self.assertEqual(9, max_ones_index([1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1]))\n    self.assertEqual(3, max_ones_index([1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]))\n    self.assertEqual(-1, max_ones_index([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))"}}}, "TestMergeInterval": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 223, "max_lineno": 240}, "methods": {"test_merge": {"args": ["self"], "min_max_lineno": {"min_lineno": 225, "max_lineno": 232}, "calls": ["algorithms.arrays.Interval.merge", "test_array.TestMergeInterval.assertEqual", "algorithms.arrays.Interval"], "store_vars_calls": {"merged_intervals": "Interval.merge"}, "source_code": "def test_merge(self):\n    interval_list = [[1, 3], [2, 6], [8, 10], [15, 18]]\n    intervals = [Interval(i[0], i[1]) for i in interval_list]\n    merged_intervals = Interval.merge(intervals)\n    self.assertEqual(merged_intervals, [Interval(1, 6), Interval(8, 10), Interval(15, 18)])"}, "test_merge_intervals": {"args": ["self"], "min_max_lineno": {"min_lineno": 234, "max_lineno": 240}, "calls": ["algorithms.arrays.merge_intervals", "test_array.TestMergeInterval.assertEqual"], "store_vars_calls": {"merged_intervals": "merge_intervals"}, "source_code": "def test_merge_intervals(self):\n    interval_list = [[1, 3], [2, 6], [8, 10], [15, 18]]\n    merged_intervals = merge_intervals(interval_list)\n    self.assertEqual(merged_intervals, [[1, 6], [8, 10], [15, 18]])"}}}, "TestMissingRanges": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 243, "max_lineno": 255}, "methods": {"test_missing_ranges": {"args": ["self"], "min_max_lineno": {"min_lineno": 245, "max_lineno": 255}, "calls": ["test_array.TestMissingRanges.assertListEqual", "algorithms.arrays.missing_ranges"], "source_code": "def test_missing_ranges(self):\n    arr = [3, 5, 10, 11, 12, 15, 19]\n    self.assertListEqual(missing_ranges(arr, 0, 20), [(0, 2), (4, 4), (6, 9), (13, 14), (16, 18), (20, 20)])\n    self.assertListEqual(missing_ranges(arr, 6, 100), [(6, 9), (13, 14), (16, 18), (20, 100)])"}}}, "TestMoveZeros": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 257, "max_lineno": 267}, "methods": {"test_move_zeros": {"args": ["self"], "min_max_lineno": {"min_lineno": 259, "max_lineno": 267}, "calls": ["test_array.TestMoveZeros.assertListEqual", "algorithms.arrays.move_zeros"], "source_code": "def test_move_zeros(self):\n    self.assertListEqual(move_zeros([False, 1, 0, 1, 2, 0, 1, 3, 'a']), [False, 1, 1, 2, 1, 3, 'a', 0, 0])\n    self.assertListEqual(move_zeros([0, 34, 'rahul', [], None, 0, True, 0]), [34, 'rahul', [], None, True, 0, 0, 0])"}}}, "TestPlusOne": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 269, "max_lineno": 300}, "methods": {"test_plus_one_v1": {"args": ["self"], "min_max_lineno": {"min_lineno": 271, "max_lineno": 280}, "calls": ["test_array.TestPlusOne.assertListEqual", "algorithms.arrays.plus_one_v1"], "source_code": "def test_plus_one_v1(self):\n    self.assertListEqual(plus_one_v1([0]), [1])\n    self.assertListEqual(plus_one_v1([9]), [1, 0])\n    self.assertListEqual(plus_one_v1([1, 0, 9]), [1, 1, 0])\n    self.assertListEqual(plus_one_v1([9, 9, 8, 0, 0, 9]), [9, 9, 8, 0, 1, 0])\n    self.assertListEqual(plus_one_v1([9, 9, 9, 9]), [1, 0, 0, 0, 0])"}, "test_plus_one_v2": {"args": ["self"], "min_max_lineno": {"min_lineno": 281, "max_lineno": 290}, "calls": ["test_array.TestPlusOne.assertListEqual", "algorithms.arrays.plus_one_v2"], "source_code": "def test_plus_one_v2(self):\n    self.assertListEqual(plus_one_v2([0]), [1])\n    self.assertListEqual(plus_one_v2([9]), [1, 0])\n    self.assertListEqual(plus_one_v2([1, 0, 9]), [1, 1, 0])\n    self.assertListEqual(plus_one_v2([9, 9, 8, 0, 0, 9]), [9, 9, 8, 0, 1, 0])\n    self.assertListEqual(plus_one_v2([9, 9, 9, 9]), [1, 0, 0, 0, 0])"}, "test_plus_one_v3": {"args": ["self"], "min_max_lineno": {"min_lineno": 291, "max_lineno": 300}, "calls": ["test_array.TestPlusOne.assertListEqual", "algorithms.arrays.plus_one_v3"], "source_code": "def test_plus_one_v3(self):\n    self.assertListEqual(plus_one_v3([0]), [1])\n    self.assertListEqual(plus_one_v3([9]), [1, 0])\n    self.assertListEqual(plus_one_v3([1, 0, 9]), [1, 1, 0])\n    self.assertListEqual(plus_one_v3([9, 9, 8, 0, 0, 9]), [9, 9, 8, 0, 1, 0])\n    self.assertListEqual(plus_one_v3([9, 9, 9, 9]), [1, 0, 0, 0, 0])"}}}, "TestRotateArray": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 302, "max_lineno": 333}, "methods": {"test_rotate_v1": {"args": ["self"], "min_max_lineno": {"min_lineno": 304, "max_lineno": 313}, "calls": ["test_array.TestRotateArray.assertListEqual", "algorithms.arrays.rotate_v1"], "source_code": "def test_rotate_v1(self):\n    self.assertListEqual(rotate_v1([1, 2, 3, 4, 5, 6, 7], k=3), [5, 6, 7, 1, 2, 3, 4])\n    self.assertListEqual(rotate_v1([1, 2, 3, 4, 5, 6, 7], k=1), [7, 1, 2, 3, 4, 5, 6])\n    self.assertListEqual(rotate_v1([1, 2, 3, 4, 5, 6, 7], k=7), [1, 2, 3, 4, 5, 6, 7])\n    self.assertListEqual(rotate_v1([1, 2], k=111), [2, 1])"}, "test_rotate_v2": {"args": ["self"], "min_max_lineno": {"min_lineno": 314, "max_lineno": 323}, "calls": ["test_array.TestRotateArray.assertListEqual", "algorithms.arrays.rotate_v2"], "source_code": "def test_rotate_v2(self):\n    self.assertListEqual(rotate_v2([1, 2, 3, 4, 5, 6, 7], k=3), [5, 6, 7, 1, 2, 3, 4])\n    self.assertListEqual(rotate_v2([1, 2, 3, 4, 5, 6, 7], k=1), [7, 1, 2, 3, 4, 5, 6])\n    self.assertListEqual(rotate_v2([1, 2, 3, 4, 5, 6, 7], k=7), [1, 2, 3, 4, 5, 6, 7])\n    self.assertListEqual(rotate_v2([1, 2], k=111), [2, 1])"}, "test_rotate_v3": {"args": ["self"], "min_max_lineno": {"min_lineno": 324, "max_lineno": 333}, "calls": ["test_array.TestRotateArray.assertListEqual", "algorithms.arrays.rotate_v3"], "source_code": "def test_rotate_v3(self):\n    self.assertListEqual(rotate_v3([1, 2, 3, 4, 5, 6, 7], k=3), [5, 6, 7, 1, 2, 3, 4])\n    self.assertListEqual(rotate_v3([1, 2, 3, 4, 5, 6, 7], k=1), [7, 1, 2, 3, 4, 5, 6])\n    self.assertListEqual(rotate_v3([1, 2, 3, 4, 5, 6, 7], k=7), [1, 2, 3, 4, 5, 6, 7])\n    self.assertListEqual(rotate_v3([1, 2], k=111), [2, 1])"}}}, "TestSummaryRanges": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 335, "max_lineno": 345}, "methods": {"test_summarize_ranges": {"args": ["self"], "min_max_lineno": {"min_lineno": 337, "max_lineno": 345}, "calls": ["test_array.TestSummaryRanges.assertListEqual", "algorithms.arrays.summarize_ranges"], "source_code": "def test_summarize_ranges(self):\n    self.assertListEqual(summarize_ranges([0, 1, 2, 4, 5, 7]), [(0, 2), (4, 5), (7, 7)])\n    self.assertListEqual(summarize_ranges([-5, -4, -3, 1, 2, 4, 5, 6]), [(-5, -3), (1, 2), (4, 6)])\n    self.assertListEqual(summarize_ranges([-2, -1, 0, 1, 2]), [(-2, 2)])"}}}, "TestThreeSum": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 347, "max_lineno": 356}, "methods": {"test_three_sum": {"args": ["self"], "min_max_lineno": {"min_lineno": 349, "max_lineno": 356}, "calls": ["test_array.TestThreeSum.assertSetEqual", "algorithms.arrays.three_sum"], "source_code": "def test_three_sum(self):\n    self.assertSetEqual(three_sum([-1, 0, 1, 2, -1, -4]), {(-1, 0, 1), (-1, -1, 2)})\n    self.assertSetEqual(three_sum([-1, 3, 1, 2, -1, -4, -2]), {(-4, 1, 3), (-2, -1, 3), (-1, -1, 2)})"}}}, "TestTwoSum": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 358, "max_lineno": 366}, "methods": {"test_two_sum": {"args": ["self"], "min_max_lineno": {"min_lineno": 360, "max_lineno": 366}, "calls": ["test_array.TestTwoSum.assertTupleEqual", "test_array.TestTwoSum.assertIsNone", "algorithms.arrays.two_sum"], "source_code": "def test_two_sum(self):\n    self.assertTupleEqual((0, 2), two_sum([2, 11, 7, 9], target=9))\n    self.assertTupleEqual((0, 3), two_sum([-3, 5, 2, 3, 8, -9], target=0))\n    self.assertIsNone(two_sum([-3, 5, 2, 3, 8, -9], target=6))"}}}, "TestTrimmean": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 368, "max_lineno": 375}, "methods": {"test_trimmean": {"args": ["self"], "min_max_lineno": {"min_lineno": 370, "max_lineno": 375}, "calls": ["test_array.TestTrimmean.assertEqual", "algorithms.arrays.trimmean"], "source_code": "def test_trimmean(self):\n    self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20), 5.5)\n    self.assertEqual(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 20), 6.0)"}}}, "TestTop1": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 377, "max_lineno": 383}, "methods": {"test_top_1": {"args": ["self"], "min_max_lineno": {"min_lineno": 379, "max_lineno": 383}, "calls": ["test_array.TestTop1.assertListEqual", "algorithms.arrays.top_1"], "source_code": "def test_top_1(self):\n    self.assertListEqual(top_1([1, 1, 2, 2, 3]), [1, 2])\n    self.assertListEqual(top_1([1, 2, 3, 324, 234, 23, 23, 1, 23, 23]), [23])"}}}, "TestLimit": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 385, "max_lineno": 392}, "methods": {"test_limit": {"args": ["self"], "min_max_lineno": {"min_lineno": 387, "max_lineno": 392}, "calls": ["test_array.TestLimit.assertListEqual", "algorithms.arrays.limit"], "source_code": "def test_limit(self):\n    self.assertListEqual(limit([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5])\n    self.assertListEqual(limit([1, 2, 3, 4, 5], 2, 4), [2, 3, 4])\n    self.assertListEqual(limit([1, 2, 3, 4, 5], 2), [2, 3, 4, 5])\n    self.assertListEqual(limit([1, 2, 3, 4, 5], None, 4), [1, 2, 3, 4])"}}}, "TestNSum": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 394, "max_lineno": 427}, "methods": {"test_n_sum": {"args": ["self"], "min_max_lineno": {"min_lineno": 396, "max_lineno": 427}, "calls": ["test_array.TestNSum.assertEqual", "algorithms.arrays.n_sum", "sorted"], "source_code": "def test_n_sum(self):\n    self.assertEqual(n_sum(2, [-3, 5, 2, 3, 8, -9], 6), [])\n    self.assertEqual(n_sum(3, [-5, -4, -3, -2, -1, 0, 1, 2, 3], 0), sorted([[-5, 2, 3], [-2, 0, 2], [-4, 1, 3], [-3, 1, 2], [-1, 0, 1], [-2, -1, 3], [-3, 0, 3]]))\n    self.assertEqual(n_sum(3, [-1, 0, 1, 2, -1, -4], 0), sorted([[-1, -1, 2], [-1, 0, 1]]))\n    self.assertEqual(n_sum(4, [1, 0, -1, 0, -2, 2], 0), sorted([[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]))\n    self.assertEqual(n_sum(4, [7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 6, 4, -3, -2], 10), sorted([[-6, 2, 7, 7], [-6, 3, 6, 7], [-6, 4, 5, 7], [-6, 4, 6, 6], [-5, 1, 7, 7], [-5, 2, 6, 7], [-5, 3, 5, 7], [-5, 3, 6, 6], [-5, 4, 4, 7], [-5, 4, 5, 6], [-4, 0, 7, 7], [-4, 1, 6, 7], [-4, 2, 5, 7], [-4, 2, 6, 6], [-4, 3, 4, 7], [-4, 3, 5, 6], [-4, 4, 4, 6], [-3, -1, 7, 7], [-3, 0, 6, 7], [-3, 1, 5, 7], [-3, 1, 6, 6], [-3, 2, 4, 7], [-3, 2, 5, 6], [-3, 3, 4, 6], [-3, 4, 4, 5], [-2, -2, 7, 7], [-2, -1, 6, 7], [-2, 0, 5, 7], [-2, 0, 6, 6], [-2, 1, 4, 7], [-2, 1, 5, 6], [-2, 2, 3, 7], [-2, 2, 4, 6], [-2, 3, 4, 5], [-1, 0, 4, 7], [-1, 0, 5, 6], [-1, 1, 3, 7], [-1, 1, 4, 6], [-1, 2, 3, 6], [-1, 2, 4, 5], [-1, 3, 4, 4], [0, 1, 2, 7], [0, 1, 3, 6], [0, 1, 4, 5], [0, 2, 3, 5], [0, 2, 4, 4], [1, 2, 3, 4]]))\n    self.assertEqual(n_sum(2, [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]], 0, sum_closure=lambda a, b: a[0] + b[0]), [[[-3, 0], [3, 3]], [[-2, 1], [2, 2]]])\n    self.assertEqual(n_sum(2, [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]], [0, 3], sum_closure=lambda a, b: [a[0] + b[0], a[1] + b[1]], same_closure=lambda a, b: a[0] == b[0] and a[1] == b[1]), [[[-3, 0], [3, 3]], [[-2, 1], [2, 2]]])\n    self.assertEqual(n_sum(2, [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]], -5, sum_closure=lambda a, b: [a[0] + b[1], a[1] + b[0]], compare_closure=lambda a, b: -1 if a[0] < b else 1 if a[0] > b else 0), [[[-9, 5], [8, 4]]])"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "test_array.unittest.main", "type": "script"}, "is_test": true}], "output/keon/algorithms/algorithms/docs/source": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/SemanticCodeSearch/Code2code/SearchEngine/content/keon/algorithms/docs/source/conf.py", "fileNameBase": "conf", "extension": "py"}, "dependencies": [{"from_module": "recommonmark.parser", "import": "CommonMarkParser", "type": "external", "type_element": "module"}], "is_test": false}], "readme_files": {"output/keon/algorithms/algorithms/README.md": "[![PyPI version](https://badge.fury.io/py/algorithms.svg)](https://badge.fury.io/py/algorithms)\n[![Open Source Helpers](https://www.codetriage.com/keon/algorithms/badges/users.svg)](https://www.codetriage.com/keon/algorithms)\n[![Build Status](https://travis-ci.org/keon/algorithms.svg?branch=master)](https://travis-ci.org/keon/algorithms)\n[![Coverage Status](https://coveralls.io/repos/github/keon/algorithms/badge.svg?branch=master)](https://coveralls.io/github/keon/algorithms?branch=master)\n\n<p align=\"center\"><img src=\"https://raw.githubusercontent.com/keon/algorithms/master/docs/source/_static/logo/logotype1blue.png\"></p>\n\nPythonic Data Structures and Algorithms\n=========================================\n\nMinimal and clean example implementations of data structures and algorithms in Python 3.\n\n## Contributing\nThanks for your interest in contributing! There are many ways to contribute to this project. [Get started here](CONTRIBUTING.md)\n\n## Tests\n\n### Use unittest\nFor running all tests write down:\n\n    $ python3 -m unittest discover tests\n\nFor running some specific tests you can do this as following (Ex: sort):\n\n    $ python3 -m unittest tests.test_sort\n\n### Use pytest\nFor running all tests write down:\n\n    $ python3 -m pytest tests\n\n## Install\nIf you want to use the API algorithms in your code, it is as simple as:\n\n    $ pip3 install algorithms\n\nYou can test by creating a python file: (Ex: use `merge_sort` in `sort`)\n\n```python3\nfrom algorithms.sort import merge_sort\n\nif __name__ == \"__main__\":\n    my_list = [1, 8, 3, 5, 6]\n    my_list = merge_sort(my_list)\n    print(my_list)\n```\n\n## Uninstall\nIf you want to uninstall algorithms, it is as simple as:\n\n    $ pip3 uninstall -y algorithms\n\n## List of Implementations\n\n- [arrays](algorithms/arrays)\n    - [delete_nth](algorithms/arrays/delete_nth.py)\n    - [flatten](algorithms/arrays/flatten.py)\n    - [garage](algorithms/arrays/garage.py)\n    - [josephus_problem](algorithms/arrays/josephus.py)\n    - [limit](algorithms/arrays/limit.py)\n    - [longest_non_repeat](algorithms/arrays/longest_non_repeat.py/)\n    - [max_ones_index](algorithms/arrays/max_ones_index.py)\n    - [merge_intervals](algorithms/arrays/merge_intervals.py)\n    - [missing_ranges](algorithms/arrays/missing_ranges.py)\n    - [plus_one](algorithms/arrays/plus_one.py)\n    - [rotate](algorithms/arrays/rotate.py)\n    - [summarize_ranges](algorithms/arrays/summarize_ranges.py)\n    - [three_sum](algorithms/arrays/three_sum.py)\n    - [trimmean](algorithms/arrays/trimmean.py)\n    - [top_1](algorithms/arrays/top_1.py)\n    - [two_sum](algorithms/arrays/two_sum.py)\n    - [move_zeros](algorithms/arrays/move_zeros.py)\n    - [n_sum](algorithms/arrays/n_sum.py)\n- [greedy](algorithms/greedy/)\n    - [max_contiguous_subsequence_sum](algorithms/greedy/max_contiguous_subsequence_sum.py)\n- [automata](algorithms/automata)\n    - [DFA](algorithms/automata/dfa.py)\n- [backtrack](algorithms/backtrack)\n    - [general_solution.md](algorithms/backtrack/)\n    - [add_operators](algorithms/backtrack/add_operators.py)\n    - [anagram](algorithms/backtrack/anagram.py)\n    - [array_sum_combinations](algorithms/backtrack/array_sum_combinations.py)\n    - [combination_sum](algorithms/backtrack/combination_sum.py)\n    - [factor_combinations](algorithms/backtrack/factor_combinations.py)\n    - [generate_abbreviations](algorithms/backtrack/generate_abbreviations.py)\n    - [generate_parenthesis](algorithms/backtrack/generate_parenthesis.py)\n    - [letter_combination](algorithms/backtrack/letter_combination.py)\n    - [palindrome_partitioning](algorithms/backtrack/palindrome_partitioning.py)\n    - [pattern_match](algorithms/backtrack/pattern_match.py)\n    - [permute](algorithms/backtrack/permute.py)\n    - [permute_unique](algorithms/backtrack/permute_unique.py)\n    - [subsets](algorithms/backtrack/subsets.py)\n    - [subsets_unique](algorithms/backtrack/subsets_unique.py)\n- [bfs](algorithms/bfs)\n    - [maze_search](algorithms/bfs/maze_search.py)\n    - [shortest_distance_from_all_buildings](algorithms/bfs/shortest_distance_from_all_buildings.py)\n    - [word_ladder](algorithms/bfs/word_ladder.py)\n- [bit](algorithms/bit)\n    - [add_bitwise_operator](algorithms/bit/add_bitwise_operator.py)\n    - [bit_operation](algorithms/bit/bit_operation.py)\n    - [bytes_int_conversion](algorithms/bit/bytes_int_conversion.py)\n    - [count_flips_to_convert](algorithms/bit/count_flips_to_convert.py)\n    - [count_ones](algorithms/bit/count_ones.py)\n    - [find_difference](algorithms/bit/find_difference.py)\n    - [find_missing_number](algorithms/bit/find_missing_number.py)\n    - [flip_bit_longest_sequence](algorithms/bit/flip_bit_longest_sequence.py)\n    - [power_of_two](algorithms/bit/power_of_two.py)\n    - [reverse_bits](algorithms/bit/reverse_bits.py)\n    - [single_number](algorithms/bit/single_number.py)\n    - [single_number2](algorithms/bit/single_number2.py)\n    - [single_number3](algorithms/bit/single_number3.py)\n    - [subsets](algorithms/bit/subsets.py)\n    - [swap_pair](algorithms/bit/swap_pair.py)\n    - [has_alternative_bit](algorithms/bit/has_alternative_bit.py)\n    - [insert_bit](algorithms/bit/insert_bit.py)\n    - [remove_bit](algorithms/bit/remove_bit.py)\n    - [binary_gap](algorithms/bit/binary_gap.py)\n- [compression](algorithms/compression)\n    - [huffman_coding](algorithms/compression/huffman_coding.py)\n    - [rle_compression](algorithms/compression/rle_compression.py)\n    - [elias](algorithms/compression/elias.py)\n- [dfs](algorithms/dfs)\n    - [all_factors](algorithms/dfs/all_factors.py)\n    - [count_islands](algorithms/dfs/count_islands.py)\n    - [pacific_atlantic](algorithms/dfs/pacific_atlantic.py)\n    - [sudoku_solver](algorithms/dfs/sudoku_solver.py)\n    - [walls_and_gates](algorithms/dfs/walls_and_gates.py)\n- [distribution](algorithms/distribution)\n    - [histogram](algorithms/distribution/histogram.py)\n- [dp](algorithms/dp)\n    - [buy_sell_stock](algorithms/dp/buy_sell_stock.py)\n    - [climbing_stairs](algorithms/dp/climbing_stairs.py)\n    - [coin_change](algorithms/dp/coin_change.py)\n    - [combination_sum](algorithms/dp/combination_sum.py)\n    - [egg_drop](algorithms/dp/egg_drop.py)\n    - [house_robber](algorithms/dp/house_robber.py)\n    - [int_divide](algorithms/dp/int_divide.py)\n    - [job_scheduling](algorithms/dp/job_scheduling.py)\n    - [knapsack](algorithms/dp/knapsack.py)\n    - [longest_increasing](algorithms/dp/longest_increasing.py)\n    - [matrix_chain_order](algorithms/dp/matrix_chain_order.py)\n    - [max_product_subarray](algorithms/dp/max_product_subarray.py)\n    - [max_subarray](algorithms/dp/max_subarray.py)\n    - [min_cost_path](algorithms/dp/min_cost_path.py)\n    - [num_decodings](algorithms/dp/num_decodings.py)\n    - [regex_matching](algorithms/dp/regex_matching.py)\n    - [rod_cut](algorithms/dp/rod_cut.py)\n    - [word_break](algorithms/dp/word_break.py)\n    - [fibonacci](algorithms/dp/fib.py)\n\t- [hosoya triangle](algorithms/dp/hosoya_triangle.py)\n\t- [K-Factor_strings](algorithms/dp/k_factor.py)\n    - [planting_trees](algorithms/dp/planting_trees.py)\n- [graph](algorithms/graph)\n    - [check_bipartite](algorithms/graph/check_bipartite.py)\n    - [strongly_connected](algorithms/graph/check_digraph_strongly_connected.py)\n    - [clone_graph](algorithms/graph/clone_graph.py)\n    - [cycle_detection](algorithms/graph/cycle_detection.py)\n    - [find_all_cliques](algorithms/graph/find_all_cliques.py)\n    - [find_path](algorithms/graph/find_path.py)\n    - [graph](algorithms/graph/graph.py)\n    - [dijkstra](algorithms/graph/dijkstra.py)\n    - [markov_chain](algorithms/graph/markov_chain.py)\n    - [minimum_spanning_tree](algorithms/graph/minimum_spanning_tree.py)\n    - [satisfiability](algorithms/graph/satisfiability.py)\n    - [minimum_spanning_tree_prims](algorithms/graph/prims_minimum_spanning.py)\n    - [tarjan](algorithms/graph/tarjan.py)\n    - [traversal](algorithms/graph/traversal.py)\n\t  - [maximum_flow](algorithms/graph/maximum_flow.py)\n    - [maximum_flow_bfs](algorithms/graph/maximum_flow_bfs.py)\n    - [maximum_flow_dfs](algorithms/graph/maximum_flow_dfs.py)\n    - [all_pairs_shortest_path](algorithms/graph/all_pairs_shortest_path.py)\n    - [bellman_ford](algorithms/graph/bellman_ford.py)\n    - [Count Connected Components](algorithms/graph/count_connected_number_of_component.py)\n- [heap](algorithms/heap)\n    - [merge_sorted_k_lists](algorithms/heap/merge_sorted_k_lists.py)\n    - [skyline](algorithms/heap/skyline.py)\n    - [sliding_window_max](algorithms/heap/sliding_window_max.py)\n    - [binary_heap](algorithms/heap/binary_heap.py)\n    - [k_closest_points](algorithms/heap/k_closest_points.py)\n- [linkedlist](algorithms/linkedlist)\n    - [add_two_numbers](algorithms/linkedlist/add_two_numbers.py)\n    - [copy_random_pointer](algorithms/linkedlist/copy_random_pointer.py)\n    - [delete_node](algorithms/linkedlist/delete_node.py)\n    - [first_cyclic_node](algorithms/linkedlist/first_cyclic_node.py)\n    - [is_cyclic](algorithms/linkedlist/is_cyclic.py)\n    - [is_palindrome](algorithms/linkedlist/is_palindrome.py)\n    - [kth_to_last](algorithms/linkedlist/kth_to_last.py)\n    - [linkedlist](algorithms/linkedlist/linkedlist.py)\n    - [remove_duplicates](algorithms/linkedlist/remove_duplicates.py)\n    - [reverse](algorithms/linkedlist/reverse.py)\n    - [rotate_list](algorithms/linkedlist/rotate_list.py)\n    - [swap_in_pairs](algorithms/linkedlist/swap_in_pairs.py)\n    - [is_sorted](algorithms/linkedlist/is_sorted.py)\n    - [remove_range](algorithms/linkedlist/remove_range.py)\n- [map](algorithms/map)\n    - [hashtable](algorithms/map/hashtable.py)\n    - [separate_chaining_hashtable](algorithms/map/separate_chaining_hashtable.py)\n    - [longest_common_subsequence](algorithms/map/longest_common_subsequence.py)\n    - [longest_palindromic_subsequence](algorithms/map/longest_palindromic_subsequence.py)\n    - [randomized_set](algorithms/map/randomized_set.py)\n    - [valid_sudoku](algorithms/map/valid_sudoku.py)\n    - [word_pattern](algorithms/map/word_pattern.py)\n    - [is_isomorphic](algorithms/map/is_isomorphic.py)\n    - [is_anagram](algorithms/map/is_anagram.py)\n- [maths](algorithms/maths)\n    - [base_conversion](algorithms/maths/base_conversion.py)\n    - [chinese_remainder_theorem](algorithms/maths/chinese_remainder_theorem.py)\n    - [combination](algorithms/maths/combination.py)\n    - [cosine_similarity](algorithms/maths/cosine_similarity.py)\n    - [decimal_to_binary_ip](algorithms/maths/decimal_to_binary_ip.py)\n    - [diffie_hellman_key_exchange](algorithms/maths/diffie_hellman_key_exchange.py)\n    - [euler_totient](algorithms/maths/euler_totient.py)\n    - [extended_gcd](algorithms/maths/extended_gcd.py)\n    - [factorial](algorithms/maths/factorial.py)\n    - [find_order](algorithms/maths/find_order_simple.py)\n    - [find_primitive_root](algorithms/maths/find_primitive_root_simple.py)\n    - [gcd/lcm](algorithms/maths/gcd.py)\n    - [generate_strobogrammtic](algorithms/maths/generate_strobogrammtic.py)\n    - [hailstone](algorithms/maths/hailstone.py)\n    - [is_strobogrammatic](algorithms/maths/is_strobogrammatic.py)\n    - [krishnamurthy_number](algorithms/maths/krishnamurthy_number.py)\n    - [magic_number](algorithms/maths/magic_number.py)\n    - [modular_exponential](algorithms/maths/modular_exponential.py)\n    - [modular_inverse](algorithms/maths/modular_inverse.py)\n    - [next_bigger](algorithms/maths/next_bigger.py)\n    - [next_perfect_square](algorithms/maths/next_perfect_square.py)\n    - [nth_digit](algorithms/maths/nth_digit.py)\n    - [num_perfect_squares](algorithms/maths/num_perfect_squares.py)\n    - [polynomial](algorithms/maths/polynomial.py)\n    - [power](algorithms/maths/power.py)\n    - [prime_check](algorithms/maths/prime_check.py)\n    - [primes_sieve_of_eratosthenes](algorithms/maths/primes_sieve_of_eratosthenes.py)\n    - [pythagoras](algorithms/maths/pythagoras.py)\n    - [rabin_miller](algorithms/maths/rabin_miller.py)\n    - [recursive_binomial_coefficient](algorithms/maths/recursive_binomial_coefficient.py)\n    - [rsa](algorithms/maths/rsa.py)\n    - [sqrt_precision_factor](algorithms/maths/sqrt_precision_factor.py)\n    - [summing_digits](algorithms/maths/summing_digits.py)\n    - [symmetry_group_cycle_index](algorithms/maths/symmetry_group_cycle_index.py)\n- [matrix](algorithms/matrix)\n    - [sudoku_validator](algorithms/matrix/sudoku_validator.py)\n    - [bomb_enemy](algorithms/matrix/bomb_enemy.py)\n    - [copy_transform](algorithms/matrix/copy_transform.py)\n    - [count_paths](algorithms/matrix/count_paths.py)\n    - [matrix_exponentiation](algorithms/matrix/matrix_exponentiation.py)\n    - [matrix_inversion](algorithms/matrix/matrix_inversion.py)\n    - [matrix_multiplication](algorithms/matrix/multiply.py)\n    - [rotate_image](algorithms/matrix/rotate_image.py)\n    - [search_in_sorted_matrix](algorithms/matrix/search_in_sorted_matrix.py)\n    - [sparse_dot_vector](algorithms/matrix/sparse_dot_vector.py)\n    - [sparse_mul](algorithms/matrix/sparse_mul.py)\n    - [spiral_traversal](algorithms/matrix/spiral_traversal.py)\n\t- [crout_matrix_decomposition](algorithms/matrix/crout_matrix_decomposition.py)\n\t- [cholesky_matrix_decomposition](algorithms/matrix/cholesky_matrix_decomposition.py)\n    - [sum_sub_squares](algorithms/matrix/sum_sub_squares.py)\n    - [sort_matrix_diagonally](algorithms/matrix/sort_matrix_diagonally.py)\n- [queues](algorithms/queues)\n    - [max_sliding_window](algorithms/queues/max_sliding_window.py)\n    - [moving_average](algorithms/queues/moving_average.py)\n    - [queue](algorithms/queues/queue.py)\n    - [reconstruct_queue](algorithms/queues/reconstruct_queue.py)\n    - [zigzagiterator](algorithms/queues/zigzagiterator.py)\n- [search](algorithms/search)\n    - [binary_search](algorithms/search/binary_search.py)\n    - [first_occurrence](algorithms/search/first_occurrence.py)\n    - [last_occurrence](algorithms/search/last_occurrence.py)\n    - [linear_search](algorithms/search/linear_search.py)\n    - [search_insert](algorithms/search/search_insert.py)\n    - [two_sum](algorithms/search/two_sum.py)\n    - [search_range](algorithms/search/search_range.py)\n    - [find_min_rotate](algorithms/search/find_min_rotate.py)\n    - [search_rotate](algorithms/search/search_rotate.py)\n    - [jump_search](algorithms/search/jump_search.py)\n    - [next_greatest_letter](algorithms/search/next_greatest_letter.py)\n    - [interpolation_search](algorithms/search/interpolation_search.py)\n- [set](algorithms/set)\n    - [randomized_set](algorithms/set/randomized_set.py)\n    - [set_covering](algorithms/set/set_covering.py)\n    - [find_keyboard_row](algorithms/set/find_keyboard_row.py)\n- [sort](algorithms/sort)\n    - [bitonic_sort](algorithms/sort/bitonic_sort.py)\n    - [bogo_sort](algorithms/sort/bogo_sort.py)\n    - [bubble_sort](algorithms/sort/bubble_sort.py)\n    - [bucket_sort](algorithms/sort/bucket_sort.py)\n    - [cocktail_shaker_sort](algorithms/sort/cocktail_shaker_sort.py)\n    - [comb_sort](algorithms/sort/comb_sort.py)\n    - [counting_sort](algorithms/sort/counting_sort.py)\n    - [cycle_sort](algorithms/sort/cycle_sort.py)\n    - [exchange_sort](algorithms/sort/exchange_sort.py)\n    - [gnome_sort](algorithms/sort/gnome_sort.py)\n    - [heap_sort](algorithms/sort/heap_sort.py)\n    - [insertion_sort](algorithms/sort/insertion_sort.py)\n    - [meeting_rooms](algorithms/sort/meeting_rooms.py)\n    - [merge_sort](algorithms/sort/merge_sort.py)\n    - [pancake_sort](algorithms/sort/pancake_sort.py)\n    - [pigeonhole_sort](algorithms/sort/pigeonhole_sort.py)\n    - [quick_sort](algorithms/sort/quick_sort.py)\n    - [radix_sort](algorithms/sort/radix_sort.py)\n    - [selection_sort](algorithms/sort/selection_sort.py)\n    - [shell_sort](algorithms/sort/shell_sort.py)\n    - [sort_colors](algorithms/sort/sort_colors.py)\n    - [stooge_sort](algorithms/sort/stooge_sort.py)\n    - [top_sort](algorithms/sort/top_sort.py)\n    - [wiggle_sort](algorithms/sort/wiggle_sort.py)\n- [stack](algorithms/stack)\n    - [longest_abs_path](algorithms/stack/longest_abs_path.py)\n    - [simplify_path](algorithms/stack/simplify_path.py)\n    - [stack](algorithms/stack/stack.py)\n    - [valid_parenthesis](algorithms/stack/valid_parenthesis.py)\n    - [stutter](algorithms/stack/stutter.py)\n    - [switch_pairs](algorithms/stack/switch_pairs.py)\n    - [is_consecutive](algorithms/stack/is_consecutive.py)\n    - [remove_min](algorithms/stack/remove_min.py)\n    - [is_sorted](algorithms/stack/is_sorted.py)\n- [streaming](algorithms/streaming)\n    - [1-sparse-recovery](algorithms/streaming/one_sparse_recovery.py)\n    - [misra-gries](algorithms/streaming/misra_gries.py)\n- [strings](algorithms/strings)\n    - [fizzbuzz](algorithms/strings/fizzbuzz.py)\n    - [delete_reoccurring](algorithms/strings/delete_reoccurring.py)\n    - [strip_url_params](algorithms/strings/strip_url_params.py)\n    - [validate_coordinates](algorithms/strings/validate_coordinates.py)\n    - [domain_extractor](algorithms/strings/domain_extractor.py)\n    - [merge_string_checker](algorithms/strings/merge_string_checker.py)\n    - [add_binary](algorithms/strings/add_binary.py)\n    - [breaking_bad](algorithms/strings/breaking_bad.py)\n    - [decode_string](algorithms/strings/decode_string.py)\n    - [encode_decode](algorithms/strings/encode_decode.py)\n    - [group_anagrams](algorithms/strings/group_anagrams.py)\n    - [int_to_roman](algorithms/strings/int_to_roman.py)\n    - [is_palindrome](algorithms/strings/is_palindrome.py)\n    - [license_number](algorithms/strings/license_number.py)\n    - [make_sentence](algorithms/strings/make_sentence.py)\n    - [multiply_strings](algorithms/strings/multiply_strings.py)\n    - [one_edit_distance](algorithms/strings/one_edit_distance.py)\n    - [rabin_karp](algorithms/strings/rabin_karp.py)\n    - [reverse_string](algorithms/strings/reverse_string.py)\n    - [reverse_vowel](algorithms/strings/reverse_vowel.py)\n    - [reverse_words](algorithms/strings/reverse_words.py)\n    - [roman_to_int](algorithms/strings/roman_to_int.py)\n    - [word_squares](algorithms/strings/word_squares.py)\n    - [unique_morse](algorithms/strings/unique_morse.py)\n    - [judge_circle](algorithms/strings/judge_circle.py)\n    - [strong_password](algorithms/strings/strong_password.py)\n    - [caesar_cipher](algorithms/strings/caesar_cipher.py)\n    - [check_pangram](algorithms/strings/check_pangram.py)\n    - [contain_string](algorithms/strings/contain_string.py)\n    - [count_binary_substring](algorithms/strings/count_binary_substring.py)\n    - [repeat_string](algorithms/strings/repeat_string.py)\n    - [min_distance](algorithms/strings/min_distance.py)\n    - [longest_common_prefix](algorithms/strings/longest_common_prefix.py)\n    - [rotate](algorithms/strings/rotate.py)\n    - [first_unique_char](algorithms/strings/first_unique_char.py)\n    - [repeat_substring](algorithms/strings/repeat_substring.py)\n\t  - [atbash_cipher](algorithms/strings/atbash_cipher.py)\n    - [longest_palindromic_substring](algorithms/strings/longest_palindromic_substring.py)\n  \t- [knuth_morris_pratt](algorithms/strings/knuth_morris_pratt.py)\n    - [panagram](algorithms/strings/panagram.py)\n- [tree](algorithms/tree)\n    - [bst](algorithms/tree/bst)\n        - [array_to_bst](algorithms/tree/bst/array_to_bst.py)\n        - [bst_closest_value](algorithms/tree/bst/bst_closest_value.py)\n        - [BSTIterator](algorithms/tree/bst/BSTIterator.py)\n        - [delete_node](algorithms/tree/bst/delete_node.py)\n        - [is_bst](algorithms/tree/bst/is_bst.py)\n        - [kth_smallest](algorithms/tree/bst/kth_smallest.py)\n        - [lowest_common_ancestor](algorithms/tree/bst/lowest_common_ancestor.py)\n        - [predecessor](algorithms/tree/bst/predecessor.py)\n        - [serialize_deserialize](algorithms/tree/bst/serialize_deserialize.py)\n        - [successor](algorithms/tree/bst/successor.py)\n        - [unique_bst](algorithms/tree/bst/unique_bst.py)\n        - [depth_sum](algorithms/tree/bst/depth_sum.py)\n        - [count_left_node](algorithms/tree/bst/count_left_node.py)\n        - [num_empty](algorithms/tree/bst/num_empty.py)\n        - [height](algorithms/tree/bst/height.py)\n\t- [fenwick_tree](algorithms/tree/fenwick_tree/fenwick_tree.py)\n    - [red_black_tree](algorithms/tree/red_black_tree)\n        - [red_black_tree](algorithms/tree/red_black_tree/red_black_tree.py)\n    - [segment_tree](algorithms/tree/segment_tree)\n        - [segment_tree](algorithms/tree/segment_tree/segment_tree.py)\n        - [iterative_segment_tree](algorithms/tree/segment_tree/iterative_segment_tree.py)\n    - [traversal](algorithms/tree/traversal)\n        - [inorder](algorithms/tree/traversal/inorder.py)\n        - [level_order](algorithms/tree/traversal/level_order.py)\n        - [postorder](algorithms/tree/traversal/postorder.py)\n        - [preorder](algorithms/tree/traversal/preorder.py)\n        - [zigzag](algorithms/tree/traversal/zigzag.py)\n    - [trie](algorithms/tree/trie)\n        - [add_and_search](algorithms/tree/trie/add_and_search.py)\n        - [trie](algorithms/tree/trie/trie.py)\n    - [b_tree](algorithms/tree/b_tree.py)\n    - [binary_tree_paths](algorithms/tree/binary_tree_paths.py)\n    - [bin_tree_to_list](algorithms/tree/bin_tree_to_list.py)\n    - [construct_tree_preorder_postorder](algorithms/tree/construct_tree_postorder_preorder.py)\n    - [deepest_left](algorithms/tree/deepest_left.py)\n    - [invert_tree](algorithms/tree/invert_tree.py)\n    - [is_balanced](algorithms/tree/is_balanced.py)\n    - [is_subtree](algorithms/tree/is_subtree.py)\n    - [is_symmetric](algorithms/tree/is_symmetric.py)\n    - [longest_consecutive](algorithms/tree/longest_consecutive.py)\n    - [lowest_common_ancestor](algorithms/tree/lowest_common_ancestor.py)\n    - [max_height](algorithms/tree/max_height.py)\n    - [max_path_sum](algorithms/tree/max_path_sum.py)\n    - [min_height](algorithms/tree/min_height.py)\n    - [path_sum](algorithms/tree/path_sum.py)\n    - [path_sum2](algorithms/tree/path_sum2.py)\n    - [pretty_print](algorithms/tree/pretty_print.py)\n    - [same_tree](algorithms/tree/same_tree.py)\n    - [tree](algorithms/tree/tree.py)\n- [unix](algorithms/unix)\n    - [path](algorithms/unix/path/)\n        - [join_with_slash](algorithms/unix/path/join_with_slash.py)\n        - [full_path](algorithms/unix/path/full_path.py)\n        - [split](algorithms/unix/path/split.py)\n        - [simplify_path](algorithms/unix/path/simplify_path.py)\n- [unionfind](algorithms/unionfind)\n    - [count_islands](algorithms/unionfind/count_islands.py)\n\n\n## Contributors\n\nThanks to [all the contributors](https://github.com/keon/algorithms/graphs/contributors)\nwho helped in building the repo.\n"}}