{"output/keon/algorithms/algorithms": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/setup.py", "fileNameBase": "setup", "extension": "py"}, "dependencies": [{"import": "io", "type": "external", "type_element": "module"}, {"from_module": "setuptools", "import": "find_packages", "type": "external", "type_element": "module"}, {"from_module": "setuptools", "import": "setup", "type": "external", "type_element": "module"}], "functions": {"long_description": {"returns": ["readme"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 9}, "calls": ["io.open", "f.read"], "store_vars_calls": {"readme": "f.read"}, "source_code": "def long_description():\n    with io.open('README.md', 'r', encoding='utf-8') as f:\n        readme = f.read()\n    return readme"}}, "body": {"calls": ["setuptools.setup", "setup.long_description", "setuptools.find_packages"], "source_code": ["setup(name='algorithms', version='0.1.4', description='Pythonic Data Structures and Algorithms', long_description=long_description(), long_description_content_type='text/markdown', url='https://github.com/keon/algorithms', author='Algorithms Team & Contributors', author_email='kwk236@gmail.com', license='MIT', packages=find_packages(exclude=('tests', 'tests.*')), classifiers=['Programming Language :: Python :: 3', 'Programming Language :: Python :: 3.4', 'Programming Language :: Python :: 3.5', 'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: 3.7'], zip_safe=False)", "long_description()", "find_packages(exclude=('tests', 'tests.*'))"]}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/streaming": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/streaming/misra_gries.py", "fileNameBase": "misra_gries", "extension": "py", "doc": {"long_description": "Given a list of items and a value k, it returns the every item in the list\nthat appears at least n/k times, where n is the length of the array\n\nBy default, k is set to 2, solving the majority problem.\n\nFor the majority problem, this algorithm only guarantees that if there is\nan element that appears more than n/2 times, it will be outputed. If there\nis no such element, any arbitrary element is returned by the algorithm.\nTherefore, we need to iterate through again at the end. But since we have filtred\nout the suspects, the memory complexity is significantly lower than\nit would be to create counter for every element in the list.\n\nFor example:\nInput misras_gries([1,4,4,4,5,4,4])\nOutput {'4':5}\nInput misras_gries([0,0,0,1,1,1,1])\nOutput {'1':4}\nInput misras_gries([0,0,0,0,1,1,1,2,2],3)\nOutput {'0':4,'1':3}\nInput misras_gries([0,0,0,1,1,1]\nOutput None", "short_description": "Implementation of the Misra-Gries algorithm.", "full": "Implementation of the Misra-Gries algorithm.\nGiven a list of items and a value k, it returns the every item in the list\nthat appears at least n/k times, where n is the length of the array\n\nBy default, k is set to 2, solving the majority problem.\n\nFor the majority problem, this algorithm only guarantees that if there is\nan element that appears more than n/2 times, it will be outputed. If there\nis no such element, any arbitrary element is returned by the algorithm.\nTherefore, we need to iterate through again at the end. But since we have filtred\nout the suspects, the memory complexity is significantly lower than\nit would be to create counter for every element in the list.\n\nFor example:\nInput misras_gries([1,4,4,4,5,4,4])\nOutput {'4':5}\nInput misras_gries([0,0,0,1,1,1,1])\nOutput {'1':4}\nInput misras_gries([0,0,0,0,1,1,1,2,2],3)\nOutput {'0':4,'1':3}\nInput misras_gries([0,0,0,1,1,1]\nOutput None"}}, "functions": {"misras_gries": {"doc": {"long_description": "Keyword arguments:\narray -- list of integers\nk -- value of k (default 2)", "short_description": "Misra-Gries algorithm"}, "args": ["array", "k"], "returns": ["frequencies if len(frequencies) > 0 else None"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 57}, "calls": ["keys.keys", "str", "misra_gries._count_frequency", "int", "len", "list"], "store_vars_calls": {"suspects": "keys.keys", "val": "str", "freq": "_count_frequency"}, "source_code": "def misras_gries(array, k=2):\n    \"\"\"Misra-Gries algorithm\n\n    Keyword arguments:\n    array -- list of integers\n    k -- value of k (default 2)\n    \"\"\"\n    keys = {}\n    for i in array:\n        val = str(i)\n        if val in keys:\n            keys[val] = keys[val] + 1\n        elif len(keys) < k - 1:\n            keys[val] = 1\n        else:\n            for key in list(keys):\n                keys[key] = keys[key] - 1\n                if keys[key] == 0:\n                    del keys[key]\n    suspects = keys.keys()\n    frequencies = {}\n    for suspect in suspects:\n        freq = _count_frequency(array, int(suspect))\n        if freq >= len(array) / k:\n            frequencies[suspect] = freq\n    return frequencies if len(frequencies) > 0 else None"}, "_count_frequency": {"args": ["array", "element"], "returns": ["array.count(element)"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 61}, "calls": ["array.count"], "source_code": "def _count_frequency(array, element):\n    return array.count(element)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/streaming/one_sparse_recovery.py", "fileNameBase": "one_sparse_recovery", "extension": "py", "doc": {"long_description": "This algorithm assumes we have a non negative dynamic stream.\n\nGiven a stream of tuples, where each tuple contains a number and a sign (+/-), it check if the\nstream is 1-sparse, meaning if the elements in the stream cancel eacheother out in such\na way that ther is only a unique number at the end.\n\nExamples:\n#1\nInput:  [(4,'+'), (2,'+'),(2,'-'),(4,'+'),(3,'+'),(3,'-')],\nOutput: 4\nComment: Since 2 and 3 gets removed.\n#2\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+')]\nOutput: 2\nComment: No other numbers present\n#3\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(1,'+')]\nOutput: None\nComment: Not 1-sparse", "short_description": "Non-negative 1-sparse recovery problem.", "full": "Non-negative 1-sparse recovery problem.\nThis algorithm assumes we have a non negative dynamic stream.\n\nGiven a stream of tuples, where each tuple contains a number and a sign (+/-), it check if the\nstream is 1-sparse, meaning if the elements in the stream cancel eacheother out in such\na way that ther is only a unique number at the end.\n\nExamples:\n#1\nInput:  [(4,'+'), (2,'+'),(2,'-'),(4,'+'),(3,'+'),(3,'-')],\nOutput: 4\nComment: Since 2 and 3 gets removed.\n#2\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+')]\nOutput: 2\nComment: No other numbers present\n#3\nInput:  [(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(2,'+'),(1,'+')]\nOutput: None\nComment: Not 1-sparse"}}, "functions": {"one_sparse": {"doc": {"long_description": "Keyword arguments:\narray -- stream of tuples", "short_description": "1-sparse algorithm"}, "args": ["array"], "returns": ["int(sum_values / sum_signs)", "None"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 47}, "calls": ["one_sparse_recovery._get_bit_sum", "one_sparse_recovery._check_every_number_in_bitsum", "int"], "source_code": "def one_sparse(array):\n    \"\"\"1-sparse algorithm\n\n    Keyword arguments:\n    array -- stream of tuples\n    \"\"\"\n    sum_signs = 0\n    bitsum = [0] * 32\n    sum_values = 0\n    for (val, sign) in array:\n        if sign == '+':\n            sum_signs += 1\n            sum_values += val\n        else:\n            sum_signs -= 1\n            sum_values -= val\n        _get_bit_sum(bitsum, val, sign)\n    if sum_signs > 0 and _check_every_number_in_bitsum(bitsum, sum_signs):\n        return int(sum_values / sum_signs)\n    else:\n        return None"}, "_check_every_number_in_bitsum": {"args": ["bitsum", "sum_signs"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 55}, "source_code": "def _check_every_number_in_bitsum(bitsum, sum_signs):\n    for val in bitsum:\n        if val != 0 and val != sum_signs:\n            return False\n    return True"}, "_get_bit_sum": {"args": ["bitsum", "val", "sign"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 69}, "source_code": "def _get_bit_sum(bitsum, val, sign):\n    i = 0\n    if sign == '+':\n        while val:\n            bitsum[i] += val & 1\n            i += 1\n            val >>= 1\n    else:\n        while val:\n            bitsum[i] -= val & 1\n            i += 1\n            val >>= 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/streaming/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "one_sparse_recovery", "import": "one_sparse", "type": "internal", "type_element": "function"}, {"from_module": "one_sparse_recovery", "import": "_check_every_number_in_bitsum", "type": "internal", "type_element": "function"}, {"from_module": "one_sparse_recovery", "import": "_get_bit_sum", "type": "internal", "type_element": "function"}, {"from_module": "misra_gries", "import": "misras_gries", "type": "internal", "type_element": "function"}, {"from_module": "misra_gries", "import": "_count_frequency", "type": "internal", "type_element": "function"}], "is_test": false}], "output/keon/algorithms/algorithms/algorithms/map": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/map/word_pattern.py", "fileNameBase": "word_pattern", "extension": "py", "doc": {"long_description": "Here follow means a full match, such that there is a bijection between a\nletter in pattern and a non-empty word in str.\n\nExample 1:\nInput: pattern = \"abba\", str = \"dog cat cat dog\"\nOutput: true\n\nExample 2:\nInput:pattern = \"abba\", str = \"dog cat cat fish\"\nOutput: false\n\nExample 3:\nInput: pattern = \"aaaa\", str = \"dog cat cat dog\"\nOutput: false\n\nExample 4:\nInput: pattern = \"abba\", str = \"dog dog dog dog\"\nOutput: false\nNotes:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\nReference: https://leetcode.com/problems/word-pattern/description/", "short_description": "Given a pattern and a string str, find if str follows the same pattern.", "full": "Given a pattern and a string str, find if str follows the same pattern.\nHere follow means a full match, such that there is a bijection between a\nletter in pattern and a non-empty word in str.\n\nExample 1:\nInput: pattern = \"abba\", str = \"dog cat cat dog\"\nOutput: true\n\nExample 2:\nInput:pattern = \"abba\", str = \"dog cat cat fish\"\nOutput: false\n\nExample 3:\nInput: pattern = \"aaaa\", str = \"dog cat cat dog\"\nOutput: false\n\nExample 4:\nInput: pattern = \"abba\", str = \"dog dog dog dog\"\nOutput: false\nNotes:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\nReference: https://leetcode.com/problems/word-pattern/description/"}}, "functions": {"word_pattern": {"args": ["pattern", "str"], "returns": ["True", "False", "False", "False"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 41}, "calls": ["set", "str.split", "range", "len", "set.add"], "store_vars_calls": {"set_value": "set", "list_str": "str.split"}, "source_code": "def word_pattern(pattern, str):\n    dict = {}\n    set_value = set()\n    list_str = str.split()\n    if len(list_str) != len(pattern):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] not in dict:\n            if list_str[i] in set_value:\n                return False\n            dict[pattern[i]] = list_str[i]\n            set_value.add(list_str[i])\n        elif dict[pattern[i]] != list_str[i]:\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/map/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "hashtable", "import": "HashTable", "type": "internal", "type_element": "class"}, {"from_module": "hashtable", "import": "ResizableHashTable", "type": "internal", "type_element": "class"}, {"from_module": "separate_chaining_hashtable", "import": "Node", "type": "internal", "type_element": "class"}, {"from_module": "separate_chaining_hashtable", "import": "SeparateChainingHashTable", "type": "internal", "type_element": "class"}, {"from_module": "word_pattern", "import": "word_pattern", "type": "internal", "type_element": "function"}, {"from_module": "is_isomorphic", "import": "is_isomorphic", "type": "internal", "type_element": "function"}, {"from_module": "is_anagram", "import": "is_anagram", "type": "internal", "type_element": "function"}, {"from_module": "longest_palindromic_subsequence", "import": "longest_palindromic_subsequence", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/map/randomized_set.py", "fileNameBase": "randomized_set", "extension": "py", "doc": {"long_description": "in average O(1) time.\n\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\ngetRandom: Returns a random element from current set of elements.\nEach element must have the same probability of being returned.", "short_description": "Design a data structure that supports all following operations", "full": "Design a data structure that supports all following operations\nin average O(1) time.\n\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\ngetRandom: Returns a random element from current set of elements.\nEach element must have the same probability of being returned."}}, "dependencies": [{"import": "random", "type": "external", "type_element": "module"}], "classes": {"RandomizedSet": {"min_max_lineno": {"min_lineno": 15, "max_lineno": 39}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 19}, "source_code": "def __init__(self):\n    self.nums = []\n    self.idxs = {}"}, "insert": {"args": ["self", "val"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 26}, "calls": ["randomized_set.RandomizedSet.nums.append", "len"], "source_code": "def insert(self, val):\n    if val not in self.idxs:\n        self.nums.append(val)\n        self.idxs[val] = len(self.nums) - 1\n        return True\n    return False"}, "remove": {"args": ["self", "val"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 35}, "calls": ["randomized_set.RandomizedSet.nums.pop", "randomized_set.RandomizedSet.idxs.pop"], "source_code": "def remove(self, val):\n    if val in self.idxs:\n        (idx, last) = (self.idxs[val], self.nums[-1])\n        (self.nums[idx], self.idxs[last]) = (last, idx)\n        self.nums.pop()\n        self.idxs.pop(val, 0)\n        return True\n    return False"}, "get_random": {"args": ["self"], "returns": ["self.nums[idx]"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 39}, "calls": ["random.randint", "len"], "store_vars_calls": {"idx": "random.randint"}, "source_code": "def get_random(self):\n    idx = random.randint(0, len(self.nums) - 1)\n    return self.nums[idx]"}}}}, "body": {"calls": ["print", "randomized_set.RandomizedSet.insert", "randomized_set.RandomizedSet.remove", "randomized_set.RandomizedSet.get_random"], "store_vars_calls": {"rs": "RandomizedSet"}, "source_code": ["RandomizedSet()", "print('insert 1: ', rs.insert(1))", "rs.insert(1)", "print('insert 2: ', rs.insert(2))", "rs.insert(2)", "print('insert 3: ', rs.insert(3))", "rs.insert(3)", "print('insert 4: ', rs.insert(4))", "rs.insert(4)", "print('remove 3: ', rs.remove(3))", "rs.remove(3)", "print('remove 3: ', rs.remove(3))", "rs.remove(3)", "print('remove 1: ', rs.remove(1))", "rs.remove(1)", "print('random: ', rs.get_random())", "rs.get_random()", "print('random: ', rs.get_random())", "rs.get_random()", "print('random: ', rs.get_random())", "rs.get_random()", "print('random: ', rs.get_random())", "rs.get_random()"]}, "main_info": {"main_flag": 1, "main_function": "randomized_set.RandomizedSet", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/map/longest_palindromic_subsequence.py", "fileNameBase": "longest_palindromic_subsequence", "extension": "py"}, "functions": {"longest_palindromic_subsequence": {"args": ["s"], "returns": ["logestLen"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 30}, "calls": ["len", "range"], "store_vars_calls": {"k": "len"}, "source_code": "def longest_palindromic_subsequence(s):\n    k = len(s)\n    olist = [0] * k\n    nList = [0] * k\n    logestSubStr = ''\n    logestLen = 0\n    for j in range(0, k):\n        for i in range(0, j + 1):\n            if j - i <= 1:\n                if s[i] == s[j]:\n                    nList[i] = 1\n                    len_t = j - i + 1\n                    if logestLen < len_t:\n                        logestSubStr = s[i:j + 1]\n                        logestLen = len_t\n            elif s[i] == s[j] and olist[i + 1]:\n                nList[i] = 1\n                len_t = j - i + 1\n                if logestLen < len_t:\n                    logestSubStr = s[i:j + 1]\n                    logestLen = len_t\n        olist = nList\n        nList = [0] * k\n    return logestLen"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/map/longest_common_subsequence.py", "fileNameBase": "longest_common_subsequence", "extension": "py", "doc": {"long_description": "find the longest common sub sequence's length.\n\nExpected complexity O(n logn).", "short_description": "Given string a and b, with b containing all distinct characters,", "full": "Given string a and b, with b containing all distinct characters,\nfind the longest common sub sequence's length.\n\nExpected complexity O(n logn)."}}, "functions": {"max_common_sub_string": {"args": ["s1", "s2"], "returns": ["subs"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 29}, "calls": ["len", "range"], "source_code": "def max_common_sub_string(s1, s2):\n    s2dic = {s2[i]: i for i in range(len(s2))}\n    maxr = 0\n    subs = ''\n    i = 0\n    while i < len(s1):\n        if s1[i] in s2dic:\n            j = s2dic[s1[i]]\n            k = i\n            while j < len(s2) and k < len(s1) and (s1[k] == s2[j]):\n                k += 1\n                j += 1\n            if k - i > maxr:\n                maxr = k - i\n                subs = s1[i:k]\n            i = k\n        else:\n            i += 1\n    return subs"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/map/is_anagram.py", "fileNameBase": "is_anagram", "extension": "py", "doc": {"long_description": "Example 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nNote:\nYou may assume the string contains only lowercase alphabets.\n\nReference: https://leetcode.com/problems/valid-anagram/description/", "short_description": "Given two strings s and t , write a function to determine if t is an anagram of s.", "full": "Given two strings s and t , write a function to determine if t is an anagram of s.\n\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nNote:\nYou may assume the string contains only lowercase alphabets.\n\nReference: https://leetcode.com/problems/valid-anagram/description/"}}, "functions": {"is_anagram": {"args": ["s", "t"], "returns": ["maps == mapt"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 30}, "calls": ["maps.get", "mapt.get"], "source_code": "def is_anagram(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    maps = {}\n    mapt = {}\n    for i in s:\n        maps[i] = maps.get(i, 0) + 1\n    for i in t:\n        mapt[i] = mapt.get(i, 0) + 1\n    return maps == mapt"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/map/is_isomorphic.py", "fileNameBase": "is_isomorphic", "extension": "py", "doc": {"long_description": "Two strings are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while\npreserving the order of characters. No two characters may map to the same\ncharacter but a character may map to itself.\n\nExample 1:\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\nExample 2:\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\nInput: s = \"paper\", t = \"title\"\nOutput: true\nReference: https://leetcode.com/problems/isomorphic-strings/description/", "short_description": "Given two strings s and t, determine if they are isomorphic.", "full": "Given two strings s and t, determine if they are isomorphic.\nTwo strings are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while\npreserving the order of characters. No two characters may map to the same\ncharacter but a character may map to itself.\n\nExample 1:\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\nExample 2:\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\nInput: s = \"paper\", t = \"title\"\nOutput: true\nReference: https://leetcode.com/problems/isomorphic-strings/description/"}}, "functions": {"is_isomorphic": {"args": ["s", "t"], "returns": ["True", "False", "False", "False"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 41}, "calls": ["set", "range", "len", "set.add"], "store_vars_calls": {"set_value": "set"}, "source_code": "def is_isomorphic(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    dict = {}\n    set_value = set()\n    for i in range(len(s)):\n        if s[i] not in dict:\n            if t[i] in set_value:\n                return False\n            dict[s[i]] = t[i]\n            set_value.add(t[i])\n        elif dict[s[i]] != t[i]:\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/map/valid_sudoku.py", "fileNameBase": "valid_sudoku", "extension": "py", "doc": {"long_description": "The Sudoku board could be partially filled, where empty cells are filled with\nthe character '.'.", "short_description": "Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.", "full": "Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\n\nThe Sudoku board could be partially filled, where empty cells are filled with\nthe character '.'."}}, "functions": {"is_valid_sudoku": {"args": ["self", "board"], "returns": ["len(seen) == len(set(seen))"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 15}, "calls": ["enumerate", "len", "set"], "source_code": "def is_valid_sudoku(self, board):\n    seen = []\n    for (i, row) in enumerate(board):\n        for (j, c) in enumerate(row):\n            if c != '.':\n                seen += [(c, j), (i, c), (i / 3, j / 3, c)]\n    return len(seen) == len(set(seen))"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/stack": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/valid_parenthesis.py", "fileNameBase": "valid_parenthesis", "extension": "py", "doc": {"long_description": "'(', ')', '{', '}', '[' and ']',\ndetermine if the input string is valid.\n\nThe brackets must close in the correct order,\n\"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.", "short_description": "Given a string containing just the characters", "full": "Given a string containing just the characters\n'(', ')', '{', '}', '[' and ']',\ndetermine if the input string is valid.\n\nThe brackets must close in the correct order,\n\"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not."}}, "functions": {"is_valid": {"args": ["s"], "annotated_arg_types": {"s": "str"}, "annotated_return_type": "bool", "returns": ["not stack", "False"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 23}, "calls": ["dic.values", "stack.append", "stack.pop"], "source_code": "def is_valid(s: str) -> bool:\n    stack = []\n    dic = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in dic.values():\n            stack.append(char)\n        elif char in dic:\n            if not stack or dic[char] != stack.pop():\n                return False\n    return not stack"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/longest_abs_path.py", "fileNameBase": "longest_abs_path", "extension": "py"}, "functions": {"length_longest_path": {"args": ["input"], "returns": ["max_len"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 59}, "calls": ["input.split", "print", "s.count", "stack.append", "len", "stack.pop", "max", "s.strip"], "store_vars_calls": {"depth": "s.count", "max_len": "max"}, "source_code": "def length_longest_path(input):\n    \"\"\"\n    :type input: str\n    :rtype: int\n    \"\"\"\n    (curr_len, max_len) = (0, 0)\n    stack = []\n    for s in input.split('\\n'):\n        print('---------')\n        print('<path>:', s)\n        depth = s.count('\\t')\n        print('depth: ', depth)\n        print('stack: ', stack)\n        print('curlen: ', curr_len)\n        while len(stack) > depth:\n            curr_len -= stack.pop()\n        stack.append(len(s.strip('\\t')) + 1)\n        curr_len += stack[-1]\n        print('stack: ', stack)\n        print('curlen: ', curr_len)\n        if '.' in s:\n            max_len = max(max_len, curr_len - 1)\n    return max_len"}}, "body": {"calls": ["print", "longest_abs_path.length_longest_path"], "source_code": ["print('path:', st2)", "print('answer:', length_longest_path(st2))", "length_longest_path(st2)"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/remove_min.py", "fileNameBase": "remove_min", "extension": "py", "doc": {"long_description": "and removes the smallest value from the stack.\n\nFor example:\nbottom [2, 8, 3, -6, 7, 3] top\nAfter remove_min(stack):\nbottom [2, 8, 3, 7, 3] top", "short_description": "Given a stack, a function remove_min accepts a stack as a parameter", "full": "Given a stack, a function remove_min accepts a stack as a parameter\nand removes the smallest value from the stack.\n\nFor example:\nbottom [2, 8, 3, -6, 7, 3] top\nAfter remove_min(stack):\nbottom [2, 8, 3, 7, 3] top"}}, "functions": {"remove_min": {"args": ["stack"], "returns": ["stack", "stack"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 31}, "calls": ["stack.pop", "stack.append", "range", "len", "storage_stack.append", "storage_stack.pop"], "store_vars_calls": {"min": "stack.pop", "val": "storage_stack.pop"}, "source_code": "def remove_min(stack):\n    storage_stack = []\n    if len(stack) == 0:\n        return stack\n    min = stack.pop()\n    stack.append(min)\n    for i in range(len(stack)):\n        val = stack.pop()\n        if val <= min:\n            min = val\n        storage_stack.append(val)\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        if val != min:\n            stack.append(val)\n    return stack"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/stutter.py", "fileNameBase": "stutter", "extension": "py", "doc": {"long_description": "in the stack with two occurrences of that value.\n\nFor example, suppose the stack stores these values:\nbottom [3, 7, 1, 14, 9] top\nThen the stack should store these values after the method terminates:\nbottom [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] top\n\nNote: There are 2 solutions:\nfirst_stutter: it uses a single stack as auxiliary storage\nsecond_stutter: it uses a single queue as auxiliary storage", "short_description": "Given a stack, stutter takes a stack as a parameter and  replaces every value", "full": "Given a stack, stutter takes a stack as a parameter and  replaces every value\nin the stack with two occurrences of that value.\n\nFor example, suppose the stack stores these values:\nbottom [3, 7, 1, 14, 9] top\nThen the stack should store these values after the method terminates:\nbottom [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] top\n\nNote: There are 2 solutions:\nfirst_stutter: it uses a single stack as auxiliary storage\nsecond_stutter: it uses a single queue as auxiliary storage"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"first_stutter": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 27}, "calls": ["range", "len", "storage_stack.append", "storage_stack.pop", "stack.append", "stack.pop"], "store_vars_calls": {"val": "storage_stack.pop"}, "source_code": "def first_stutter(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        stack.append(val)\n        stack.append(val)\n    return stack"}, "second_stutter": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 47}, "calls": ["collections.deque", "range", "len", "collections.deque.append", "stack.append", "collections.deque.pop", "stack.pop"], "store_vars_calls": {"q": "collections.deque", "val": "q.pop"}, "source_code": "def second_stutter(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        val = q.pop()\n        stack.append(val)\n        stack.append(val)\n    return stack"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/simplify_path.py", "fileNameBase": "simplify_path", "extension": "py", "doc": {"long_description": "For example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\n* Did you consider the case where path = \"/../\"?\n    In this case, you should return \"/\".\n* Another corner case is the path might contain multiple slashes '/' together,\n    such as \"/home//foo/\". In this case, you should ignore redundant\n    slashes and return \"/home/foo\".", "short_description": "Given an absolute path for a file (Unix-style), simplify it.", "full": "Given an absolute path for a file (Unix-style), simplify it.\n\nFor example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\n* Did you consider the case where path = \"/../\"?\n    In this case, you should return \"/\".\n* Another corner case is the path might contain multiple slashes '/' together,\n    such as \"/home//foo/\". In this case, you should ignore redundant\n    slashes and return \"/home/foo\"."}}, "functions": {"simplify_path": {"args": ["path"], "returns": ["'/' + '/'.join(stack)"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 29}, "calls": ["path.split", "stack.pop", "stack.append"], "store_vars_calls": {"paths": "path.split"}, "source_code": "def simplify_path(path):\n    \"\"\"\n    :type path: str\n    :rtype: str\n    \"\"\"\n    skip = {'..', '.', ''}\n    stack = []\n    paths = path.split('/')\n    for tok in paths:\n        if tok == '..':\n            if stack:\n                stack.pop()\n        elif tok not in skip:\n            stack.append(tok)\n    return '/' + '/'.join(stack)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/is_consecutive.py", "fileNameBase": "is_consecutive", "extension": "py", "doc": {"long_description": "returns whether or not the stack contains a sequence of consecutive integers\nstarting from the bottom of the stack (returning true if it does, returning\nfalse if it does not).\n\nFor example:\nbottom [3, 4, 5, 6, 7] top\nThen the call of is_consecutive(s) should return true.\nbottom [3, 4, 6, 7] top\nThen the call of is_consecutive(s) should return false.\nbottom [3, 2, 1] top\nThe function should return false due to reverse order.\n\nNote: There are 2 solutions:\nfirst_is_consecutive: it uses a single stack as auxiliary storage\nsecond_is_consecutive: it uses a single queue as auxiliary storage", "short_description": "Given a stack, a function is_consecutive takes a stack as a parameter and that", "full": "Given a stack, a function is_consecutive takes a stack as a parameter and that\nreturns whether or not the stack contains a sequence of consecutive integers\nstarting from the bottom of the stack (returning true if it does, returning\nfalse if it does not).\n\nFor example:\nbottom [3, 4, 5, 6, 7] top\nThen the call of is_consecutive(s) should return true.\nbottom [3, 4, 6, 7] top\nThen the call of is_consecutive(s) should return false.\nbottom [3, 2, 1] top\nThe function should return false due to reverse order.\n\nNote: There are 2 solutions:\nfirst_is_consecutive: it uses a single stack as auxiliary storage\nsecond_is_consecutive: it uses a single queue as auxiliary storage"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"first_is_consecutive": {"args": ["stack"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 38}, "calls": ["range", "len", "stack.pop", "stack.append", "storage_stack.append", "storage_stack.pop"], "store_vars_calls": {"first_value": "stack.pop", "second_value": "stack.pop"}, "source_code": "def first_is_consecutive(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        storage_stack.append(first_value)\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True"}, "second_is_consecutive": {"args": ["stack"], "returns": ["True", "True", "False"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 61}, "calls": ["collections.deque", "range", "len", "stack.pop", "stack.append", "collections.deque.append", "collections.deque.pop"], "store_vars_calls": {"q": "collections.deque", "first_value": "stack.pop", "second_value": "stack.pop"}, "source_code": "def second_is_consecutive(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        q.append(first_value)\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/is_sorted.py", "fileNameBase": "is_sorted", "extension": "py", "doc": {"long_description": "true if the elements in the stack occur in ascending increasing order from\nbottom, and false otherwise. That is, the smallest element should be at bottom\n\nFor example:\nbottom [6, 3, 5, 1, 2, 4] top\nThe function should return false\nbottom [1, 2, 3, 4, 5, 6] top\nThe function should return true", "short_description": "Given a stack, a function is_sorted accepts a stack as a parameter and returns", "full": "Given a stack, a function is_sorted accepts a stack as a parameter and returns\ntrue if the elements in the stack occur in ascending increasing order from\nbottom, and false otherwise. That is, the smallest element should be at bottom\n\nFor example:\nbottom [6, 3, 5, 1, 2, 4] top\nThe function should return false\nbottom [1, 2, 3, 4, 5, 6] top\nThe function should return true"}}, "functions": {"is_sorted": {"args": ["stack"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 33}, "calls": ["range", "len", "stack.pop", "storage_stack.append", "stack.append", "storage_stack.pop"], "store_vars_calls": {"first_val": "stack.pop", "second_val": "stack.pop"}, "source_code": "def is_sorted(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        if len(stack) == 0:\n            break\n        first_val = stack.pop()\n        if len(stack) == 0:\n            break\n        second_val = stack.pop()\n        if first_val < second_val:\n            return False\n        storage_stack.append(first_val)\n        stack.append(second_val)\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/switch_pairs.py", "fileNameBase": "switch_pairs", "extension": "py", "doc": {"long_description": "switches successive pairs of numbers starting at the bottom of the stack.\n\nFor example, if the stack initially stores these values:\nbottom [3, 8, 17, 9, 1, 10] top\nYour function should switch the first pair (3, 8),\nthe second pair (17, 9), ...:\nbottom [8, 3, 9, 17, 10, 1] top\n\nif there are an odd number of values in the stack, the value at the top of the\nstack is not moved: For example:\nbottom [3, 8, 17, 9, 1] top\nIt would again switch pairs of values, but the value at the\ntop of the stack (1)\nwould not be moved\nbottom [8, 3, 9, 17, 1] top\n\nNote: There are 2 solutions:\nfirst_switch_pairs: it uses a single stack as auxiliary storage\nsecond_switch_pairs: it uses a single queue as auxiliary storage", "short_description": "Given a stack, switch_pairs function takes a stack as a parameter and that", "full": "Given a stack, switch_pairs function takes a stack as a parameter and that\nswitches successive pairs of numbers starting at the bottom of the stack.\n\nFor example, if the stack initially stores these values:\nbottom [3, 8, 17, 9, 1, 10] top\nYour function should switch the first pair (3, 8),\nthe second pair (17, 9), ...:\nbottom [8, 3, 9, 17, 10, 1] top\n\nif there are an odd number of values in the stack, the value at the top of the\nstack is not moved: For example:\nbottom [3, 8, 17, 9, 1] top\nIt would again switch pairs of values, but the value at the\ntop of the stack (1)\nwould not be moved\nbottom [8, 3, 9, 17, 1] top\n\nNote: There are 2 solutions:\nfirst_switch_pairs: it uses a single stack as auxiliary storage\nsecond_switch_pairs: it uses a single queue as auxiliary storage"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"first_switch_pairs": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 41}, "calls": ["range", "len", "storage_stack.append", "storage_stack.pop", "stack.append", "stack.pop"], "store_vars_calls": {"first": "storage_stack.pop", "second": "storage_stack.pop"}, "source_code": "def first_switch_pairs(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        if len(storage_stack) == 0:\n            break\n        first = storage_stack.pop()\n        if len(storage_stack) == 0:\n            stack.append(first)\n            break\n        second = storage_stack.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack"}, "second_switch_pairs": {"args": ["stack"], "returns": ["stack"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 67}, "calls": ["collections.deque", "range", "len", "collections.deque.append", "stack.append", "collections.deque.pop", "stack.pop"], "store_vars_calls": {"q": "collections.deque", "first": "q.pop", "second": "q.pop"}, "source_code": "def second_switch_pairs(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        if len(q) == 0:\n            break\n        first = q.pop()\n        if len(q) == 0:\n            stack.append(first)\n            break\n        second = q.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/ordered_stack.py", "fileNameBase": "ordered_stack", "extension": "py"}, "classes": {"OrderedStack": {"min_max_lineno": {"min_lineno": 5, "max_lineno": 37}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 8}, "source_code": "def __init__(self):\n    self.items = []"}, "is_empty": {"args": ["self"], "returns": ["self.items == []"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 11}, "source_code": "def is_empty(self):\n    return self.items == []"}, "push_t": {"args": ["self", "item"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 14}, "calls": ["ordered_stack.OrderedStack.items.append"], "source_code": "def push_t(self, item):\n    self.items.append(item)"}, "push": {"args": ["self", "item"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 26}, "calls": ["ordered_stack.OrderedStack.is_empty", "ordered_stack.OrderedStack.push_t", "ordered_stack.OrderedStack.peek", "ordered_stack.OrderedStack.push_t", "ordered_stack.OrderedStack.is_empty", "ordered_stack.OrderedStack.pop", "ordered_stack.OrderedStack.pop"], "store_vars_calls": {"temp_stack": "OrderedStack"}, "source_code": "def push(self, item):\n    temp_stack = OrderedStack()\n    if self.is_empty() or item > self.peek():\n        self.push_t(item)\n    else:\n        while item < self.peek() and (not self.is_empty()):\n            temp_stack.push_t(self.pop())\n        self.push_t(item)\n        while not temp_stack.is_empty():\n            self.push_t(temp_stack.pop())"}, "pop": {"args": ["self"], "returns": ["self.items.pop()"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 31}, "calls": ["ordered_stack.OrderedStack.is_empty", "ordered_stack.OrderedStack.items.pop", "IndexError"], "source_code": "def pop(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    return self.items.pop()"}, "peek": {"args": ["self"], "returns": ["self.items[len(self.items) - 1]"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 34}, "calls": ["len"], "source_code": "def peek(self):\n    return self.items[len(self.items) - 1]"}, "size": {"args": ["self"], "returns": ["len(self.items)"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 37}, "calls": ["len"], "source_code": "def size(self):\n    return len(self.items)"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/stack/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "stack", "import": "AbstractStack", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "ArrayStack", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "StackNode", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "LinkedListStack", "type": "internal", "type_element": "class"}, {"from_module": "is_consecutive", "import": "first_is_consecutive", "type": "internal", "type_element": "function"}, {"from_module": "is_consecutive", "import": "second_is_consecutive", "type": "internal", "type_element": "function"}, {"from_module": "is_sorted", "import": "is_sorted", "type": "internal", "type_element": "function"}, {"from_module": "remove_min", "import": "remove_min", "type": "internal", "type_element": "function"}, {"from_module": "stutter", "import": "first_stutter", "type": "internal", "type_element": "function"}, {"from_module": "stutter", "import": "second_stutter", "type": "internal", "type_element": "function"}, {"from_module": "switch_pairs", "import": "first_switch_pairs", "type": "internal", "type_element": "function"}, {"from_module": "switch_pairs", "import": "second_switch_pairs", "type": "internal", "type_element": "function"}, {"from_module": "valid_parenthesis", "import": "is_valid", "type": "internal", "type_element": "function"}, {"from_module": "simplify_path", "import": "simplify_path", "type": "internal", "type_element": "function"}, {"from_module": "stack", "import": "AbstractStack", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "ArrayStack", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "StackNode", "type": "internal", "type_element": "class"}, {"from_module": "stack", "import": "LinkedListStack", "type": "internal", "type_element": "class"}, {"from_module": "ordered_stack", "import": "OrderedStack", "type": "internal", "type_element": "class"}], "is_test": false}], "output/keon/algorithms/algorithms/algorithms/dfs": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dfs/all_factors.py", "fileNameBase": "all_factors", "extension": "py", "doc": {"long_description": "8 = 2 x 2 x 2;\n  = 2 x 4.\n\n\nWrite a function that takes an integer n and return all possible combinations\nof its factors.Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\nExamples:\ninput: 1\noutput:\n[]\n\n\ninput: 37\noutput:\n[]\n\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],", "short_description": "Numbers can be regarded as product of its factors. For example,", "full": "Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\n\nWrite a function that takes an integer n and return all possible combinations\nof its factors.Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\nExamples:\ninput: 1\noutput:\n[]\n\n\ninput: 37\noutput:\n[]\n\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],"}}, "functions": {"get_factors": {"args": ["n"], "returns": ["factor(n, 2, [], [])", "res"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 61}, "calls": ["all_factors.get_factors.factor"], "functions": {"factor": {"args": ["n", "i", "combi", "res"], "returns": ["res"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 60}, "calls": ["factor", "int"], "source_code": "def factor(n, i, combi, res):\n    \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res"}}, "source_code": "def get_factors(n):\n    \"\"\"[summary]\n    \n    Arguments:\n        n {[int]} -- [to analysed number]\n    \n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])"}, "get_factors_iterative1": {"args": ["n"], "returns": ["res"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 85}, "calls": ["todo.pop", "todo.append"], "source_code": "def get_factors_iterative1(n):\n    \"\"\"[summary]\n    Computes all factors of n.\n    Translated the function get_factors(...) in\n    a call-stack modell.\n\n    Arguments:\n        n {[int]} -- [to analysed number]\n    \n    Returns:\n        [list of lists] -- [all factors]\n    \"\"\"\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res"}, "get_factors_iterative2": {"args": ["n"], "returns": ["ans"], "min_max_lineno": {"min_lineno": 87, "max_lineno": 112}, "calls": ["ans.append", "stack.pop", "stack.append"], "store_vars_calls": {"x": "stack.pop"}, "source_code": "def get_factors_iterative2(n):\n    \"\"\"[summary]\n    analog as above\n\n    Arguments:\n        n {[int]} -- [description]\n    \n    Returns:\n        [list of lists] -- [all factors of n]\n    \"\"\"\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dfs/maze_search.py", "fileNameBase": "maze_search", "extension": "py", "doc": {"long_description": "only step on the columns whose value is 1\nif there is no path, it returns -1\n(The first column(top left column) is not included in the answer.)\n\nEx 1)\nIf maze is\n[[1,0,1,1,1,1],\n [1,0,1,0,1,0],\n [1,0,1,0,1,1],\n [1,1,1,0,1,1]],\nthe answer is: 14\n\nEx 2)\nIf maze is\n[[1,0,0],\n [0,1,1],\n [0,1,1]],\nthe answer is: -1", "short_description": "Find shortest path from top left column to the right lowest column using DFS.", "full": "Find shortest path from top left column to the right lowest column using DFS.\nonly step on the columns whose value is 1\nif there is no path, it returns -1\n(The first column(top left column) is not included in the answer.)\n\nEx 1)\nIf maze is\n[[1,0,1,1,1,1],\n [1,0,1,0,1,0],\n [1,0,1,0,1,1],\n [1,1,1,0,1,1]],\nthe answer is: 14\n\nEx 2)\nIf maze is\n[[1,0,0],\n [0,1,1],\n [0,1,1]],\nthe answer is: -1"}}, "functions": {"find_path": {"args": ["maze"], "returns": ["cnt"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 27}, "calls": ["maze_search.dfs"], "store_vars_calls": {"cnt": "dfs"}, "source_code": "def find_path(maze):\n    cnt = dfs(maze, 0, 0, 0, -1)\n    return cnt"}, "dfs": {"args": ["maze", "i", "j", "depth", "cnt"], "returns": ["cnt", "cnt"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 56}, "calls": ["len", "range", "maze_search.dfs"], "store_vars_calls": {"row": "len", "col": "len", "cnt": "dfs"}, "source_code": "def dfs(maze, i, j, depth, cnt):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    row = len(maze)\n    col = len(maze[0])\n    if i == row - 1 and j == col - 1:\n        if cnt == -1:\n            cnt = depth\n        elif cnt > depth:\n            cnt = depth\n        return cnt\n    maze[i][j] = 0\n    for k in range(len(directions)):\n        nx_i = i + directions[k][0]\n        nx_j = j + directions[k][1]\n        if nx_i >= 0 and nx_i < row and (nx_j >= 0) and (nx_j < col):\n            if maze[nx_i][nx_j] == 1:\n                cnt = dfs(maze, nx_i, nx_j, depth + 1, cnt)\n    maze[i][j] = 1\n    return cnt"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dfs/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "all_factors", "import": "get_factors", "type": "internal", "type_element": "function"}, {"from_module": "all_factors", "import": "get_factors_iterative1", "type": "internal", "type_element": "function"}, {"from_module": "all_factors", "import": "get_factors_iterative2", "type": "internal", "type_element": "function"}, {"from_module": "count_islands", "import": "num_islands", "type": "internal", "type_element": "function"}, {"from_module": "count_islands", "import": "dfs", "type": "internal", "type_element": "function"}, {"from_module": "pacific_atlantic", "import": "pacific_atlantic", "type": "internal", "type_element": "function"}, {"from_module": "pacific_atlantic", "import": "dfs", "type": "internal", "type_element": "function"}, {"from_module": "sudoku_solver", "import": "Sudoku", "type": "internal", "type_element": "class"}, {"from_module": "walls_and_gates", "import": "walls_and_gates", "type": "internal", "type_element": "function"}, {"from_module": "walls_and_gates", "import": "dfs", "type": "internal", "type_element": "function"}, {"from_module": "maze_search", "import": "find_path", "type": "internal", "type_element": "function"}, {"from_module": "maze_search", "import": "dfs", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dfs/sudoku_solver.py", "fileNameBase": "sudoku_solver", "extension": "py", "doc": {"long_description": "create a hash table (dictionary) val to store possible values in every location.\nEach time, start from the location with fewest possible values, choose one value\nfrom it and then update the board and possible values at other locations.\nIf this update is valid, keep solving (DFS). If this update is invalid (leaving\nzero possible values at some locations) or this value doesn't lead to the\nsolution, undo the updates and then choose the next value.\nSince we calculated val at the beginning and start filling the board from the\nlocation with fewest possible values, the amount of calculation and thus the\nruntime can be significantly reduced:\n\n\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest\npython solutions here.\n\n\nThe PossibleVals function may be further simplified/optimized, but it works just\nfine for now. (it would look less lengthy if we are allowed to use numpy array\nfor the board lol).", "short_description": "It's similar to how human solve Sudoku.", "full": "It's similar to how human solve Sudoku.\n\ncreate a hash table (dictionary) val to store possible values in every location.\nEach time, start from the location with fewest possible values, choose one value\nfrom it and then update the board and possible values at other locations.\nIf this update is valid, keep solving (DFS). If this update is invalid (leaving\nzero possible values at some locations) or this value doesn't lead to the\nsolution, undo the updates and then choose the next value.\nSince we calculated val at the beginning and start filling the board from the\nlocation with fewest possible values, the amount of calculation and thus the\nruntime can be significantly reduced:\n\n\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest\npython solutions here.\n\n\nThe PossibleVals function may be further simplified/optimized, but it works just\nfine for now. (it would look less lengthy if we are allowed to use numpy array\nfor the board lol)."}}, "classes": {"Sudoku": {"min_max_lineno": {"min_lineno": 23, "max_lineno": 96}, "methods": {"__init__": {"args": ["self", "board", "row", "col"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 29}, "calls": ["sudoku_solver.Sudoku.possible_values"], "store_vars_calls": {"self.val": "self.possible_values"}, "source_code": "def __init__(self, board, row, col):\n    self.board = board\n    self.row = row\n    self.col = col\n    self.val = self.possible_values()"}, "possible_values": {"args": ["self"], "returns": ["val"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 46}, "calls": ["range", "val.keys", "d.get"], "source_code": "def possible_values(self):\n    a = '123456789'\n    (d, val) = ({}, {})\n    for i in range(self.row):\n        for j in range(self.col):\n            ele = self.board[i][j]\n            if ele != '.':\n                d['r', i] = d.get(('r', i), []) + [ele]\n                d['c', j] = d.get(('c', j), []) + [ele]\n                d[i // 3, j // 3] = d.get((i // 3, j // 3), []) + [ele]\n            else:\n                val[i, j] = []\n    for (i, j) in val.keys():\n        inval = d.get(('r', i), []) + d.get(('c', j), []) + d.get((i / 3, j / 3), [])\n        val[i, j] = [n for n in a if n not in inval]\n    return val"}, "solve": {"args": ["self"], "returns": ["False", "True", "True"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 59}, "calls": ["min", "len", "sudoku_solver.Sudoku.val.keys", "sudoku_solver.Sudoku.valid_one", "sudoku_solver.Sudoku.undo", "sudoku_solver.Sudoku.solve"], "store_vars_calls": {"kee": "min"}, "source_code": "def solve(self):\n    if len(self.val) == 0:\n        return True\n    kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\n    nums = self.val[kee]\n    for n in nums:\n        update = {kee: self.val[kee]}\n        if self.valid_one(n, kee, update):\n            if self.solve():\n                return True\n        self.undo(kee, update)\n    return False"}, "valid_one": {"args": ["self", "n", "kee", "update"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 60, "max_lineno": 72}, "calls": ["sudoku_solver.Sudoku.val.keys", "sudoku_solver.Sudoku.val[].remove", "len"], "source_code": "def valid_one(self, n, kee, update):\n    self.board[kee[0]][kee[1]] = n\n    del self.val[kee]\n    (i, j) = kee\n    for ind in self.val.keys():\n        if n in self.val[ind]:\n            if ind[0] == i or ind[1] == j or (ind[0] / 3, ind[1] / 3) == (i / 3, j / 3):\n                update[ind] = n\n                self.val[ind].remove(n)\n                if len(self.val[ind]) == 0:\n                    return False\n    return True"}, "undo": {"args": ["self", "kee", "update"], "returns": ["None"], "min_max_lineno": {"min_lineno": 73, "max_lineno": 81}, "calls": ["sudoku_solver.Sudoku.val[].append"], "source_code": "def undo(self, kee, update):\n    self.board[kee[0]][kee[1]] = '.'\n    for k in update:\n        if k not in self.val:\n            self.val[k] = update[k]\n        else:\n            self.val[k].append(update[k])\n    return None"}, "__str__": {"doc": {"long_description": "Generates a board representation as string.", "short_description": "[summary]", "returns": {"description": "[str] -- [board representation]", "is_generator": false}}, "args": ["self"], "returns": ["resp"], "min_max_lineno": {"min_lineno": 82, "max_lineno": 96}, "calls": ["range"], "source_code": "def __str__(self):\n    \"\"\"[summary]\n        Generates a board representation as string.\n\n        Returns:\n            [str] -- [board representation]\n        \"\"\"\n    resp = ''\n    for i in range(self.row):\n        for j in range(self.col):\n            resp += ' {0} '.format(self.board[i][j])\n        resp += '\\n'\n    return resp"}}}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/dp": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/egg_drop.py", "fileNameBase": "egg_drop", "extension": "py", "doc": {"long_description": "from 1 to N. Each egg is identical in function, and if an egg breaks,\nyou cannot drop it again. You know that there exists a floor F with\n0 <= F <= N such that any egg dropped at a floor higher than F will\nbreak, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop\nit from any floor X (with 1 <= X <= N). Your goal is to know with\ncertainty what the value of F is. What is the minimum number of moves\nthat you need to know with certainty what F is, regardless of the\ninitial value of F?\n\nExample:\nInput: K = 1, N = 2\nOutput: 2\nExplanation:\nDrop the egg from floor 1.  If it breaks, we know with certainty that F = 0.\nOtherwise, drop the egg from floor 2.  If it breaks, we know with\ncertainty that F = 1.\nIf it didn't break, then we know with certainty F = 2.\nHence, we needed 2 moves in the worst case to know what F is with certainty.", "short_description": "You are given K eggs, and you have access to a building with N floors", "full": "You are given K eggs, and you have access to a building with N floors\nfrom 1 to N. Each egg is identical in function, and if an egg breaks,\nyou cannot drop it again. You know that there exists a floor F with\n0 <= F <= N such that any egg dropped at a floor higher than F will\nbreak, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop\nit from any floor X (with 1 <= X <= N). Your goal is to know with\ncertainty what the value of F is. What is the minimum number of moves\nthat you need to know with certainty what F is, regardless of the\ninitial value of F?\n\nExample:\nInput: K = 1, N = 2\nOutput: 2\nExplanation:\nDrop the egg from floor 1.  If it breaks, we know with certainty that F = 0.\nOtherwise, drop the egg from floor 2.  If it breaks, we know with\ncertainty that F = 1.\nIf it didn't break, then we know with certainty F = 2.\nHence, we needed 2 moves in the worst case to know what F is with certainty."}}, "functions": {"egg_drop": {"doc": {"long_description": "n -- number of floors\nk -- number of eggs", "short_description": "Keyword arguments:"}, "args": ["n", "k"], "returns": ["egg_floor[n][k]"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 59}, "calls": ["range", "max"], "source_code": "def egg_drop(n, k):\n    \"\"\"\n    Keyword arguments:\n    n -- number of floors\n    k -- number of eggs\n    \"\"\"\n    egg_floor = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        egg_floor[i][1] = 1\n        egg_floor[i][0] = 0\n    for j in range(1, k + 1):\n        egg_floor[1][j] = j\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            egg_floor[i][j] = INT_MAX\n            for x in range(1, j + 1):\n                res = 1 + max(egg_floor[i - 1][x - 1], egg_floor[i][j - x])\n                if res < egg_floor[i][j]:\n                    egg_floor[i][j] = res\n    return egg_floor[n][k]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/hosoya_triangle.py", "fileNameBase": "hosoya_triangle", "extension": "py", "doc": {"long_description": "of numbers, where if you take any number it is the sum of 2 numbers above.\nFirst line is always 1, and second line is always {1     1}.\n\nThis printHosoya function takes argument n which is the height of the triangle\n(number of lines).\n\nFor example:\nprintHosoya( 6 ) would return:\n1\n1 1\n2 1 2\n3 2 2 3\n5 3 4 3 5\n8 5 6 6 5 8\n\nThe complexity is O(n^3).", "short_description": "Hosoya triangle (originally Fibonacci triangle) is a triangular arrangement", "full": "Hosoya triangle (originally Fibonacci triangle) is a triangular arrangement\nof numbers, where if you take any number it is the sum of 2 numbers above.\nFirst line is always 1, and second line is always {1     1}.\n\nThis printHosoya function takes argument n which is the height of the triangle\n(number of lines).\n\nFor example:\nprintHosoya( 6 ) would return:\n1\n1 1\n2 1 2\n3 2 2 3\n5 3 4 3 5\n8 5 6 6 5 8\n\nThe complexity is O(n^3)."}}, "functions": {"hosoya": {"doc": {"long_description": "height -- height of the triangle", "short_description": "Calculates the hosoya triangle"}, "args": ["height", "width"], "returns": ["0", "1", "1", "hosoya(height - 1, width) + hosoya(height - 2, width)", "hosoya(height - 1, width - 1) + hosoya(height - 2, width - 2)"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 36}, "calls": ["hosoya_triangle.hosoya"], "source_code": "def hosoya(height, width):\n    \"\"\" Calculates the hosoya triangle\n\n    height -- height of the triangle\n    \"\"\"\n    if width == 0 and height in (0, 1):\n        return 1\n    if width == 1 and height in (1, 2):\n        return 1\n    if height > width:\n        return hosoya(height - 1, width) + hosoya(height - 2, width)\n    if width == height:\n        return hosoya(height - 1, width - 1) + hosoya(height - 2, width - 2)\n    return 0"}, "print_hosoya": {"doc": {"long_description": "height -- height of the triangle", "short_description": "Prints the hosoya triangle"}, "args": ["height"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 46}, "calls": ["range", "print", "hosoya_triangle.hosoya"], "source_code": "def print_hosoya(height):\n    \"\"\"Prints the hosoya triangle\n\n    height -- height of the triangle\n    \"\"\"\n    for i in range(height):\n        for j in range(i + 1):\n            print(hosoya(i, j), end=' ')\n        print('\\n', end='')"}, "hosoya_testing": {"doc": {"long_description": "height -- height of the triangle", "short_description": "Test hosoya function"}, "args": ["height"], "returns": ["res"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 57}, "calls": ["range", "res.append", "hosoya_triangle.hosoya"], "source_code": "def hosoya_testing(height):\n    \"\"\"Test hosoya function\n\n    height -- height of the triangle\n    \"\"\"\n    res = []\n    for i in range(height):\n        for j in range(i + 1):\n            res.append(hosoya(i, j))\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/edit_distance.py", "fileNameBase": "edit_distance", "extension": "py", "doc": {"long_description": "of letter insertions, letter deletions, and letter substitutions\nrequired to transform one word into another.\n\nFor example, the edit distance between FOOD and MONEY is at\nmost four:\n\nFOOD -> MOOD -> MOND -> MONED -> MONEY\n\nGiven two words A and B, find the minimum number of operations\nrequired to transform one string into the other.\nIn other words, find the edit distance between A and B.\n\nThought process:\n\nLet edit(i, j) denote the edit distance between\nthe prefixes A[1..i] and B[1..j].\n\nThen, the function satifies the following recurrence:\n\nedit(i, j) = i if j = 0\n             j if i = 0\n             min(edit(i-1, j) + 1,\n                 edit(i, j-1), + 1,\n                 edit(i-1, j-1) + cost) otherwise\n\nThere are two base cases, both of which occur when one string is empty\nand the other is not.\n1. To convert an empty string A into a string B of length n,\nperform n insertions.\n2. To convert a string A of length m into an empty string B,\nperform m deletions.\n\nHere, the cost is 1 if a substitution is required,\nor 0 if both chars in words A and B are the same at\nindexes i and j, respectively.\n\nTo find the edit distance between two words A and B,\nwe need to find edit(length_a, length_b).\n\nTime: O(length_a*length_b)\nSpace: O(length_a*length_b)", "short_description": "The edit distance between two words is the minimum number", "full": "The edit distance between two words is the minimum number\nof letter insertions, letter deletions, and letter substitutions\nrequired to transform one word into another.\n\nFor example, the edit distance between FOOD and MONEY is at\nmost four:\n\nFOOD -> MOOD -> MOND -> MONED -> MONEY\n\nGiven two words A and B, find the minimum number of operations\nrequired to transform one string into the other.\nIn other words, find the edit distance between A and B.\n\nThought process:\n\nLet edit(i, j) denote the edit distance between\nthe prefixes A[1..i] and B[1..j].\n\nThen, the function satifies the following recurrence:\n\nedit(i, j) = i if j = 0\n             j if i = 0\n             min(edit(i-1, j) + 1,\n                 edit(i, j-1), + 1,\n                 edit(i-1, j-1) + cost) otherwise\n\nThere are two base cases, both of which occur when one string is empty\nand the other is not.\n1. To convert an empty string A into a string B of length n,\nperform n insertions.\n2. To convert a string A of length m into an empty string B,\nperform m deletions.\n\nHere, the cost is 1 if a substitution is required,\nor 0 if both chars in words A and B are the same at\nindexes i and j, respectively.\n\nTo find the edit distance between two words A and B,\nwe need to find edit(length_a, length_b).\n\nTime: O(length_a*length_b)\nSpace: O(length_a*length_b)"}}, "functions": {"edit_distance": {"doc": {"long_description": "Kwyword arguments:\nword_a -- string\nword_b -- string", "short_description": "Finds edit distance between word_a and word_b"}, "args": ["word_a", "word_b"], "returns": ["edit[-1][-1]"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 70}, "calls": ["range", "len", "min"], "source_code": "def edit_distance(word_a, word_b):\n    \"\"\"Finds edit distance between word_a and word_b\n\n    Kwyword arguments:\n    word_a -- string\n    word_b -- string\n    \"\"\"\n    (length_a, length_b) = (len(word_a) + 1, len(word_b) + 1)\n    edit = [[0 for _ in range(length_b)] for _ in range(length_a)]\n    for i in range(1, length_a):\n        edit[i][0] = i\n    for j in range(1, length_b):\n        edit[0][j] = j\n    for i in range(1, length_a):\n        for j in range(1, length_b):\n            cost = 0 if word_a[i - 1] == word_b[j - 1] else 1\n            edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + cost)\n    return edit[-1][-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/word_break.py", "fileNameBase": "word_break", "extension": "py", "doc": {"long_description": "containing a list of non-empty words,\ndetermine if word can be segmented into a space-separated\nsequence of one or more dictionary words.\nYou may assume the dictionary does not contain duplicate words.\n\nFor example, given\nword = \"leetcode\",\ndict = [\"leet\", \"code\"].\n\nReturn true because \"leetcode\" can be segmented as \"leet code\".\n\nword = abc word_dict = [\"a\",\"bc\"]\nTrue False False False", "short_description": "Given a non-empty string s and a dictionary wordDict", "full": "Given a non-empty string s and a dictionary wordDict\ncontaining a list of non-empty words,\ndetermine if word can be segmented into a space-separated\nsequence of one or more dictionary words.\nYou may assume the dictionary does not contain duplicate words.\n\nFor example, given\nword = \"leetcode\",\ndict = [\"leet\", \"code\"].\n\nReturn true because \"leetcode\" can be segmented as \"leet code\".\n\nword = abc word_dict = [\"a\",\"bc\"]\nTrue False False False"}}, "functions": {"word_break": {"args": ["word", "word_dict"], "returns": ["dp_array[-1]"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 35}, "calls": ["range", "len"], "source_code": "def word_break(word, word_dict):\n    \"\"\"\n    :type word: str\n    :type word_dict: Set[str]\n    :rtype: bool\n    \"\"\"\n    dp_array = [False] * (len(word) + 1)\n    dp_array[0] = True\n    for i in range(1, len(word) + 1):\n        for j in range(0, i):\n            if dp_array[j] and word[j:i] in word_dict:\n                dp_array[i] = True\n                break\n    return dp_array[-1]"}}, "body": {"calls": ["print", "word_break.word_break"], "source_code": ["print(word_break(str, dic))", "word_break(str, dic)"]}, "main_info": {"main_flag": 1, "main_function": "word_break.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/rod_cut.py", "fileNameBase": "rod_cut", "extension": "py", "doc": {"short_description": "A Dynamic Programming solution for Rod cutting problem", "full": "A Dynamic Programming solution for Rod cutting problem"}}, "functions": {"cut_rod": {"doc": {"long_description": "price[] as prices of different pieces", "short_description": "Returns the best obtainable price for a rod of length n and"}, "args": ["price"], "returns": ["val[n]"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 23}, "calls": ["len", "range", "max"], "store_vars_calls": {"n": "len", "max_val": "max"}, "source_code": "def cut_rod(price):\n    \"\"\"\n    Returns the best obtainable price for a rod of length n and\n    price[] as prices of different pieces\n    \"\"\"\n    n = len(price)\n    val = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_val = INT_MIN\n        for j in range(i):\n            max_val = max(max_val, price[j] + val[i - j - 1])\n        val[i] = max_val\n    return val[n]"}}, "body": {"calls": ["print", "str", "rod_cut.cut_rod"], "source_code": ["print('Maximum Obtainable Value is ' + str(cut_rod(arr)))", "str(cut_rod(arr))", "cut_rod(arr)"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/climbing_stairs.py", "fileNameBase": "climbing_stairs", "extension": "py", "doc": {"long_description": "It takes `steps` number of steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps.\nIn how many distinct ways can you climb to the top?\n\nNote: Given argument `steps` will be a positive integer.", "short_description": "You are climbing a stair case.", "full": "You are climbing a stair case.\nIt takes `steps` number of steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps.\nIn how many distinct ways can you climb to the top?\n\nNote: Given argument `steps` will be a positive integer."}}, "functions": {"climb_stairs": {"args": ["steps"], "returns": ["arr[-1]"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 23}, "calls": ["range", "arr.append"], "source_code": "def climb_stairs(steps):\n    \"\"\"\n    :type steps: int\n    :rtype: int\n    \"\"\"\n    arr = [1, 1]\n    for _ in range(1, steps):\n        arr.append(arr[-1] + arr[-2])\n    return arr[-1]"}, "climb_stairs_optimized": {"args": ["steps"], "returns": ["a_steps"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 37}, "calls": ["range"], "source_code": "def climb_stairs_optimized(steps):\n    \"\"\"\n    :type steps: int\n    :rtype: int\n    \"\"\"\n    a_steps = b_steps = 1\n    for _ in range(steps):\n        (a_steps, b_steps) = (b_steps, a_steps + b_steps)\n    return a_steps"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/coin_change.py", "fileNameBase": "coin_change", "extension": "py", "doc": {"long_description": "Given a value `value`, if we want to make change for `value` cents, and we have infinite\nsupply of each of coins = {S1, S2, .. , Sm} valued `coins`, how many ways can we make the change?\nThe order of `coins` doesn't matter.\nFor example, for `value` = 4 and `coins` = [1, 2, 3], there are four solutions:\n[1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3].\nSo output should be 4.\n\nFor `value` = 10 and `coins` = [2, 5, 3, 6], there are five solutions:\n\n[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5] and [5, 5].\nSo the output should be 5.\n\nTime complexity: O(n * m) where n is the `value` and m is the number of `coins`\nSpace complexity: O(n)", "short_description": "Problem", "full": "Problem\nGiven a value `value`, if we want to make change for `value` cents, and we have infinite\nsupply of each of coins = {S1, S2, .. , Sm} valued `coins`, how many ways can we make the change?\nThe order of `coins` doesn't matter.\nFor example, for `value` = 4 and `coins` = [1, 2, 3], there are four solutions:\n[1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3].\nSo output should be 4.\n\nFor `value` = 10 and `coins` = [2, 5, 3, 6], there are five solutions:\n\n[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5] and [5, 5].\nSo the output should be 5.\n\nTime complexity: O(n * m) where n is the `value` and m is the number of `coins`\nSpace complexity: O(n)"}}, "functions": {"count": {"doc": {"long_description": "Keyword arguments:\ncoins -- int[]\nvalue -- int", "short_description": "Find number of combination of `coins` that adds upp to `value`"}, "args": ["coins", "value"], "returns": ["dp_array[value]"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 35}, "calls": ["range"], "source_code": "def count(coins, value):\n    \"\"\" Find number of combination of `coins` that adds upp to `value`\n\n    Keyword arguments:\n    coins -- int[]\n    value -- int\n    \"\"\"\n    dp_array = [1] + [0] * value\n    for coin in coins:\n        for i in range(coin, value + 1):\n            dp_array[i] += dp_array[i - coin]\n    return dp_array[value]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/k_factor.py", "fileNameBase": "k_factor", "extension": "py", "doc": {"long_description": "substring. Given two numbers `length` and `k_factor`, find the number of\nstrings of length `length` with 'K factor' = `k_factor`.\n\nThe algorithms is as follows:\n\ndp[length][k_factor] will be a 4 element array, wherein each element can be the\nnumber of strings of length `length` and 'K factor' = `k_factor` which belong\nto the criteria represented by that index:\n\n    - dp[length][k_factor][0] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'a'\n\n    - dp[length][k_factor][1] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'ab'\n\n    - dp[length][k_factor][2] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'abb'\n\n    - dp[length][k_factor][3] can be the number of strings of `length` and\n      K-factor = `k_factor` which end with anything other than the above\n      substrings (anything other than 'a' 'ab' 'abb')\n\nExample inputs\n\nlength=4 k_factor=1  no of strings = 1\nlength=7 k_factor=1 no of strings = 70302\nlength=10 k_factor=2 no of strings = 74357", "short_description": "The K factor of a string is defined as the number of times 'abba' appears as a", "full": "The K factor of a string is defined as the number of times 'abba' appears as a\nsubstring. Given two numbers `length` and `k_factor`, find the number of\nstrings of length `length` with 'K factor' = `k_factor`.\n\nThe algorithms is as follows:\n\ndp[length][k_factor] will be a 4 element array, wherein each element can be the\nnumber of strings of length `length` and 'K factor' = `k_factor` which belong\nto the criteria represented by that index:\n\n    - dp[length][k_factor][0] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'a'\n\n    - dp[length][k_factor][1] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'ab'\n\n    - dp[length][k_factor][2] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'abb'\n\n    - dp[length][k_factor][3] can be the number of strings of `length` and\n      K-factor = `k_factor` which end with anything other than the above\n      substrings (anything other than 'a' 'ab' 'abb')\n\nExample inputs\n\nlength=4 k_factor=1  no of strings = 1\nlength=7 k_factor=1 no of strings = 70302\nlength=10 k_factor=2 no of strings = 74357"}}, "functions": {"find_k_factor": {"doc": {"long_description": "Keyword arguments:\nlength -- integer\nk_factor -- integer", "short_description": "Find the number of strings of length `length` with K factor = `k_factor`."}, "args": ["length", "k_factor"], "returns": ["sum(mat[length][k_factor])", "0"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 86}, "calls": ["range", "sum"], "source_code": "def find_k_factor(length, k_factor):\n    \"\"\"Find the number of strings of length `length` with K factor = `k_factor`.\n\n    Keyword arguments:\n    length -- integer\n    k_factor -- integer\n    \"\"\"\n    mat = [[[0 for i in range(4)] for j in range((length - 1) // 3 + 2)] for k in range(length + 1)]\n    if 3 * k_factor + 1 > length:\n        return 0\n    mat[1][0][0] = 1\n    mat[1][0][1] = 0\n    mat[1][0][2] = 0\n    mat[1][0][3] = 25\n    for i in range(2, length + 1):\n        for j in range((length - 1) // 3 + 2):\n            if j == 0:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 < i:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3] + mat[i - 1][j - 1][2]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 == i:\n                mat[i][j][0] = 1\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n            else:\n                mat[i][j][0] = 0\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n    return sum(mat[length][k_factor])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/regex_matching.py", "fileNameBase": "regex_matching", "extension": "py", "doc": {"long_description": "'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nThe function prototype should be:\nbool is_match(const char *s, const char *p)\n\nSome examples:\nis_match(\"aa\",\"a\") \u2192 false\nis_match(\"aa\",\"aa\") \u2192 true\nis_match(\"aaa\",\"aa\") \u2192 false\nis_match(\"aa\", \"a*\") \u2192 true\nis_match(\"aa\", \".*\") \u2192 true\nis_match(\"ab\", \".*\") \u2192 true\nis_match(\"aab\", \"c*a*b\") \u2192 true", "short_description": "Implement regular expression matching with support for '.' and '*'.", "full": "Implement regular expression matching with support for '.' and '*'.\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nThe function prototype should be:\nbool is_match(const char *s, const char *p)\n\nSome examples:\nis_match(\"aa\",\"a\") \u2192 false\nis_match(\"aa\",\"aa\") \u2192 true\nis_match(\"aaa\",\"aa\") \u2192 false\nis_match(\"aa\", \"a*\") \u2192 true\nis_match(\"aa\", \".*\") \u2192 true\nis_match(\"ab\", \".*\") \u2192 true\nis_match(\"aab\", \"c*a*b\") \u2192 true"}}, "functions": {"is_match": {"doc": {"long_description": "Keyword arguments:\nstr_a -- string\nstr_b -- string", "short_description": "Finds if `str_a` matches `str_b`"}, "args": ["str_a", "str_b"], "returns": ["matches[-1][-1]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 62}, "calls": ["enumerate", "len", "range"], "source_code": "def is_match(str_a, str_b):\n    \"\"\"Finds if `str_a` matches `str_b`\n\n    Keyword arguments:\n    str_a -- string\n    str_b -- string\n    \"\"\"\n    (len_a, len_b) = (len(str_a) + 1, len(str_b) + 1)\n    matches = [[False] * len_b for _ in range(len_a)]\n    matches[0][0] = True\n    for (i, element) in enumerate(str_b[1:], 2):\n        matches[0][i] = matches[0][i - 2] and element == '*'\n    for (i, char_a) in enumerate(str_a, 1):\n        for (j, char_b) in enumerate(str_b, 1):\n            if char_b != '*':\n                matches[i][j] = matches[i - 1][j - 1] and char_b in (char_a, '.')\n            else:\n                matches[i][j] |= matches[i][j - 2]\n                if char_a == str_b[j - 2] or str_b[j - 2] == '.':\n                    matches[i][j] |= matches[i - 1][j]\n    return matches[-1][-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "buy_sell_stock", "import": "max_profit_naive", "type": "internal", "type_element": "function"}, {"from_module": "buy_sell_stock", "import": "max_profit_optimized", "type": "internal", "type_element": "function"}, {"from_module": "climbing_stairs", "import": "climb_stairs", "type": "internal", "type_element": "function"}, {"from_module": "climbing_stairs", "import": "climb_stairs_optimized", "type": "internal", "type_element": "function"}, {"from_module": "coin_change", "import": "count", "type": "internal", "type_element": "function"}, {"from_module": "combination_sum", "import": "helper_topdown", "type": "internal", "type_element": "function"}, {"from_module": "combination_sum", "import": "combination_sum_topdown", "type": "internal", "type_element": "function"}, {"from_module": "combination_sum", "import": "combination_sum_bottom_up", "type": "internal", "type_element": "function"}, {"from_module": "edit_distance", "import": "edit_distance", "type": "internal", "type_element": "function"}, {"from_module": "egg_drop", "import": "egg_drop", "type": "internal", "type_element": "function"}, {"from_module": "fib", "import": "fib_recursive", "type": "internal", "type_element": "function"}, {"from_module": "fib", "import": "fib_list", "type": "internal", "type_element": "function"}, {"from_module": "fib", "import": "fib_iter", "type": "internal", "type_element": "function"}, {"from_module": "hosoya_triangle", "import": "hosoya", "type": "internal", "type_element": "function"}, {"from_module": "hosoya_triangle", "import": "print_hosoya", "type": "internal", "type_element": "function"}, {"from_module": "hosoya_triangle", "import": "hosoya_testing", "type": "internal", "type_element": "function"}, {"from_module": "house_robber", "import": "house_robber", "type": "internal", "type_element": "function"}, {"from_module": "job_scheduling", "import": "binary_search", "type": "internal", "type_element": "function"}, {"from_module": "job_scheduling", "import": "schedule", "type": "internal", "type_element": "function"}, {"from_module": "job_scheduling", "import": "Job", "type": "internal", "type_element": "class"}, {"from_module": "knapsack", "import": "get_maximum_value", "type": "internal", "type_element": "function"}, {"from_module": "knapsack", "import": "Item", "type": "internal", "type_element": "class"}, {"from_module": "longest_increasing", "import": "longest_increasing_subsequence", "type": "internal", "type_element": "function"}, {"from_module": "longest_increasing", "import": "longest_increasing_subsequence_optimized", "type": "internal", "type_element": "function"}, {"from_module": "longest_increasing", "import": "longest_increasing_subsequence_optimized2", "type": "internal", "type_element": "function"}, {"from_module": "matrix_chain_order", "import": "matrix_chain_order", "type": "internal", "type_element": "function"}, {"from_module": "matrix_chain_order", "import": "print_optimal_solution", "type": "internal", "type_element": "function"}, {"from_module": "matrix_chain_order", "import": "main", "type": "internal", "type_element": "function"}, {"from_module": "max_product_subarray", "import": "max_product", "type": "internal", "type_element": "function"}, {"from_module": "max_product_subarray", "import": "subarray_with_max_product", "type": "internal", "type_element": "function"}, {"from_module": "max_subarray", "import": "max_subarray", "type": "internal", "type_element": "function"}, {"from_module": "min_cost_path", "import": "min_cost", "type": "internal", "type_element": "function"}, {"from_module": "num_decodings", "import": "num_decodings", "type": "internal", "type_element": "function"}, {"from_module": "num_decodings", "import": "num_decodings2", "type": "internal", "type_element": "function"}, {"from_module": "regex_matching", "import": "is_match", "type": "internal", "type_element": "function"}, {"from_module": "rod_cut", "import": "cut_rod", "type": "internal", "type_element": "function"}, {"from_module": "word_break", "import": "word_break", "type": "internal", "type_element": "function"}, {"from_module": "int_divide", "import": "int_divide", "type": "internal", "type_element": "function"}, {"from_module": "k_factor", "import": "find_k_factor", "type": "internal", "type_element": "function"}, {"from_module": "planting_trees", "import": "planting_trees", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/buy_sell_stock.py", "fileNameBase": "buy_sell_stock", "extension": "py", "doc": {"long_description": "is the price of a given stock on day i.\n\nIf you were only permitted to complete at most one transaction\n(ie, buy one and sell one share of the stock),\ndesign an algorithm to find the maximum profit.\n\nExample 1:\nInput: [7, 1, 5, 3, 6, 4]\nOutput: 5\n\nmax. difference = 6-1 = 5\n(not 7-1 = 6, as selling price needs to be larger than buying price)\nExample 2:\nInput: [7, 6, 4, 3, 1]\nOutput: 0\n\nIn this case, no transaction is done, i.e. max profit = 0.", "short_description": "Say you have an array for which the ith element", "full": "Say you have an array for which the ith element\nis the price of a given stock on day i.\n\nIf you were only permitted to complete at most one transaction\n(ie, buy one and sell one share of the stock),\ndesign an algorithm to find the maximum profit.\n\nExample 1:\nInput: [7, 1, 5, 3, 6, 4]\nOutput: 5\n\nmax. difference = 6-1 = 5\n(not 7-1 = 6, as selling price needs to be larger than buying price)\nExample 2:\nInput: [7, 6, 4, 3, 1]\nOutput: 0\n\nIn this case, no transaction is done, i.e. max profit = 0."}}, "functions": {"max_profit_naive": {"args": ["prices"], "returns": ["max_so_far"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 34}, "calls": ["range", "len", "max"], "store_vars_calls": {"max_so_far": "max"}, "source_code": "def max_profit_naive(prices):\n    \"\"\"\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    max_so_far = 0\n    for i in range(0, len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            max_so_far = max(max_so_far, prices[j] - prices[i])\n    return max_so_far"}, "max_profit_optimized": {"doc": {"long_description": "diff : [X, -6, 4, -2, 3, -2]", "short_description": "input: [7, 1, 5, 3, 6, 4]"}, "args": ["prices"], "returns": ["max_so_far"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 49}, "calls": ["range", "len", "max"], "store_vars_calls": {"cur_max": "max", "max_so_far": "max"}, "source_code": "def max_profit_optimized(prices):\n    \"\"\"\n    input: [7, 1, 5, 3, 6, 4]\n    diff : [X, -6, 4, -2, 3, -2]\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    (cur_max, max_so_far) = (0, 0)\n    for i in range(1, len(prices)):\n        cur_max = max(0, cur_max + prices[i] - prices[i - 1])\n        max_so_far = max(max_so_far, cur_max)\n    return max_so_far"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/max_subarray.py", "fileNameBase": "max_subarray", "extension": "py"}, "functions": {"max_subarray": {"args": ["array"], "returns": ["max_so_far"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 8}, "calls": ["range", "len", "max"], "store_vars_calls": {"max_now": "max", "max_so_far": "max"}, "source_code": "def max_subarray(array):\n    max_so_far = max_now = array[0]\n    for i in range(1, len(array)):\n        max_now = max(array[i], max_now + array[i])\n        max_so_far = max(max_so_far, max_now)\n    return max_so_far"}}, "body": {"calls": ["print", "max_subarray.max_subarray"], "source_code": ["print(a)", "print(max_subarray(a))", "max_subarray(a)"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/planting_trees.py", "fileNameBase": "planting_trees", "extension": "py", "doc": {"long_description": "assigned the job to plant these trees at an even interval on both sides of the\nroad. The length and width of the road are variable, and a pair of trees must\nbe planted at the beginning (at 0) and at the end (at length) of the road. Only\none tree can be moved at a time. The goal is to calculate the lowest amount of\ndistance that the trees have to be moved before they are all in a valid\nposition.", "short_description": "An even number of trees are left along one side of a country road. You've been", "full": "An even number of trees are left along one side of a country road. You've been\nassigned the job to plant these trees at an even interval on both sides of the\nroad. The length and width of the road are variable, and a pair of trees must\nbe planted at the beginning (at 0) and at the end (at length) of the road. Only\none tree can be moved at a time. The goal is to calculate the lowest amount of\ndistance that the trees have to be moved before they are all in a valid\nposition."}}, "dependencies": [{"from_module": "math", "import": "sqrt", "type": "external", "type_element": "module"}], "functions": {"planting_trees": {"doc": {"long_description": "are all in a valid state.\n\n    Parameters:\n        tree (list<int>): A sorted list of integers with all trees'\n                          position along the road.\n        length (int): An integer with the length of the road.\n        width (int): An integer with the width of the road.\n\n    Returns:\n        A float number with the total distance trees have been moved.", "short_description": "Returns the minimum distance that trees have to be moved before they"}, "args": ["trees", "length", "width"], "returns": ["cmatrix[n_pairs][n_pairs]"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 50}, "calls": ["int", "range", "len", "math.sqrt", "abs", "min"], "store_vars_calls": {"n_pairs": "int"}, "source_code": "def planting_trees(trees, length, width):\n    \"\"\"\n    Returns the minimum distance that trees have to be moved before they\n    are all in a valid state.\n\n        Parameters:\n            tree (list<int>): A sorted list of integers with all trees'\n                              position along the road.\n            length (int): An integer with the length of the road.\n            width (int): An integer with the width of the road.\n\n        Returns:\n            A float number with the total distance trees have been moved.\n    \"\"\"\n    trees = [0] + trees\n    n_pairs = int(len(trees) / 2)\n    space_between_pairs = length / (n_pairs - 1)\n    target_locations = [location * space_between_pairs for location in range(n_pairs)]\n    cmatrix = [[0 for _ in range(n_pairs + 1)] for _ in range(n_pairs + 1)]\n    for r_i in range(1, n_pairs + 1):\n        cmatrix[r_i][0] = cmatrix[r_i - 1][0] + sqrt(width + abs(trees[r_i] - target_locations[r_i - 1]) ** 2)\n    for l_i in range(1, n_pairs + 1):\n        cmatrix[0][l_i] = cmatrix[0][l_i - 1] + abs(trees[l_i] - target_locations[l_i - 1])\n    for r_i in range(1, n_pairs + 1):\n        for l_i in range(1, n_pairs + 1):\n            cmatrix[r_i][l_i] = min(cmatrix[r_i - 1][l_i] + sqrt(width + (trees[l_i + r_i] - target_locations[r_i - 1]) ** 2), cmatrix[r_i][l_i - 1] + abs(trees[l_i + r_i] - target_locations[l_i - 1]))\n    return cmatrix[n_pairs][n_pairs]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/knapsack.py", "fileNameBase": "knapsack", "extension": "py", "doc": {"long_description": "return the maximum summarized value of the items that can be fit in the\nknapsack.\n\nExample:\ncapacity = 5, items(value, weight) = [(60, 5), (50, 3), (70, 4), (30, 2)]\nresult = 80 (items valued 50 and 30 can both be fit in the knapsack)\n\nThe time complexity is O(n * m) and the space complexity is O(m), where n is\nthe total number of items and m is the knapsack's capacity.", "short_description": "Given the capacity of the knapsack and items specified by weights and values,", "full": "Given the capacity of the knapsack and items specified by weights and values,\nreturn the maximum summarized value of the items that can be fit in the\nknapsack.\n\nExample:\ncapacity = 5, items(value, weight) = [(60, 5), (50, 3), (70, 4), (30, 2)]\nresult = 80 (items valued 50 and 30 can both be fit in the knapsack)\n\nThe time complexity is O(n * m) and the space complexity is O(m), where n is\nthe total number of items and m is the knapsack's capacity."}}, "classes": {"Item": {"min_max_lineno": {"min_lineno": 15, "max_lineno": 20}, "methods": {"__init__": {"args": ["self", "value", "weight"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 20}, "source_code": "def __init__(self, value, weight):\n    self.value = value\n    self.weight = weight"}}}}, "functions": {"get_maximum_value": {"args": ["items", "capacity"], "returns": ["dp[capacity]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 28}, "calls": ["reversed", "range", "max"], "source_code": "def get_maximum_value(items, capacity):\n    dp = [0] * (capacity + 1)\n    for item in items:\n        for cur_weight in reversed(range(item.weight, capacity + 1)):\n            dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight])\n    return dp[capacity]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/num_decodings.py", "fileNameBase": "num_decodings", "extension": "py", "doc": {"long_description": "encoded to numbers using the following mapping:\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\nGiven an encoded message containing digits,\ndetermine the total number of ways to decode it.\n\nFor example,\nGiven encoded message \"12\",\nit could be decoded as \"AB\" (1 2) or \"L\" (12).\n\nThe number of ways decoding \"12\" is 2.", "short_description": "A message containing letters from A-Z is being", "full": "A message containing letters from A-Z is being\nencoded to numbers using the following mapping:\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\nGiven an encoded message containing digits,\ndetermine the total number of ways to decode it.\n\nFor example,\nGiven encoded message \"12\",\nit could be decoded as \"AB\" (1 2) or \"L\" (12).\n\nThe number of ways decoding \"12\" is 2."}}, "functions": {"num_decodings": {"args": ["enc_mes"], "returns": ["last_char", "0"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 34}, "calls": ["range", "len", "int"], "source_code": "def num_decodings(enc_mes):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if not enc_mes or enc_mes[0] == '0':\n        return 0\n    (last_char, last_two_chars) = (1, 1)\n    for i in range(1, len(enc_mes)):\n        last = last_char if enc_mes[i] != '0' else 0\n        last_two = last_two_chars if int(enc_mes[i - 1:i + 1]) < 27 and enc_mes[i - 1] != '0' else 0\n        last_two_chars = last_char\n        last_char = last + last_two\n    return last_char"}, "num_decodings2": {"args": ["enc_mes"], "returns": ["stack[-1]", "0", "0"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 57}, "calls": ["range", "enc_mes.startswith", "len", "stack.append", "int"], "source_code": "def num_decodings2(enc_mes):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if not enc_mes or enc_mes.startswith('0'):\n        return 0\n    stack = [1, 1]\n    for i in range(1, len(enc_mes)):\n        if enc_mes[i] == '0':\n            if enc_mes[i - 1] == '0' or enc_mes[i - 1] > '2':\n                return 0\n            stack.append(stack[-2])\n        elif 9 < int(enc_mes[i - 1:i + 1]) < 27:\n            stack.append(stack[-2] + stack[-1])\n        else:\n            stack.append(stack[-1])\n    return stack[-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/longest_common_subsequence.py", "fileNameBase": "longest_common_subsequence", "extension": "py", "doc": {"long_description": "sequence by deleting some or no elements without changing the\norder of the remaining elements.\n\nFor example, 'abd' is a subsequence of 'abcd' whereas 'adc' is not\n\nGiven 2 strings containing lowercase english alphabets, find the length\nof the Longest Common Subsequence (L.C.S.).", "short_description": "A subsequence is a sequence that can be derived from another", "full": "A subsequence is a sequence that can be derived from another\nsequence by deleting some or no elements without changing the\norder of the remaining elements.\n\nFor example, 'abd' is a subsequence of 'abcd' whereas 'adc' is not\n\nGiven 2 strings containing lowercase english alphabets, find the length\nof the Longest Common Subsequence (L.C.S.).\n\nExample:\n    Input:  'abcdgh'\n            'aedfhr'\n    Output: 3\n\n    Explanation: The longest subsequence common to both the string is \"adh\"\n\nTime Complexity : O(M*N)\nSpace Complexity : O(M*N), where M and N are the lengths of the 1st and 2nd string\nrespectively."}}, "functions": {"longest_common_subsequence": {"doc": {"args": {"s1": {"description": "string"}, "s2": {"description": "string"}}, "returns": {"description": "int", "is_generator": false}}, "args": ["s_1", "s_2"], "returns": ["mat[m][n]"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 47}, "calls": ["len", "range", "max"], "store_vars_calls": {"m": "len", "n": "len"}, "source_code": "def longest_common_subsequence(s_1, s_2):\n    \"\"\"\n    :param s1: string\n    :param s2: string\n    :return: int\n    \"\"\"\n    m = len(s_1)\n    n = len(s_2)\n    mat = [[0] * (n + 1) for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                mat[i][j] = 0\n            elif s_1[i - 1] == s_2[j - 1]:\n                mat[i][j] = mat[i - 1][j - 1] + 1\n            else:\n                mat[i][j] = max(mat[i - 1][j], mat[i][j - 1])\n    return mat[m][n]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/max_product_subarray.py", "fileNameBase": "max_product_subarray", "extension": "py", "doc": {"long_description": "(containing at least one number) which has the largest product.\n\nFor example, given the array [2,3,-2,4],\nthe contiguous subarray [2,3] has the largest product = 6.", "short_description": "Find the contiguous subarray within an array", "full": "Find the contiguous subarray within an array\n(containing at least one number) which has the largest product.\n\nFor example, given the array [2,3,-2,4],\nthe contiguous subarray [2,3] has the largest product = 6."}}, "dependencies": [{"from_module": "functools", "import": "reduce", "type": "external", "type_element": "module"}], "functions": {"max_product": {"args": ["nums"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 23}, "calls": ["max", "min"], "store_vars_calls": {"lmax": "max", "lmin": "min", "gmax": "max"}, "source_code": "def max_product(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    lmin = lmax = gmax = nums[0]\n    for num in nums:\n        t_1 = num * lmax\n        t_2 = num * lmin\n        lmax = max(max(t_1, t_2), num)\n        lmin = min(min(t_1, t_2), num)\n        gmax = max(gmax, lmax)"}, "subarray_with_max_product": {"doc": {"short_description": "arr is list of positive/negative numbers "}, "args": ["arr"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 67}, "calls": ["len", "range", "print", "functools.reduce"], "store_vars_calls": {"length": "len"}, "source_code": "def subarray_with_max_product(arr):\n    \"\"\" arr is list of positive/negative numbers \"\"\"\n    length = len(arr)\n    product_so_far = max_product_end = 1\n    max_start_i = 0\n    so_far_start_i = so_far_end_i = 0\n    all_negative_flag = True\n    for i in range(length):\n        max_product_end *= arr[i]\n        if arr[i] > 0:\n            all_negative_flag = False\n        if max_product_end <= 0:\n            max_product_end = arr[i]\n            max_start_i = i\n        if product_so_far <= max_product_end:\n            product_so_far = max_product_end\n            so_far_end_i = i\n            so_far_start_i = max_start_i\n    if all_negative_flag:\n        print(f'max_product_so_far: {reduce(lambda x, y: x * y, arr)}, {arr}')\n    else:\n        print(f'max_product_so_far: {product_so_far},{arr[so_far_start_i:so_far_end_i + 1]}')"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/int_divide.py", "fileNameBase": "int_divide", "extension": "py", "doc": {"long_description": "non-negative number division, or decomposition.\n\nThe complexity is O(n^2).\n\nExample 1:\nInput: 4\nOutput: 5\nExplaination:\n4=4\n4=3+1\n4=2+2\n4=2+1+1\n4=1+1+1+1\n\nExample :\nInput: 7\nOutput: 15\nExplaination:\n7=7\n7=6+1\n7=5+2\n7=5+1+1\n7=4+3\n7=4+2+1\n7=4+1+1+1\n7=3+3+1\n7=3+2+2\n7=3+2+1+1\n7=3+1+1+1+1\n7=2+2+2+1\n7=2+2+1+1+1\n7=2+1+1+1+1+1\n7=1+1+1+1+1+1+1", "short_description": "Given positive integer decompose, find an algorithm to find the number of", "full": "Given positive integer decompose, find an algorithm to find the number of\nnon-negative number division, or decomposition.\n\nThe complexity is O(n^2).\n\nExample 1:\nInput: 4\nOutput: 5\nExplaination:\n4=4\n4=3+1\n4=2+2\n4=2+1+1\n4=1+1+1+1\n\nExample :\nInput: 7\nOutput: 15\nExplaination:\n7=7\n7=6+1\n7=5+2\n7=5+1+1\n7=4+3\n7=4+2+1\n7=4+1+1+1\n7=3+3+1\n7=3+2+2\n7=3+2+1+1\n7=3+1+1+1+1\n7=2+2+2+1\n7=2+2+1+1+1\n7=2+1+1+1+1+1\n7=1+1+1+1+1+1+1"}}, "functions": {"int_divide": {"doc": {"long_description": "decompose -- integer", "short_description": "Find number of decompositions from `decompose`"}, "args": ["decompose"], "returns": ["arr[decompose][decompose]"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 56}, "calls": ["range"], "source_code": "def int_divide(decompose):\n    \"\"\"Find number of decompositions from `decompose`\n\n    decompose -- integer\n    \"\"\"\n    arr = [[0 for i in range(decompose + 1)] for j in range(decompose + 1)]\n    arr[1][1] = 1\n    for i in range(1, decompose + 1):\n        for j in range(1, decompose + 1):\n            if i < j:\n                arr[i][j] = arr[i][i]\n            elif i == j:\n                arr[i][j] = 1 + arr[i][j - 1]\n            else:\n                arr[i][j] = arr[i][j - 1] + arr[i - j][j]\n    return arr[decompose][decompose]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/job_scheduling.py", "fileNameBase": "job_scheduling", "extension": "py", "doc": {"long_description": "Programming and Binary Search", "short_description": "Python program for weighted job scheduling using Dynamic", "full": "Python program for weighted job scheduling using Dynamic\nProgramming and Binary Search"}}, "classes": {"Job": {"doc": {"short_description": "Class to represent a job", "full": "Class to represent a job"}, "min_max_lineno": {"min_lineno": 6, "max_lineno": 14}, "methods": {"__init__": {"args": ["self", "start", "finish", "profit"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 14}, "source_code": "def __init__(self, start, finish, profit):\n    self.start = start\n    self.finish = finish\n    self.profit = profit"}}}}, "functions": {"binary_search": {"doc": {"long_description": "(before current job) that doesn't conflict with current\njob.  \"index\" is index of the current job.  This function\nreturns -1 if all jobs before index conflict with it.\nThe array jobs[] is sorted in increasing order of finish\ntime.", "short_description": "A Binary Search based function to find the latest job"}, "args": ["job", "start_index"], "returns": ["-1", "mid"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 39}, "source_code": "def binary_search(job, start_index):\n    \"\"\"\n    A Binary Search based function to find the latest job\n    (before current job) that doesn't conflict with current\n    job.  \"index\" is index of the current job.  This function\n    returns -1 if all jobs before index conflict with it.\n    The array jobs[] is sorted in increasing order of finish\n    time.\n    \"\"\"\n    left = 0\n    right = start_index - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if job[mid].finish <= job[start_index].start:\n            if job[mid + 1].finish <= job[start_index].start:\n                left = mid + 1\n            else:\n                return mid\n        else:\n            right = mid - 1\n    return -1"}, "schedule": {"doc": {"long_description": "profit from given array of jobs", "short_description": "The main function that returns the maximum possible"}, "args": ["job"], "returns": ["table[length - 1]"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 69}, "calls": ["sorted", "len", "range", "job_scheduling.binary_search", "max"], "store_vars_calls": {"job": "sorted", "length": "len", "pos": "binary_search"}, "source_code": "def schedule(job):\n    \"\"\"\n    The main function that returns the maximum possible\n    profit from given array of jobs\n    \"\"\"\n    job = sorted(job, key=lambda j: j.finish)\n    length = len(job)\n    table = [0 for _ in range(length)]\n    table[0] = job[0].profit\n    for i in range(1, length):\n        incl_prof = job[i].profit\n        pos = binary_search(job, i)\n        if pos != -1:\n            incl_prof += table[pos]\n        table[i] = max(incl_prof, table[i - 1])\n    return table[length - 1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/combination_sum.py", "fileNameBase": "combination_sum", "extension": "py", "doc": {"long_description": "find the number of possible combinations that\nadd up to a positive integer target.\n\nExample:\n\nnums = [1, 2, 3]\ntarget = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is 7.\nFollow up:\nWhat if negative numbers are allowed in the given array?\nHow does it change the problem?\nWhat limitation we need to add to the question to allow negative numbers?", "short_description": "Given an integer array with all positive numbers and no duplicates,", "full": "Given an integer array with all positive numbers and no duplicates,\nfind the number of possible combinations that\nadd up to a positive integer target.\n\nExample:\n\nnums = [1, 2, 3]\ntarget = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is 7.\nFollow up:\nWhat if negative numbers are allowed in the given array?\nHow does it change the problem?\nWhat limitation we need to add to the question to allow negative numbers?"}}, "functions": {"helper_topdown": {"doc": {"long_description": "Keyword arguments:\nnums -- positive integer array without duplicates\ntarget -- integer describing what a valid combination should add to", "short_description": "Generates DP and finds result."}, "args": ["nums", "target"], "returns": ["res", "DP[target]"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 47}, "calls": ["combination_sum.helper_topdown"], "source_code": "def helper_topdown(nums, target):\n    \"\"\"Generates DP and finds result.\n\n    Keyword arguments:\n    nums -- positive integer array without duplicates\n    target -- integer describing what a valid combination should add to\n    \"\"\"\n    if DP[target] != -1:\n        return DP[target]\n    res = 0\n    for num in nums:\n        if target >= num:\n            res += helper_topdown(nums, target - num)\n    DP[target] = res\n    return res"}, "combination_sum_topdown": {"doc": {"long_description": "Keyword arguments:\nnums -- positive integer array without duplicates\ntarget -- integer describing what a valid combination should add to", "short_description": "Find number of possible combinations in nums that add up to target, in top-down manner."}, "args": ["nums", "target"], "returns": ["helper_topdown(nums, target)"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 60}, "calls": ["combination_sum.helper_topdown"], "source_code": "def combination_sum_topdown(nums, target):\n    \"\"\"Find number of possible combinations in nums that add up to target, in top-down manner.\n\n    Keyword arguments:\n    nums -- positive integer array without duplicates\n    target -- integer describing what a valid combination should add to\n    \"\"\"\n    global DP\n    DP = [-1] * (target + 1)\n    DP[0] = 1\n    return helper_topdown(nums, target)"}, "combination_sum_bottom_up": {"doc": {"long_description": "Keyword arguments:\nnums -- positive integer array without duplicates\ntarget -- integer describing what a valid combination should add to", "short_description": "Find number of possible combinations in nums that add up to target, in bottom-up manner."}, "args": ["nums", "target"], "returns": ["combs[target]"], "min_max_lineno": {"min_lineno": 61, "max_lineno": 75}, "calls": ["range", "len"], "source_code": "def combination_sum_bottom_up(nums, target):\n    \"\"\"Find number of possible combinations in nums that add up to target, in bottom-up manner.\n\n    Keyword arguments:\n    nums -- positive integer array without duplicates\n    target -- integer describing what a valid combination should add to\n    \"\"\"\n    combs = [0] * (target + 1)\n    combs[0] = 1\n    for i in range(0, len(combs)):\n        for num in nums:\n            if i - num >= 0:\n                combs[i] += combs[i - num]\n    return combs[target]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/fib.py", "fileNameBase": "fib", "extension": "py", "doc": {"long_description": "form a sequence, called the Fibonacci sequence,\nsuch that each number is the sum of the two preceding ones,\nstarting from 0 and 1.\nThat is,\n    F0=0 , F1=1\nand\n    Fn= F(n-1) + F(n-2)\nThe Fibonacci numbers are the numbers in the following integer sequence.\n    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026\u2026.\n\nIn mathematical terms, the sequence Fn of Fibonacci numbers is\ndefined by the recurrence relation\n\nHere, given a number n, print n-th Fibonacci Number.", "short_description": "In mathematics, the Fibonacci numbers, commonly denoted Fn,", "full": "In mathematics, the Fibonacci numbers, commonly denoted Fn,\nform a sequence, called the Fibonacci sequence,\nsuch that each number is the sum of the two preceding ones,\nstarting from 0 and 1.\nThat is,\n    F0=0 , F1=1\nand\n    Fn= F(n-1) + F(n-2)\nThe Fibonacci numbers are the numbers in the following integer sequence.\n    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026\u2026.\n\nIn mathematical terms, the sequence Fn of Fibonacci numbers is\ndefined by the recurrence relation\n\nHere, given a number n, print n-th Fibonacci Number."}}, "functions": {"fib_recursive": {"args": ["n"], "returns": ["fib_recursive(n - 1) + fib_recursive(n - 2)", "n"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 39}, "calls": ["fib.fib_recursive"], "source_code": "def fib_recursive(n):\n    \"\"\"[summary]\n    Computes the n-th fibonacci number recursive.\n    Problem: This implementation is very slow.\n    approximate O(2^n)\n\n    Arguments:\n        n {[int]} -- [description]\n\n    Returns:\n        [int] -- [description]\n    \"\"\"\n    assert n >= 0, 'n must be a positive integer'\n    if n <= 1:\n        return n\n    return fib_recursive(n - 1) + fib_recursive(n - 2)"}, "fib_list": {"args": ["n"], "returns": ["list_results[n]"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 63}, "calls": ["range", "list_results.append"], "source_code": "def fib_list(n):\n    \"\"\"[summary]\n    This algorithm computes the n-th fibbonacci number\n    very quick. approximate O(n)\n    The algorithm use dynamic programming.\n\n    Arguments:\n        n {[int]} -- [description]\n\n    Returns:\n        [int] -- [description]\n    \"\"\"\n    assert n >= 0, 'n must be a positive integer'\n    list_results = [0, 1]\n    for i in range(2, n + 1):\n        list_results.append(list_results[i - 1] + list_results[i - 2])\n    return list_results[n]"}, "fib_iter": {"args": ["n"], "returns": ["res", "n"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 91}, "calls": ["range"], "source_code": "def fib_iter(n):\n    \"\"\"[summary]\n    Works iterative approximate O(n)\n\n    Arguments:\n        n {[int]} -- [description]\n\n    Returns:\n        [int] -- [description]\n    \"\"\"\n    assert n >= 0, 'n must be positive integer'\n    fib_1 = 0\n    fib_2 = 1\n    res = 0\n    if n <= 1:\n        return n\n    for _ in range(n - 1):\n        res = fib_1 + fib_2\n        fib_1 = fib_2\n        fib_2 = res\n    return res"}}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/house_robber.py", "fileNameBase": "house_robber", "extension": "py", "doc": {"long_description": "Each house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them\nis that adjacent houses have security system connected and\nit will automatically contact the police if two adjacent houses\nwere broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money\nof each house, determine the maximum amount of money you\ncan rob tonight without alerting the police.", "short_description": "You are a professional robber planning to rob houses along a street.", "full": "You are a professional robber planning to rob houses along a street.\nEach house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them\nis that adjacent houses have security system connected and\nit will automatically contact the police if two adjacent houses\nwere broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money\nof each house, determine the maximum amount of money you\ncan rob tonight without alerting the police."}}, "functions": {"house_robber": {"args": ["houses"], "returns": ["now"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 20}, "calls": ["max"], "source_code": "def house_robber(houses):\n    (last, now) = (0, 0)\n    for house in houses:\n        (last, now) = (now, max(last + house, now))\n    return now"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/matrix_chain_order.py", "fileNameBase": "matrix_chain_order", "extension": "py", "doc": {"long_description": "Implementation of matrix Chain Multiplication\nTime Complexity: O(n^3)\nSpace Complexity: O(n^2)", "short_description": "Dynamic Programming", "full": "Dynamic Programming\nImplementation of matrix Chain Multiplication\nTime Complexity: O(n^3)\nSpace Complexity: O(n^2)"}}, "functions": {"matrix_chain_order": {"doc": {"long_description": "array -- int[]", "short_description": "Finds optimal order to multiply matrices"}, "args": ["array"], "returns": [["matrix", "sol"]], "min_max_lineno": {"min_lineno": 10, "max_lineno": 29}, "calls": ["len", "range"], "store_vars_calls": {"n": "len"}, "source_code": "def matrix_chain_order(array):\n    \"\"\"Finds optimal order to multiply matrices\n\n    array -- int[]\n    \"\"\"\n    n = len(array)\n    matrix = [[0 for x in range(n)] for x in range(n)]\n    sol = [[0 for x in range(n)] for x in range(n)]\n    for chain_length in range(2, n):\n        for a in range(1, n - chain_length + 1):\n            b = a + chain_length - 1\n            matrix[a][b] = INF\n            for c in range(a, b):\n                cost = matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]\n                if cost < matrix[a][b]:\n                    matrix[a][b] = cost\n                    sol[a][b] = c\n    return (matrix, sol)"}, "print_optimal_solution": {"doc": {"long_description": "optimal_solution -- int[][]\ni -- int[]\nj -- int[]", "short_description": "Print the solution"}, "args": ["optimal_solution", "i", "j"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 45}, "calls": ["print", "matrix_chain_order.print_optimal_solution", "str"], "source_code": "def print_optimal_solution(optimal_solution, i, j):\n    \"\"\"Print the solution\n\n    optimal_solution -- int[][]\n    i -- int[]\n    j -- int[]\n    \"\"\"\n    if i == j:\n        print('A' + str(i), end=' ')\n    else:\n        print('(', end=' ')\n        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])\n        print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)\n        print(')', end=' ')"}, "main": {"doc": {"short_description": "Testing for matrix_chain_ordering"}, "min_max_lineno": {"min_lineno": 47, "max_lineno": 59}, "calls": ["len", "matrix_chain_order.matrix_chain_order", "print", "matrix_chain_order.print_optimal_solution", "str"], "store_vars_calls": {"length": "len"}, "source_code": "def main():\n    \"\"\"\n    Testing for matrix_chain_ordering\n    \"\"\"\n    array = [30, 35, 15, 5, 10, 20, 25]\n    length = len(array)\n    (matrix, optimal_solution) = matrix_chain_order(array)\n    print('No. of Operation required: ' + str(matrix[1][length - 1]))\n    print_optimal_solution(optimal_solution, 1, length - 1)"}}, "body": {"calls": ["float", "matrix_chain_order.main"], "store_vars_calls": {"INF": "float"}, "source_code": ["float('inf')", "main()"]}, "main_info": {"main_flag": 1, "main_function": "matrix_chain_order.main", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/dp/min_cost_path.py", "fileNameBase": "min_cost_path", "extension": "py", "doc": {"long_description": "To find minimum cost path\nfrom station 0 to station N-1,\nwhere cost of moving from ith station to jth station is given as:\n\nMatrix of size (N x N)\nwhere Matrix[i][j] denotes the cost of moving from\nstation i --> station j   for i < j\n\nNOTE that values where Matrix[i][j] and i > j does not\nmean anything, and hence represented by -1 or INF\n\nFor the input below (cost matrix),\nMinimum cost is obtained as from  { 0 --> 1 --> 3}\n                                  = cost[0][1] + cost[1][3] = 65\nthe Output will be:\n\nThe Minimum cost to reach station 4 is 65\n\nTime Complexity: O(n^2)\nSpace Complexity: O(n)", "short_description": "author @goswami-rahul", "full": "author @goswami-rahul\n\nTo find minimum cost path\nfrom station 0 to station N-1,\nwhere cost of moving from ith station to jth station is given as:\n\nMatrix of size (N x N)\nwhere Matrix[i][j] denotes the cost of moving from\nstation i --> station j   for i < j\n\nNOTE that values where Matrix[i][j] and i > j does not\nmean anything, and hence represented by -1 or INF\n\nFor the input below (cost matrix),\nMinimum cost is obtained as from  { 0 --> 1 --> 3}\n                                  = cost[0][1] + cost[1][3] = 65\nthe Output will be:\n\nThe Minimum cost to reach station 4 is 65\n\nTime Complexity: O(n^2)\nSpace Complexity: O(n)"}}, "functions": {"min_cost": {"doc": {"long_description": "Keyword arguments:\ncost -- matrix containing costs", "short_description": "Find minimum cost."}, "args": ["cost"], "returns": ["dist[length - 1]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 46}, "calls": ["len", "range", "min"], "store_vars_calls": {"length": "len"}, "source_code": "def min_cost(cost):\n    \"\"\"Find minimum cost.\n\n    Keyword arguments:\n    cost -- matrix containing costs\n    \"\"\"\n    length = len(cost)\n    dist = [INF] * length\n    dist[0] = 0\n    for i in range(length):\n        for j in range(i + 1, length):\n            dist[j] = min(dist[j], dist[i] + cost[i][j])\n    return dist[length - 1]"}}, "body": {"calls": ["float", "len", "min_cost_path.min_cost", "print"], "store_vars_calls": {"INF": "float", "TOTAL_LEN": "len", "mcost": "min_cost"}, "source_code": ["float('inf')", "len(costs)", "min_cost(costs)", "print(f'The minimum cost to reach station {TOTAL_LEN} is {mcost}')"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": true}], "output/keon/algorithms/algorithms/algorithms/search": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/interpolation_search.py", "fileNameBase": "interpolation_search", "extension": "py", "doc": {"long_description": "Given a sorted array in increasing order, interpolation search calculates\nthe starting point of its search according to the search key.\n\nFORMULA: start_pos = low + [ (x - arr[low])*(high - low) / (arr[high] - arr[low]) ]\n\nDoc: https://en.wikipedia.org/wiki/Interpolation_search\n\nTime Complexity: O(log2(log2 n)) for average cases, O(n) for the worst case.\nThe algorithm performs best with uniformly distributed arrays.", "short_description": "Python implementation of the Interpolation Search algorithm.", "full": "Python implementation of the Interpolation Search algorithm.\nGiven a sorted array in increasing order, interpolation search calculates\nthe starting point of its search according to the search key.\n\nFORMULA: start_pos = low + [ (x - arr[low])*(high - low) / (arr[high] - arr[low]) ]\n\nDoc: https://en.wikipedia.org/wiki/Interpolation_search\n\nTime Complexity: O(log2(log2 n)) for average cases, O(n) for the worst case.\nThe algorithm performs best with uniformly distributed arrays."}}, "dependencies": [{"from_module": "typing", "import": "List", "type": "external", "type_element": "module"}], "functions": {"interpolation_search": {"doc": {"args": {"array": {"description": "The array to be searched."}, "search_key": {"description": "The key to be searched in the array."}}, "returns": {"description": "Index of search_key in array if found, else -1.\nExamples:\n\n>>> interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)\n2\n>>> interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)\n-1\n>>> interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)\n-1", "is_generator": false}}, "args": ["array", "search_key"], "annotated_arg_types": {"array": "List[int]", "search_key": "int"}, "annotated_return_type": "int", "returns": ["-1", "pos"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 57}, "calls": ["len", "int"], "source_code": "def interpolation_search(array: List[int], search_key: int) -> int:\n    \"\"\"\n    :param array: The array to be searched.\n    :param search_key: The key to be searched in the array.\n\n    :returns: Index of search_key in array if found, else -1.\n\n    Examples:\n\n    >>> interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)\n    2\n    >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)\n    -1\n    >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)\n    -1\n\n    \"\"\"\n    high = len(array) - 1\n    low = 0\n    while low <= high and array[low] <= search_key <= array[high]:\n        pos = low + int((search_key - array[low]) * (high - low) / (array[high] - array[low]))\n        if array[pos] == search_key:\n            return pos\n        if array[pos] < search_key:\n            low = pos + 1\n        else:\n            high = pos - 1\n    return -1"}}, "body": {"calls": ["doctest.testmod"], "source_code": ["doctest.testmod()"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/search_rotate.py", "fileNameBase": "search_rotate", "extension": "py", "doc": {"long_description": "Suppose an array sorted in ascending order is rotated at some pivot unknown\nto you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\n\nYou are given a target value to search. If found in the array return its index,\notherwise return -1.\n\nYour algorithm's runtime complexity must be in the order of O(log n).\n---------------------------------------------------------------------------------\nExplanation algorithm:\n\nIn classic binary search, we compare val with the midpoint to figure out if\nval belongs on the low or the high side. The complication here is that the\narray is rotated and may have an inflection point. Consider, for example:\n\nArray1: [10, 15, 20, 0, 5]\nArray2: [50, 5, 20, 30, 40]\n\nNote that both arrays have a midpoint of 20, but 5 appears on the left side of\none and on the right side of the other. Therefore, comparing val with the\nmidpoint is insufficient.\n\nHowever, if we look a bit deeper, we can see that one half of the array must be\nordered normally(increasing order). We can therefore look at the normally ordered\nhalf to determine whether we should search the low or hight side.\n\nFor example, if we are searching for 5 in Array1, we can look at the left element (10)\nand middle element (20). Since 10 < 20, the left half must be ordered normally. And, since 5\nis not between those, we know that we must search the right half\n\nIn array2, we can see that since 50 > 20, the right half must be ordered normally. We turn to\nthe middle 20, and right 40 element to check if 5 would fall between them. The value 5 would not\nTherefore, we search the left half.\n\nThere are 2 possible solution: iterative and recursion.\nRecursion helps you understand better the above algorithm explanation", "short_description": "Search in Rotated Sorted Array", "full": "Search in Rotated Sorted Array\nSuppose an array sorted in ascending order is rotated at some pivot unknown\nto you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\n\nYou are given a target value to search. If found in the array return its index,\notherwise return -1.\n\nYour algorithm's runtime complexity must be in the order of O(log n).\n---------------------------------------------------------------------------------\nExplanation algorithm:\n\nIn classic binary search, we compare val with the midpoint to figure out if\nval belongs on the low or the high side. The complication here is that the\narray is rotated and may have an inflection point. Consider, for example:\n\nArray1: [10, 15, 20, 0, 5]\nArray2: [50, 5, 20, 30, 40]\n\nNote that both arrays have a midpoint of 20, but 5 appears on the left side of\none and on the right side of the other. Therefore, comparing val with the\nmidpoint is insufficient.\n\nHowever, if we look a bit deeper, we can see that one half of the array must be\nordered normally(increasing order). We can therefore look at the normally ordered\nhalf to determine whether we should search the low or hight side.\n\nFor example, if we are searching for 5 in Array1, we can look at the left element (10)\nand middle element (20). Since 10 < 20, the left half must be ordered normally. And, since 5\nis not between those, we know that we must search the right half\n\nIn array2, we can see that since 50 > 20, the right half must be ordered normally. We turn to\nthe middle 20, and right 40 element to check if 5 would fall between them. The value 5 would not\nTherefore, we search the left half.\n\nThere are 2 possible solution: iterative and recursion.\nRecursion helps you understand better the above algorithm explanation"}}, "functions": {"search_rotate": {"doc": {"long_description": "ascending order and then rotated at some unknown pivot.", "short_description": "Finds the index of the given value in an array that has been sorted in"}, "args": ["array", "val"], "returns": ["-1", "mid"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 62}, "calls": ["len"], "source_code": "def search_rotate(array, val):\n    \"\"\"\n    Finds the index of the given value in an array that has been sorted in\n    ascending order and then rotated at some unknown pivot.\n    \"\"\"\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if val == array[mid]:\n            return mid\n        if array[low] <= array[mid]:\n            if array[low] <= val <= array[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        elif array[mid] <= val <= array[high]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1"}, "search_rotate_recur": {"doc": {"long_description": "ascending order and then rotated at some unknown pivot.", "short_description": "Finds the index of the given value in an array that has been sorted in"}, "args": ["array", "low", "high", "val"], "returns": ["search_rotate_recur(array, low, mid - 1, val)", "-1", "mid", "search_rotate_recur(array, mid + 1, high, val)", "search_rotate_recur(array, mid + 1, high, val)", "search_rotate_recur(array, low, mid - 1, val)"], "min_max_lineno": {"min_lineno": 64, "max_lineno": 81}, "calls": ["search_rotate.search_rotate_recur"], "source_code": "def search_rotate_recur(array, low, high, val):\n    \"\"\"\n    Finds the index of the given value in an array that has been sorted in\n    ascending order and then rotated at some unknown pivot.\n    \"\"\"\n    if low >= high:\n        return -1\n    mid = (low + high) // 2\n    if val == array[mid]:\n        return mid\n    if array[low] <= array[mid]:\n        if array[low] <= val <= array[mid]:\n            return search_rotate_recur(array, low, mid - 1, val)\n        return search_rotate_recur(array, mid + 1, high, val)\n    if array[mid] <= val <= array[high]:\n        return search_rotate_recur(array, mid + 1, high, val)\n    return search_rotate_recur(array, low, mid - 1, val)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/first_occurrence.py", "fileNameBase": "first_occurrence", "extension": "py", "doc": {"long_description": "Approach- Binary Search\nT(n)- O(log n)", "short_description": "Find first occurance of a number in a sorted array (increasing order)", "full": "Find first occurance of a number in a sorted array (increasing order)\nApproach- Binary Search\nT(n)- O(log n)"}}, "functions": {"first_occurrence": {"doc": {"long_description": "The array has to be sorted in increasing order.", "short_description": "Returns the index of the first occurance of the given element in an array."}, "args": ["array", "query"], "returns": ["low"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 24}, "calls": ["len"], "source_code": "def first_occurrence(array, query):\n    \"\"\"\n    Returns the index of the first occurance of the given element in an array.\n    The array has to be sorted in increasing order.\n    \"\"\"\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = low + (high - low) // 2\n        if low == high:\n            break\n        if array[mid] < query:\n            low = mid + 1\n        else:\n            high = mid\n    if array[low] == query:\n        return low"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/two_sum.py", "fileNameBase": "two_sum", "extension": "py", "doc": {"long_description": "numbers such that they add up to a specific target number. The function two_sum\nshould return indices of the two numbers such that they add up to the target,\nwhere index1 must be less than index2. Please note that your returned answers\n(both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution and you\nmay not use the same element twice.\n\nInput: numbers = [2, 7, 11, 15], target=9\nOutput: index1 = 1, index2 = 2\n\nSolution:\ntwo_sum: using binary search\ntwo_sum1: using dictionary as a hash table\ntwo_sum2: using two pointers", "short_description": "Given an array of integers that is already sorted in ascending order, find two", "full": "Given an array of integers that is already sorted in ascending order, find two\nnumbers such that they add up to a specific target number. The function two_sum\nshould return indices of the two numbers such that they add up to the target,\nwhere index1 must be less than index2. Please note that your returned answers\n(both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution and you\nmay not use the same element twice.\n\nInput: numbers = [2, 7, 11, 15], target=9\nOutput: index1 = 1, index2 = 2\n\nSolution:\ntwo_sum: using binary search\ntwo_sum1: using dictionary as a hash table\ntwo_sum2: using two pointers"}}, "functions": {"two_sum": {"doc": {"long_description": "numbers such that their sum is the given target.\n\nUsing binary search.", "short_description": "Given a list of numbers sorted in ascending order, find the indices of two"}, "args": ["numbers", "target"], "returns": ["None", "[i + 1, mid + 1]"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 39}, "calls": ["enumerate", "len"], "source_code": "def two_sum(numbers, target):\n    \"\"\"\n    Given a list of numbers sorted in ascending order, find the indices of two\n    numbers such that their sum is the given target.\n\n    Using binary search.\n    \"\"\"\n    for (i, number) in enumerate(numbers):\n        second_val = target - number\n        (low, high) = (i + 1, len(numbers) - 1)\n        while low <= high:\n            mid = low + (high - low) // 2\n            if second_val == numbers[mid]:\n                return [i + 1, mid + 1]\n            if second_val > numbers[mid]:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return None"}, "two_sum1": {"doc": {"long_description": "sum is the given target.\n\nUsing a hash table.", "short_description": "Given a list of numbers, find the indices of two numbers such that their"}, "args": ["numbers", "target"], "returns": ["None", "[dic[target - num] + 1, i + 1]"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 53}, "calls": ["enumerate"], "source_code": "def two_sum1(numbers, target):\n    \"\"\"\n    Given a list of numbers, find the indices of two numbers such that their\n    sum is the given target.\n\n    Using a hash table.\n    \"\"\"\n    dic = {}\n    for (i, num) in enumerate(numbers):\n        if target - num in dic:\n            return [dic[target - num] + 1, i + 1]\n        dic[num] = i\n    return None"}, "two_sum2": {"doc": {"long_description": "numbers such that their sum is the given target.\n\nUsing a bidirectional linear search.", "short_description": "Given a list of numbers sorted in ascending order, find the indices of two"}, "args": ["numbers", "target"], "returns": ["[left + 1, right + 1]"], "min_max_lineno": {"min_lineno": 54, "max_lineno": 72}, "calls": ["len"], "source_code": "def two_sum2(numbers, target):\n    \"\"\"\n    Given a list of numbers sorted in ascending order, find the indices of two\n    numbers such that their sum is the given target.\n\n    Using a bidirectional linear search.\n    \"\"\"\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        if current_sum > target:\n            right = right - 1\n        else:\n            left = left + 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/find_min_rotate.py", "fileNameBase": "find_min_rotate", "extension": "py", "doc": {"long_description": "to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n\nFind the minimum element. The complexity must be O(logN)\n\nYou may assume no duplicate exists in the array.", "short_description": "Suppose an array sorted in ascending order is rotated at some pivot unknown", "full": "Suppose an array sorted in ascending order is rotated at some pivot unknown\nto you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n\nFind the minimum element. The complexity must be O(logN)\n\nYou may assume no duplicate exists in the array."}}, "functions": {"find_min_rotate": {"doc": {"short_description": "Finds the minimum element in a sorted array that has been rotated."}, "args": ["array"], "returns": ["array[low]"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 23}, "calls": ["len"], "source_code": "def find_min_rotate(array):\n    \"\"\"\n    Finds the minimum element in a sorted array that has been rotated.\n    \"\"\"\n    low = 0\n    high = len(array) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if array[mid] > array[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return array[low]"}, "find_min_rotate_recur": {"doc": {"short_description": "Finds the minimum element in a sorted array that has been rotated."}, "args": ["array", "low", "high"], "returns": ["find_min_rotate_recur(array, low, mid)", "array[low]", "find_min_rotate_recur(array, mid + 1, high)"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 34}, "calls": ["find_min_rotate.find_min_rotate_recur"], "source_code": "def find_min_rotate_recur(array, low, high):\n    \"\"\"\n    Finds the minimum element in a sorted array that has been rotated.\n    \"\"\"\n    mid = (low + high) // 2\n    if mid == low:\n        return array[low]\n    if array[mid] > array[high]:\n        return find_min_rotate_recur(array, mid + 1, high)\n    return find_min_rotate_recur(array, low, mid)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/next_greatest_letter.py", "fileNameBase": "next_greatest_letter", "extension": "py", "doc": {"long_description": "and given a target letter target, find the smallest element in the list that\nis larger than the given target.\n\nLetters also wrap around. For example, if the target is target = 'z' and\nletters = ['a', 'b'], the answer is 'a'.\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nOutput: \"c\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\n\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/", "short_description": "Given a list of sorted characters letters containing only lowercase letters,", "full": "Given a list of sorted characters letters containing only lowercase letters,\nand given a target letter target, find the smallest element in the list that\nis larger than the given target.\n\nLetters also wrap around. For example, if the target is target = 'z' and\nletters = ['a', 'b'], the answer is 'a'.\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nOutput: \"c\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\nOutput: \"f\"\n\nInput:\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\nOutput: \"f\"\n\nReference: https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/"}}, "dependencies": [{"import": "bisect", "type": "external", "type_element": "module"}], "functions": {"next_greatest_letter": {"doc": {"short_description": "Using bisect libarary"}, "args": ["letters", "target"], "returns": ["letters[index % len(letters)]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 35}, "calls": ["bisect.bisect", "len"], "store_vars_calls": {"index": "bisect.bisect"}, "source_code": "def next_greatest_letter(letters, target):\n    \"\"\"\n    Using bisect libarary\n    \"\"\"\n    index = bisect.bisect(letters, target)\n    return letters[index % len(letters)]"}, "next_greatest_letter_v1": {"doc": {"short_description": "Using binary search: complexity O(logN)"}, "args": ["letters", "target"], "returns": ["letters[left]", "letters[0]", "letters[0]"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 52}, "calls": ["len"], "source_code": "def next_greatest_letter_v1(letters, target):\n    \"\"\"\n    Using binary search: complexity O(logN)\n    \"\"\"\n    if letters[0] > target:\n        return letters[0]\n    if letters[len(letters) - 1] <= target:\n        return letters[0]\n    (left, right) = (0, len(letters) - 1)\n    while left <= right:\n        mid = left + (right - left) // 2\n        if letters[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return letters[left]"}, "next_greatest_letter_v2": {"doc": {"short_description": "Brute force: complexity O(N)"}, "args": ["letters", "target"], "returns": ["letters[0]", "index"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 61}, "source_code": "def next_greatest_letter_v2(letters, target):\n    \"\"\"\n    Brute force: complexity O(N)\n    \"\"\"\n    for index in letters:\n        if index > target:\n            return index\n    return letters[0]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/search_range.py", "fileNameBase": "search_range", "extension": "py", "doc": {"long_description": "and ending position of a given target value. If the target is not found in the\narray, return [-1, -1].\n\nFor example:\nInput: nums = [5,7,7,8,8,8,10], target = 8\nOutput: [3,5]\nInput: nums = [5,7,7,8,8,8,10], target = 11\nOutput: [-1,-1]", "short_description": "Given an array of integers nums sorted in ascending order, find the starting", "full": "Given an array of integers nums sorted in ascending order, find the starting\nand ending position of a given target value. If the target is not found in the\narray, return [-1, -1].\n\nFor example:\nInput: nums = [5,7,7,8,8,8,10], target = 8\nOutput: [3,5]\nInput: nums = [5,7,7,8,8,8,10], target = 11\nOutput: [-1,-1]"}}, "functions": {"search_range": {"args": ["nums", "target"], "returns": ["[-1, -1]", "[low, j]"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 34}, "calls": ["range", "len"], "source_code": "def search_range(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if target <= nums[mid]:\n            high = mid\n        else:\n            low = mid + 1\n    for j in range(len(nums) - 1, -1, -1):\n        if nums[j] == target:\n            return [low, j]\n    return [-1, -1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/binary_search.py", "fileNameBase": "binary_search", "extension": "py", "doc": {"long_description": "Find an element in a sorted array (in ascending order).", "short_description": "Binary Search", "full": "Binary Search\n\nFind an element in a sorted array (in ascending order)."}}, "functions": {"binary_search": {"doc": {"long_description": "reference: https://en.wikipedia.org/wiki/Binary_search_algorithm", "short_description": "Worst-case Complexity: O(log(n))"}, "args": ["array", "query"], "returns": ["None", "mid"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 36}, "calls": ["len"], "source_code": "def binary_search(array, query):\n    \"\"\"\n    Worst-case Complexity: O(log(n))\n\n    reference: https://en.wikipedia.org/wiki/Binary_search_algorithm\n    \"\"\"\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (high + low) // 2\n        val = array[mid]\n        if val == query:\n            return mid\n        if val < query:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None"}, "binary_search_recur": {"doc": {"long_description": "reference: https://en.wikipedia.org/wiki/Binary_search_algorithm", "short_description": "Worst-case Complexity: O(log(n))"}, "args": ["array", "low", "high", "val"], "returns": ["mid", "-1", "binary_search_recur(array, low, mid - 1, val)", "binary_search_recur(array, mid + 1, high, val)"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 53}, "calls": ["binary_search.binary_search_recur"], "source_code": "def binary_search_recur(array, low, high, val):\n    \"\"\"\n    Worst-case Complexity: O(log(n))\n\n    reference: https://en.wikipedia.org/wiki/Binary_search_algorithm\n    \"\"\"\n    if low > high:\n        return -1\n    mid = low + (high - low) // 2\n    if val < array[mid]:\n        return binary_search_recur(array, low, mid - 1, val)\n    if val > array[mid]:\n        return binary_search_recur(array, mid + 1, high, val)\n    return mid"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/search_insert.py", "fileNameBase": "search_insert", "extension": "py", "doc": {"short_description": "Helper methods for implementing insertion sort.", "full": "Helper methods for implementing insertion sort."}}, "functions": {"search_insert": {"doc": {"long_description": "found. If not, return the index where it would be if it were inserted in order.\n\nFor example:\n[1,3,5,6], 5 -> 2\n[1,3,5,6], 2 -> 1\n[1,3,5,6], 7 -> 4\n[1,3,5,6], 0 -> 0", "short_description": "Given a sorted array and a target value, return the index if the target is"}, "args": ["array", "val"], "returns": ["low"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 25}, "calls": ["len"], "source_code": "def search_insert(array, val):\n    \"\"\"\n    Given a sorted array and a target value, return the index if the target is\n    found. If not, return the index where it would be if it were inserted in order.\n\n    For example:\n    [1,3,5,6], 5 -> 2\n    [1,3,5,6], 2 -> 1\n    [1,3,5,6], 7 -> 4\n    [1,3,5,6], 0 -> 0\n    \"\"\"\n    low = 0\n    high = len(array) - 1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if val > array[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/ternary_search.py", "fileNameBase": "ternary_search", "extension": "py", "doc": {"long_description": "It is similar to binary search where we divide the array into two parts but in this algorithm,\nwe divide the given array into three parts and determine which has the key (searched element).\nWe can divide the array into three parts by taking mid1 and mid2.\nInitially, l and r will be equal to 0 and n-1 respectively, where n is the length of the array.\nmid1 = l + (r-l)/3\nmid2 = r \u2013 (r-l)/3\n\nNote: Array needs to be sorted to perform ternary search on it.\nT(N) = O(log3(N))\nlog3 = log base 3", "short_description": "Ternary search is a divide and conquer algorithm that can be used to find an element in an array.", "full": "Ternary search is a divide and conquer algorithm that can be used to find an element in an array.\nIt is similar to binary search where we divide the array into two parts but in this algorithm,\nwe divide the given array into three parts and determine which has the key (searched element).\nWe can divide the array into three parts by taking mid1 and mid2.\nInitially, l and r will be equal to 0 and n-1 respectively, where n is the length of the array.\nmid1 = l + (r-l)/3\nmid2 = r \u2013 (r-l)/3\n\nNote: Array needs to be sorted to perform ternary search on it.\nT(N) = O(log3(N))\nlog3 = log base 3"}}, "functions": {"ternary_search": {"doc": {"long_description": "Returns the index of the value if found, and -1 otherwise.\nIf the index is not in the range left..right (ie. left <= index < right) returns -1.", "short_description": "Find the given value (key) in an array sorted in ascending order."}, "args": ["left", "right", "key", "arr"], "returns": ["-1", "mid1", "mid2"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 43}, "source_code": "def ternary_search(left, right, key, arr):\n    \"\"\"\n    Find the given value (key) in an array sorted in ascending order.\n    Returns the index of the value if found, and -1 otherwise.\n    If the index is not in the range left..right (ie. left <= index < right) returns -1.\n    \"\"\"\n    while right >= left:\n        mid1 = left + (right - left) // 3\n        mid2 = right - (right - left) // 3\n        if key == arr[mid1]:\n            return mid1\n        if key == mid2:\n            return mid2\n        if key < arr[mid1]:\n            right = mid1 - 1\n        elif key > arr[mid2]:\n            left = mid2 + 1\n        else:\n            left = mid1 + 1\n            right = mid2 - 1\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/last_occurrence.py", "fileNameBase": "last_occurrence", "extension": "py", "doc": {"long_description": "Approach- Binary Search\nT(n)- O(log n)", "short_description": "Find last occurance of a number in a sorted array (increasing order)", "full": "Find last occurance of a number in a sorted array (increasing order)\nApproach- Binary Search\nT(n)- O(log n)"}}, "functions": {"last_occurrence": {"doc": {"long_description": "The array has to be sorted in increasing order.", "short_description": "Returns the index of the last occurance of the given element in an array."}, "args": ["array", "query"], "returns": ["mid"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 21}, "calls": ["len"], "source_code": "def last_occurrence(array, query):\n    \"\"\"\n    Returns the index of the last occurance of the given element in an array.\n    The array has to be sorted in increasing order.\n    \"\"\"\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (high + low) // 2\n        if array[mid] == query and mid == len(array) - 1 or (array[mid] == query and array[mid + 1] > query):\n            return mid\n        if array[mid] <= query:\n            low = mid + 1\n        else:\n            high = mid - 1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/jump_search.py", "fileNameBase": "jump_search", "extension": "py", "doc": {"long_description": "Find an element in a sorted array.", "short_description": "Jump Search", "full": "Jump Search\n\nFind an element in a sorted array."}}, "dependencies": [{"import": "math", "type": "external", "type_element": "module"}], "functions": {"jump_search": {"doc": {"long_description": "All items in list must be sorted like binary search\n\nFind block that contains target value and search it linearly in that block\nIt returns a first target value in array\n\nreference: https://en.wikipedia.org/wiki/Jump_search", "short_description": "Worst-case Complexity: O(\u221an) (root(n))"}, "args": ["arr", "target"], "returns": ["-1", "-1", "block_prev", "-1"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 46}, "calls": ["len", "int", "math.sqrt", "min"], "store_vars_calls": {"length": "len", "block_size": "int"}, "source_code": "def jump_search(arr, target):\n    \"\"\"\n    Worst-case Complexity: O(\u221an) (root(n))\n    All items in list must be sorted like binary search\n\n    Find block that contains target value and search it linearly in that block\n    It returns a first target value in array\n\n    reference: https://en.wikipedia.org/wiki/Jump_search\n    \"\"\"\n    length = len(arr)\n    block_size = int(math.sqrt(length))\n    block_prev = 0\n    block = block_size\n    if arr[length - 1] < target:\n        return -1\n    while block <= length and arr[block - 1] < target:\n        block_prev = block\n        block += block_size\n    while arr[block_prev] < target:\n        block_prev += 1\n        if block_prev == min(block, length):\n            return -1\n    if arr[block_prev] == target:\n        return block_prev\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/__init__.py", "fileNameBase": "__init__", "extension": "py", "doc": {"short_description": "Collection of search algorithms: finding the needle in a haystack.", "full": "Collection of search algorithms: finding the needle in a haystack."}}, "dependencies": [{"from_module": "binary_search", "import": "binary_search", "type": "internal", "type_element": "function"}, {"from_module": "binary_search", "import": "binary_search_recur", "type": "internal", "type_element": "function"}, {"from_module": "ternary_search", "import": "ternary_search", "type": "internal", "type_element": "function"}, {"from_module": "first_occurrence", "import": "first_occurrence", "type": "internal", "type_element": "function"}, {"from_module": "last_occurrence", "import": "last_occurrence", "type": "internal", "type_element": "function"}, {"from_module": "linear_search", "import": "linear_search", "type": "internal", "type_element": "function"}, {"from_module": "search_insert", "import": "search_insert", "type": "internal", "type_element": "function"}, {"from_module": "two_sum", "import": "two_sum", "type": "internal", "type_element": "function"}, {"from_module": "two_sum", "import": "two_sum1", "type": "internal", "type_element": "function"}, {"from_module": "two_sum", "import": "two_sum2", "type": "internal", "type_element": "function"}, {"from_module": "search_range", "import": "search_range", "type": "internal", "type_element": "function"}, {"from_module": "find_min_rotate", "import": "find_min_rotate", "type": "internal", "type_element": "function"}, {"from_module": "find_min_rotate", "import": "find_min_rotate_recur", "type": "internal", "type_element": "function"}, {"from_module": "search_rotate", "import": "search_rotate", "type": "internal", "type_element": "function"}, {"from_module": "search_rotate", "import": "search_rotate_recur", "type": "internal", "type_element": "function"}, {"from_module": "jump_search", "import": "jump_search", "type": "internal", "type_element": "function"}, {"from_module": "next_greatest_letter", "import": "next_greatest_letter", "type": "internal", "type_element": "function"}, {"from_module": "next_greatest_letter", "import": "next_greatest_letter_v1", "type": "internal", "type_element": "function"}, {"from_module": "next_greatest_letter", "import": "next_greatest_letter_v2", "type": "internal", "type_element": "function"}, {"from_module": "interpolation_search", "import": "interpolation_search", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/search/linear_search.py", "fileNameBase": "linear_search", "extension": "py", "doc": {"long_description": "T(n): O(n)", "short_description": "Linear search works in any array.", "full": "Linear search works in any array.\nT(n): O(n)"}}, "functions": {"linear_search": {"doc": {"long_description": "There are no restrictions on the order of the elements in the array.\nIf the element couldn't be found, returns -1.", "short_description": "Find the index of the given element in the array."}, "args": ["array", "query"], "returns": ["-1", "i"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 16}, "calls": ["enumerate"], "source_code": "def linear_search(array, query):\n    \"\"\"\n    Find the index of the given element in the array.\n    There are no restrictions on the order of the elements in the array.\n    If the element couldn't be found, returns -1.\n    \"\"\"\n    for (i, value) in enumerate(array):\n        if value == query:\n            return i\n    return -1"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/queues": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/queues/moving_average.py", "fileNameBase": "moving_average", "extension": "py"}, "dependencies": [{"from_module": "__future__", "import": "division", "type": "external", "type_element": "module"}, {"from_module": "collections", "import": "deque", "type": "external", "type_element": "module"}], "classes": {"MovingAverage": {"extend": ["object"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 20}, "methods": {"__init__": {"doc": {"short_description": "Initialize your data structure here."}, "args": ["self", "size"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 12}, "calls": ["collections.deque"], "store_vars_calls": {"self.queue": "deque"}, "source_code": "def __init__(self, size):\n    \"\"\"\n        Initialize your data structure here.\n        :type size: int\n        \"\"\"\n    self.queue = deque(maxlen=size)"}, "next": {"args": ["self", "val"], "returns": ["sum(self.queue) / len(self.queue)"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 20}, "calls": ["moving_average.MovingAverage.queue.append", "sum", "len"], "source_code": "def next(self, val):\n    \"\"\"\n        :type val: int\n        :rtype: float\n        \"\"\"\n    self.queue.append(val)\n    return sum(self.queue) / len(self.queue)"}}}}, "body": {"calls": ["moving_average.MovingAverage.next"], "store_vars_calls": {"m": "MovingAverage"}, "source_code": ["MovingAverage(3)", "m.next(1)", "m.next(10)", "m.next(3)", "m.next(5)"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/queues/reconstruct_queue.py", "fileNameBase": "reconstruct_queue", "extension": "py"}, "functions": {"reconstruct_queue": {"args": ["people"], "returns": ["queue"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 28}, "calls": ["people.sort", "queue.insert"], "source_code": "def reconstruct_queue(people):\n    \"\"\"\n    :type people: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n    for (h, k) in people:\n        queue.insert(k, [h, k])\n    return queue"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/queues/zigzagiterator.py", "fileNameBase": "zigzagiterator", "extension": "py"}, "classes": {"ZigZagIterator": {"min_max_lineno": {"min_lineno": 1, "max_lineno": 28}, "methods": {"__init__": {"doc": {"short_description": "Initialize your data structure here."}, "args": ["self", "v1", "v2"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 10}, "calls": ["print"], "source_code": "def __init__(self, v1, v2):\n    \"\"\"\n        Initialize your data structure here.\n        :type v1: List[int]\n        :type v2: List[int]\n        \"\"\"\n    self.queue = [_ for _ in (v1, v2) if _]\n    print(self.queue)"}, "next": {"args": ["self"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 20}, "calls": ["zigzagiterator.ZigZagIterator.queue.pop", "zigzagiterator.ZigZagIterator.pop", "zigzagiterator.ZigZagIterator.queue.append"], "store_vars_calls": {"v": "self.queue.pop", "ret": "v.pop"}, "source_code": "def next(self):\n    \"\"\"\n        :rtype: int\n        \"\"\"\n    v = self.queue.pop(0)\n    ret = v.pop(0)\n    if v:\n        self.queue.append(v)\n    return ret"}, "has_next": {"args": ["self"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 28}, "source_code": "def has_next(self):\n    \"\"\"\n        :rtype: bool\n        \"\"\"\n    if self.queue:\n        return True\n    return False"}}}}, "body": {"calls": ["zigzagiterator.ZigZagIterator.has_next", "print", "zigzagiterator.ZigZagIterator.next"], "store_vars_calls": {"it": "ZigZagIterator"}, "source_code": ["ZigZagIterator(l1, l2)", "it.has_next()", "print(it.next())", "it.next()"]}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/queues/max_sliding_window.py", "fileNameBase": "max_sliding_window", "extension": "py", "doc": {"long_description": "Find the max elements of each of its sub-arrays of length k.\n\nKeep indexes of good candidates in deque d.\nThe indexes in d are from the current window, they're increasing,\nand their corresponding nums are decreasing.\nThen the first deque element is the index of the largest window value.\n\nFor each index i:\n\n1. Pop (from the end) indexes of smaller elements (they'll be useless).\n2. Append the current index.\n3. Pop (from the front) the index i - k, if it's still in the deque\n   (it falls out of the window).\n4. If our window has reached size k,\n   append the current window maximum to the output.", "short_description": "Given an array and a number k", "full": "Given an array and a number k\nFind the max elements of each of its sub-arrays of length k.\n\nKeep indexes of good candidates in deque d.\nThe indexes in d are from the current window, they're increasing,\nand their corresponding nums are decreasing.\nThen the first deque element is the index of the largest window value.\n\nFor each index i:\n\n1. Pop (from the end) indexes of smaller elements (they'll be useless).\n2. Append the current index.\n3. Pop (from the front) the index i - k, if it's still in the deque\n   (it falls out of the window).\n4. If our window has reached size k,\n   append the current window maximum to the output."}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"max_sliding_window": {"args": ["arr", "k"], "returns": ["result"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 35}, "calls": ["collections.deque", "enumerate", "collections.deque.append", "collections.deque.pop", "collections.deque.popleft", "result.append"], "store_vars_calls": {"qi": "collections.deque"}, "source_code": "def max_sliding_window(arr, k):\n    qi = collections.deque()\n    result = []\n    for (i, n) in enumerate(arr):\n        while qi and arr[qi[-1]] < n:\n            qi.pop()\n        qi.append(i)\n        if qi[0] == i - k:\n            qi.popleft()\n        if i >= k - 1:\n            result.append(arr[qi[0]])\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/queues/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "queue", "import": "AbstractQueue", "type": "internal", "type_element": "class"}, {"from_module": "queue", "import": "ArrayQueue", "type": "internal", "type_element": "class"}, {"from_module": "queue", "import": "QueueNode", "type": "internal", "type_element": "class"}, {"from_module": "queue", "import": "LinkedListQueue", "type": "internal", "type_element": "class"}, {"from_module": "max_sliding_window", "import": "max_sliding_window", "type": "internal", "type_element": "function"}, {"from_module": "reconstruct_queue", "import": "reconstruct_queue", "type": "internal", "type_element": "function"}, {"from_module": "priority_queue", "import": "PriorityQueueNode", "type": "internal", "type_element": "class"}, {"from_module": "priority_queue", "import": "PriorityQueue", "type": "internal", "type_element": "class"}], "is_test": false}], "output/keon/algorithms/algorithms/algorithms/greedy": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/greedy/max_contiguous_subsequence_sum.py", "fileNameBase": "max_contiguous_subsequence_sum", "extension": "py", "doc": {"long_description": "kadane's algorithm is used for finding the maximum sum of contiguous subsequence in a sequence.\nIt is considered a greedy/dp algorithm but I think they more greedy than dp\nhere are some of the examples to understand the use case more clearly\nExample1 => [-2, 3, 8, -1, 4]\nresult =>  {3, 8, -1, 4} => 14\nExample2 => [-1, 1, 0]\nresult => {1} => 1\nExample3 => [-1, -3, -4]\nresult => -1\nExample1 => [-2, 3, 8, -12, 8, 4]\nresult =>  {8, 4} => 12\nBasic Algorithm Idea\n    If the sum of the current contiguous subsequence after adding the value at the current position is less than the value\n    at the current position then we know that it will be better if we start the current contiguous subsequence from this position.\n    Else we add the value at the current position to the current contiguous subsequence.\nNote\n    In the implementation, the contiguous subsequence has at least one element.\n    If it can have 0 elements then the result will be max(max_till_now, 0)", "short_description": "Algorithm used => Kadane's Algorithm", "full": "Algorithm used => Kadane's Algorithm\n\nkadane's algorithm is used for finding the maximum sum of contiguous subsequence in a sequence.\nIt is considered a greedy/dp algorithm but I think they more greedy than dp\nhere are some of the examples to understand the use case more clearly\nExample1 => [-2, 3, 8, -1, 4]\nresult =>  {3, 8, -1, 4} => 14\nExample2 => [-1, 1, 0]\nresult => {1} => 1\nExample3 => [-1, -3, -4]\nresult => -1\nExample1 => [-2, 3, 8, -12, 8, 4]\nresult =>  {8, 4} => 12\nBasic Algorithm Idea\n    If the sum of the current contiguous subsequence after adding the value at the current position is less than the value\n    at the current position then we know that it will be better if we start the current contiguous subsequence from this position.\n    Else we add the value at the current position to the current contiguous subsequence.\nNote\n    In the implementation, the contiguous subsequence has at least one element.\n    If it can have 0 elements then the result will be max(max_till_now, 0)"}}, "functions": {"max_contiguous_subsequence_sum": {"args": ["arr"], "annotated_return_type": "int", "returns": ["max_till_now", "0"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 43}, "calls": ["len", "range", "max"], "store_vars_calls": {"arr_size": "len", "max_till_now": "max"}, "source_code": "def max_contiguous_subsequence_sum(arr) -> int:\n    arr_size = len(arr)\n    if arr_size == 0:\n        return 0\n    max_till_now = arr[0]\n    curr_sub_sum = 0\n    for i in range(0, arr_size):\n        if curr_sub_sum + arr[i] < arr[i]:\n            curr_sub_sum = arr[i]\n        else:\n            curr_sub_sum += arr[i]\n        max_till_now = max(max_till_now, curr_sub_sum)\n    return max_till_now"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/greedy/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "max_contiguous_subsequence_sum", "import": "max_contiguous_subsequence_sum", "type": "internal", "type_element": "function"}], "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/lowest_common_ancestor.py", "fileNameBase": "lowest_common_ancestor", "extension": "py", "doc": {"long_description": "(LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two nodes\n    v and w as the lowest node in T that has both v and w as\n    descendants\n    (where we allow a node to be a descendant of itself).\u201d\n\n        _______3______\n       /                  ___5__          ___1__\n   /      \\        /         6      _2       0       8\n         /           7   4\nFor example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3.\nAnother example is LCA of nodes 5 and 4 is 5,\nsince a node can be a descendant of itself according to the LCA definition.", "short_description": "Given a binary tree, find the lowest common ancestor", "full": "Given a binary tree, find the lowest common ancestor\n(LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two nodes\n    v and w as the lowest node in T that has both v and w as\n    descendants\n    (where we allow a node to be a descendant of itself).\u201d\n\n        _______3______\n       /                  ___5__          ___1__\n   /      \\        /         6      _2       0       8\n         /           7   4\nFor example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3.\nAnother example is LCA of nodes 5 and 4 is 5,\nsince a node can be a descendant of itself according to the LCA definition."}}, "functions": {"lca": {"args": ["root", "p", "q"], "returns": ["left if left else right", "root", "root"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 38}, "calls": ["lowest_common_ancestor.lca"], "store_vars_calls": {"left": "lca", "right": "lca"}, "source_code": "def lca(root, p, q):\n    \"\"\"\n    :type root: TreeNode\n    :type p: TreeNode\n    :type q: TreeNode\n    :rtype: TreeNode\n    \"\"\"\n    if root is None or root is p or root is q:\n        return root\n    left = lca(root.left, p, q)\n    right = lca(root.right, p, q)\n    if left is not None and right is not None:\n        return root\n    return left if left else right"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/pretty_print.py", "fileNameBase": "pretty_print", "extension": "py"}, "dependencies": [{"from_module": "__future__", "import": "print_function", "type": "external", "type_element": "module"}], "functions": {"tree_print": {"args": ["tree"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 24}, "calls": ["print", "type"], "source_code": "def tree_print(tree):\n    for key in tree:\n        print(key, end=' ')\n        tree_element = tree[key]\n        for subElem in tree_element:\n            print(' -> ', subElem, end=' ')\n            if type(subElem) != str:\n                print('\\n ')\n        print()"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/min_height.py", "fileNameBase": "min_height", "extension": "py"}, "dependencies": [{"from_module": "tree", "import": "TreeNode", "type": "internal", "type_element": "module"}], "functions": {"min_depth": {"args": ["self", "root"], "returns": ["min(self.minDepth(root.left), self.minDepth(root.right)) + 1", "0", "max(self.minDepth(root.left), self.minDepth(root.right)) + 1"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 14}, "calls": ["min", "max", "min_height..minDepth"], "source_code": "def min_depth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right)) + 1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, "min_height": {"args": ["root"], "returns": ["height", "0", "height"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 34}, "calls": ["new_level.append"], "source_code": "def min_height(root):\n    if root is None:\n        return 0\n    height = 0\n    level = [root]\n    while level:\n        height += 1\n        new_level = []\n        for node in level:\n            if node.left is None and node.right is None:\n                return height\n            if node.left is not None:\n                new_level.append(node.left)\n            if node.right is not None:\n                new_level.append(node.right)\n        level = new_level\n    return height"}, "print_tree": {"args": ["root"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 41}, "calls": ["print", "min_height.print_tree"], "source_code": "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)"}}, "body": {"calls": ["tree.TreeNode", "min_height.min_height", "min_height.print_tree", "print"], "store_vars_calls": {"tree": "TreeNode", "tree.left": "TreeNode", "tree.right": "TreeNode", "tree.left.left": "TreeNode", "tree.left.left.right": "TreeNode", "tree.left.right": "TreeNode", "tree.right.left": "TreeNode", "height": "min_height"}, "source_code": ["TreeNode(10)", "TreeNode(12)", "TreeNode(15)", "TreeNode(25)", "TreeNode(100)", "TreeNode(30)", "TreeNode(36)", "min_height(tree)", "print_tree(tree)", "print('height:', height)"]}, "main_info": {"main_flag": 1, "main_function": "min_height.TreeNode", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/max_height.py", "fileNameBase": "max_height", "extension": "py", "doc": {"long_description": "The maximum depth is the number of nodes along the\nlongest path from the root node down to the farthest leaf node.", "short_description": "Given a binary tree, find its maximum depth.", "full": "Given a binary tree, find its maximum depth.\n\nThe maximum depth is the number of nodes along the\nlongest path from the root node down to the farthest leaf node."}}, "dependencies": [{"from_module": "tree", "import": "TreeNode", "type": "internal", "type_element": "module"}], "functions": {"max_height": {"args": ["root"], "returns": ["height", "0"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 34}, "calls": ["queue.pop", "level.append"], "store_vars_calls": {"node": "queue.pop"}, "source_code": "def max_height(root):\n    if root is None:\n        return 0\n    height = 0\n    queue = [root]\n    while queue:\n        height += 1\n        level = []\n        while queue:\n            node = queue.pop(0)\n            if node.left is not None:\n                level.append(node.left)\n            if node.right is not None:\n                level.append(node.right)\n        queue = level\n    return height"}, "print_tree": {"args": ["root"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 41}, "calls": ["print", "max_height.print_tree"], "source_code": "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)"}}, "body": {"calls": ["tree.TreeNode", "max_height.max_height", "max_height.print_tree", "print"], "store_vars_calls": {"tree": "TreeNode", "tree.left": "TreeNode", "tree.right": "TreeNode", "tree.left.left": "TreeNode", "tree.left.left.right": "TreeNode", "tree.left.right": "TreeNode", "tree.right.left": "TreeNode", "height": "max_height"}, "source_code": ["TreeNode(10)", "TreeNode(12)", "TreeNode(15)", "TreeNode(25)", "TreeNode(100)", "TreeNode(30)", "TreeNode(36)", "max_height(tree)", "print_tree(tree)", "print('height:', height)"]}, "main_info": {"main_flag": 1, "main_function": "max_height.TreeNode", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/same_tree.py", "fileNameBase": "same_tree", "extension": "py", "doc": {"long_description": "if they are equal or not.\n\nTwo binary trees are considered equal if they are\nstructurally identical and the nodes have the same value.", "short_description": "Given two binary trees, write a function to check", "full": "Given two binary trees, write a function to check\nif they are equal or not.\n\nTwo binary trees are considered equal if they are\nstructurally identical and the nodes have the same value."}}, "functions": {"is_same_tree": {"args": ["tree_p", "tree_q"], "returns": ["False", "True", "is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 16}, "calls": ["same_tree.is_same_tree"], "source_code": "def is_same_tree(tree_p, tree_q):\n    if tree_p is None and tree_q is None:\n        return True\n    if tree_p is not None and tree_q is not None and (tree_p.val == tree_q.val):\n        return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/path_sum.py", "fileNameBase": "path_sum", "extension": "py", "doc": {"long_description": "path such that adding up all the values along the path equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\              7    2      1\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.", "short_description": "Given a binary tree and a sum, determine if the tree has a root-to-leaf", "full": "Given a binary tree and a sum, determine if the tree has a root-to-leaf\npath such that adding up all the values along the path equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\              7    2      1\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22."}}, "functions": {"has_path_sum": {"args": ["root", "sum"], "returns": ["has_path_sum(root.left, sum) or has_path_sum(root.right, sum)", "False", "True"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 30}, "calls": ["path_sum.has_path_sum"], "source_code": "def has_path_sum(root, sum):\n    \"\"\"\n    :type root: TreeNode\n    :type sum: int\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return False\n    if root.left is None and root.right is None and (root.val == sum):\n        return True\n    sum -= root.val\n    return has_path_sum(root.left, sum) or has_path_sum(root.right, sum)"}, "has_path_sum2": {"args": ["root", "sum"], "returns": ["False", "False", "True"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 47}, "calls": ["stack.pop", "stack.append"], "source_code": "def has_path_sum2(root, sum):\n    if root is None:\n        return False\n    stack = [(root, root.val)]\n    while stack:\n        (node, val) = stack.pop()\n        if node.left is None and node.right is None:\n            if val == sum:\n                return True\n        if node.left is not None:\n            stack.append((node.left, val + node.left.val))\n        if node.right is not None:\n            stack.append((node.right, val + node.right.val))\n    return False"}, "has_path_sum3": {"args": ["root", "sum"], "returns": ["False", "False", "True"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 64}, "calls": ["queue.pop", "queue.append"], "source_code": "def has_path_sum3(root, sum):\n    if root is None:\n        return False\n    queue = [(root, sum - root.val)]\n    while queue:\n        (node, val) = queue.pop(0)\n        if node.left is None and node.right is None:\n            if val == 0:\n                return True\n        if node.left is not None:\n            queue.append((node.left, val - node.left.val))\n        if node.right is not None:\n            queue.append((node.right, val - node.right.val))\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/path_sum2.py", "fileNameBase": "path_sum2", "extension": "py", "doc": {"long_description": "paths where each path's sum equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\    /         7    2  5   1\nreturn\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]", "short_description": "Given a binary tree and a sum, find all root-to-leaf", "full": "Given a binary tree and a sum, find all root-to-leaf\npaths where each path's sum equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             /             4   8\n           /   /           11  13  4\n         /  \\    /         7    2  5   1\nreturn\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]"}}, "functions": {"path_sum": {"args": ["root", "sum"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 28}, "calls": ["path_sum2.dfs"], "source_code": "def path_sum(root, sum):\n    if root is None:\n        return []\n    res = []\n    dfs(root, sum, [], res)\n    return res"}, "dfs": {"args": ["root", "sum", "ls", "res"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 38}, "calls": ["ls.append", "res.append", "path_sum2.dfs"], "source_code": "def dfs(root, sum, ls, res):\n    if root.left is None and root.right is None and (root.val == sum):\n        ls.append(root.val)\n        res.append(ls)\n    if root.left is not None:\n        dfs(root.left, sum - root.val, ls + [root.val], res)\n    if root.right is not None:\n        dfs(root.right, sum - root.val, ls + [root.val], res)"}, "path_sum2": {"args": ["root", "s"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 55}, "calls": ["stack.pop", "res.append", "stack.append", "sum"], "source_code": "def path_sum2(root, s):\n    if root is None:\n        return []\n    res = []\n    stack = [(root, [root.val])]\n    while stack:\n        (node, ls) = stack.pop()\n        if node.left is None and node.right is None and (sum(ls) == s):\n            res.append(ls)\n        if node.left is not None:\n            stack.append((node.left, ls + [node.left.val]))\n        if node.right is not None:\n            stack.append((node.right, ls + [node.right.val]))\n    return res"}, "path_sum3": {"args": ["root", "sum"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 72}, "calls": ["queue.pop", "res.append", "queue.append"], "source_code": "def path_sum3(root, sum):\n    if root is None:\n        return []\n    res = []\n    queue = [(root, root.val, [root.val])]\n    while queue:\n        (node, val, ls) = queue.pop(0)\n        if node.left is None and node.right is None and (val == sum):\n            res.append(ls)\n        if node.left is not None:\n            queue.append((node.left, val + node.left.val, ls + [node.left.val]))\n        if node.right is not None:\n            queue.append((node.right, val + node.right.val, ls + [node.right.val]))\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/construct_tree_postorder_preorder.py", "fileNameBase": "construct_tree_postorder_preorder", "extension": "py", "doc": {"long_description": "binary tree, construct the binary tree and print the inorder traversal of the\ntree.\nA full binary tree has either 0 or 2 children.\nAlgorithm:\n    1. Assign the first element of preorder array as root of the tree.\n    2. Find the same element in the postorder array and divide the postorder\n        array into left and right subtree.\n    3. Repeat the above steps for all the elements and construct the tree.\nEg: pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7}\n    post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1}\n    Tree:\n            1\n          /                2     3\n        / \\   /            4   5 6   7\n      /          8   9\n  Output: 8 4 9 2 5 1 6 3 7", "short_description": "Given two arrays representing preorder and postorder traversal of a full", "full": "Given two arrays representing preorder and postorder traversal of a full\nbinary tree, construct the binary tree and print the inorder traversal of the\ntree.\nA full binary tree has either 0 or 2 children.\nAlgorithm:\n    1. Assign the first element of preorder array as root of the tree.\n    2. Find the same element in the postorder array and divide the postorder\n        array into left and right subtree.\n    3. Repeat the above steps for all the elements and construct the tree.\nEg: pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7}\n    post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1}\n    Tree:\n            1\n          /                2     3\n        / \\   /            4   5 6   7\n      /          8   9\n  Output: 8 4 9 2 5 1 6 3 7"}}, "classes": {"TreeNode": {"min_max_lineno": {"min_lineno": 24, "max_lineno": 30}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 30}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}}, "functions": {"construct_tree_util": {"doc": {"long_description": "preIndex is a global variable that keeps track of the index in preorder\narray.\npreorder and postorder array are represented are pre[] and post[] respectively.\nlow and high are the indices for the postorder array.", "short_description": "Recursive function that constructs tree from preorder and postorder array."}, "args": ["pre", "post", "low", "high", "size"], "annotated_arg_types": {"pre": "list", "post": "list", "low": "int", "high": "int", "size": "int"}, "returns": ["root", "None", "root"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 75}, "calls": ["construct_tree_postorder_preorder.construct_tree_util"], "store_vars_calls": {"root": "TreeNode", "root.left": "construct_tree_util", "root.right": "construct_tree_util"}, "source_code": "def construct_tree_util(pre: list, post: list, low: int, high: int, size: int):\n    \"\"\"\n        Recursive function that constructs tree from preorder and postorder array.\n        \n        preIndex is a global variable that keeps track of the index in preorder\n        array.\n        preorder and postorder array are represented are pre[] and post[] respectively.\n        low and high are the indices for the postorder array.\n    \"\"\"\n    global pre_index\n    if pre_index == -1:\n        pre_index = 0\n    if pre_index >= size or low > high:\n        return None\n    root = TreeNode(pre[pre_index])\n    pre_index += 1\n    if low == high or pre_index >= size:\n        return root\n    i = low\n    while i <= high:\n        if pre[pre_index] == post[i]:\n            break\n        i += 1\n    if i <= high:\n        root.left = construct_tree_util(pre, post, low, i, size)\n        root.right = construct_tree_util(pre, post, i + 1, high, size)\n    return root"}, "construct_tree": {"doc": {"long_description": "and postorder array.", "short_description": "Main Function that will construct the full binary tree from given preorder"}, "args": ["pre", "post", "size"], "annotated_arg_types": {"pre": "list", "post": "list", "size": "int"}, "returns": ["print_inorder(root)"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 87}, "calls": ["construct_tree_postorder_preorder.construct_tree_util", "construct_tree_postorder_preorder.print_inorder"], "store_vars_calls": {"root": "construct_tree_util"}, "source_code": "def construct_tree(pre: list, post: list, size: int):\n    \"\"\"\n        Main Function that will construct the full binary tree from given preorder\n        and postorder array.\n    \"\"\"\n    global pre_index\n    root = construct_tree_util(pre, post, 0, size - 1, size)\n    return print_inorder(root)"}, "print_inorder": {"doc": {"short_description": "Prints the tree constructed in inorder format"}, "args": ["root", "result"], "annotated_arg_types": {"root": "TreeNode"}, "returns": ["result", "[]"], "min_max_lineno": {"min_lineno": 90, "max_lineno": 103}, "calls": ["construct_tree_postorder_preorder.print_inorder", "result.append"], "source_code": "def print_inorder(root: TreeNode, result=None):\n    \"\"\"\n        Prints the tree constructed in inorder format\n    \"\"\"\n    if root is None:\n        return []\n    if result is None:\n        result = []\n    print_inorder(root.left, result)\n    result.append(root.val)\n    print_inorder(root.right, result)\n    return result"}}, "body": {"calls": ["len", "construct_tree_postorder_preorder.construct_tree", "print"], "store_vars_calls": {"size": "len", "result": "construct_tree"}, "source_code": ["len(pre)", "construct_tree(pre, post, size)", "print(result)"]}, "main_info": {"main_flag": 1, "main_function": "construct_tree_postorder_preorder.len", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/is_symmetric.py", "fileNameBase": "is_symmetric", "extension": "py", "doc": {"long_description": "itself (ie, symmetric around its center).\n\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n    1\n   /   2   2\n / \\ / 3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   /   2   2\n   \\      3    3\nNote:\nBonus points if you could solve it both recursively and iteratively.", "short_description": "Given a binary tree, check whether it is a mirror of", "full": "Given a binary tree, check whether it is a mirror of\nitself (ie, symmetric around its center).\n\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n    1\n   /   2   2\n / \\ / 3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   /   2   2\n   \\      3    3\nNote:\nBonus points if you could solve it both recursively and iteratively."}}, "functions": {"is_symmetric": {"args": ["root"], "returns": ["helper(root.left, root.right)", "True"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 27}, "calls": ["is_symmetric.helper"], "source_code": "def is_symmetric(root):\n    if root is None:\n        return True\n    return helper(root.left, root.right)"}, "helper": {"args": ["p", "q"], "returns": ["helper(p.left, q.right) and helper(p.right, q.left)", "True", "False"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 35}, "calls": ["is_symmetric.helper"], "source_code": "def helper(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None or q is not None or q.val != p.val:\n        return False\n    return helper(p.left, q.right) and helper(p.right, q.left)"}, "is_symmetric_iterative": {"args": ["root"], "returns": ["True", "True", "False", "False"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 53}, "calls": ["stack.pop", "stack.append"], "source_code": "def is_symmetric_iterative(root):\n    if root is None:\n        return True\n    stack = [[root.left, root.right]]\n    while stack:\n        (left, right) = stack.pop()\n        if left is None and right is None:\n            continue\n        if left is None or right is None:\n            return False\n        if left.val == right.val:\n            stack.append([left.left, right.right])\n            stack.append([left.right, right.left])\n        else:\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/is_balanced.py", "fileNameBase": "is_balanced", "extension": "py"}, "functions": {"is_balanced": {"args": ["root"], "returns": ["__is_balanced_recursive(root)"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 3}, "calls": ["is_balanced.__is_balanced_recursive"], "source_code": "def is_balanced(root):\n    return __is_balanced_recursive(root)"}, "__is_balanced_recursive": {"doc": {"short_description": "O(N) solution"}, "args": ["root"], "returns": ["-1 != __get_depth(root)"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 10}, "calls": ["is_balanced.__get_depth"], "source_code": "def __is_balanced_recursive(root):\n    \"\"\"\n    O(N) solution\n    \"\"\"\n    return -1 != __get_depth(root)"}, "__get_depth": {"doc": {"short_description": "return 0 if unbalanced else depth + 1"}, "args": ["root"], "returns": ["1 + max(left, right)", "0", "-1"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 23}, "calls": ["is_balanced.__get_depth", "max", "abs"], "store_vars_calls": {"left": "__get_depth", "right": "__get_depth"}, "source_code": "def __get_depth(root):\n    \"\"\"\n    return 0 if unbalanced else depth + 1\n    \"\"\"\n    if root is None:\n        return 0\n    left = __get_depth(root.left)\n    right = __get_depth(root.right)\n    if abs(left - right) > 1 or -1 in [left, right]:\n        return -1\n    return 1 + max(left, right)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/tree.py", "fileNameBase": "tree", "extension": "py"}, "classes": {"TreeNode": {"min_max_lineno": {"min_lineno": 1, "max_lineno": 6}, "methods": {"__init__": {"args": ["self", "val"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 6}, "source_code": "def __init__(self, val=0):\n    self.val = val\n    self.left = None\n    self.right = None"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/binary_tree_paths.py", "fileNameBase": "binary_tree_paths", "extension": "py"}, "functions": {"binary_tree_paths": {"args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 7}, "calls": ["binary_tree_paths.dfs", "str"], "source_code": "def binary_tree_paths(root):\n    res = []\n    if root is None:\n        return res\n    dfs(res, root, str(root.val))\n    return res"}, "dfs": {"args": ["res", "root", "cur"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 16}, "calls": ["res.append", "binary_tree_paths.dfs", "str"], "source_code": "def dfs(res, root, cur):\n    if root.left is None and root.right is None:\n        res.append(cur)\n    if root.left:\n        dfs(res, root.left, cur + '->' + str(root.left.val))\n    if root.right:\n        dfs(res, root.right, cur + '->' + str(root.right.val))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/b_tree.py", "fileNameBase": "b_tree", "extension": "py", "doc": {"long_description": "at least t-1 keys (t children) and at most 2*t - 1 keys (2*t children)\nwhere t is the degree of b-tree. It is not a kind of typical bst tree, because\nthis tree grows up.\nB-tree is balanced which means that the difference between height of left\nsubtree and right subtree is at most 1.\n\nComplexity\n    n - number of elements\n    t - degree of tree\n    Tree always has height at most logt (n+1)/2\n    Algorithm        Average        Worst case\n    Space            O(n)           O(n)\n    Search           O(log n)       O(log n)\n    Insert           O(log n)       O(log n)\n    Delete           O(log n)       O(log n)", "short_description": "B-tree is used to disk operations. Each node (except root) contains", "full": "B-tree is used to disk operations. Each node (except root) contains\nat least t-1 keys (t children) and at most 2*t - 1 keys (2*t children)\nwhere t is the degree of b-tree. It is not a kind of typical bst tree, because\nthis tree grows up.\nB-tree is balanced which means that the difference between height of left\nsubtree and right subtree is at most 1.\n\nComplexity\n    n - number of elements\n    t - degree of tree\n    Tree always has height at most logt (n+1)/2\n    Algorithm        Average        Worst case\n    Space            O(n)           O(n)\n    Search           O(log n)       O(log n)\n    Insert           O(log n)       O(log n)\n    Delete           O(log n)       O(log n)"}}, "classes": {"Node": {"doc": {"short_description": "Class of Node", "full": "Class of Node"}, "min_max_lineno": {"min_lineno": 21, "max_lineno": 36}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 28}, "source_code": "def __init__(self):\n    self.keys = []\n    self.children = []"}, "__repr__": {"args": ["self"], "returns": ["'<id_node: {0}>'.format(self.keys)"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 31}, "source_code": "def __repr__(self):\n    return '<id_node: {0}>'.format(self.keys)"}, "is_leaf": {"doc": {"short_description": "Return if it is a leaf"}, "args": ["self"], "returns": ["len(self.children) == 0"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 36}, "calls": ["len"], "source_code": "@property\ndef is_leaf(self):\n    \"\"\" Return if it is a leaf\"\"\"\n    return len(self.children) == 0"}}}, "BTree": {"doc": {"short_description": "Class of BTree ", "full": "Class of BTree "}, "min_max_lineno": {"min_lineno": 38, "max_lineno": 252}, "methods": {"__init__": {"args": ["self", "t_val"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 46}, "store_vars_calls": {"self.root": "Node"}, "source_code": "def __init__(self, t_val=2):\n    self.min_numbers_of_keys = t_val - 1\n    self.max_number_of_keys = 2 * t_val - 1\n    self.root = Node()"}, "_split_child": {"args": ["self", "parent", "child_index"], "annotated_arg_types": {"parent": "Node", "child_index": "int"}, "min_max_lineno": {"min_lineno": 47, "max_lineno": 62}, "calls": ["parent.keys.insert", "parent.children.insert"], "store_vars_calls": {"new_right_child": "Node"}, "source_code": "def _split_child(self, parent: Node, child_index: int):\n    new_right_child = Node()\n    half_max = self.max_number_of_keys // 2\n    child = parent.children[child_index]\n    middle_key = child.keys[half_max]\n    new_right_child.keys = child.keys[half_max + 1:]\n    child.keys = child.keys[:half_max]\n    if not child.is_leaf:\n        new_right_child.children = child.children[half_max + 1:]\n        child.children = child.children[:half_max + 1]\n    parent.keys.insert(child_index, middle_key)\n    parent.children.insert(child_index + 1, new_right_child)"}, "insert_key": {"doc": {"short_description": "overflow, tree increases in height "}, "args": ["self", "key"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 73}, "calls": ["len", "Node.children.append", "b_tree.BTree._split_child", "b_tree.BTree._insert_to_nonfull_node"], "store_vars_calls": {"new_root": "Node"}, "source_code": "def insert_key(self, key):\n    \"\"\" overflow, tree increases in height \"\"\"\n    if len(self.root.keys) >= self.max_number_of_keys:\n        new_root = Node()\n        new_root.children.append(self.root)\n        self.root = new_root\n        self._split_child(new_root, 0)\n        self._insert_to_nonfull_node(self.root, key)\n    else:\n        self._insert_to_nonfull_node(self.root, key)"}, "_insert_to_nonfull_node": {"args": ["self", "node", "key"], "annotated_arg_types": {"node": "Node"}, "min_max_lineno": {"min_lineno": 74, "max_lineno": 90}, "calls": ["len", "node.keys.insert", "b_tree.BTree._insert_to_nonfull_node", "b_tree.BTree._split_child"], "source_code": "def _insert_to_nonfull_node(self, node: Node, key):\n    i = len(node.keys) - 1\n    while i >= 0 and node.keys[i] >= key:\n        i -= 1\n    if node.is_leaf:\n        node.keys.insert(i + 1, key)\n    else:\n        if len(node.children[i + 1].keys) >= self.max_number_of_keys:\n            self._split_child(node, i + 1)\n            if node.keys[i + 1] < key:\n                i += 1\n        self._insert_to_nonfull_node(node.children[i + 1], key)"}, "find": {"doc": {"short_description": "Finds key "}, "args": ["self", "key"], "annotated_return_type": "bool", "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 91, "max_lineno": 103}, "calls": ["len"], "source_code": "def find(self, key) -> bool:\n    \"\"\" Finds key \"\"\"\n    current_node = self.root\n    while True:\n        i = len(current_node.keys) - 1\n        while i >= 0 and current_node.keys[i] > key:\n            i -= 1\n        if i >= 0 and current_node.keys[i] == key:\n            return True\n        if current_node.is_leaf:\n            return False\n        current_node = current_node.children[i + 1]"}, "remove_key": {"args": ["self", "key"], "min_max_lineno": {"min_lineno": 104, "max_lineno": 106}, "calls": ["b_tree.BTree._remove_key"], "source_code": "def remove_key(self, key):\n    self._remove_key(self.root, key)"}, "_remove_key": {"args": ["self", "node", "key"], "annotated_arg_types": {"node": "Node"}, "annotated_return_type": "bool", "returns": ["True", "False", "self._remove_key(node, key)", "self._remove_key(node.children[i], key)"], "min_max_lineno": {"min_lineno": 107, "max_lineno": 132}, "calls": ["node.keys.index", "node.keys.remove", "b_tree.BTree._remove_from_nonleaf_node", "print", "len", "b_tree.BTree._repair_tree", "b_tree.BTree._remove_key"], "store_vars_calls": {"key_index": "node.keys.index", "number_of_keys": "len", "action_performed": "self._repair_tree"}, "source_code": "def _remove_key(self, node: Node, key) -> bool:\n    try:\n        key_index = node.keys.index(key)\n        if node.is_leaf:\n            node.keys.remove(key)\n        else:\n            self._remove_from_nonleaf_node(node, key_index)\n        return True\n    except ValueError:\n        if node.is_leaf:\n            print('Key not found.')\n            return False\n        else:\n            i = 0\n            number_of_keys = len(node.keys)\n            while i < number_of_keys and key > node.keys[i]:\n                i += 1\n            action_performed = self._repair_tree(node, i)\n            if action_performed:\n                return self._remove_key(node, key)\n            else:\n                return self._remove_key(node.children[i], key)"}, "_repair_tree": {"args": ["self", "node", "child_index"], "annotated_arg_types": {"node": "Node", "child_index": "int"}, "annotated_return_type": "bool", "returns": ["True", "False", "True", "True"], "min_max_lineno": {"min_lineno": 133, "max_lineno": 156}, "calls": ["len", "b_tree.BTree._rotate_right", "b_tree.BTree._rotate_left", "b_tree.BTree._merge"], "source_code": "def _repair_tree(self, node: Node, child_index: int) -> bool:\n    child = node.children[child_index]\n    if self.min_numbers_of_keys < len(child.keys) <= self.max_number_of_keys:\n        return False\n    if child_index > 0 and len(node.children[child_index - 1].keys) > self.min_numbers_of_keys:\n        self._rotate_right(node, child_index)\n        return True\n    if child_index < len(node.children) - 1 and len(node.children[child_index + 1].keys) > self.min_numbers_of_keys:\n        self._rotate_left(node, child_index)\n        return True\n    if child_index > 0:\n        self._merge(node, child_index - 1, child_index)\n    else:\n        self._merge(node, child_index, child_index + 1)\n    return True"}, "_rotate_left": {"doc": {"short_description": "Take key from right brother of the child and transfer to the child"}, "args": ["self", "parent_node", "child_index"], "annotated_arg_types": {"parent_node": "Node", "child_index": "int"}, "min_max_lineno": {"min_lineno": 157, "max_lineno": 172}, "calls": ["parent_node.children[].keys.pop", "parent_node.children[].keys.append", "parent_node.children[].children.pop", "parent_node.children[].children.append"], "store_vars_calls": {"new_parent_key": "parent_node.children[].keys.pop", "ownerless_child": "parent_node.children[].children.pop"}, "source_code": "def _rotate_left(self, parent_node: Node, child_index: int):\n    \"\"\"\n        Take key from right brother of the child and transfer to the child\n        \"\"\"\n    new_child_key = parent_node.keys[child_index]\n    new_parent_key = parent_node.children[child_index + 1].keys.pop(0)\n    parent_node.children[child_index].keys.append(new_child_key)\n    parent_node.keys[child_index] = new_parent_key\n    if not parent_node.children[child_index + 1].is_leaf:\n        ownerless_child = parent_node.children[child_index + 1].children.pop(0)\n        parent_node.children[child_index].children.append(ownerless_child)"}, "_rotate_right": {"doc": {"short_description": "Take key from left brother of the child and transfer to the child"}, "args": ["self", "parent_node", "child_index"], "annotated_arg_types": {"parent_node": "Node", "child_index": "int"}, "min_max_lineno": {"min_lineno": 173, "max_lineno": 189}, "calls": ["parent_node.children[].keys.pop", "parent_node.children[].keys.insert", "parent_node.children[].children.pop", "parent_node.children[].children.insert"], "store_vars_calls": {"new_parent_key": "parent_node.children[].keys.pop", "ownerless_child": "parent_node.children[].children.pop"}, "source_code": "def _rotate_right(self, parent_node: Node, child_index: int):\n    \"\"\"\n        Take key from left brother of the child and transfer to the child\n        \"\"\"\n    parent_key = parent_node.keys[child_index - 1]\n    new_parent_key = parent_node.children[child_index - 1].keys.pop()\n    parent_node.children[child_index].keys.insert(0, parent_key)\n    parent_node.keys[child_index - 1] = new_parent_key\n    if not parent_node.children[child_index - 1].is_leaf:\n        ownerless_child = parent_node.children[child_index - 1].children.pop()\n        parent_node.children[child_index].children.insert(0, ownerless_child)"}, "_merge": {"args": ["self", "parent_node", "to_merge_index", "transfered_child_index"], "annotated_arg_types": {"parent_node": "Node", "to_merge_index": "int", "transfered_child_index": "int"}, "min_max_lineno": {"min_lineno": 190, "max_lineno": 202}, "calls": ["parent_node.children.pop", "parent_node.keys.pop", "to_merge_node.keys.append", "to_merge_node.keys.extend", "to_merge_node.children.extend"], "store_vars_calls": {"from_merge_node": "parent_node.children.pop", "parent_key_to_merge": "parent_node.keys.pop"}, "source_code": "def _merge(self, parent_node: Node, to_merge_index: int, transfered_child_index: int):\n    from_merge_node = parent_node.children.pop(transfered_child_index)\n    parent_key_to_merge = parent_node.keys.pop(to_merge_index)\n    to_merge_node = parent_node.children[to_merge_index]\n    to_merge_node.keys.append(parent_key_to_merge)\n    to_merge_node.keys.extend(from_merge_node.keys)\n    if not to_merge_node.is_leaf:\n        to_merge_node.children.extend(from_merge_node.children)\n    if parent_node == self.root and (not parent_node.keys):\n        self.root = to_merge_node"}, "_remove_from_nonleaf_node": {"args": ["self", "node", "key_index"], "annotated_arg_types": {"node": "Node", "key_index": "int"}, "returns": ["self._remove_key(node, key)"], "min_max_lineno": {"min_lineno": 203, "max_lineno": 217}, "calls": ["len", "b_tree.BTree._find_largest_and_delete_in_left_subtree", "b_tree.BTree._find_largest_and_delete_in_right_subtree", "b_tree.BTree._merge", "b_tree.BTree._remove_key"], "store_vars_calls": {"largest_key": "self._find_largest_and_delete_in_right_subtree"}, "source_code": "def _remove_from_nonleaf_node(self, node: Node, key_index: int):\n    key = node.keys[key_index]\n    left_subtree = node.children[key_index]\n    if len(left_subtree.keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_left_subtree(left_subtree)\n    elif len(node.children[key_index + 1].keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_right_subtree(node.children[key_index + 1])\n    else:\n        self._merge(node, key_index, key_index + 1)\n        return self._remove_key(node, key)\n    node.keys[key_index] = largest_key"}, "_find_largest_and_delete_in_left_subtree": {"args": ["self", "node"], "annotated_arg_types": {"node": "Node"}, "returns": ["node.keys.pop()", "largest_key_in_subtree"], "min_max_lineno": {"min_lineno": 218, "max_lineno": 228}, "calls": ["node.keys.pop", "b_tree.BTree._repair_tree", "b_tree.BTree._find_largest_and_delete_in_left_subtree", "len"], "store_vars_calls": {"largest_key_in_subtree": "self._find_largest_and_delete_in_left_subtree"}, "source_code": "def _find_largest_and_delete_in_left_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop()\n    else:\n        ch_index = len(node.children) - 1\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_left_subtree(node.children[len(node.children) - 1])\n        return largest_key_in_subtree"}, "_find_largest_and_delete_in_right_subtree": {"args": ["self", "node"], "annotated_arg_types": {"node": "Node"}, "returns": ["node.keys.pop(0)", "largest_key_in_subtree"], "min_max_lineno": {"min_lineno": 229, "max_lineno": 239}, "calls": ["node.keys.pop", "b_tree.BTree._repair_tree", "b_tree.BTree._find_largest_and_delete_in_right_subtree"], "store_vars_calls": {"largest_key_in_subtree": "self._find_largest_and_delete_in_right_subtree"}, "source_code": "def _find_largest_and_delete_in_right_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop(0)\n    else:\n        ch_index = 0\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_right_subtree(node.children[0])\n        return largest_key_in_subtree"}, "traverse_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 240, "max_lineno": 243}, "calls": ["b_tree.BTree._traverse_tree", "print"], "source_code": "def traverse_tree(self):\n    self._traverse_tree(self.root)\n    print()"}, "_traverse_tree": {"args": ["self", "node"], "annotated_arg_types": {"node": "Node"}, "min_max_lineno": {"min_lineno": 244, "max_lineno": 252}, "calls": ["print", "enumerate", "b_tree.BTree._traverse_tree"], "source_code": "def _traverse_tree(self, node: Node):\n    if node.is_leaf:\n        print(node.keys, end=' ')\n    else:\n        for (i, key) in enumerate(node.keys):\n            self._traverse_tree(node.children[i])\n            print(key, end=' ')\n        self._traverse_tree(node.children[-1])"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bin_tree_to_list.py", "fileNameBase": "bin_tree_to_list", "extension": "py"}, "dependencies": [{"from_module": "tree.tree", "import": "TreeNode", "type": "external", "type_element": "module"}], "functions": {"bin_tree_to_list": {"doc": {"short_description": "type root: root class"}, "args": ["root"], "returns": ["root", "root"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 14}, "calls": ["bin_tree_to_list.bin_tree_to_list_util"], "store_vars_calls": {"root": "bin_tree_to_list_util"}, "source_code": "def bin_tree_to_list(root):\n    \"\"\"\n    type root: root class\n    \"\"\"\n    if not root:\n        return root\n    root = bin_tree_to_list_util(root)\n    while root.left:\n        root = root.left\n    return root"}, "bin_tree_to_list_util": {"args": ["root"], "returns": ["root", "root"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 32}, "calls": ["bin_tree_to_list.bin_tree_to_list_util"], "store_vars_calls": {"left": "bin_tree_to_list_util", "right": "bin_tree_to_list_util"}, "source_code": "def bin_tree_to_list_util(root):\n    if not root:\n        return root\n    if root.left:\n        left = bin_tree_to_list_util(root.left)\n        while left.right:\n            left = left.right\n        left.right = root\n        root.left = left\n    if root.right:\n        right = bin_tree_to_list_util(root.right)\n        while right.left:\n            right = right.left\n        right.left = root\n        root.right = right\n    return root"}, "print_tree": {"args": ["root"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 38}, "calls": ["print"], "source_code": "def print_tree(root):\n    while root:\n        print(root.val)\n        root = root.right"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/max_path_sum.py", "fileNameBase": "max_path_sum", "extension": "py"}, "functions": {"max_path_sum": {"args": ["root"], "returns": ["maximum"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 5}, "calls": ["float", "max_path_sum.helper"], "store_vars_calls": {"maximum": "float"}, "source_code": "def max_path_sum(root):\n    maximum = float('-inf')\n    helper(root, maximum)\n    return maximum"}, "helper": {"args": ["root", "maximum"], "returns": ["root.val + maximum", "0"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 14}, "calls": ["max_path_sum.helper", "max"], "store_vars_calls": {"left": "helper", "right": "helper", "maximum": "max"}, "source_code": "def helper(root, maximum):\n    if root is None:\n        return 0\n    left = helper(root.left, maximum)\n    right = helper(root.right, maximum)\n    maximum = max(maximum, left + right + root.val)\n    return root.val + maximum"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/is_subtree.py", "fileNameBase": "is_subtree", "extension": "py", "doc": {"long_description": "A subtree of a tree t is a tree consisting of a node in t and\nall of its descendants in t.\n\nExample 1:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n\nGiven t:\n\n   4\n  /  1   2\nReturn true, because t is a subtree of s.\n\nExample 2:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n    /\n   0\n\nGiven t:\n\n     3\n    /\n   4\n  /  1   2\nReturn false, because even though t is part of s,\nit does not contain all descendants of t.\n\nFollow up:\nWhat if one tree is significantly lager than the other?", "short_description": "Given two binary trees s and t, check if t is a subtree of s.", "full": "Given two binary trees s and t, check if t is a subtree of s.\nA subtree of a tree t is a tree consisting of a node in t and\nall of its descendants in t.\n\nExample 1:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n\nGiven t:\n\n   4\n  /  1   2\nReturn true, because t is a subtree of s.\n\nExample 2:\n\nGiven s:\n\n     3\n    /    4   5\n  /  1   2\n    /\n   0\n\nGiven t:\n\n     3\n    /\n   4\n  /  1   2\nReturn false, because even though t is part of s,\nit does not contain all descendants of t.\n\nFollow up:\nWhat if one tree is significantly lager than the other?"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"is_subtree": {"args": ["big", "small"], "returns": ["flag"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 64}, "calls": ["collections.deque", "collections.deque.append", "collections.deque.popleft", "is_subtree.comp"], "store_vars_calls": {"queue": "collections.deque", "node": "queue.popleft", "flag": "comp"}, "source_code": "def is_subtree(big, small):\n    flag = False\n    queue = collections.deque()\n    queue.append(big)\n    while queue:\n        node = queue.popleft()\n        if node.val == small.val:\n            flag = comp(node, small)\n            break\n        else:\n            queue.append(node.left)\n            queue.append(node.right)\n    return flag"}, "comp": {"args": ["p", "q"], "returns": ["False", "True", "p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right)"], "min_max_lineno": {"min_lineno": 66, "max_lineno": 72}, "calls": ["is_subtree.comp"], "source_code": "def comp(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None and q is not None:\n        return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right)\n    return False"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/segment_tree": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/segment_tree/segment_tree.py", "fileNameBase": "segment_tree", "extension": "py", "doc": {"long_description": "allowing queries to be done later in log(N) time\nfunction takes 2 values and returns a same type value", "short_description": "Segment_tree creates a segment tree with a given array and function,", "full": "Segment_tree creates a segment tree with a given array and function,\nallowing queries to be done later in log(N) time\nfunction takes 2 values and returns a same type value"}}, "classes": {"SegmentTree": {"min_max_lineno": {"min_lineno": 6, "max_lineno": 38}, "methods": {"__init__": {"args": ["self", "arr", "function"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 12}, "calls": ["segment_tree.SegmentTree.make_tree", "range", "len"], "source_code": "def __init__(self, arr, function):\n    self.segment = [0 for x in range(3 * len(arr) + 3)]\n    self.arr = arr\n    self.fn = function\n    self.make_tree(0, 0, len(arr) - 1)"}, "make_tree": {"args": ["self", "i", "l", "r"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 20}, "calls": ["segment_tree.SegmentTree.make_tree", "segment_tree.SegmentTree.fn", "int"], "source_code": "def make_tree(self, i, l, r):\n    if l == r:\n        self.segment[i] = self.arr[l]\n    elif l < r:\n        self.make_tree(2 * i + 1, l, int((l + r) / 2))\n        self.make_tree(2 * i + 2, int((l + r) / 2) + 1, r)\n        self.segment[i] = self.fn(self.segment[2 * i + 1], self.segment[2 * i + 2])"}, "__query": {"args": ["self", "i", "L", "R", "l", "r"], "returns": ["val2", "None", "self.segment[i]", "val1", "self.fn(val1, val2)"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 34}, "calls": ["segment_tree.SegmentTree.__query", "print", "int", "segment_tree.SegmentTree.fn"], "store_vars_calls": {"val1": "self.__query", "val2": "self.__query"}, "source_code": "def __query(self, i, L, R, l, r):\n    if l > R or r < L or L > R or (l > r):\n        return None\n    if L >= l and R <= r:\n        return self.segment[i]\n    val1 = self.__query(2 * i + 1, L, int((L + R) / 2), l, r)\n    val2 = self.__query(2 * i + 2, int((L + R + 2) / 2), R, l, r)\n    print(L, R, ' returned ', val1, val2)\n    if val1 != None:\n        if val2 != None:\n            return self.fn(val1, val2)\n        return val1\n    return val2"}, "query": {"args": ["self", "L", "R"], "returns": ["self.__query(0, 0, len(self.arr) - 1, L, R)"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 38}, "calls": ["segment_tree.SegmentTree.__query", "len"], "source_code": "def query(self, L, R):\n    return self.__query(0, 0, len(self.arr) - 1, L, R)"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/segment_tree/iterative_segment_tree.py", "fileNameBase": "iterative_segment_tree", "extension": "py", "doc": {"long_description": "this non-recursive version uses less memory than the recursive version and include:\n1. range queries in log(N) time\n2. update an element in log(N) time\nthe function should be commutative and takes 2 values and returns the same type value\n\nExamples -\nmytree = SegmentTree([2, 4, 5, 3, 4],max)\nprint(mytree.query(2, 4))\nmytree.update(3, 6)\nprint(mytree.query(0, 3)) ...\n\nmytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b)\nprint(mytree.query(0, 6))\nmytree.update(2, -10)\nprint(mytree.query(0, 6)) ...\n\nmytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))\nmytree.update(2, (-1, 2))\nprint(mytree.query(0, 2)) ...", "short_description": "SegmentTree creates a segment tree with a given array and a \"commutative\" function,", "full": "SegmentTree creates a segment tree with a given array and a \"commutative\" function,\nthis non-recursive version uses less memory than the recursive version and include:\n1. range queries in log(N) time\n2. update an element in log(N) time\nthe function should be commutative and takes 2 values and returns the same type value\n\nExamples -\nmytree = SegmentTree([2, 4, 5, 3, 4],max)\nprint(mytree.query(2, 4))\nmytree.update(3, 6)\nprint(mytree.query(0, 3)) ...\n\nmytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b)\nprint(mytree.query(0, 6))\nmytree.update(2, -10)\nprint(mytree.query(0, 6)) ...\n\nmytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1]))\nprint(mytree.query(0, 2))\nmytree.update(2, (-1, 2))\nprint(mytree.query(0, 2)) ..."}}, "classes": {"SegmentTree": {"min_max_lineno": {"min_lineno": 26, "max_lineno": 54}, "methods": {"__init__": {"args": ["self", "arr", "function"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 32}, "calls": ["len", "iterative_segment_tree.SegmentTree.build_tree", "range"], "store_vars_calls": {"self.size": "len"}, "source_code": "def __init__(self, arr, function):\n    self.tree = [None for _ in range(len(arr))] + arr\n    self.size = len(arr)\n    self.fn = function\n    self.build_tree()"}, "build_tree": {"args": ["self"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 36}, "calls": ["range", "iterative_segment_tree.SegmentTree.fn"], "source_code": "def build_tree(self):\n    for i in range(self.size - 1, 0, -1):\n        self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])"}, "update": {"args": ["self", "p", "v"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 43}, "calls": ["iterative_segment_tree.SegmentTree.fn"], "source_code": "def update(self, p, v):\n    p += self.size\n    self.tree[p] = v\n    while p > 1:\n        p = p // 2\n        self.tree[p] = self.fn(self.tree[p * 2], self.tree[p * 2 + 1])"}, "query": {"args": ["self", "l", "r"], "returns": ["res"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 54}, "calls": ["iterative_segment_tree.SegmentTree.fn"], "source_code": "def query(self, l, r):\n    (l, r) = (l + self.size, r + self.size)\n    res = None\n    while l <= r:\n        if l % 2 == 1:\n            res = self.tree[l] if res is None else self.fn(res, self.tree[l])\n        if r % 2 == 0:\n            res = self.tree[r] if res is None else self.fn(res, self.tree[r])\n        (l, r) = ((l + 1) // 2, (r - 1) // 2)\n    return res"}}}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/trie": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/trie/trie.py", "fileNameBase": "trie", "extension": "py", "doc": {"long_description": "Note:\nYou may assume that all inputs are consist of lowercase letters a-z.", "short_description": "Implement a trie with insert, search, and startsWith methods.", "full": "Implement a trie with insert, search, and startsWith methods.\n\nNote:\nYou may assume that all inputs are consist of lowercase letters a-z."}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "classes": {"TrieNode": {"min_max_lineno": {"min_lineno": 10, "max_lineno": 14}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 14}, "calls": ["collections.defaultdict"], "store_vars_calls": {"self.children": "collections.defaultdict"}, "source_code": "def __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False"}}}, "Trie": {"min_max_lineno": {"min_lineno": 16, "max_lineno": 41}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 19}, "store_vars_calls": {"self.root": "TrieNode"}, "source_code": "def __init__(self):\n    self.root = TrieNode()"}, "insert": {"args": ["self", "word"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 25}, "source_code": "def insert(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children[letter]\n    current.is_word = True"}, "search": {"args": ["self", "word"], "returns": ["current.is_word", "False"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 33}, "calls": ["current.children.get.children.get.children.get"], "store_vars_calls": {"current": "current.children.get"}, "source_code": "def search(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return current.is_word"}, "starts_with": {"args": ["self", "prefix"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 41}, "calls": ["current.children.get.children.get.children.get"], "store_vars_calls": {"current": "current.children.get"}, "source_code": "def starts_with(self, prefix):\n    current = self.root\n    for letter in prefix:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return True"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/trie/add_and_search.py", "fileNameBase": "add_and_search", "extension": "py", "doc": {"long_description": "that allows us to add and search for words.\nThe search can be a literal word or regular expression\ncontaining \u201c.\u201d, where \u201c.\u201d can be any letter.\n\nExample:\naddWord(\u201cbad\u201d)\naddWord(\u201cdad\u201d)\naddWord(\u201cmad\u201d)\nsearch(\u201cpad\u201d) -> false\nsearch(\u201cbad\u201d) -> true\nsearch(\u201c.ad\u201d) -> true\nsearch(\u201cb..\u201d) -> true", "short_description": "We are asked to design an efficient data structure", "full": "We are asked to design an efficient data structure\nthat allows us to add and search for words.\nThe search can be a literal word or regular expression\ncontaining \u201c.\u201d, where \u201c.\u201d can be any letter.\n\nExample:\naddWord(\u201cbad\u201d)\naddWord(\u201cdad\u201d)\naddWord(\u201cmad\u201d)\nsearch(\u201cpad\u201d) -> false\nsearch(\u201cbad\u201d) -> true\nsearch(\u201c.ad\u201d) -> true\nsearch(\u201cb..\u201d) -> true"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "classes": {"TrieNode": {"extend": ["object"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 23}, "methods": {"__init__": {"args": ["self", "letter", "is_terminal"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 23}, "calls": ["dict"], "store_vars_calls": {"self.children": "dict"}, "source_code": "def __init__(self, letter, is_terminal=False):\n    self.children = dict()\n    self.letter = letter\n    self.is_terminal = is_terminal"}}}, "WordDictionary": {"extend": ["object"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 57}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 27}, "store_vars_calls": {"self.root": "TrieNode"}, "source_code": "def __init__(self):\n    self.root = TrieNode('')"}, "add_word": {"args": ["self", "word"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 35}, "source_code": "def add_word(self, word):\n    cur = self.root\n    for letter in word:\n        if letter not in cur.children:\n            cur.children[letter] = TrieNode(letter)\n        cur = cur.children[letter]\n    cur.is_terminal = True"}, "search": {"args": ["self", "word", "node"], "returns": ["cur.is_terminal", "False", "False", "False", "True", "True"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 57}, "calls": ["enumerate", "cur.children.itervalues", "len", "add_and_search.WordDictionary.search"], "source_code": "def search(self, word, node=None):\n    cur = node\n    if not cur:\n        cur = self.root\n    for (i, letter) in enumerate(word):\n        if letter == '.':\n            if i == len(word) - 1:\n                for child in cur.children.itervalues():\n                    if child.is_terminal:\n                        return True\n                return False\n            for child in cur.children.itervalues():\n                if self.search(word[i + 1:], child) == True:\n                    return True\n            return False\n        if letter not in cur.children:\n            return False\n        cur = cur.children[letter]\n    return cur.is_terminal"}}}, "WordDictionary2": {"extend": ["object"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 80}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 61}, "calls": ["collections.defaultdict"], "store_vars_calls": {"self.word_dict": "collections.defaultdict"}, "source_code": "def __init__(self):\n    self.word_dict = collections.defaultdict(list)"}, "add_word": {"args": ["self", "word"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 66}, "calls": ["add_and_search.WordDictionary2.word_dict[].append", "len"], "source_code": "def add_word(self, word):\n    if word:\n        self.word_dict[len(word)].append(word)"}, "search": {"args": ["self", "word"], "returns": ["False", "False", "word in self.word_dict[len(word)]", "True"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 80}, "calls": ["len", "enumerate"], "source_code": "def search(self, word):\n    if not word:\n        return False\n    if '.' not in word:\n        return word in self.word_dict[len(word)]\n    for v in self.word_dict[len(word)]:\n        for (i, ch) in enumerate(word):\n            if ch != v[i] and ch != '.':\n                break\n        else:\n            return True\n    return False"}}}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/traversal": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/traversal/inorder.py", "fileNameBase": "inorder", "extension": "py", "doc": {"short_description": "Time complexity : O(n)", "full": "Time complexity : O(n)"}}, "classes": {"Node": {"min_max_lineno": {"min_lineno": 6, "max_lineno": 12}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 12}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}}, "functions": {"inorder": {"doc": {"short_description": "In order function "}, "args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 28}, "calls": ["stack.pop", "res.append", "stack.append"], "store_vars_calls": {"root": "stack.pop"}, "source_code": "def inorder(root):\n    \"\"\" In order function \"\"\"\n    res = []\n    if not root:\n        return res\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        res.append(root.val)\n        root = root.right\n    return res"}, "inorder_rec": {"doc": {"short_description": "Recursive Implementation "}, "args": ["root", "res"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 39}, "calls": ["inorder.inorder_rec", "res.append"], "source_code": "def inorder_rec(root, res=None):\n    \"\"\" Recursive Implementation \"\"\"\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    inorder_rec(root.left, res)\n    res.append(root.val)\n    inorder_rec(root.right, res)\n    return res"}}, "body": {"calls": ["inorder.Node", "inorder.inorder", "inorder.inorder_rec"], "store_vars_calls": {"n1": "Node", "n2": "Node", "n3": "Node", "n4": "Node", "n5": "Node", "n6": "Node", "n7": "Node"}, "source_code": ["Node(100)", "Node(50)", "Node(150)", "Node(25)", "Node(75)", "Node(125)", "Node(175)", "inorder(n1)", "inorder_rec(n1)"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/traversal/preorder.py", "fileNameBase": "preorder", "extension": "py", "doc": {"short_description": "Time complexity : O(n)", "full": "Time complexity : O(n)"}}, "classes": {"Node": {"doc": {"short_description": "This is a class of Node ", "full": "This is a class of Node "}, "min_max_lineno": {"min_lineno": 6, "max_lineno": 13}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 13}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}}, "functions": {"preorder": {"doc": {"short_description": "Function to Preorder "}, "args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 30}, "calls": ["stack.append", "stack.pop", "res.append"], "store_vars_calls": {"root": "stack.pop"}, "source_code": "def preorder(root):\n    \"\"\" Function to Preorder \"\"\"\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res.append(root.val)\n        if root.right:\n            stack.append(root.right)\n        if root.left:\n            stack.append(root.left)\n    return res"}, "preorder_rec": {"doc": {"short_description": "Recursive Implementation "}, "args": ["root", "res"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 41}, "calls": ["res.append", "preorder.preorder_rec"], "source_code": "def preorder_rec(root, res=None):\n    \"\"\" Recursive Implementation \"\"\"\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    res.append(root.val)\n    preorder_rec(root.left, res)\n    preorder_rec(root.right, res)\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/traversal/level_order.py", "fileNameBase": "level_order", "extension": "py", "doc": {"long_description": "its nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   /   9  20\n    /     15   7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]", "short_description": "Given a binary tree, return the level order traversal of", "full": "Given a binary tree, return the level order traversal of\nits nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   /   9  20\n    /     15   7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]"}}, "functions": {"level_order": {"args": ["root"], "returns": ["ans", "ans"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 38}, "calls": ["ans.append", "current.append", "new_level.append"], "source_code": "def level_order(root):\n    ans = []\n    if not root:\n        return ans\n    level = [root]\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        ans.append(current)\n    return ans"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/traversal/postorder.py", "fileNameBase": "postorder", "extension": "py", "doc": {"short_description": "Time complexity : O(n)", "full": "Time complexity : O(n)"}}, "classes": {"Node": {"min_max_lineno": {"min_lineno": 5, "max_lineno": 11}, "methods": {"__init__": {"args": ["self", "val", "left", "right"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 11}, "source_code": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right"}}}}, "functions": {"postorder": {"args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 30}, "calls": ["stack.append", "stack.pop", "res_temp.append", "res.append", "res_temp.pop"], "store_vars_calls": {"root": "stack.pop"}, "source_code": "def postorder(root):\n    res_temp = []\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res_temp.append(root.val)\n        if root.left:\n            stack.append(root.left)\n        if root.right:\n            stack.append(root.right)\n    while res_temp:\n        res.append(res_temp.pop())\n    return res"}, "postorder_rec": {"args": ["root", "res"], "returns": ["res", "[]"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 41}, "calls": ["postorder.postorder_rec", "res.append"], "source_code": "def postorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    postorder_rec(root.left, res)\n    postorder_rec(root.right, res)\n    res.append(root.val)\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/traversal/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "preorder", "import": "preorder", "type": "internal", "type_element": "function"}, {"from_module": "preorder", "import": "preorder_rec", "type": "internal", "type_element": "function"}, {"from_module": "preorder", "import": "Node", "type": "internal", "type_element": "class"}, {"from_module": "postorder", "import": "postorder", "type": "internal", "type_element": "function"}, {"from_module": "postorder", "import": "postorder_rec", "type": "internal", "type_element": "function"}, {"from_module": "postorder", "import": "Node", "type": "internal", "type_element": "class"}, {"from_module": "inorder", "import": "inorder", "type": "internal", "type_element": "function"}, {"from_module": "inorder", "import": "inorder_rec", "type": "internal", "type_element": "function"}, {"from_module": "inorder", "import": "Node", "type": "internal", "type_element": "class"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/traversal/zigzag.py", "fileNameBase": "zigzag", "extension": "py", "doc": {"long_description": "of its nodes' values.\n(ie, from left to right, then right to left\nfor the next level and alternate between).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   /   9  20\n    /     15   7\nreturn its zigzag level order traversal as:\n[\n  [3],\n  [20,9],\n  [15,7]\n]", "short_description": "Given a binary tree, return the zigzag level order traversal", "full": "Given a binary tree, return the zigzag level order traversal\nof its nodes' values.\n(ie, from left to right, then right to left\nfor the next level and alternate between).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   /   9  20\n    /     15   7\nreturn its zigzag level order traversal as:\n[\n  [3],\n  [20,9],\n  [15,7]\n]"}}, "functions": {"zigzag_level": {"args": ["root"], "returns": ["res", "res"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 42}, "calls": ["res.append", "current.append", "new_level.append"], "source_code": "def zigzag_level(root):\n    res = []\n    if not root:\n        return res\n    level = [root]\n    flag = 1\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        res.append(current[::flag])\n        flag *= -1\n    return res"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/fenwick_tree": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/fenwick_tree/fenwick_tree.py", "fileNameBase": "fenwick_tree", "extension": "py", "doc": {"long_description": "Consider we have an array arr[0 . . . n-1]. We would like to\n1. Compute the sum of the first i elements.\n2. Modify the value of a specified element of the array arr[i] = x where 0 <= i <= n-1.\n\nA simple solution is to run a loop from 0 to i-1 and calculate the sum of the elements. To update a value, simply do arr[i] = x.\nThe first operation takes O(n) time and the second operation takes O(1) time.\nAnother simple solution is to create an extra array and store the sum of the first i-th elements at the i-th index in this new array.\nThe sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now.\nThis works well if there are a large number of query operations but a very few number of update operations.\n\n\nThere are two solutions that can perform both the query and update operations in O(logn) time.\n1. Fenwick Tree\n2. Segment Tree\n\nCompared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement.", "short_description": "Fenwick Tree / Binary Indexed Tree", "full": "Fenwick Tree / Binary Indexed Tree\n\nConsider we have an array arr[0 . . . n-1]. We would like to\n1. Compute the sum of the first i elements.\n2. Modify the value of a specified element of the array arr[i] = x where 0 <= i <= n-1.\n\nA simple solution is to run a loop from 0 to i-1 and calculate the sum of the elements. To update a value, simply do arr[i] = x.\nThe first operation takes O(n) time and the second operation takes O(1) time.\nAnother simple solution is to create an extra array and store the sum of the first i-th elements at the i-th index in this new array.\nThe sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now.\nThis works well if there are a large number of query operations but a very few number of update operations.\n\n\nThere are two solutions that can perform both the query and update operations in O(logn) time.\n1. Fenwick Tree\n2. Segment Tree\n\nCompared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement."}}, "classes": {"Fenwick_Tree": {"extend": ["object"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 78}, "methods": {"__init__": {"args": ["self", "freq"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 26}, "calls": ["len"], "store_vars_calls": {"self.n": "len"}, "source_code": "def __init__(self, freq):\n    self.arr = freq\n    self.n = len(freq)"}, "get_sum": {"doc": {"short_description": "Returns sum of arr[0..index]. This function assumes that the array is preprocessed and partial sums of array elements are stored in bit_tree[]. "}, "args": ["self", "bit_tree", "i"], "returns": ["s"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 46}, "source_code": "def get_sum(self, bit_tree, i):\n    \"\"\"\n             Returns sum of arr[0..index]. This function assumes that the array is preprocessed and partial sums of array elements are stored in bit_tree[]. \n        \"\"\"\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += bit_tree[i]\n        i -= i & -i\n    return s"}, "update_bit": {"doc": {"short_description": "Updates a node in Binary Index Tree (bit_tree) at given index in bit_tree. The given value 'val' is added to bit_tree[i] and all of its ancestors in tree. "}, "args": ["self", "bit_tree", "i", "v"], "min_max_lineno": {"min_lineno": 47, "max_lineno": 63}, "source_code": "def update_bit(self, bit_tree, i, v):\n    \"\"\"\n             Updates a node in Binary Index Tree (bit_tree) at given index in bit_tree. The given value 'val' is added to bit_tree[i] and all of its ancestors in tree. \n        \"\"\"\n    i += 1\n    while i <= self.n:\n        bit_tree[i] += v\n        i += i & -i"}, "construct": {"doc": {"short_description": "Constructs and returns a Binary Indexed Tree for given array of size n. "}, "args": ["self"], "returns": ["bit_tree"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 78}, "calls": ["range", "fenwick_tree.Fenwick_Tree.update_bit"], "source_code": "def construct(self):\n    \"\"\"\n             Constructs and returns a Binary Indexed Tree for given array of size n. \n        \"\"\"\n    bit_tree = [0] * (self.n + 1)\n    for i in range(self.n):\n        self.update_bit(bit_tree, i, self.arr[i])\n    return bit_tree"}}}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/bst": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/depth_sum.py", "fileNameBase": "depth_sum", "extension": "py", "doc": {"long_description": "in a binary search tree of integers weighted by the depth of each value.\n\nFor example:\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    depth_sum = 1*9 + 2*(6+12) + 3*(3+8+10+15) + 4*(7+18)", "short_description": "Write a function depthSum returns the sum of the values stored", "full": "Write a function depthSum returns the sum of the values stored\nin a binary search tree of integers weighted by the depth of each value.\n\nFor example:\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    depth_sum = 1*9 + 2*(6+12) + 3*(3+8+10+15) + 4*(7+18)"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "bst", "import": "Node", "type": "internal", "type_element": "module"}, {"from_module": "bst", "import": "bst", "type": "internal", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 64}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 61}, "calls": ["bst.bst.bst", "depth_sum.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "bst"}, "source_code": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)"}, "test_depth_sum": {"args": ["self"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 64}, "calls": ["depth_sum.TestSuite.assertEqual", "depth_sum.depth_sum"], "source_code": "def test_depth_sum(self):\n    self.assertEqual(253, depth_sum(self.tree.root, 4))"}}}}, "functions": {"depth_sum": {"args": ["root", "n"], "returns": ["recur_depth_sum(root, 1)"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 25}, "calls": ["depth_sum.recur_depth_sum"], "source_code": "def depth_sum(root, n):\n    if root:\n        return recur_depth_sum(root, 1)"}, "recur_depth_sum": {"args": ["root", "n"], "returns": ["0", "root.data * n", "n * root.data + recur_depth_sum(root.left, n + 1) + recur_depth_sum(root.right, n + 1)"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 33}, "calls": ["depth_sum.recur_depth_sum"], "source_code": "def recur_depth_sum(root, n):\n    if root is None:\n        return 0\n    elif root.left is None and root.right is None:\n        return root.data * n\n    else:\n        return n * root.data + recur_depth_sum(root.left, n + 1) + recur_depth_sum(root.right, n + 1)"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "depth_sum.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/count_left_node.py", "fileNameBase": "count_left_node", "extension": "py", "doc": {"long_description": "tree. For example: the following tree has four left children (the nodes\nstoring the values 6, 3, 7, and 10):\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    count_left_node = 4", "short_description": "Write a function count_left_node returns the number of left children in the", "full": "Write a function count_left_node returns the number of left children in the\ntree. For example: the following tree has four left children (the nodes\nstoring the values 6, 3, 7, and 10):\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    count_left_node = 4"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "bst", "import": "Node", "type": "internal", "type_element": "module"}, {"from_module": "bst", "import": "bst", "type": "internal", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 59}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 56}, "calls": ["bst.bst.bst", "count_left_node.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "bst"}, "source_code": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)"}, "test_count_left_node": {"args": ["self"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 59}, "calls": ["count_left_node.TestSuite.assertEqual", "count_left_node.count_left_node"], "source_code": "def test_count_left_node(self):\n    self.assertEqual(4, count_left_node(self.tree.root))"}}}}, "functions": {"count_left_node": {"args": ["root"], "returns": ["0", "count_left_node(root.right)", "1 + count_left_node(root.left) + count_left_node(root.right)"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 28}, "calls": ["count_left_node.count_left_node"], "source_code": "def count_left_node(root):\n    if root is None:\n        return 0\n    elif root.left is None:\n        return count_left_node(root.right)\n    else:\n        return 1 + count_left_node(root.left) + count_left_node(root.right)"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "count_left_node.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/height.py", "fileNameBase": "height", "extension": "py", "doc": {"long_description": "be the number of levels. The empty tree has height 0, a tree of one node has\nheight 1, a root node with one or two leaves as children has height 2, and so on\nFor example: height of tree is 4\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    height = 4", "short_description": "Write a function height returns the height of a tree. The height is defined to", "full": "Write a function height returns the height of a tree. The height is defined to\nbe the number of levels. The empty tree has height 0, a tree of one node has\nheight 1, a root node with one or two leaves as children has height 2, and so on\nFor example: height of tree is 4\n\n                    9\n                 /                     6         12\n              / \\       /               3     8   10      15\n                 /                              7                18\n\n    height = 4"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "bst", "import": "Node", "type": "internal", "type_element": "module"}, {"from_module": "bst", "import": "bst", "type": "internal", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 58}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 55}, "calls": ["bst.bst.bst", "height.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "bst"}, "source_code": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)"}, "test_height": {"args": ["self"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 58}, "calls": ["height.TestSuite.assertEqual", "height.height"], "source_code": "def test_height(self):\n    self.assertEqual(4, height(self.tree.root))"}}}}, "functions": {"height": {"args": ["root"], "returns": ["0", "1 + max(height(root.left), height(root.right))"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 27}, "calls": ["max", "height.height"], "source_code": "def height(root):\n    if root is None:\n        return 0\n    else:\n        return 1 + max(height(root.left), height(root.right))"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "height.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/bst.py", "fileNameBase": "bst", "extension": "py", "doc": {"long_description": "1. Insert\n2. Search\n3. Size\n4. Traversal (Preorder, Inorder, Postorder)", "short_description": "Implement Binary Search Tree. It has method:", "full": "Implement Binary Search Tree. It has method:\n    1. Insert\n    2. Search\n    3. Size\n    4. Traversal (Preorder, Inorder, Postorder)"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}], "classes": {"Node": {"extend": ["object"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 16}, "methods": {"__init__": {"args": ["self", "data"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 16}, "source_code": "def __init__(self, data):\n    self.data = data\n    self.left = None\n    self.right = None"}}}, "BST": {"extend": ["object"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 101}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 20}, "source_code": "def __init__(self):\n    self.root = None"}, "get_root": {"args": ["self"], "returns": ["self.root"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 23}, "source_code": "def get_root(self):\n    return self.root"}, "size": {"args": ["self"], "returns": ["self.recur_size(self.root)"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 30}, "calls": ["bst.BST.recur_size"], "source_code": "def size(self):\n    return self.recur_size(self.root)"}, "recur_size": {"args": ["self", "root"], "returns": ["0", "1 + self.recur_size(root.left) + self.recur_size(root.right)"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 36}, "calls": ["bst.BST.recur_size"], "source_code": "def recur_size(self, root):\n    if root is None:\n        return 0\n    else:\n        return 1 + self.recur_size(root.left) + self.recur_size(root.right)"}, "search": {"args": ["self", "data"], "returns": ["self.recur_search(self.root, data)"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 43}, "calls": ["bst.BST.recur_search"], "source_code": "def search(self, data):\n    return self.recur_search(self.root, data)"}, "recur_search": {"args": ["self", "root", "data"], "returns": ["False", "True", "self.recur_search(root.right, data)", "self.recur_search(root.left, data)"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 53}, "calls": ["bst.BST.recur_search"], "source_code": "def recur_search(self, root, data):\n    if root is None:\n        return False\n    if root.data == data:\n        return True\n    elif data > root.data:\n        return self.recur_search(root.right, data)\n    else:\n        return self.recur_search(root.left, data)"}, "insert": {"args": ["self", "data"], "returns": ["self.recur_insert(self.root, data)", "True"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 64}, "calls": ["bst.BST.recur_insert"], "store_vars_calls": {"self.root": "Node"}, "source_code": "def insert(self, data):\n    if self.root:\n        return self.recur_insert(self.root, data)\n    else:\n        self.root = Node(data)\n        return True"}, "recur_insert": {"args": ["self", "root", "data"], "returns": ["False", "self.recur_insert(root.left, data)", "True", "self.recur_insert(root.right, data)", "True"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 80}, "calls": ["bst.BST.recur_insert", "bst.Node"], "store_vars_calls": {"root.left": "Node", "root.right": "Node"}, "source_code": "def recur_insert(self, root, data):\n    if root.data == data:\n        return False\n    elif data < root.data:\n        if root.left:\n            return self.recur_insert(root.left, data)\n        else:\n            root.left = Node(data)\n            return True\n    elif root.right:\n        return self.recur_insert(root.right, data)\n    else:\n        root.right = Node(data)\n        return True"}, "preorder": {"args": ["self", "root"], "min_max_lineno": {"min_lineno": 84, "max_lineno": 89}, "calls": ["print", "bst.BST.preorder", "str"], "source_code": "def preorder(self, root):\n    if root:\n        print(str(root.data), end=' ')\n        self.preorder(root.left)\n        self.preorder(root.right)"}, "inorder": {"args": ["self", "root"], "min_max_lineno": {"min_lineno": 90, "max_lineno": 95}, "calls": ["bst.BST.inorder", "print", "str"], "source_code": "def inorder(self, root):\n    if root:\n        self.inorder(root.left)\n        print(str(root.data), end=' ')\n        self.inorder(root.right)"}, "postorder": {"args": ["self", "root"], "min_max_lineno": {"min_lineno": 96, "max_lineno": 101}, "calls": ["bst.BST.postorder", "print", "str"], "source_code": "def postorder(self, root):\n    if root:\n        self.postorder(root.left)\n        self.postorder(root.right)\n        print(str(root.data), end=' ')"}}}, "TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 116, "max_lineno": 137}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 117, "max_lineno": 130}, "calls": ["bst.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "BST"}, "source_code": "def setUp(self):\n    self.tree = BST()\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(6)\n    self.tree.insert(4)\n    self.tree.insert(9)\n    self.tree.insert(12)\n    self.tree.insert(24)\n    self.tree.insert(7)\n    self.tree.insert(20)\n    self.tree.insert(30)\n    self.tree.insert(18)"}, "test_search": {"args": ["self"], "min_max_lineno": {"min_lineno": 131, "max_lineno": 134}, "calls": ["bst.TestSuite.assertTrue", "bst.TestSuite.assertFalse", "bst.TestSuite.tree.search"], "source_code": "def test_search(self):\n    self.assertTrue(self.tree.search(24))\n    self.assertFalse(self.tree.search(50))"}, "test_size": {"args": ["self"], "min_max_lineno": {"min_lineno": 135, "max_lineno": 137}, "calls": ["bst.TestSuite.assertEqual", "bst.TestSuite.tree.size"], "source_code": "def test_size(self):\n    self.assertEqual(11, self.tree.size())"}}}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "bst.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/lowest_common_ancestor.py", "fileNameBase": "lowest_common_ancestor", "extension": "py", "doc": {"long_description": "find the lowest common ancestor (LCA) of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two\n    nodes v and w as the lowest node in T that has both v and w\n    as descendants (where we allow a node to be a descendant of itself).\u201d\n\n        _______6______\n       /                  ___2__          ___8__\n   /      \\        /         0      _4       7       9\n         /           3   5\n\nFor example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6.\nAnother example is LCA of nodes 2 and 4 is 2,\nsince a node can be a descendant of itself according to the LCA definition.", "short_description": "Given a binary search tree (BST),", "full": "Given a binary search tree (BST),\nfind the lowest common ancestor (LCA) of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia:\n    \u201cThe lowest common ancestor is defined between two\n    nodes v and w as the lowest node in T that has both v and w\n    as descendants (where we allow a node to be a descendant of itself).\u201d\n\n        _______6______\n       /                  ___2__          ___8__\n   /      \\        /         0      _4       7       9\n         /           3   5\n\nFor example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6.\nAnother example is LCA of nodes 2 and 4 is 2,\nsince a node can be a descendant of itself according to the LCA definition."}}, "functions": {"lowest_common_ancestor": {"args": ["root", "p", "q"], "returns": ["root"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 38}, "source_code": "def lowest_common_ancestor(root, p, q):\n    \"\"\"\n    :type root: Node\n    :type p: Node\n    :type q: Node\n    :rtype: Node\n    \"\"\"\n    while root:\n        if p.val > root.val < q.val:\n            root = root.right\n        elif p.val < root.val > q.val:\n            root = root.left\n        else:\n            return root"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/array_to_bst.py", "fileNameBase": "array_to_bst", "extension": "py", "doc": {"long_description": "convert it to a height balanced BST.", "short_description": "Given an array where elements are sorted in ascending order,", "full": "Given an array where elements are sorted in ascending order,\nconvert it to a height balanced BST."}}, "classes": {"TreeNode": {"extend": ["object"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 12}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 12}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.left = None\n    self.right = None"}}}}, "functions": {"array_to_bst": {"args": ["nums"], "returns": ["node", "None"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 22}, "calls": ["array_to_bst.array_to_bst", "len"], "store_vars_calls": {"node": "TreeNode", "node.left": "array_to_bst", "node.right": "array_to_bst"}, "source_code": "def array_to_bst(nums):\n    if not nums:\n        return None\n    mid = len(nums) // 2\n    node = TreeNode(nums[mid])\n    node.left = array_to_bst(nums[:mid])\n    node.right = array_to_bst(nums[mid + 1:])\n    return node"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/is_bst.py", "fileNameBase": "is_bst", "extension": "py", "doc": {"long_description": "Assume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes\nwith keys less than the node's key.\nThe right subtree of a node contains only nodes\nwith keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\n    2\n   /   1   3\nBinary tree [2,1,3], return true.\nExample 2:\n    1\n   /   2   3\nBinary tree [1,2,3], return false.", "short_description": "Given a binary tree, determine if it is a valid binary search tree (BST).", "full": "Given a binary tree, determine if it is a valid binary search tree (BST).\n\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes\nwith keys less than the node's key.\nThe right subtree of a node contains only nodes\nwith keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\n    2\n   /   1   3\nBinary tree [2,1,3], return true.\nExample 2:\n    1\n   /   2   3\nBinary tree [1,2,3], return false."}}, "functions": {"is_bst": {"args": ["root"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 43}, "calls": ["stack.pop", "stack.append"], "store_vars_calls": {"root": "stack.pop"}, "source_code": "def is_bst(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    stack = []\n    pre = None\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if pre and root.val <= pre.val:\n            return False\n        pre = root\n        root = root.right\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/BSTIterator.py", "fileNameBase": "BSTIterator", "extension": "py"}, "classes": {"BSTIterator": {"min_max_lineno": {"min_lineno": 2, "max_lineno": 21}, "methods": {"__init__": {"args": ["self", "root"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 8}, "calls": ["BSTIterator.BSTIterator.stack.append"], "source_code": "def __init__(self, root):\n    self.stack = []\n    while root:\n        self.stack.append(root)\n        root = root.left"}, "has_next": {"args": ["self"], "returns": ["bool(self.stack)"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 11}, "calls": ["bool"], "source_code": "def has_next(self):\n    return bool(self.stack)"}, "next": {"args": ["self"], "returns": ["node.val"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 21}, "calls": ["BSTIterator.BSTIterator.stack.pop", "BSTIterator.BSTIterator.stack.append"], "store_vars_calls": {"node": "self.stack.pop"}, "source_code": "def next(self):\n    node = self.stack.pop()\n    tmp = node\n    if tmp.right:\n        tmp = tmp.right\n        while tmp:\n            self.stack.append(tmp)\n            tmp = tmp.left\n    return node.val"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/unique_bst.py", "fileNameBase": "unique_bst", "extension": "py", "doc": {"long_description": "(binary search trees) that store values 1...n?\n\nFor example,\nGiven n = 3, there are a total of 5 unique BST's.\n\n   1         3     3      2      1\n    \\       /     /      / \\           3     2     1      1   3      2\n    /     /       \\                    2     1         2                 3", "short_description": "Given n, how many structurally unique BST's", "full": "Given n, how many structurally unique BST's\n(binary search trees) that store values 1...n?\n\nFor example,\nGiven n = 3, there are a total of 5 unique BST's.\n\n   1         3     3      2      1\n    \\       /     /      / \\           3     2     1      1   3      2\n    /     /       \\                    2     1         2                 3"}}, "functions": {"num_trees": {"args": ["n"], "returns": ["dp[-1]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 41}, "calls": ["range"], "source_code": "def num_trees(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i + 1):\n            dp[i] += dp[i - j] * dp[j - 1]\n    return dp[-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/successor.py", "fileNameBase": "successor", "extension": "py"}, "functions": {"successor": {"args": ["root", "node"], "returns": ["succ"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 10}, "source_code": "def successor(root, node):\n    succ = None\n    while root:\n        if node.val < root.val:\n            succ = root\n            root = root.left\n        else:\n            root = root.right\n    return succ"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/serialize_deserialize.py", "fileNameBase": "serialize_deserialize", "extension": "py"}, "classes": {"TreeNode": {"extend": ["object"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 8}, "methods": {"__init__": {"args": ["self", "x"], "min_max_lineno": {"min_lineno": 4, "max_lineno": 8}, "source_code": "def __init__(self, x):\n    self.val = x\n    self.left = None\n    self.right = None"}}}}, "functions": {"serialize": {"args": ["root"], "returns": ["' '.join(vals)"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 21}, "calls": ["serialize_deserialize.serialize.build_string"], "functions": {"build_string": {"args": ["node"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 18}, "calls": ["vals.append", "build_string", "str"], "source_code": "def build_string(node):\n    if node:\n        vals.append(str(node.val))\n        build_string(node.left)\n        build_string(node.right)\n    else:\n        vals.append('#')"}}, "source_code": "def serialize(root):\n\n    def build_string(node):\n        if node:\n            vals.append(str(node.val))\n            build_string(node.left)\n            build_string(node.right)\n        else:\n            vals.append('#')\n    vals = []\n    build_string(root)\n    return ' '.join(vals)"}, "deserialize": {"args": ["data"], "returns": ["build_tree()", "node", "None"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 34}, "calls": ["iter", "serialize_deserialize.deserialize.build_tree"], "store_vars_calls": {"vals": "iter", "val": "next", "node": "TreeNode", "node.left": "build_tree", "node.right": "build_tree"}, "functions": {"build_tree": {"returns": ["node", "None"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 32}, "calls": ["next", "build_tree", "int"], "store_vars_calls": {"val": "next", "node": "TreeNode", "node.left": "build_tree", "node.right": "build_tree"}, "source_code": "def build_tree():\n    val = next(vals)\n    if val == '#':\n        return None\n    node = TreeNode(int(val))\n    node.left = build_tree()\n    node.right = build_tree()\n    return node"}}, "source_code": "def deserialize(data):\n\n    def build_tree():\n        val = next(vals)\n        if val == '#':\n            return None\n        node = TreeNode(int(val))\n        node.left = build_tree()\n        node.right = build_tree()\n        return node\n    vals = iter(data.split())\n    return build_tree()"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/predecessor.py", "fileNameBase": "predecessor", "extension": "py"}, "functions": {"predecessor": {"args": ["root", "node"], "returns": ["pred"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 10}, "source_code": "def predecessor(root, node):\n    pred = None\n    while root:\n        if node.val > root.val:\n            pred = root\n            root = root.right\n        else:\n            root = root.left\n    return pred"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/num_empty.py", "fileNameBase": "num_empty", "extension": "py", "doc": {"long_description": "tree. Function should count the total number of empty branches among the nodes\nof the tree. A leaf node has two empty branches. In the case, if root is None,\nit considered as a 1 empty branch\nFor example: the following tree has 10 empty branch (* is empty branch)\n\n                    9 __\n                 /      \\___\n               6            12\n              / \\          /               3     8       10      15\n          /  \\   / \\     /  \\    /            *    * 7   *   *    *  *    18\n               / \\                   /                *   *                 *    *\n\n    empty_branch = 10", "short_description": "Write a function num_empty returns returns the number of empty branches in a", "full": "Write a function num_empty returns returns the number of empty branches in a\ntree. Function should count the total number of empty branches among the nodes\nof the tree. A leaf node has two empty branches. In the case, if root is None,\nit considered as a 1 empty branch\nFor example: the following tree has 10 empty branch (* is empty branch)\n\n                    9 __\n                 /      \\___\n               6            12\n              / \\          /               3     8       10      15\n          /  \\   / \\     /  \\    /            *    * 7   *   *    *  *    18\n               / \\                   /                *   *                 *    *\n\n    empty_branch = 10"}}, "dependencies": [{"import": "unittest", "type": "external", "type_element": "module"}, {"from_module": "bst", "import": "Node", "type": "internal", "type_element": "module"}, {"from_module": "bst", "import": "bst", "type": "internal", "type_element": "module"}], "classes": {"TestSuite": {"extend": ["unittest.TestCase"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 65}, "methods": {"setUp": {"args": ["self"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 62}, "calls": ["bst.bst.bst", "num_empty.TestSuite.tree.insert"], "store_vars_calls": {"self.tree": "bst"}, "source_code": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)"}, "test_num_empty": {"args": ["self"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 65}, "calls": ["num_empty.TestSuite.assertEqual", "num_empty.num_empty"], "source_code": "def test_num_empty(self):\n    self.assertEqual(10, num_empty(self.tree.root))"}}}}, "functions": {"num_empty": {"args": ["root"], "returns": ["1", "1 + num_empty(root.right)", "1 + num_empty(root.left)", "num_empty(root.left) + num_empty(root.right)"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 34}, "calls": ["num_empty.num_empty"], "source_code": "def num_empty(root):\n    if root is None:\n        return 1\n    elif root.left is None and root.right:\n        return 1 + num_empty(root.right)\n    elif root.right is None and root.left:\n        return 1 + num_empty(root.left)\n    else:\n        return num_empty(root.left) + num_empty(root.right)"}}, "body": {"calls": ["unittest.main"], "source_code": ["unittest.main()"]}, "main_info": {"main_flag": 1, "main_function": "num_empty.unittest.main", "type": "script"}, "is_test": true}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/bst_closest_value.py", "fileNameBase": "bst_closest_value", "extension": "py"}, "functions": {"closest_value": {"args": ["root", "target"], "returns": ["min((a, b), key=lambda x: abs(target - x))", "a"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 29}, "calls": ["bst_closest_value.closest_value", "min", "abs"], "store_vars_calls": {"b": "closest_value"}, "source_code": "def closest_value(root, target):\n    \"\"\"\n    :type root: TreeNode\n    :type target: float\n    :rtype: int\n    \"\"\"\n    a = root.val\n    kid = root.left if target < a else root.right\n    if not kid:\n        return a\n    b = closest_value(kid, target)\n    return min((a, b), key=lambda x: abs(target - x))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/bst/delete_node.py", "fileNameBase": "delete_node", "extension": "py", "doc": {"long_description": "Basically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\nNote: Time complexity should be O(height of tree).\n\nExample:\n\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   /   3   6\n / \\   2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   /   4   6\n /     2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   /   2   6\n   \\       4   7", "short_description": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.", "full": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n\nBasically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\nNote: Time complexity should be O(height of tree).\n\nExample:\n\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   /   3   6\n / \\   2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   /   4   6\n /     2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   /   2   6\n   \\       4   7"}}, "classes": {"Solution": {"extend": ["object"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 67}, "methods": {"delete_node": {"args": ["self", "root", "key"], "returns": ["root", "None", "root.left", "root.right"], "min_max_lineno": {"min_lineno": 41, "max_lineno": 67}, "calls": ["delete_node.Solution.deleteNode"], "store_vars_calls": {"root.left": "self.deleteNode", "root.right": "self.deleteNode"}, "source_code": "def delete_node(self, root, key):\n    \"\"\"\n        :type root: TreeNode\n        :type key: int\n        :rtype: TreeNode\n        \"\"\"\n    if not root:\n        return None\n    if root.val == key:\n        if root.left:\n            left_right_most = root.left\n            while left_right_most.right:\n                left_right_most = left_right_most.right\n            left_right_most.right = root.right\n            return root.left\n        else:\n            return root.right\n    elif root.val > key:\n        root.left = self.deleteNode(root.left, key)\n    else:\n        root.right = self.deleteNode(root.right, key)\n    return root"}}}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/tree/avl": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/avl/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/tree/avl/avl.py", "fileNameBase": "avl", "extension": "py", "doc": {"short_description": "Imports TreeNodes", "full": "Imports TreeNodes"}}, "dependencies": [{"from_module": "tree.tree", "import": "TreeNode", "type": "external", "type_element": "module"}], "classes": {"AvlTree": {"doc": {"short_description": "An avl tree.", "full": "An avl tree."}, "extend": ["object"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 127}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 15}, "source_code": "def __init__(self):\n    self.node = None\n    self.height = -1\n    self.balance = 0"}, "insert": {"doc": {"short_description": "Insert new key into node"}, "args": ["self", "key"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 31}, "calls": ["tree.tree.TreeNode", "avl.AvlTree.re_balance", "avl.AvlTree", "avl.AvlTree.node.left.insert", "avl.AvlTree.node.right.insert"], "store_vars_calls": {"node": "TreeNode", "self.node.left": "AvlTree", "self.node.right": "AvlTree"}, "source_code": "def insert(self, key):\n    \"\"\"\n        Insert new key into node\n        \"\"\"\n    node = TreeNode(key)\n    if not self.node:\n        self.node = node\n        self.node.left = AvlTree()\n        self.node.right = AvlTree()\n    elif key < self.node.val:\n        self.node.left.insert(key)\n    elif key > self.node.val:\n        self.node.right.insert(key)\n    self.re_balance()"}, "re_balance": {"doc": {"short_description": "Re balance tree. After inserting or deleting a node,"}, "args": ["self"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 57}, "calls": ["avl.AvlTree.update_heights", "avl.AvlTree.update_balances", "avl.AvlTree.rotate_right", "avl.AvlTree.rotate_left", "avl.AvlTree.node.left.rotate_left", "avl.AvlTree.node.right.rotate_right"], "source_code": "def re_balance(self):\n    \"\"\"\n        Re balance tree. After inserting or deleting a node,\n        \"\"\"\n    self.update_heights(recursive=False)\n    self.update_balances(False)\n    while self.balance < -1 or self.balance > 1:\n        if self.balance > 1:\n            if self.node.left.balance < 0:\n                self.node.left.rotate_left()\n                self.update_heights()\n                self.update_balances()\n            self.rotate_right()\n            self.update_heights()\n            self.update_balances()\n        if self.balance < -1:\n            if self.node.right.balance > 0:\n                self.node.right.rotate_right()\n                self.update_heights()\n                self.update_balances()\n            self.rotate_left()\n            self.update_heights()\n            self.update_balances()"}, "update_heights": {"doc": {"short_description": "Update tree height"}, "args": ["self", "recursive"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 73}, "calls": ["max", "avl.AvlTree.node.left.update_heights", "avl.AvlTree.node.right.update_heights"], "source_code": "def update_heights(self, recursive=True):\n    \"\"\"\n        Update tree height\n        \"\"\"\n    if self.node:\n        if recursive:\n            if self.node.left:\n                self.node.left.update_heights()\n            if self.node.right:\n                self.node.right.update_heights()\n        self.height = 1 + max(self.node.left.height, self.node.right.height)\n    else:\n        self.height = -1"}, "update_balances": {"doc": {"short_description": "Calculate tree balance factor"}, "args": ["self", "recursive"], "min_max_lineno": {"min_lineno": 74, "max_lineno": 89}, "calls": ["avl.AvlTree.node.left.update_balances", "avl.AvlTree.node.right.update_balances"], "source_code": "def update_balances(self, recursive=True):\n    \"\"\"\n        Calculate tree balance factor\n\n        \"\"\"\n    if self.node:\n        if recursive:\n            if self.node.left:\n                self.node.left.update_balances()\n            if self.node.right:\n                self.node.right.update_balances()\n        self.balance = self.node.left.height - self.node.right.height\n    else:\n        self.balance = 0"}, "rotate_right": {"doc": {"short_description": "Right rotation"}, "args": ["self"], "min_max_lineno": {"min_lineno": 90, "max_lineno": 101}, "source_code": "def rotate_right(self):\n    \"\"\"\n        Right rotation\n        \"\"\"\n    new_root = self.node.left.node\n    new_left_sub = new_root.right.node\n    old_root = self.node\n    self.node = new_root\n    old_root.left.node = new_left_sub\n    new_root.right.node = old_root"}, "rotate_left": {"doc": {"short_description": "Left rotation"}, "args": ["self"], "min_max_lineno": {"min_lineno": 102, "max_lineno": 113}, "source_code": "def rotate_left(self):\n    \"\"\"\n        Left rotation\n        \"\"\"\n    new_root = self.node.right.node\n    new_left_sub = new_root.left.node\n    old_root = self.node\n    self.node = new_root\n    old_root.right.node = new_left_sub\n    new_root.left.node = old_root"}, "in_order_traverse": {"doc": {"short_description": "In-order traversal of the tree"}, "args": ["self"], "returns": ["result", "result"], "min_max_lineno": {"min_lineno": 114, "max_lineno": 127}, "calls": ["result.extend", "result.append", "avl.AvlTree.node.left.in_order_traverse", "avl.AvlTree.node.right.in_order_traverse"], "source_code": "def in_order_traverse(self):\n    \"\"\"\n        In-order traversal of the tree\n        \"\"\"\n    result = []\n    if not self.node:\n        return result\n    result.extend(self.node.left.in_order_traverse())\n    result.append(self.node.key)\n    result.extend(self.node.right.in_order_traverse())\n    return result"}}}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/automata": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/automata/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "dfa", "import": "DFA", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/automata/dfa.py", "fileNameBase": "dfa", "extension": "py"}, "functions": {"DFA": {"args": ["transitions", "start", "final", "string"], "returns": ["False", "False", "True"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 18}, "calls": ["len", "range"], "store_vars_calls": {"num": "len", "num_final": "len"}, "source_code": "def DFA(transitions, start, final, string):\n    num = len(string)\n    num_final = len(final)\n    cur = start\n    for i in range(num):\n        if transitions[cur][string[i]] is None:\n            return False\n        else:\n            cur = transitions[cur][string[i]]\n    for i in range(num_final):\n        if cur == final[i]:\n            return True\n    return False"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/strings": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/min_distance.py", "fileNameBase": "min_distance", "extension": "py", "doc": {"long_description": "make word1 and word2 the same, where in each step you can delete one character\nin either string.\n\nFor example:\nInput: \"sea\", \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\n\nReference: https://leetcode.com/problems/delete-operation-for-two-strings/description/", "short_description": "Given two words word1 and word2, find the minimum number of steps required to", "full": "Given two words word1 and word2, find the minimum number of steps required to\nmake word1 and word2 the same, where in each step you can delete one character\nin either string.\n\nFor example:\nInput: \"sea\", \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\n\nReference: https://leetcode.com/problems/delete-operation-for-two-strings/description/"}}, "functions": {"min_distance": {"doc": {"short_description": "Finds minimum distance by getting longest common subsequence"}, "args": ["word1", "word2"], "returns": ["len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 23}, "calls": ["len", "min_distance.lcs"], "source_code": "def min_distance(word1, word2):\n    \"\"\"\n    Finds minimum distance by getting longest common subsequence\n\n    :type word1: str\n    :type word2: str\n    :rtype: int\n    \"\"\"\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))"}, "lcs": {"doc": {"short_description": "The length of longest common subsequence among the two given strings word1 and word2"}, "args": ["word1", "word2", "i", "j"], "returns": ["max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))", "0", "1 + lcs(word1, word2, i - 1, j - 1)"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 33}, "calls": ["max", "min_distance.lcs"], "source_code": "def lcs(word1, word2, i, j):\n    \"\"\"\n    The length of longest common subsequence among the two given strings word1 and word2\n    \"\"\"\n    if i == 0 or j == 0:\n        return 0\n    if word1[i - 1] == word2[j - 1]:\n        return 1 + lcs(word1, word2, i - 1, j - 1)\n    return max(lcs(word1, word2, i - 1, j), lcs(word1, word2, i, j - 1))"}, "min_distance_dp": {"doc": {"long_description": "TC: O(length1*length2), SC: O(length1*length2)", "short_description": "Finds minimum distance in a dynamic programming manner"}, "args": ["word1", "word2"], "returns": ["res[len(word1)][len(word2)]"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 63}, "calls": ["range", "len", "min"], "source_code": "def min_distance_dp(word1, word2):\n    \"\"\"\n    Finds minimum distance in a dynamic programming manner\n    TC: O(length1*length2), SC: O(length1*length2)\n\n    :type word1: str\n    :type word2: str\n    :rtype: int\n    \"\"\"\n    (length1, length2) = (len(word1) + 1, len(word2) + 1)\n    res = [[0 for _ in range(length2)] for _ in range(length1)]\n    if length1 == length2:\n        for i in range(1, length1):\n            (res[i][0], res[0][i]) = (i, i)\n    else:\n        for i in range(length1):\n            res[i][0] = i\n        for i in range(length2):\n            res[0][i] = i\n    for i in range(1, length1):\n        for j in range(1, length2):\n            if word1[i - 1] == word2[j - 1]:\n                res[i][j] = res[i - 1][j - 1]\n            else:\n                res[i][j] = min(res[i - 1][j], res[i][j - 1]) + 1\n    return res[len(word1)][len(word2)]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/delete_reoccurring.py", "fileNameBase": "delete_reoccurring", "extension": "py", "doc": {"long_description": "character, and return the new string.\n\nThis is a Google warmup interview question that was asked duirng phone screening\nat my university.", "short_description": "QUESTION: Given a string as your input, delete any reoccurring ", "full": "QUESTION: Given a string as your input, delete any reoccurring \ncharacter, and return the new string.\n\nThis is a Google warmup interview question that was asked duirng phone screening\nat my university. "}}, "functions": {"delete_reoccurring_characters": {"args": ["string"], "returns": ["output_string"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 18}, "calls": ["set", "set.add"], "store_vars_calls": {"seen_characters": "set"}, "source_code": "def delete_reoccurring_characters(string):\n    seen_characters = set()\n    output_string = ''\n    for char in string:\n        if char not in seen_characters:\n            seen_characters.add(char)\n            output_string += char\n    return output_string"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/is_palindrome.py", "fileNameBase": "is_palindrome", "extension": "py", "doc": {"long_description": "considering only alphanumeric characters and ignoring cases.\nFor example,\n\"A man, a plan, a canal: Panama\" is a palindrome.\n\"race a car\" is not a palindrome.\nNote:\nHave you consider that the string might be empty?\nThis is a good question to ask during an interview.\nFor the purpose of this problem,\nwe define empty string as valid palindrome.", "short_description": "Given a string, determine if it is a palindrome,", "full": "Given a string, determine if it is a palindrome,\nconsidering only alphanumeric characters and ignoring cases.\nFor example,\n\"A man, a plan, a canal: Panama\" is a palindrome.\n\"race a car\" is not a palindrome.\nNote:\nHave you consider that the string might be empty?\nThis is a good question to ask during an interview.\nFor the purpose of this problem,\nwe define empty string as valid palindrome."}}, "dependencies": [{"from_module": "string", "import": "ascii_letters", "type": "external", "type_element": "module"}, {"from_module": "collections", "import": "deque", "type": "external", "type_element": "module"}], "functions": {"is_palindrome": {"args": ["s"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 33}, "calls": ["len", "s[].isalnum", "s[].lower"], "source_code": "def is_palindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        while not s[i].isalnum():\n            i += 1\n        while not s[j].isalnum():\n            j -= 1\n        if s[i].lower() != s[j].lower():\n            return False\n        (i, j) = (i + 1, j - 1)\n    return True"}, "remove_punctuation": {"doc": {"short_description": "Remove punctuation, case sensitivity and spaces"}, "args": ["s"], "returns": ["''.join((i.lower() for i in s if i in ascii_letters))"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 54}, "calls": ["i.lower"], "source_code": "def remove_punctuation(s):\n    \"\"\"\n    Remove punctuation, case sensitivity and spaces\n    \"\"\"\n    return ''.join((i.lower() for i in s if i in ascii_letters))"}, "string_reverse": {"args": ["s"], "returns": ["s[::-1]"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 58}, "source_code": "def string_reverse(s):\n    return s[::-1]"}, "is_palindrome_reverse": {"args": ["s"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 59, "max_lineno": 66}, "calls": ["is_palindrome.remove_punctuation", "is_palindrome.string_reverse"], "store_vars_calls": {"s": "remove_punctuation"}, "source_code": "def is_palindrome_reverse(s):\n    s = remove_punctuation(s)\n    if s == string_reverse(s):\n        return True\n    return False"}, "is_palindrome_two_pointer": {"args": ["s"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 76}, "calls": ["is_palindrome.remove_punctuation", "range", "len"], "store_vars_calls": {"s": "remove_punctuation"}, "source_code": "def is_palindrome_two_pointer(s):\n    s = remove_punctuation(s)\n    for i in range(0, len(s) // 2):\n        if s[i] != s[len(s) - i - 1]:\n            return False\n    return True"}, "is_palindrome_stack": {"args": ["s"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 79, "max_lineno": 89}, "calls": ["is_palindrome.remove_punctuation", "range", "len", "stack.append", "stack.pop"], "store_vars_calls": {"s": "remove_punctuation"}, "source_code": "def is_palindrome_stack(s):\n    stack = []\n    s = remove_punctuation(s)\n    for i in range(len(s) // 2, len(s)):\n        stack.append(s[i])\n    for i in range(0, len(s) // 2):\n        if s[i] != stack.pop():\n            return False\n    return True"}, "is_palindrome_deque": {"args": ["s"], "returns": ["equal"], "min_max_lineno": {"min_lineno": 91, "max_lineno": 106}, "calls": ["is_palindrome.remove_punctuation", "collections.deque", "collections.deque.appendleft", "collections.deque.pop", "collections.deque.popleft", "len"], "store_vars_calls": {"s": "remove_punctuation", "deq": "deque", "first": "deq.pop", "last": "deq.popleft"}, "source_code": "def is_palindrome_deque(s):\n    s = remove_punctuation(s)\n    deq = deque()\n    for char in s:\n        deq.appendleft(char)\n    equal = True\n    while len(deq) > 1 and equal:\n        first = deq.pop()\n        last = deq.popleft()\n        if first != last:\n            equal = False\n    return equal"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/knuth_morris_pratt.py", "fileNameBase": "knuth_morris_pratt", "extension": "py"}, "dependencies": [{"from_module": "typing", "import": "Sequence", "type": "external", "type_element": "module"}, {"from_module": "typing", "import": "List", "type": "external", "type_element": "module"}], "functions": {"knuth_morris_pratt": {"doc": {"long_description": "using knuth_morris_pratt algorithm.", "short_description": "Given two strings text and pattern, return the list of start indexes in text that matches with the pattern", "args": {"text": {"description": "Text to search"}, "pattern": {"description": "Pattern to search in the text"}}, "returns": {"description": "List of indices of patterns found", "is_generator": false}}, "args": ["text", "pattern"], "annotated_arg_types": {"text": "Sequence", "pattern": "Sequence"}, "annotated_return_type": "List[int]", "returns": ["ret"], "min_max_lineno": {"min_lineno": 3, "max_lineno": 45}, "calls": ["len", "range", "ret.append"], "store_vars_calls": {"n": "len", "m": "len"}, "source_code": "def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]:\n    \"\"\"\n    Given two strings text and pattern, return the list of start indexes in text that matches with the pattern\n    using knuth_morris_pratt algorithm.\n\n    Args:\n        text: Text to search\n        pattern: Pattern to search in the text\n    Returns:\n        List of indices of patterns found\n\n    Example:\n        >>> knuth_morris_pratt('hello there hero!', 'he')\n        [0, 7, 12]\n\n    If idx is in the list, text[idx : idx + M] matches with pattern.\n    Time complexity of the algorithm is O(N+M), with N and M the length of text and pattern, respectively.\n    \"\"\"\n    n = len(text)\n    m = len(pattern)\n    pi = [0 for i in range(m)]\n    i = 0\n    j = 0\n    for i in range(1, m):\n        while j and pattern[i] != pattern[j]:\n            j = pi[j - 1]\n        if pattern[i] == pattern[j]:\n            j += 1\n            pi[i] = j\n    j = 0\n    ret = []\n    for i in range(n):\n        while j and text[i] != pattern[j]:\n            j = pi[j - 1]\n        if text[i] == pattern[j]:\n            j += 1\n            if j == m:\n                ret.append(i - m + 1)\n                j = pi[j - 1]\n    return ret"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/license_number.py", "fileNameBase": "license_number", "extension": "py"}, "functions": {"license_number": {"args": ["key", "k"], "returns": ["''.join(res[::-1])"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 12}, "calls": ["enumerate", "reversed", "res.append", "alnum.append", "len"], "source_code": "def license_number(key, k):\n    (res, alnum) = ([], [])\n    for char in key:\n        if char != '-':\n            alnum.append(char)\n    for (i, char) in enumerate(reversed(alnum)):\n        res.append(char)\n        if (i + 1) % k == 0 and i != len(alnum) - 1:\n            res.append('-')\n    return ''.join(res[::-1])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/is_rotated.py", "fileNameBase": "is_rotated", "extension": "py", "doc": {"long_description": "For example,\nis_rotated(\"hello\", \"llohe\") returns True\nis_rotated(\"hello\", \"helol\") returns False\n\naccepts two strings\nreturns bool\nReference: https://leetcode.com/problems/rotate-string/description/", "short_description": "Given two strings s1 and s2, determine if s2 is a rotated version of s1.", "full": "Given two strings s1 and s2, determine if s2 is a rotated version of s1.\nFor example,\nis_rotated(\"hello\", \"llohe\") returns True\nis_rotated(\"hello\", \"helol\") returns False\n\naccepts two strings\nreturns bool\nReference: https://leetcode.com/problems/rotate-string/description/"}}, "functions": {"is_rotated": {"args": ["s1", "s2"], "returns": ["s2 in s1 + s1", "False"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 17}, "calls": ["len"], "source_code": "def is_rotated(s1, s2):\n    if len(s1) == len(s2):\n        return s2 in s1 + s1\n    else:\n        return False"}, "is_rotated_v1": {"args": ["s1", "s2"], "returns": ["False", "False", "True", "True"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 32}, "calls": ["range", "len", "all"], "source_code": "def is_rotated_v1(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    if len(s1) == 0:\n        return True\n    for c in range(len(s1)):\n        if all((s1[(c + i) % len(s1)] == s2[i] for i in range(len(s1)))):\n            return True\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/domain_extractor.py", "fileNameBase": "domain_extractor", "extension": "py", "doc": {"long_description": "Examples:\ndomain_name(\"http://github.com/SaadBenn\") == \"github\" \ndomain_name(\"http://www.zombie-bites.com\") == \"zombie-bites\"\ndomain_name(\"https://www.cnet.com\") == \"cnet\"\n\nNote: The idea is not to use any built-in libraries such as re (regular expression) or urlparse except .split() built-in function", "short_description": "Write a function that when given a URL as a string, parses out just the domain name and returns it as a string. ", "full": "Write a function that when given a URL as a string, parses out just the domain name and returns it as a string. \n\nExamples:\ndomain_name(\"http://github.com/SaadBenn\") == \"github\" \ndomain_name(\"http://www.zombie-bites.com\") == \"zombie-bites\"\ndomain_name(\"https://www.cnet.com\") == \"cnet\"\n\nNote: The idea is not to use any built-in libraries such as re (regular expression) or urlparse except .split() built-in function"}}, "functions": {"domain_name_1": {"args": ["url"], "returns": ["actual_domain[0]", "actual_domain[1]"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 24}, "calls": ["full_domain_name.split", "url.split", "len"], "store_vars_calls": {"actual_domain": "full_domain_name.split"}, "source_code": "def domain_name_1(url):\n    full_domain_name = url.split('//')[-1]\n    actual_domain = full_domain_name.split('.')\n    if len(actual_domain) > 2:\n        return actual_domain[1]\n    return actual_domain[0]"}, "domain_name_2": {"args": ["url"], "returns": ["url.split('//')[-1].split('www.')[-1].split('.')[0]"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 29}, "calls": ["[].split", "url.split"], "source_code": "def domain_name_2(url):\n    return url.split('//')[-1].split('www.')[-1].split('.')[0]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/unique_morse.py", "fileNameBase": "unique_morse", "extension": "py", "doc": {"long_description": "a series of dots and dashes, as follows: \"a\" maps to \".-\", \"b\" maps to \"-...\", \"c\"\nmaps to \"-.-.\", and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n        'a':\".-\",\n        'b':\"-...\",\n        'c':\"-.-.\",\n        'd': \"-..\",\n        'e':\".\",\n        'f':\"..-.\",\n        'g':\"--.\",\n        'h':\"....\",\n        'i':\"..\",\n        'j':\".---\",\n        'k':\"-.-\",\n        'l':\".-..\",\n        'm':\"--\",\n        'n':\"-.\",\n        'o':\"---\",\n        'p':\".--.\",\n        'q':\"--.-\",\n        'r':\".-.\",\n        's':\"...\",\n        't':\"-\",\n        'u':\"..-\",\n        'v':\"...-\",\n        'w':\".--\",\n        'x':\"-..-\",\n        'y':\"-.--\",\n        'z':\"--..\"\n\nNow, given a list of words, each word can be written as a concatenation of the\nMorse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\",\n(which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a\nconcatenation, the transformation of a word.\n\nReturn the number of different transformations among all words we have.\nExample:\nInput: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\nOutput: 2\nExplanation:\nThe transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\".", "short_description": "International Morse Code defines a standard encoding where each letter is mapped to", "full": "International Morse Code defines a standard encoding where each letter is mapped to\na series of dots and dashes, as follows: \"a\" maps to \".-\", \"b\" maps to \"-...\", \"c\"\nmaps to \"-.-.\", and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n        'a':\".-\",\n        'b':\"-...\",\n        'c':\"-.-.\",\n        'd': \"-..\",\n        'e':\".\",\n        'f':\"..-.\",\n        'g':\"--.\",\n        'h':\"....\",\n        'i':\"..\",\n        'j':\".---\",\n        'k':\"-.-\",\n        'l':\".-..\",\n        'm':\"--\",\n        'n':\"-.\",\n        'o':\"---\",\n        'p':\".--.\",\n        'q':\"--.-\",\n        'r':\".-.\",\n        's':\"...\",\n        't':\"-\",\n        'u':\"..-\",\n        'v':\"...-\",\n        'w':\".--\",\n        'x':\"-..-\",\n        'y':\"-.--\",\n        'z':\"--..\"\n\nNow, given a list of words, each word can be written as a concatenation of the\nMorse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\",\n(which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a\nconcatenation, the transformation of a word.\n\nReturn the number of different transformations among all words we have.\nExample:\nInput: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\nOutput: 2\nExplanation:\nThe transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\"."}}, "functions": {"convert_morse_word": {"args": ["word"], "returns": ["morse_word"], "min_max_lineno": {"min_lineno": 81, "max_lineno": 87}, "calls": ["word.lower.lower"], "store_vars_calls": {"word": "word.lower"}, "source_code": "def convert_morse_word(word):\n    morse_word = ''\n    word = word.lower()\n    for char in word:\n        morse_word = morse_word + morse_code[char]\n    return morse_word"}, "unique_morse": {"args": ["words"], "returns": ["len(unique_morse_word)"], "min_max_lineno": {"min_lineno": 88, "max_lineno": 95}, "calls": ["len", "unique_morse.convert_morse_word", "unique_morse_word.append"], "store_vars_calls": {"morse_word": "convert_morse_word"}, "source_code": "def unique_morse(words):\n    unique_morse_word = []\n    for word in words:\n        morse_word = convert_morse_word(word)\n        if morse_word not in unique_morse_word:\n            unique_morse_word.append(morse_word)\n    return len(unique_morse_word)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/text_justification.py", "fileNameBase": "text_justification", "extension": "py", "doc": {"long_description": "has exactly maxWidth characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as\nyou can in each line. Pad extra spaces ' ' when necessary so that each line has\nexactly maxWidth characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the\nnumber of spaces on a line do not divide evenly between words, the empty slots\non the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left justified and no extra space is\ninserted between words.\n\nNote:\nA word is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\nThe input array words contains at least one word.\n\nExample:\nInput:\nwords = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\nmaxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]", "short_description": "Given an array of words and a width maxWidth, format the text such that each line", "full": "Given an array of words and a width maxWidth, format the text such that each line\nhas exactly maxWidth characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as\nyou can in each line. Pad extra spaces ' ' when necessary so that each line has\nexactly maxWidth characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the\nnumber of spaces on a line do not divide evenly between words, the empty slots\non the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left justified and no extra space is\ninserted between words.\n\nNote:\nA word is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\nThe input array words contains at least one word.\n\nExample:\nInput:\nwords = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\nmaxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]"}}, "functions": {"text_justification": {"args": ["words", "max_width"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 90}, "calls": ["len", "ret.append", "row_words.append", "ValueError", "row_words.pop", "range"], "source_code": "def text_justification(words, max_width):\n    \"\"\"\n    :type words: list\n    :type max_width: int\n    :rtype: list\n    \"\"\"\n    ret = []\n    row_len = 0\n    row_words = []\n    index = 0\n    is_first_word = True\n    while index < len(words):\n        while row_len <= max_width and index < len(words):\n            if len(words[index]) > max_width:\n                raise ValueError('there exists word whose length is larger than max_width')\n            tmp = row_len\n            row_words.append(words[index])\n            tmp += len(words[index])\n            if not is_first_word:\n                tmp += 1\n            if tmp > max_width:\n                row_words.pop()\n                break\n            row_len = tmp\n            index += 1\n            is_first_word = False\n        row = ''\n        if index == len(words):\n            for word in row_words:\n                row += word + ' '\n            row = row[:-1]\n            row += ' ' * (max_width - len(row))\n        elif len(row_words) != 1:\n            space_num = max_width - row_len\n            space_num_of_each_interval = space_num // (len(row_words) - 1)\n            space_num_rest = space_num - space_num_of_each_interval * (len(row_words) - 1)\n            for j in range(len(row_words)):\n                row += row_words[j]\n                if j != len(row_words) - 1:\n                    row += ' ' * (1 + space_num_of_each_interval)\n                if space_num_rest > 0:\n                    row += ' '\n                    space_num_rest -= 1\n        else:\n            row += row_words[0]\n            row += ' ' * (max_width - len(row))\n        ret.append(row)\n        row_len = 0\n        row_words = []\n        is_first_word = True\n    return ret"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/group_anagrams.py", "fileNameBase": "group_anagrams", "extension": "py", "doc": {"long_description": "For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\nReturn:\n\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]", "short_description": "Given an array of strings, group anagrams together.", "full": "Given an array of strings, group anagrams together.\n\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\nReturn:\n\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]"}}, "functions": {"group_anagrams": {"args": ["strs"], "returns": ["ans"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 29}, "calls": ["sorted", "ans.append", "ans[].append"], "source_code": "def group_anagrams(strs):\n    d = {}\n    ans = []\n    k = 0\n    for str in strs:\n        sstr = ''.join(sorted(str))\n        if sstr not in d:\n            d[sstr] = k\n            k += 1\n            ans.append([])\n            ans[-1].append(str)\n        else:\n            ans[d[sstr]].append(str)\n    return ans"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/roman_to_int.py", "fileNameBase": "roman_to_int", "extension": "py", "doc": {"long_description": "Input is guaranteed to be within the range from 1 to 3999.", "short_description": "Given a roman numeral, convert it to an integer.", "full": "Given a roman numeral, convert it to an integer.\nInput is guaranteed to be within the range from 1 to 3999."}}, "functions": {"roman_to_int": {"args": ["s"], "annotated_arg_types": {"s": "'str'"}, "annotated_return_type": "'int'", "returns": ["number + roman[s[-1]]"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 16}, "calls": ["range", "len"], "source_code": "def roman_to_int(s: 'str') -> 'int':\n    number = 0\n    roman = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}\n    for i in range(len(s) - 1):\n        if roman[s[i]] < roman[s[i + 1]]:\n            number -= roman[s[i]]\n        else:\n            number += roman[s[i]]\n    return number + roman[s[-1]]"}}, "body": {"calls": ["print", "roman_to_int.roman_to_int"], "source_code": ["print(roman_to_int(roman))", "roman_to_int(roman)"]}, "main_info": {"main_flag": 1, "main_function": "roman_to_int.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/longest_common_prefix.py", "fileNameBase": "longest_common_prefix", "extension": "py", "doc": {"long_description": "If there is no common prefix, return an empty string \"\".\n\nExample 1:\nInput: [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\nInput: [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\nReference: https://leetcode.com/problems/longest-common-prefix/description/", "short_description": "Write a function to find the longest common prefix string amongst an array of strings.", "full": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\nExample 1:\nInput: [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\nInput: [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\nReference: https://leetcode.com/problems/longest-common-prefix/description/"}}, "functions": {"common_prefix": {"doc": {"short_description": "Return prefix common of 2 strings"}, "args": ["s1", "s2"], "returns": ["s1[0:k]", "''", "s1[0:k]"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 31}, "calls": ["len"], "source_code": "def common_prefix(s1, s2):\n    \"\"\"Return prefix common of 2 strings\"\"\"\n    if not s1 or not s2:\n        return ''\n    k = 0\n    while s1[k] == s2[k]:\n        k = k + 1\n        if k >= len(s1) or k >= len(s2):\n            return s1[0:k]\n    return s1[0:k]"}, "longest_common_prefix_v1": {"args": ["strs"], "returns": ["result", "''"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 39}, "calls": ["range", "len", "longest_common_prefix.common_prefix"], "store_vars_calls": {"result": "common_prefix"}, "source_code": "def longest_common_prefix_v1(strs):\n    if not strs:\n        return ''\n    result = strs[0]\n    for i in range(len(strs)):\n        result = common_prefix(result, strs[i])\n    return result"}, "longest_common_prefix_v2": {"args": ["strs"], "returns": ["strs[0]", "''", "strs[0][0:i]"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 51}, "calls": ["range", "len"], "source_code": "def longest_common_prefix_v2(strs):\n    if not strs:\n        return ''\n    for i in range(len(strs[0])):\n        for string in strs[1:]:\n            if i == len(string) or string[i] != strs[0][i]:\n                return strs[0][0:i]\n    return strs[0]"}, "longest_common_prefix_v3": {"args": ["strs"], "returns": ["longest_common(strs, 0, len(strs) - 1)", "''"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 59}, "calls": ["longest_common_prefix.longest_common", "len"], "source_code": "def longest_common_prefix_v3(strs):\n    if not strs:\n        return ''\n    return longest_common(strs, 0, len(strs) - 1)"}, "longest_common": {"args": ["strs", "left", "right"], "returns": ["common_prefix(lcp_left, lcp_right)", "strs[left]"], "min_max_lineno": {"min_lineno": 60, "max_lineno": 67}, "calls": ["longest_common_prefix.longest_common", "longest_common_prefix.common_prefix"], "store_vars_calls": {"lcp_left": "longest_common", "lcp_right": "longest_common"}, "source_code": "def longest_common(strs, left, right):\n    if left == right:\n        return strs[left]\n    mid = (left + right) // 2\n    lcp_left = longest_common(strs, left, mid)\n    lcp_right = longest_common(strs, mid + 1, right)\n    return common_prefix(lcp_left, lcp_right)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "add_binary", "import": "add_binary", "type": "internal", "type_element": "function"}, {"from_module": "breaking_bad", "import": "match_symbol", "type": "internal", "type_element": "function"}, {"from_module": "breaking_bad", "import": "match_symbol_1", "type": "internal", "type_element": "function"}, {"from_module": "breaking_bad", "import": "bracket", "type": "internal", "type_element": "function"}, {"from_module": "breaking_bad", "import": "TreeNode", "type": "internal", "type_element": "class"}, {"from_module": "decode_string", "import": "decode_string", "type": "internal", "type_element": "function"}, {"from_module": "delete_reoccurring", "import": "delete_reoccurring_characters", "type": "internal", "type_element": "function"}, {"from_module": "domain_extractor", "import": "domain_name_1", "type": "internal", "type_element": "function"}, {"from_module": "domain_extractor", "import": "domain_name_2", "type": "internal", "type_element": "function"}, {"from_module": "encode_decode", "import": "encode", "type": "internal", "type_element": "function"}, {"from_module": "encode_decode", "import": "decode", "type": "internal", "type_element": "function"}, {"from_module": "group_anagrams", "import": "group_anagrams", "type": "internal", "type_element": "function"}, {"from_module": "int_to_roman", "import": "int_to_roman", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "remove_punctuation", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "string_reverse", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_reverse", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_two_pointer", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_stack", "type": "internal", "type_element": "function"}, {"from_module": "is_palindrome", "import": "is_palindrome_deque", "type": "internal", "type_element": "function"}, {"from_module": "is_rotated", "import": "is_rotated", "type": "internal", "type_element": "function"}, {"from_module": "is_rotated", "import": "is_rotated_v1", "type": "internal", "type_element": "function"}, {"from_module": "license_number", "import": "license_number", "type": "internal", "type_element": "function"}, {"from_module": "make_sentence", "import": "make_sentence", "type": "internal", "type_element": "function"}, {"from_module": "merge_string_checker", "import": "is_merge_recursive", "type": "internal", "type_element": "function"}, {"from_module": "merge_string_checker", "import": "is_merge_iterative", "type": "internal", "type_element": "function"}, {"from_module": "multiply_strings", "import": "multiply", "type": "internal", "type_element": "function"}, {"from_module": "one_edit_distance", "import": "is_one_edit", "type": "internal", "type_element": "function"}, {"from_module": "one_edit_distance", "import": "is_one_edit2", "type": "internal", "type_element": "function"}, {"from_module": "rabin_karp", "import": "rabin_karp", "type": "internal", "type_element": "function"}, {"from_module": "rabin_karp", "import": "RollingHash", "type": "internal", "type_element": "class"}, {"from_module": "reverse_string", "import": "recursive", "type": "internal", "type_element": "function"}, {"from_module": "reverse_string", "import": "iterative", "type": "internal", "type_element": "function"}, {"from_module": "reverse_string", "import": "pythonic", "type": "internal", "type_element": "function"}, {"from_module": "reverse_string", "import": "ultra_pythonic", "type": "internal", "type_element": "function"}, {"from_module": "reverse_vowel", "import": "reverse_vowel", "type": "internal", "type_element": "function"}, {"from_module": "reverse_words", "import": "reverse", "type": "internal", "type_element": "function"}, {"from_module": "reverse_words", "import": "reverse_words", "type": "internal", "type_element": "function"}, {"from_module": "roman_to_int", "import": "roman_to_int", "type": "internal", "type_element": "function"}, {"from_module": "strip_url_params", "import": "strip_url_params1", "type": "internal", "type_element": "function"}, {"from_module": "strip_url_params", "import": "strip_url_params2", "type": "internal", "type_element": "function"}, {"from_module": "strip_url_params", "import": "strip_url_params3", "type": "internal", "type_element": "function"}, {"from_module": "validate_coordinates", "import": "is_valid_coordinates_0", "type": "internal", "type_element": "function"}, {"from_module": "validate_coordinates", "import": "is_valid_coordinates_1", "type": "internal", "type_element": "function"}, {"from_module": "validate_coordinates", "import": "is_valid_coordinates_regular_expression", "type": "internal", "type_element": "function"}, {"from_module": "word_squares", "import": "word_squares", "type": "internal", "type_element": "function"}, {"from_module": "unique_morse", "import": "convert_morse_word", "type": "internal", "type_element": "function"}, {"from_module": "unique_morse", "import": "unique_morse", "type": "internal", "type_element": "function"}, {"from_module": "judge_circle", "import": "judge_circle", "type": "internal", "type_element": "function"}, {"from_module": "strong_password", "import": "strong_password", "type": "internal", "type_element": "function"}, {"from_module": "caesar_cipher", "import": "caesar_cipher", "type": "internal", "type_element": "function"}, {"from_module": "check_pangram", "import": "check_pangram", "type": "internal", "type_element": "function"}, {"from_module": "contain_string", "import": "contain_string", "type": "internal", "type_element": "function"}, {"from_module": "count_binary_substring", "import": "count_binary_substring", "type": "internal", "type_element": "function"}, {"from_module": "repeat_string", "import": "repeat_string", "type": "internal", "type_element": "function"}, {"from_module": "text_justification", "import": "text_justification", "type": "internal", "type_element": "function"}, {"from_module": "min_distance", "import": "min_distance", "type": "internal", "type_element": "function"}, {"from_module": "min_distance", "import": "lcs", "type": "internal", "type_element": "function"}, {"from_module": "min_distance", "import": "min_distance_dp", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "common_prefix", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "longest_common_prefix_v1", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "longest_common_prefix_v2", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "longest_common_prefix_v3", "type": "internal", "type_element": "function"}, {"from_module": "longest_common_prefix", "import": "longest_common", "type": "internal", "type_element": "function"}, {"from_module": "rotate", "import": "rotate", "type": "internal", "type_element": "function"}, {"from_module": "rotate", "import": "rotate_alt", "type": "internal", "type_element": "function"}, {"from_module": "first_unique_char", "import": "first_unique_char", "type": "internal", "type_element": "function"}, {"from_module": "repeat_substring", "import": "repeat_substring", "type": "internal", "type_element": "function"}, {"from_module": "atbash_cipher", "import": "atbash", "type": "internal", "type_element": "function"}, {"from_module": "longest_palindromic_substring", "import": "longest_palindrome", "type": "internal", "type_element": "function"}, {"from_module": "knuth_morris_pratt", "import": "knuth_morris_pratt", "type": "internal", "type_element": "function"}, {"from_module": "panagram", "import": "panagram", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/one_edit_distance.py", "fileNameBase": "one_edit_distance", "extension": "py", "doc": {"short_description": "Given two strings S and T, determine if they are both one edit distance apart.", "full": "Given two strings S and T, determine if they are both one edit distance apart."}}, "functions": {"is_one_edit": {"args": ["s", "t"], "returns": ["True", "is_one_edit(t, s)", "False", "s[i + 1:] == t[i + 1:] or s[i:] == t[i + 1:]"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 20}, "calls": ["range", "len", "one_edit_distance.is_one_edit"], "source_code": "def is_one_edit(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    if len(s) > len(t):\n        return is_one_edit(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            return s[i + 1:] == t[i + 1:] or s[i:] == t[i + 1:]\n    return True"}, "is_one_edit2": {"args": ["s", "t"], "returns": ["s == t or s == t[:-1]", "is_one_edit2(t, s)", "False"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 36}, "calls": ["range", "len", "one_edit_distance.is_one_edit2"], "source_code": "def is_one_edit2(s, t):\n    (l1, l2) = (len(s), len(t))\n    if l1 > l2:\n        return is_one_edit2(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if l1 == l2:\n                s = s[:i] + t[i] + s[i + 1:]\n            else:\n                s = s[:i] + t[i] + s[i:]\n            break\n    return s == t or s == t[:-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/strip_url_params.py", "fileNameBase": "strip_url_params", "extension": "py", "doc": {"long_description": "Removes any duplicate query string parameters from the url\nRemoves any query string parameters specified within the 2nd argument (optional array)\n\nAn example:\nwww.saadbenn.com?a=1&b=2&a=2') // returns 'www.saadbenn.com?a=1&b=2'", "short_description": "Write a function that does the following:", "full": "Write a function that does the following:\nRemoves any duplicate query string parameters from the url\nRemoves any query string parameters specified within the 2nd argument (optional array)\n\nAn example:\nwww.saadbenn.com?a=1&b=2&a=2') // returns 'www.saadbenn.com?a=1&b=2'"}}, "dependencies": [{"from_module": "collections", "import": "defaultdict", "type": "external", "type_element": "module"}, {"import": "urllib", "type": "external", "type_element": "module"}, {"import": "urllib", "type": "external", "type_element": "module"}], "functions": {"strip_url_params1": {"args": ["url", "params_to_strip"], "returns": ["result", "url"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 69}, "calls": ["url.split", "len", "collections.defaultdict", "char.isdigit", "i.split", "key_value_string.append"], "store_vars_calls": {"tokens": "url.split", "dict": "defaultdict", "_token": "i.split", "length": "len"}, "source_code": "def strip_url_params1(url, params_to_strip=None):\n    if not params_to_strip:\n        params_to_strip = []\n    if url:\n        result = ''\n        tokens = url.split('?')\n        domain = tokens[0]\n        query_string = tokens[-1]\n        result += domain\n        if len(tokens) > 1:\n            result += '?'\n        if not query_string:\n            return url\n        else:\n            key_value_string = []\n            string = ''\n            for char in query_string:\n                if char.isdigit():\n                    key_value_string.append(string + char)\n                    string = ''\n                else:\n                    string += char\n            dict = defaultdict(int)\n            for i in key_value_string:\n                _token = i.split('=')\n                if _token[0]:\n                    length = len(_token[0])\n                    if length == 1:\n                        if _token and (not _token[0] in dict):\n                            if params_to_strip:\n                                if _token[0] != params_to_strip[0]:\n                                    dict[_token[0]] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            elif not _token[0] in dict:\n                                dict[_token[0]] = _token[1]\n                                result = result + _token[0] + '=' + _token[1]\n                    else:\n                        check = _token[0]\n                        letter = check[1]\n                        if _token and (not letter in dict):\n                            if params_to_strip:\n                                if letter != params_to_strip[0]:\n                                    dict[letter] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            elif not letter in dict:\n                                dict[letter] = _token[1]\n                                result = result + _token[0] + '=' + _token[1]\n    return result"}, "strip_url_params2": {"args": ["url", "param_to_strip"], "returns": ["url.split('?')[0] + '?' + '&'.join(queries)", "url"], "min_max_lineno": {"min_lineno": 71, "max_lineno": 82}, "calls": ["[].split", "range", "len", "[].split.pop", "url.split"], "store_vars_calls": {"queries": "[].split"}, "source_code": "def strip_url_params2(url, param_to_strip=[]):\n    if '?' not in url:\n        return url\n    queries = url.split('?')[1].split('&')\n    queries_obj = [query[0] for query in queries]\n    for i in range(len(queries_obj) - 1, 0, -1):\n        if queries_obj[i] in param_to_strip or queries_obj[i] in queries_obj[0:i]:\n            queries.pop(i)\n    return url.split('?')[0] + '?' + '&'.join(queries)"}, "strip_url_params3": {"args": ["url", "strip"], "returns": ["new.geturl()"], "min_max_lineno": {"min_lineno": 85, "max_lineno": 96}, "calls": ["urllib.parse.urlparse", "urllib.parse.urlparse", "urllib.parse.parse_qs", "urllib.parse.parse_qs", "urllib.parse.urlencode", "urllib.parse.urlencode", "urllib.parse.urlparse._replace", "parse._replace.geturl", "urllib.parse.urlencode.items"], "store_vars_calls": {"parse": "urllib.parse.urlparse", "query": "urllib.parse.urlencode", "new": "parse._replace"}, "source_code": "def strip_url_params3(url, strip=None):\n    if not strip:\n        strip = []\n    parse = urllib.parse.urlparse(url)\n    query = urllib.parse.parse_qs(parse.query)\n    query = {k: v[0] for (k, v) in query.items() if k not in strip}\n    query = urllib.parse.urlencode(query)\n    new = parse._replace(query=query)\n    return new.geturl()"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/repeat_substring.py", "fileNameBase": "repeat_substring", "extension": "py", "doc": {"long_description": "a substring of it and appending multiple copies of the substring together.\n\nFor example:\nInput: \"abab\"\nOutput: True\nExplanation: It's the substring \"ab\" twice.\n\nInput: \"aba\"\nOutput: False\n\nInput: \"abcabcabcabc\"\nOutput: True\nExplanation: It's the substring \"abc\" four times.\n\nReference: https://leetcode.com/problems/repeated-substring-pattern/description/", "short_description": "Given a non-empty string check if it can be constructed by taking", "full": "Given a non-empty string check if it can be constructed by taking\na substring of it and appending multiple copies of the substring together.\n\nFor example:\nInput: \"abab\"\nOutput: True\nExplanation: It's the substring \"ab\" twice.\n\nInput: \"aba\"\nOutput: False\n\nInput: \"abcabcabcabc\"\nOutput: True\nExplanation: It's the substring \"abc\" four times.\n\nReference: https://leetcode.com/problems/repeated-substring-pattern/description/"}}, "functions": {"repeat_substring": {"args": ["s"], "returns": ["s in str"], "min_max_lineno": {"min_lineno": 19, "max_lineno": 26}, "source_code": "def repeat_substring(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    str = (s + s)[1:-1]\n    return s in str"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/contain_string.py", "fileNameBase": "contain_string", "extension": "py", "doc": {"long_description": "Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\nExample 1:\nInput: haystack = \"hello\", needle = \"ll\"\nOutput: 2\n\nExample 2:\nInput: haystack = \"aaaaa\", needle = \"bba\"\nOutput: -1\nReference: https://leetcode.com/problems/implement-strstr/description/", "short_description": "Implement strStr().", "full": "Implement strStr().\n\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\nExample 1:\nInput: haystack = \"hello\", needle = \"ll\"\nOutput: 2\n\nExample 2:\nInput: haystack = \"aaaaa\", needle = \"bba\"\nOutput: -1\nReference: https://leetcode.com/problems/implement-strstr/description/"}}, "functions": {"contain_string": {"args": ["haystack", "needle"], "returns": ["-1", "0", "-1", "-1", "i"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 26}, "calls": ["range", "len"], "source_code": "def contain_string(haystack, needle):\n    if len(needle) == 0:\n        return 0\n    if len(needle) > len(haystack):\n        return -1\n    for i in range(len(haystack)):\n        if len(haystack) - i < len(needle):\n            return -1\n        if haystack[i:i + len(needle)] == needle:\n            return i\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/rabin_karp.py", "fileNameBase": "rabin_karp", "extension": "py"}, "classes": {"RollingHash": {"min_max_lineno": {"min_lineno": 4, "max_lineno": 31}, "methods": {"__init__": {"args": ["self", "text", "size_word"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 19}, "calls": ["range", "ord"], "source_code": "def __init__(self, text, size_word):\n    self.text = text\n    self.hash = 0\n    self.size_word = size_word\n    for i in range(0, size_word):\n        self.hash += (ord(self.text[i]) - ord('a') + 1) * 26 ** (size_word - i - 1)\n    self.window_start = 0\n    self.window_end = size_word"}, "move_window": {"args": ["self"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 28}, "calls": ["len", "ord"], "source_code": "def move_window(self):\n    if self.window_end <= len(self.text) - 1:\n        self.hash -= (ord(self.text[self.window_start]) - ord('a') + 1) * 26 ** (self.size_word - 1)\n        self.hash *= 26\n        self.hash += ord(self.text[self.window_end]) - ord('a') + 1\n        self.window_start += 1\n        self.window_end += 1"}, "window_text": {"args": ["self"], "returns": ["self.text[self.window_start:self.window_end]"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 31}, "source_code": "def window_text(self):\n    return self.text[self.window_start:self.window_end]"}}}}, "functions": {"rabin_karp": {"args": ["word", "text"], "returns": ["None", "None", "None", "i"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 48}, "calls": ["rabin_karp.RollingHash", "range", "len", "rabin_karp.RollingHash.move_window", "rabin_karp.RollingHash.window_text"], "store_vars_calls": {"rolling_hash": "RollingHash", "word_hash": "RollingHash"}, "source_code": "def rabin_karp(word, text):\n    if word == '' or text == '':\n        return None\n    if len(word) > len(text):\n        return None\n    rolling_hash = RollingHash(text, len(word))\n    word_hash = RollingHash(word, len(word))\n    for i in range(len(text) - len(word) + 1):\n        if rolling_hash.hash == word_hash.hash:\n            if rolling_hash.window_text() == word:\n                return i\n        rolling_hash.move_window()\n    return None"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/count_binary_substring.py", "fileNameBase": "count_binary_substring", "extension": "py", "doc": {"long_description": "the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.\nExample 1:\nInput: \"00110011\"\nOutput: 6\nExplanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\n\nNotice that some of these substrings repeat and are counted the number of times they occur.\n\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\nExample 2:\nInput: \"10101\"\nOutput: 4\nExplanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\nReference: https://leetcode.com/problems/count-binary-substrings/description/", "short_description": "Give a string s, count the number of non-empty (contiguous) substrings that have", "full": "Give a string s, count the number of non-empty (contiguous) substrings that have\n the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.\nExample 1:\nInput: \"00110011\"\nOutput: 6\nExplanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\n\nNotice that some of these substrings repeat and are counted the number of times they occur.\n\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\nExample 2:\nInput: \"10101\"\nOutput: 4\nExplanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\nReference: https://leetcode.com/problems/count-binary-substrings/description/"}}, "functions": {"count_binary_substring": {"args": ["s"], "returns": ["count"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 34}, "calls": ["range", "len", "min"], "source_code": "def count_binary_substring(s):\n    cur = 1\n    pre = 0\n    count = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            count = count + min(pre, cur)\n            pre = cur\n            cur = 1\n        else:\n            cur = cur + 1\n    count = count + min(pre, cur)\n    return count"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/make_sentence.py", "fileNameBase": "make_sentence", "extension": "py", "doc": {"long_description": "string, such that all the words are contained in the dictionary.\n\neg: for given string -> \"appletablet\"\n\"apple\", \"tablet\"\n\"applet\", \"able\", \"t\"\n\"apple\", \"table\", \"t\"\n\"app\", \"let\", \"able\", \"t\"\n\n\"applet\", {app, let, apple, t, applet} => 3\n\"thing\", {\"thing\"} -> 1", "short_description": "For a given string and dictionary, how many sentences can you make from the", "full": "For a given string and dictionary, how many sentences can you make from the\nstring, such that all the words are contained in the dictionary.\n\neg: for given string -> \"appletablet\"\n\"apple\", \"tablet\"\n\"applet\", \"able\", \"t\"\n\"apple\", \"table\", \"t\"\n\"app\", \"let\", \"able\", \"t\"\n\n\"applet\", {app, let, apple, t, applet} => 3\n\"thing\", {\"thing\"} -> 1"}}, "functions": {"make_sentence": {"args": ["str_piece", "dictionaries"], "returns": ["True", "True"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 28}, "calls": ["range", "len", "make_sentence.make_sentence"], "source_code": "def make_sentence(str_piece, dictionaries):\n    global count\n    if len(str_piece) == 0:\n        return True\n    for i in range(0, len(str_piece)):\n        (prefix, suffix) = (str_piece[0:i], str_piece[i:])\n        if prefix in dictionaries:\n            if suffix in dictionaries or make_sentence(suffix, dictionaries):\n                count += 1\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/caesar_cipher.py", "fileNameBase": "caesar_cipher", "extension": "py", "doc": {"long_description": "Caesar's cipher shifts each letter by a number of letters. If the shift takes you\npast the end of the alphabet, just rotate back to the front of the alphabet.\nIn the case of a rotation by 3, w, x, y and z would map to z, a, b and c.\nOriginal alphabet:      abcdefghijklmnopqrstuvwxyz\nAlphabet rotated +3:    defghijklmnopqrstuvwxyzabc", "short_description": "Julius Caesar protected his confidential information by encrypting it using a cipher.", "full": "Julius Caesar protected his confidential information by encrypting it using a cipher.\nCaesar's cipher shifts each letter by a number of letters. If the shift takes you\npast the end of the alphabet, just rotate back to the front of the alphabet.\nIn the case of a rotation by 3, w, x, y and z would map to z, a, b and c.\nOriginal alphabet:      abcdefghijklmnopqrstuvwxyz\nAlphabet rotated +3:    defghijklmnopqrstuvwxyzabc"}}, "functions": {"caesar_cipher": {"args": ["s", "k"], "returns": ["result"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 20}, "calls": ["ord", "chr"], "store_vars_calls": {"n": "ord"}, "source_code": "def caesar_cipher(s, k):\n    result = ''\n    for char in s:\n        n = ord(char)\n        if 64 < n < 91:\n            n = (n - 65 + k) % 26 + 65\n        if 96 < n < 123:\n            n = (n - 97 + k) % 26 + 97\n        result = result + chr(n)\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/int_to_roman.py", "fileNameBase": "int_to_roman", "extension": "py", "doc": {"long_description": "Input is guaranteed to be within the range from 1 to 3999.", "short_description": "Given an integer, convert it to a roman numeral.", "full": "Given an integer, convert it to a roman numeral.\nInput is guaranteed to be within the range from 1 to 3999."}}, "functions": {"int_to_roman": {"args": ["num"], "returns": ["m[num // 1000] + c[num % 1000 // 100] + x[num % 100 // 10] + i[num % 10]"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 16}, "source_code": "def int_to_roman(num):\n    \"\"\"\n    :type num: int\n    :rtype: str\n    \"\"\"\n    m = ['', 'M', 'MM', 'MMM']\n    c = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']\n    x = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']\n    i = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']\n    return m[num // 1000] + c[num % 1000 // 100] + x[num % 100 // 10] + i[num % 10]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/validate_coordinates.py", "fileNameBase": "validate_coordinates", "extension": "py", "doc": {"long_description": "Create a function that will validate if given parameters are valid geographical coordinates.\nValid coordinates look like the following: \"23.32353342, -32.543534534\". The return value should be either true or false.\nLatitude (which is first float) can be between 0 and 90, positive or negative. Longitude (which is second float) can be between 0 and 180, positive or negative.\nCoordinates can only contain digits, or one of the following symbols (including space after comma) -, .\nThere should be no space between the minus \"-\" sign and the digit after it.\n\nHere are some valid coordinates:\n-23, 25\n43.91343345, 143\n4, -3\n\nAnd some invalid ones:\n23.234, - 23.4234\nN23.43345, E32.6457\n6.325624, 43.34345.345\n0, 1,2", "short_description": "\"", "full": "\"\nCreate a function that will validate if given parameters are valid geographical coordinates.\nValid coordinates look like the following: \"23.32353342, -32.543534534\". The return value should be either true or false.\nLatitude (which is first float) can be between 0 and 90, positive or negative. Longitude (which is second float) can be between 0 and 180, positive or negative.\nCoordinates can only contain digits, or one of the following symbols (including space after comma) -, .\nThere should be no space between the minus \"-\" sign and the digit after it.\n\nHere are some valid coordinates:\n-23, 25\n43.91343345, 143\n4, -3\n\nAnd some invalid ones:\n23.234, - 23.4234\nN23.43345, E32.6457\n6.325624, 43.34345.345\n0, 1,2"}}, "dependencies": [{"import": "re", "type": "external", "type_element": "module"}], "functions": {"is_valid_coordinates_0": {"args": ["coordinates"], "returns": ["-90 <= latitude <= 90 and -180 <= longitude <= 180", "False", "False", "False"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 37}, "calls": ["coordinates.split", "len", "float", "char.isdigit"], "store_vars_calls": {"l": "coordinates.split", "latitude": "float", "longitude": "float"}, "source_code": "def is_valid_coordinates_0(coordinates):\n    for char in coordinates:\n        if not (char.isdigit() or char in ['-', '.', ',', ' ']):\n            return False\n    l = coordinates.split(', ')\n    if len(l) != 2:\n        return False\n    try:\n        latitude = float(l[0])\n        longitude = float(l[1])\n    except:\n        return False\n    return -90 <= latitude <= 90 and -180 <= longitude <= 180"}, "is_valid_coordinates_1": {"args": ["coordinates"], "returns": ["lat <= 90 and lng <= 180", "False"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 46}, "calls": ["abs", "float", "coordinates.split"], "source_code": "def is_valid_coordinates_1(coordinates):\n    try:\n        (lat, lng) = [abs(float(c)) for c in coordinates.split(',') if 'e' not in c]\n    except ValueError:\n        return False\n    return lat <= 90 and lng <= 180"}, "is_valid_coordinates_regular_expression": {"args": ["coordinates"], "returns": ["bool(re.match('-?(\\\\d|[1-8]\\\\d|90)\\\\.?\\\\d*, -?(\\\\d|[1-9]\\\\d|1[0-7]\\\\d|180)\\\\.?\\\\d*$', coordinates))"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 50}, "calls": ["bool", "re.match"], "source_code": "def is_valid_coordinates_regular_expression(coordinates):\n    return bool(re.match('-?(\\\\d|[1-8]\\\\d|90)\\\\.?\\\\d*, -?(\\\\d|[1-9]\\\\d|1[0-7]\\\\d|180)\\\\.?\\\\d*$', coordinates))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/multiply_strings.py", "fileNameBase": "multiply_strings", "extension": "py", "doc": {"long_description": "return the product of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 110.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert\nthe inputs to integer directly.", "short_description": "Given two non-negative integers num1 and num2 represented as strings,", "full": "Given two non-negative integers num1 and num2 represented as strings,\nreturn the product of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 110.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert\nthe inputs to integer directly."}}, "functions": {"multiply": {"args": ["num1", "num2"], "annotated_arg_types": {"num1": "'str'", "num2": "'str'"}, "annotated_return_type": "'str'", "returns": ["str(sum(interm))"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 29}, "calls": ["ord", "reversed", "str", "interm.append", "sum"], "store_vars_calls": {"zero": "ord"}, "source_code": "def multiply(num1: 'str', num2: 'str') -> 'str':\n    interm = []\n    zero = ord('0')\n    i_pos = 1\n    for i in reversed(num1):\n        j_pos = 1\n        add = 0\n        for j in reversed(num2):\n            mult = (ord(i) - zero) * (ord(j) - zero) * j_pos * i_pos\n            j_pos *= 10\n            add += mult\n        i_pos *= 10\n        interm.append(add)\n    return str(sum(interm))"}}, "body": {"calls": ["print", "multiply_strings.multiply"], "source_code": ["print(multiply('1', '23'))", "multiply('1', '23')", "print(multiply('23', '23'))", "multiply('23', '23')", "print(multiply('100', '23'))", "multiply('100', '23')", "print(multiply('100', '10000'))", "multiply('100', '10000')"]}, "main_info": {"main_flag": 1, "main_function": "multiply_strings.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/reverse_words.py", "fileNameBase": "reverse_words", "extension": "py"}, "functions": {"reverse": {"args": ["array", "i", "j"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 7}, "source_code": "def reverse(array, i, j):\n    while i < j:\n        (array[i], array[j]) = (array[j], array[i])\n        i += 1\n        j -= 1"}, "reverse_words": {"args": ["string"], "returns": ["' '.join(arr)"], "min_max_lineno": {"min_lineno": 9, "max_lineno": 15}, "calls": ["string.strip().split", "len", "reverse_words.reverse", "string.strip"], "store_vars_calls": {"arr": "string.strip().split", "n": "len"}, "source_code": "def reverse_words(string):\n    arr = string.strip().split()\n    n = len(arr)\n    reverse(arr, 0, n - 1)\n    return ' '.join(arr)"}}, "body": {"calls": ["print", "reverse_words.reverse_words"], "source_code": ["print(test)", "print(reverse_words(test))", "reverse_words(test)"]}, "main_info": {"main_flag": 1, "main_function": "reverse_words.print", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/reverse_vowel.py", "fileNameBase": "reverse_vowel", "extension": "py"}, "functions": {"reverse_vowel": {"args": ["s"], "returns": ["''.join(s)"], "min_max_lineno": {"min_lineno": 2, "max_lineno": 14}, "calls": ["list", "len"], "store_vars_calls": {"s": "list"}, "source_code": "def reverse_vowel(s):\n    vowels = 'AEIOUaeiou'\n    (i, j) = (0, len(s) - 1)\n    s = list(s)\n    while i < j:\n        while i < j and s[i] not in vowels:\n            i += 1\n        while i < j and s[j] not in vowels:\n            j -= 1\n        (s[i], s[j]) = (s[j], s[i])\n        (i, j) = (i + 1, j - 1)\n    return ''.join(s)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/decode_string.py", "fileNameBase": "decode_string", "extension": "py"}, "functions": {"decode_string": {"args": ["s"], "returns": ["cur_string"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 39}, "calls": ["stack.append", "stack.pop", "c.isdigit", "int"], "source_code": "def decode_string(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    stack = []\n    cur_num = 0\n    cur_string = ''\n    for c in s:\n        if c == '[':\n            stack.append((cur_string, cur_num))\n            cur_string = ''\n            cur_num = 0\n        elif c == ']':\n            (prev_string, num) = stack.pop()\n            cur_string = prev_string + num * cur_string\n        elif c.isdigit():\n            cur_num = cur_num * 10 + int(c)\n        else:\n            cur_string += c\n    return cur_string"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/judge_circle.py", "fileNameBase": "judge_circle", "extension": "py", "doc": {"long_description": "judge if this robot makes a circle, which means it moves back to the original place.\n\nThe move sequence is represented by a string. And each move is represent by a\ncharacter. The valid robot moves are R (Right), L (Left), U (Up) and D (down).\nThe output should be true or false representing whether the robot makes a circle.\n\nExample 1:\nInput: \"UD\"\nOutput: true\nExample 2:\nInput: \"LL\"\nOutput: false", "short_description": "Initially, there is a Robot at position (0, 0). Given a sequence of its moves,", "full": "Initially, there is a Robot at position (0, 0). Given a sequence of its moves,\njudge if this robot makes a circle, which means it moves back to the original place.\n\nThe move sequence is represented by a string. And each move is represent by a\ncharacter. The valid robot moves are R (Right), L (Left), U (Up) and D (down).\nThe output should be true or false representing whether the robot makes a circle.\n\nExample 1:\nInput: \"UD\"\nOutput: true\nExample 2:\nInput: \"LL\"\nOutput: false"}}, "functions": {"judge_circle": {"args": ["moves"], "returns": ["dict_moves['L'] == dict_moves['R'] and dict_moves['U'] == dict_moves['D']"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 26}, "source_code": "def judge_circle(moves):\n    dict_moves = {'U': 0, 'D': 0, 'R': 0, 'L': 0}\n    for char in moves:\n        dict_moves[char] = dict_moves[char] + 1\n    return dict_moves['L'] == dict_moves['R'] and dict_moves['U'] == dict_moves['D']"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/panagram.py", "fileNameBase": "panagram", "extension": "py", "doc": {"long_description": "A panagram is a sentence that uses every letter at least once.\n\nThe most famous example is: \"he quick brown fox jumps over the lazy dog.\n\nNote:\nA panagram in one language isn't necessarily a panagram in another. This\nmodule assumes the english language. Hence, the Finnish panagram\n'T\u00f6rkylempij\u00e4vongahdus' won't pass for a panagram despite being considered\na perfect panagram in its language. However, the Swedish panagram\n'Yxm\u00f6rdaren Julia Blomqvist p\u00e5 f\u00e4ktning i Schweiz' will pass despite\nincluding letters not used in the english alphabet. This is because the\nSwedish alphabet only extends the Latin one.", "short_description": "Given a string, check whether it is a panagram or not.", "full": "Given a string, check whether it is a panagram or not.\n\nA panagram is a sentence that uses every letter at least once.\n\nThe most famous example is: \"he quick brown fox jumps over the lazy dog.\n\nNote:\nA panagram in one language isn't necessarily a panagram in another. This\nmodule assumes the english language. Hence, the Finnish panagram\n'T\u00f6rkylempij\u00e4vongahdus' won't pass for a panagram despite being considered\na perfect panagram in its language. However, the Swedish panagram\n'Yxm\u00f6rdaren Julia Blomqvist p\u00e5 f\u00e4ktning i Schweiz' will pass despite\nincluding letters not used in the english alphabet. This is because the\nSwedish alphabet only extends the Latin one."}}, "dependencies": [{"from_module": "string", "import": "ascii_lowercase", "type": "external", "type_element": "module"}], "functions": {"panagram": {"doc": {"short_description": "Returns whether the input string is an English panagram or not.", "args": {"string": {"description": "A sentence in the form of a string.", "type_name": "str", "is_optional": false}}, "returns": {"description": "A boolean with the result.", "is_generator": false}}, "args": ["string"], "returns": ["len(letters) == 0"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 37}, "calls": ["set", "len", "set.remove", "c.lower"], "store_vars_calls": {"letters": "set"}, "source_code": "def panagram(string):\n    \"\"\"\n    Returns whether the input string is an English panagram or not.\n\n        Parameters:\n            string (str): A sentence in the form of a string.\n\n        Returns:\n            A boolean with the result.\n    \"\"\"\n    letters = set(ascii_lowercase)\n    for c in string:\n        try:\n            letters.remove(c.lower())\n        except:\n            pass\n    return len(letters) == 0"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/breaking_bad.py", "fileNameBase": "breaking_bad", "extension": "py", "doc": {"long_description": "the word with their matched symbol surrounded by square brackets.\n\nIf the word string matches more than one symbol, then choose the one with\nlongest length. (ex. 'Microsoft' matches 'i' and 'cro'):\n\nExample:\nWords array: ['Amazon', 'Microsoft', 'Google']\nSymbols: ['i', 'Am', 'cro', 'Na', 'le', 'abc']\n\nOutput:\n[Am]azon, Mi[cro]soft, Goog[le]\n\nMy solution(Wrong):\n(I sorted the symbols array in descending order of length and ran loop over\nwords array to find a symbol match(using indexOf in javascript) which\nworked. But I didn't make it through the interview, I am guessing my solution\nwas O(n^2) and they expected an efficient algorithm.\n\noutput:\n['[Am]azon', 'Mi[cro]soft', 'Goog[le]', 'Amaz[o]n', 'Micr[o]s[o]ft', 'G[o][o]gle']", "short_description": "Given an api which returns an array of words and an array of symbols, display", "full": "Given an api which returns an array of words and an array of symbols, display\nthe word with their matched symbol surrounded by square brackets.\n\nIf the word string matches more than one symbol, then choose the one with\nlongest length. (ex. 'Microsoft' matches 'i' and 'cro'):\n\nExample:\nWords array: ['Amazon', 'Microsoft', 'Google']\nSymbols: ['i', 'Am', 'cro', 'Na', 'le', 'abc']\n\nOutput:\n[Am]azon, Mi[cro]soft, Goog[le]\n\nMy solution(Wrong):\n(I sorted the symbols array in descending order of length and ran loop over\nwords array to find a symbol match(using indexOf in javascript) which\nworked. But I didn't make it through the interview, I am guessing my solution\nwas O(n^2) and they expected an efficient algorithm.\n\noutput:\n['[Am]azon', 'Mi[cro]soft', 'Goog[le]', 'Amaz[o]n', 'Micr[o]s[o]ft', 'G[o][o]gle']"}}, "dependencies": [{"from_module": "functools", "import": "reduce", "type": "external", "type_element": "module"}], "classes": {"TreeNode": {"min_max_lineno": {"min_lineno": 63, "max_lineno": 67}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 64, "max_lineno": 67}, "calls": ["dict"], "store_vars_calls": {"self.c": "dict"}, "source_code": "def __init__(self):\n    self.c = dict()\n    self.sym = None"}}}}, "functions": {"match_symbol": {"args": ["words", "symbols"], "returns": ["combined"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 37}, "calls": ["re.search", "combined.append", "re.sub"], "store_vars_calls": {"r": "re.search"}, "source_code": "def match_symbol(words, symbols):\n    import re\n    combined = []\n    for s in symbols:\n        for c in words:\n            r = re.search(s, c)\n            if r:\n                combined.append(re.sub(s, '[{}]'.format(s), c))\n    return combined"}, "match_symbol_1": {"args": ["words", "symbols"], "returns": ["res"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 54}, "calls": ["sorted", "res.append", "len", "word.find", "word.replace"], "store_vars_calls": {"symbols": "sorted", "word_replaced": "word.replace"}, "source_code": "def match_symbol_1(words, symbols):\n    res = []\n    symbols = sorted(symbols, key=lambda _: len(_), reverse=True)\n    for word in words:\n        for symbol in symbols:\n            word_replaced = ''\n            if word.find(symbol) != -1:\n                word_replaced = word.replace(symbol, '[' + symbol + ']')\n                res.append(word_replaced)\n                break\n        if word_replaced == '':\n            res.append(word)\n    return res"}, "bracket": {"args": ["words", "symbols"], "returns": ["tuple((word if word not in result else result[word] for word in words))"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 96}, "calls": ["dict", "tuple", "list", "len", "functools.reduce", "breaking_bad.TreeNode", "list.append"], "store_vars_calls": {"root": "TreeNode", "result": "dict", "symlist": "list", "sym": "reduce"}, "source_code": "def bracket(words, symbols):\n    root = TreeNode()\n    for s in symbols:\n        t = root\n        for char in s:\n            if char not in t.c:\n                t.c[char] = TreeNode()\n            t = t.c[char]\n        t.sym = s\n    result = dict()\n    for word in words:\n        i = 0\n        symlist = list()\n        while i < len(word):\n            (j, t) = (i, root)\n            while j < len(word) and word[j] in t.c:\n                t = t.c[word[j]]\n                if t.sym is not None:\n                    symlist.append((j + 1 - len(t.sym), j + 1, t.sym))\n                j += 1\n            i += 1\n        if len(symlist) > 0:\n            sym = reduce(lambda x, y: x if x[1] - x[0] >= y[1] - y[0] else y, symlist)\n            result[word] = '{}[{}]{}'.format(word[:sym[0]], sym[2], word[sym[1]:])\n    return tuple((word if word not in result else result[word] for word in words))"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/strong_password.py", "fileNameBase": "strong_password", "extension": "py", "doc": {"long_description": "must be strong. The website considers a password to be strong if it satisfies the following criteria:\n\n1) Its length is at least 6.\n2) It contains at least one digit.\n3) It contains at least one lowercase English character.\n4) It contains at least one uppercase English character.\n5) It contains at least one special character. The special characters are: !@#$%^&*()-+\nShe typed a random string of length  in the password field but wasn't sure if it was strong.\nGiven the string she typed, can you find the minimum number of characters she must add to make her password strong?\n\nNote: Here's the set of types of characters in a form you can paste in your solution:\nnumbers = \"0123456789\"\nlower_case = \"abcdefghijklmnopqrstuvwxyz\"\nupper_case = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nspecial_characters = \"!@#$%^&*()-+\"\n\nInput Format\nThe first line contains an integer  denoting the length of the string.\nThe second line contains a string consisting of  characters, the password\ntyped by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character.\n\nSample Input 1: strong_password(3,\"Ab1\")\nOutput: 3 (Because She can make the password strong by adding  characters,for example, $hk, turning the password into Ab1$hk which is strong.\n2 characters aren't enough since the length must be at least 6.)\n\nSample Output 2: strong_password(11,\"#Algorithms\")\nOutput: 1 (Because the password isn't strong, but she can make it strong by adding a single digit.)", "short_description": "The signup page required her to input a name and a password. However, the password", "full": "The signup page required her to input a name and a password. However, the password\nmust be strong. The website considers a password to be strong if it satisfies the following criteria:\n\n1) Its length is at least 6.\n2) It contains at least one digit.\n3) It contains at least one lowercase English character.\n4) It contains at least one uppercase English character.\n5) It contains at least one special character. The special characters are: !@#$%^&*()-+\nShe typed a random string of length  in the password field but wasn't sure if it was strong.\nGiven the string she typed, can you find the minimum number of characters she must add to make her password strong?\n\nNote: Here's the set of types of characters in a form you can paste in your solution:\nnumbers = \"0123456789\"\nlower_case = \"abcdefghijklmnopqrstuvwxyz\"\nupper_case = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nspecial_characters = \"!@#$%^&*()-+\"\n\nInput Format\nThe first line contains an integer  denoting the length of the string.\nThe second line contains a string consisting of  characters, the password\ntyped by Louise. Each character is either a lowercase/uppercase English alphabet, a digit, or a special character.\n\nSample Input 1: strong_password(3,\"Ab1\")\nOutput: 3 (Because She can make the password strong by adding  characters,for example, $hk, turning the password into Ab1$hk which is strong.\n2 characters aren't enough since the length must be at least 6.)\n\nSample Output 2: strong_password(11,\"#Algorithms\")\nOutput: 1 (Because the password isn't strong, but she can make it strong by adding a single digit.)"}}, "functions": {"strong_password": {"args": ["n", "password"], "returns": ["max(count_error, 6 - n)"], "min_max_lineno": {"min_lineno": 32, "max_lineno": 44}, "calls": ["max", "any", "i.isdigit", "i.islower", "i.isupper"], "source_code": "def strong_password(n, password):\n    count_error = 0\n    if any((i.isdigit() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i.islower() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i.isupper() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i in '!@#$%^&*()-+' for i in password)) == False:\n        count_error = count_error + 1\n    return max(count_error, 6 - n)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/add_binary.py", "fileNameBase": "add_binary", "extension": "py", "doc": {"long_description": "return their sum (also a binary string).\n\nFor example,\na = \"11\"\nb = \"1\"\nReturn \"100\".", "short_description": "Given two binary strings,", "full": "Given two binary strings,\nreturn their sum (also a binary string).\n\nFor example,\na = \"11\"\nb = \"1\"\nReturn \"100\"."}}, "functions": {"add_binary": {"args": ["a", "b"], "returns": ["s"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 27}, "calls": ["ord", "len", "chr"], "store_vars_calls": {"zero": "ord"}, "source_code": "def add_binary(a, b):\n    s = ''\n    (c, i, j) = (0, len(a) - 1, len(b) - 1)\n    zero = ord('0')\n    while i >= 0 or j >= 0 or c == 1:\n        if i >= 0:\n            c += ord(a[i]) - zero\n            i -= 1\n        if j >= 0:\n            c += ord(b[j]) - zero\n            j -= 1\n        s = chr(c % 2 + zero) + s\n        c //= 2\n    return s"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/atbash_cipher.py", "fileNameBase": "atbash_cipher", "extension": "py", "doc": {"long_description": "So if we take \"a\" as it is the first letter, we change it to the last - z.\n\nExample:\nAttack at dawn --> Zggzxp zg wzdm\n\nComplexity: O(n)", "short_description": "Atbash cipher is mapping the alphabet to it's reverse.", "full": "Atbash cipher is mapping the alphabet to it's reverse.\nSo if we take \"a\" as it is the first letter, we change it to the last - z.\n\nExample:\nAttack at dawn --> Zggzxp zg wzdm\n\nComplexity: O(n)"}}, "functions": {"atbash": {"args": ["s"], "returns": ["translated"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 28}, "calls": ["range", "len", "ord", "s[].isalpha", "s[].isupper", "s[].islower", "chr"], "store_vars_calls": {"n": "ord"}, "source_code": "def atbash(s):\n    translated = ''\n    for i in range(len(s)):\n        n = ord(s[i])\n        if s[i].isalpha():\n            if s[i].isupper():\n                x = n - ord('A')\n                translated += chr(ord('Z') - x)\n            if s[i].islower():\n                x = n - ord('a')\n                translated += chr(ord('z') - x)\n        else:\n            translated += s[i]\n    return translated"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/repeat_string.py", "fileNameBase": "repeat_string", "extension": "py", "doc": {"long_description": "For example, with A = \"abcd\" and B = \"cdabcdab\".\n\nReturn 3, because by repeating A three times (\u201cabcdabcdabcd\u201d), B is a substring of it; and B is not a substring of A repeated two times (\"abcdabcd\").\n\nNote:\nThe length of A and B will be between 1 and 10000.\n\nReference: https://leetcode.com/problems/repeated-string-match/description/", "short_description": "Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.", "full": "Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.\n\nFor example, with A = \"abcd\" and B = \"cdabcdab\".\n\nReturn 3, because by repeating A three times (\u201cabcdabcdabcd\u201d), B is a substring of it; and B is not a substring of A repeated two times (\"abcdabcd\").\n\nNote:\nThe length of A and B will be between 1 and 10000.\n\nReference: https://leetcode.com/problems/repeated-string-match/description/"}}, "functions": {"repeat_string": {"args": ["A", "B"], "returns": ["count"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 25}, "calls": ["len"], "source_code": "def repeat_string(A, B):\n    count = 1\n    tmp = A\n    max_count = len(B) / len(A) + 1\n    while not B in tmp:\n        tmp = tmp + A\n        if count > max_count:\n            count = -1\n            break\n        count = count + 1\n    return count"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/merge_string_checker.py", "fileNameBase": "merge_string_checker", "extension": "py", "doc": {"long_description": "given string, s, can be formed from two other strings, part1 and part2.\nThe restriction is that the characters in part1 and part2 are in the same \norder as in s. The interviewer gives you the following example and tells \nyou to figure out the rest from the given test cases.\n'codewars' is a merge from 'cdw' and 'oears':\ns:  c o d e w a r s   = codewars\npart1:  c   d   w         = cdw\npart2:    o   e   a r s   = oears", "short_description": "At a job interview, you are challenged to write an algorithm to check if a ", "full": "At a job interview, you are challenged to write an algorithm to check if a \ngiven string, s, can be formed from two other strings, part1 and part2.\nThe restriction is that the characters in part1 and part2 are in the same \norder as in s. The interviewer gives you the following example and tells \nyou to figure out the rest from the given test cases.\n'codewars' is a merge from 'cdw' and 'oears':\ns:  c o d e w a r s   = codewars\npart1:  c   d   w         = cdw\npart2:    o   e   a r s   = oears"}}, "functions": {"is_merge_recursive": {"args": ["s", "part1", "part2"], "returns": ["False", "s == part2", "s == part1", "part1 + part2 == ''", "True", "True"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 27}, "calls": ["merge_string_checker.is_merge_recursive"], "source_code": "def is_merge_recursive(s, part1, part2):\n    if not part1:\n        return s == part2\n    if not part2:\n        return s == part1\n    if not s:\n        return part1 + part2 == ''\n    if s[0] == part1[0] and is_merge_recursive(s[1:], part1[1:], part2):\n        return True\n    if s[0] == part2[0] and is_merge_recursive(s[1:], part1, part2[1:]):\n        return True\n    return False"}, "is_merge_iterative": {"args": ["s", "part1", "part2"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 43}, "calls": ["tuple_list.pop", "tuple_list.append"], "source_code": "def is_merge_iterative(s, part1, part2):\n    tuple_list = [(s, part1, part2)]\n    while tuple_list:\n        (string, p1, p2) = tuple_list.pop()\n        if string:\n            if p1 and string[0] == p1[0]:\n                tuple_list.append((string[1:], p1[1:], p2))\n            if p2 and string[0] == p2[0]:\n                tuple_list.append((string[1:], p1, p2[1:]))\n        elif not p1 and (not p2):\n            return True\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/check_pangram.py", "fileNameBase": "check_pangram", "extension": "py", "doc": {"short_description": "Algorithm that checks if a given string is a pangram or not", "full": "Algorithm that checks if a given string is a pangram or not"}}, "functions": {"check_pangram": {"args": ["input_string"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 11}, "calls": ["input_string.lower"], "source_code": "def check_pangram(input_string):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for ch in alphabet:\n        if ch not in input_string.lower():\n            return False\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/fizzbuzz.py", "fileNameBase": "fizzbuzz", "extension": "py", "doc": {"long_description": "where N is the parametered value. N will never be less than 1.\n\nReplace certain values however if any of the following conditions are met:\n\nIf the value is a multiple of 3: use the value 'Fizz' instead\nIf the value is a multiple of 5: use the value 'Buzz' instead\nIf the value is a multiple of 3 & 5: use the value 'FizzBuzz' instead", "short_description": "Write a function that returns an array containing the numbers from 1 to N, ", "full": "Write a function that returns an array containing the numbers from 1 to N, \nwhere N is the parametered value. N will never be less than 1.\n\nReplace certain values however if any of the following conditions are met:\n\nIf the value is a multiple of 3: use the value 'Fizz' instead\nIf the value is a multiple of 5: use the value 'Buzz' instead\nIf the value is a multiple of 3 & 5: use the value 'FizzBuzz' instead"}}, "functions": {"fizzbuzz": {"args": ["n"], "returns": ["result"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 48}, "calls": ["range", "ValueError", "TypeError", "result.append"], "source_code": "def fizzbuzz(n):\n    if n < 1:\n        raise ValueError('n cannot be less than one')\n    if n is None:\n        raise TypeError('n cannot be None')\n    result = []\n    for i in range(1, n + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            result.append('FizzBuzz')\n        elif i % 3 == 0:\n            result.append('Fizz')\n        elif i % 5 == 0:\n            result.append('Buzz')\n        else:\n            result.append(i)\n    return result"}, "fizzbuzz_with_helper_func": {"args": ["n"], "returns": ["[fb(m) for m in range(1, n + 1)]"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 52}, "calls": ["fizzbuzz.fb", "range"], "source_code": "def fizzbuzz_with_helper_func(n):\n    return [fb(m) for m in range(1, n + 1)]"}, "fb": {"args": ["m"], "returns": ["r if r != '' else m"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 56}, "source_code": "def fb(m):\n    r = (m % 3 == 0) * 'Fizz' + (m % 5 == 0) * 'Buzz'\n    return r if r != '' else m"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/rotate.py", "fileNameBase": "rotate", "extension": "py", "doc": {"long_description": "k can be any positive integer.\n\nFor example,\nrotate(\"hello\", 2) return \"llohe\"\nrotate(\"hello\", 5) return \"hello\"\nrotate(\"hello\", 6) return \"elloh\"\nrotate(\"hello\", 7) return \"llohe\"\nrotate(\"hello\", 102) return \"lohel\"", "short_description": "Given a strings s and int k, return a string that rotates k times", "full": "Given a strings s and int k, return a string that rotates k times\n\nk can be any positive integer.\n\nFor example,\nrotate(\"hello\", 2) return \"llohe\"\nrotate(\"hello\", 5) return \"hello\"\nrotate(\"hello\", 6) return \"elloh\"\nrotate(\"hello\", 7) return \"llohe\"\nrotate(\"hello\", 102) return \"lohel\""}}, "functions": {"rotate": {"args": ["s", "k"], "returns": ["long_string[k:k + len(s)]", "long_string[k - len(s):k]"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 20}, "calls": ["len"], "source_code": "def rotate(s, k):\n    long_string = s * (k // len(s) + 2)\n    if k <= len(s):\n        return long_string[k:k + len(s)]\n    else:\n        return long_string[k - len(s):k]"}, "rotate_alt": {"args": ["string", "k"], "returns": ["string[k:] + string[:k]"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 24}, "calls": ["len"], "source_code": "def rotate_alt(string, k):\n    k = k % len(string)\n    return string[k:] + string[:k]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/first_unique_char.py", "fileNameBase": "first_unique_char", "extension": "py", "doc": {"long_description": "index. If it doesn't exist, return -1.\n\nFor example:\ns = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\n\nReference: https://leetcode.com/problems/first-unique-character-in-a-string/description/", "short_description": "Given a string, find the first non-repeating character in it and return it's", "full": "Given a string, find the first non-repeating character in it and return it's\nindex. If it doesn't exist, return -1.\n\nFor example:\ns = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\n\nReference: https://leetcode.com/problems/first-unique-character-in-a-string/description/"}}, "functions": {"first_unique_char": {"args": ["s"], "returns": ["-1", "0", "i"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 28}, "calls": ["range", "len", "ban.append", "all"], "source_code": "def first_unique_char(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 1:\n        return 0\n    ban = []\n    for i in range(len(s)):\n        if all((s[i] != s[k] for k in range(i + 1, len(s)))) == True and s[i] not in ban:\n            return i\n        else:\n            ban.append(s[i])\n    return -1"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/reverse_string.py", "fileNameBase": "reverse_string", "extension": "py"}, "functions": {"recursive": {"args": ["s"], "returns": ["recursive(s[l // 2:]) + recursive(s[:l // 2])", "s"], "min_max_lineno": {"min_lineno": 1, "max_lineno": 6}, "calls": ["len", "reverse_string.recursive"], "store_vars_calls": {"l": "len"}, "source_code": "def recursive(s):\n    l = len(s)\n    if l < 2:\n        return s\n    return recursive(s[l // 2:]) + recursive(s[:l // 2])"}, "iterative": {"args": ["s"], "returns": ["''.join(r)"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 15}, "calls": ["list", "len"], "store_vars_calls": {"r": "list"}, "source_code": "def iterative(s):\n    r = list(s)\n    (i, j) = (0, len(s) - 1)\n    while i < j:\n        (r[i], r[j]) = (r[j], r[i])\n        i += 1\n        j -= 1\n    return ''.join(r)"}, "pythonic": {"args": ["s"], "returns": ["''.join(r)"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 19}, "calls": ["list", "reversed"], "store_vars_calls": {"r": "list"}, "source_code": "def pythonic(s):\n    r = list(reversed(s))\n    return ''.join(r)"}, "ultra_pythonic": {"args": ["s"], "returns": ["s[::-1]"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 22}, "source_code": "def ultra_pythonic(s):\n    return s[::-1]"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/longest_palindromic_substring.py", "fileNameBase": "longest_palindromic_substring", "extension": "py", "doc": {"long_description": "Example1:\n\n* input: \"dasdasdasdasdasdadsa\"\n* output: \"asdadsa\"\n\nExample2:\n\n* input: \"acdbbdaa\"\n* output: \"dbbd\"\n\nManacher's algorithm", "short_description": "Given string s, find the longest palindromic substring.", "full": "Given string s, find the longest palindromic substring.\n\nExample1:\n\n* input: \"dasdasdasdasdasdadsa\"\n* output: \"asdadsa\"\n\nExample2:\n\n* input: \"acdbbdaa\"\n* output: \"dbbd\"\n\nManacher's algorithm"}}, "functions": {"longest_palindrome": {"args": ["s"], "returns": ["s.replace('#', '')", "s"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 45}, "calls": ["range", "s.replace", "len", "min"], "source_code": "def longest_palindrome(s):\n    if len(s) < 2:\n        return s\n    n_str = '#' + '#'.join(s) + '#'\n    p = [0] * len(n_str)\n    (mx, loc) = (0, 0)\n    (index, maxlen) = (0, 0)\n    for i in range(len(n_str)):\n        if i < mx and 2 * loc - i < len(n_str):\n            p[i] = min(mx - i, p[2 * loc - i])\n        else:\n            p[i] = 1\n        while p[i] + i < len(n_str) and i - p[i] >= 0 and (n_str[i - p[i]] == n_str[i + p[i]]):\n            p[i] += 1\n        if i + p[i] > mx:\n            mx = i + p[i]\n            loc = i\n        if p[i] > maxlen:\n            index = i\n            maxlen = p[i]\n    s = n_str[index - p[index] + 1:index + p[index]]\n    return s.replace('#', '')"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/strings/encode_decode.py", "fileNameBase": "encode_decode", "extension": "py", "doc": {"long_description": "The encoded mystring is then sent over the network and is decoded\nback to the original list of strings.", "short_description": "Design an algorithm to encode a list of strings to a string.", "full": "Design an algorithm to encode a list of strings to a string.\nThe encoded mystring is then sent over the network and is decoded\nback to the original list of strings."}}, "functions": {"encode": {"doc": {"short_description": "Encodes a list of strings to a single string."}, "args": ["strs"], "returns": ["res"], "min_max_lineno": {"min_lineno": 8, "max_lineno": 17}, "calls": ["strs.split", "str", "len"], "source_code": "def encode(strs):\n    \"\"\"Encodes a list of strings to a single string.\n    :type strs: List[str]\n    :rtype: str\n    \"\"\"\n    res = ''\n    for string in strs.split():\n        res += str(len(string)) + ':' + string\n    return res"}, "decode": {"doc": {"short_description": "Decodes a single string to a list of strings."}, "args": ["s"], "returns": ["strs"], "min_max_lineno": {"min_lineno": 18, "max_lineno": 31}, "calls": ["len", "s.find", "int", "strs.append"], "store_vars_calls": {"index": "s.find", "size": "int"}, "source_code": "def decode(s):\n    \"\"\"Decodes a single string to a list of strings.\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    strs = []\n    i = 0\n    while i < len(s):\n        index = s.find(':', i)\n        size = int(s[i:index])\n        strs.append(s[index + 1:index + 1 + size])\n        i = index + 1 + size\n    return strs"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/graph": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/minimum_spanning_tree.py", "fileNameBase": "minimum_spanning_tree", "extension": "py", "doc": {"short_description": "Minimum spanning tree (MST) is going to use an undirected graph", "full": "Minimum spanning tree (MST) is going to use an undirected graph"}}, "dependencies": [{"import": "sys", "type": "external", "type_element": "module"}], "classes": {"Edge": {"doc": {"short_description": "An edge of an undirected graph", "full": "An edge of an undirected graph"}, "min_max_lineno": {"min_lineno": 8, "max_lineno": 17}, "methods": {"__init__": {"args": ["self", "source", "target", "weight"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 17}, "source_code": "def __init__(self, source, target, weight):\n    self.source = source\n    self.target = target\n    self.weight = weight"}}}, "DisjointSet": {"doc": {"long_description": "<n[i]> is the parent of the node at position <i>.\nIf <n[i]> = <i>, <i> it's a root, or a head, of a set", "short_description": "The disjoint set is represented with an list <n> of integers where", "full": "The disjoint set is represented with an list <n> of integers where\n<n[i]> is the parent of the node at position <i>.\nIf <n[i]> = <i>, <i> it's a root, or a head, of a set"}, "min_max_lineno": {"min_lineno": 19, "max_lineno": 68}, "methods": {"__init__": {"doc": {"long_description": "n (int): Number of vertices in the graph", "short_description": "Args:"}, "args": ["self", "size"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 36}, "calls": ["range"], "source_code": "def __init__(self, size):\n    \"\"\"\n        Args:\n            n (int): Number of vertices in the graph\n        \"\"\"\n    self.parent = [None] * size\n    self.size = [1] * size\n    for i in range(size):\n        self.parent[i] = i"}, "merge_set": {"doc": {"long_description": "node1, node2 (int): Indexes of nodes whose sets will be merged.", "short_description": "Args:"}, "args": ["self", "node1", "node2"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 55}, "calls": ["minimum_spanning_tree.DisjointSet.find_set"], "store_vars_calls": {"node1": "self.find_set", "node2": "self.find_set"}, "source_code": "def merge_set(self, node1, node2):\n    \"\"\"\n        Args:\n            node1, node2 (int): Indexes of nodes whose sets will be merged.\n        \"\"\"\n    node1 = self.find_set(node1)\n    node2 = self.find_set(node2)\n    if self.size[node1] < self.size[node2]:\n        self.parent[node1] = node2\n        self.size[node2] += self.size[node1]\n    else:\n        self.parent[node2] = node1\n        self.size[node1] += self.size[node2]"}, "find_set": {"doc": {"short_description": "Get the root element of the set containing <a>"}, "args": ["self", "node"], "returns": ["self.parent[node]"], "min_max_lineno": {"min_lineno": 56, "max_lineno": 68}, "calls": ["minimum_spanning_tree.DisjointSet.find_set"], "source_code": "def find_set(self, node):\n    \"\"\"\n        Get the root element of the set containing <a>\n        \"\"\"\n    if self.parent[node] != node:\n        self.parent[node] = self.find_set(self.parent[node])\n    return self.parent[node]"}}}}, "functions": {"kruskal": {"doc": {"args": {"vertex_count": {"description": "Number of vertices in the graph", "type_name": "int", "is_optional": false}, "edges": {"description": "Edges of the graph", "type_name": "list of Edge", "is_optional": false}, "forest": {"description": "DisjointSet of the vertices", "type_name": "DisjointSet", "is_optional": false}}, "returns": {"description": "sum of weights of the minnimum spanning tree\nKruskal algorithm:\n    This algorithm will find the optimal graph with less edges and less\n    total weight to connect all vertices (MST), the MST will always contain\n    n-1 edges because it's the minimum required to connect n vertices.\n\nProcedure:\n    Sort the edges (criteria: less weight).\n    Only take edges of nodes in different sets.\n    If we take a edge, we need to merge the sets to discard these.\n    After repeat this until select n-1 edges, we will have the complete MST.", "type_name": "int", "is_generator": false}}, "args": ["vertex_count", "edges", "forest"], "returns": ["sum([edge.weight for edge in mst])"], "min_max_lineno": {"min_lineno": 70, "max_lineno": 106}, "calls": ["edges.sort", "sum", "forest.find_set", "forest.merge_set", "mst.append", "len"], "store_vars_calls": {"set_u": "forest.find_set", "set_v": "forest.find_set"}, "source_code": "def kruskal(vertex_count, edges, forest):\n    \"\"\"\n    Args:\n        vertex_count (int): Number of vertices in the graph\n        edges (list of Edge): Edges of the graph\n        forest (DisjointSet): DisjointSet of the vertices\n    Returns:\n        int: sum of weights of the minnimum spanning tree\n\n    Kruskal algorithm:\n        This algorithm will find the optimal graph with less edges and less\n        total weight to connect all vertices (MST), the MST will always contain\n        n-1 edges because it's the minimum required to connect n vertices.\n\n    Procedure:\n        Sort the edges (criteria: less weight).\n        Only take edges of nodes in different sets.\n        If we take a edge, we need to merge the sets to discard these.\n        After repeat this until select n-1 edges, we will have the complete MST.\n    \"\"\"\n    edges.sort(key=lambda edge: edge.weight)\n    mst = []\n    for edge in edges:\n        set_u = forest.find_set(edge.u)\n        set_v = forest.find_set(edge.v)\n        if set_u != set_v:\n            forest.merge_set(set_u, set_v)\n            mst.append(edge)\n            if len(mst) == vertex_count - 1:\n                break\n    return sum([edge.weight for edge in mst])"}, "main": {"doc": {"long_description": "Input consists of different weighted, connected, undirected graphs.\nline 1:\n  integers n, m\nlines 2..m+2:\n  edge with the format -> node index u, node index v, integer weight\n\nSamples of input:\n\n5 6\n1 2 3\n1 3 8\n2 4 5\n3 4 2\n3 5 4\n4 5 6\n\n3 3\n2 1 20\n3 1 20\n2 3 100\n\nSum of weights of the optimal paths:\n14, 40", "short_description": "Test. How input works:"}, "min_max_lineno": {"min_lineno": 108, "max_lineno": 149}, "calls": ["map", "range", "print", "size.split", "minimum_spanning_tree.kruskal", "input().split", "input"], "store_vars_calls": {"forest": "DisjointSet"}, "source_code": "def main():\n    \"\"\"\n    Test. How input works:\n    Input consists of different weighted, connected, undirected graphs.\n    line 1:\n      integers n, m\n    lines 2..m+2:\n      edge with the format -> node index u, node index v, integer weight\n\n    Samples of input:\n\n    5 6\n    1 2 3\n    1 3 8\n    2 4 5\n    3 4 2\n    3 5 4\n    4 5 6\n\n    3 3\n    2 1 20\n    3 1 20\n    2 3 100\n\n    Sum of weights of the optimal paths:\n    14, 40\n    \"\"\"\n    for size in sys.stdin:\n        (vertex_count, edge_count) = map(int, size.split())\n        forest = DisjointSet(edge_count)\n        edges = [None] * edge_count\n        for i in range(edge_count):\n            (source, target, weight) = map(int, input().split())\n            source -= 1\n            target -= 1\n            edges[i] = Edge(source, target, weight)\n        print('MST weights sum:', kruskal(vertex_count, edges, forest))"}}, "body": {"calls": ["minimum_spanning_tree.main"], "source_code": ["main()"]}, "main_info": {"main_flag": 1, "main_function": "minimum_spanning_tree.main", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/dijkstra.py", "fileNameBase": "dijkstra", "extension": "py", "doc": {"short_description": "Dijkstra's single-source shortest-path algorithm", "full": "Dijkstra's single-source shortest-path algorithm"}}, "classes": {"Dijkstra": {"doc": {"short_description": "A fully connected directed graph with edge weights", "full": "A fully connected directed graph with edge weights"}, "min_max_lineno": {"min_lineno": 5, "max_lineno": 50}, "methods": {"__init__": {"args": ["self", "vertex_count"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 13}, "calls": ["range"], "source_code": "def __init__(self, vertex_count):\n    self.vertex_count = vertex_count\n    self.graph = [[0 for _ in range(vertex_count)] for _ in range(vertex_count)]"}, "min_distance": {"doc": {"short_description": "Find the vertex that is closest to the visited set"}, "args": ["self", "dist", "min_dist_set"], "returns": ["min_index"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 26}, "calls": ["float", "range"], "store_vars_calls": {"min_dist": "float"}, "source_code": "def min_distance(self, dist, min_dist_set):\n    \"\"\"\n        Find the vertex that is closest to the visited set\n        \"\"\"\n    min_dist = float('inf')\n    for target in range(self.vertex_count):\n        if min_dist_set[target]:\n            continue\n        if dist[target] < min_dist:\n            min_dist = dist[target]\n            min_index = target\n    return min_index"}, "dijkstra": {"doc": {"short_description": "Given a node, returns the shortest distance to every other node"}, "args": ["self", "src"], "returns": ["dist"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 50}, "calls": ["range", "dijkstra.Dijkstra.min_distance", "float"], "store_vars_calls": {"source": "self.min_distance"}, "source_code": "def dijkstra(self, src):\n    \"\"\"\n        Given a node, returns the shortest distance to every other node\n        \"\"\"\n    dist = [float('inf')] * self.vertex_count\n    dist[src] = 0\n    min_dist_set = [False] * self.vertex_count\n    for _ in range(self.vertex_count):\n        source = self.min_distance(dist, min_dist_set)\n        min_dist_set[source] = True\n        for target in range(self.vertex_count):\n            if self.graph[source][target] <= 0 or min_dist_set[target]:\n                continue\n            if dist[target] > dist[source] + self.graph[source][target]:\n                dist[target] = dist[source] + self.graph[source][target]\n    return dist"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/cycle_detection.py", "fileNameBase": "cycle_detection", "extension": "py", "doc": {"long_description": "Real-life scenario: deadlock detection in a system. Processes may be\nrepresented by vertices, then and an edge A -> B could mean that process A is\nwaiting for B to release its lock on a resource.", "short_description": "Given a directed graph, check whether it contains a cycle.", "full": "Given a directed graph, check whether it contains a cycle.\n\nReal-life scenario: deadlock detection in a system. Processes may be\nrepresented by vertices, then and an edge A -> B could mean that process A is\nwaiting for B to release its lock on a resource."}}, "dependencies": [{"from_module": "enum", "import": "Enum", "type": "external", "type_element": "module"}], "classes": {"TraversalState": {"doc": {"long_description": "- WHITE: has not been visited yet\n- GRAY: is currently being investigated for a cycle\n- BLACK: is not part of a cycle", "short_description": "For a given node:", "full": "For a given node:\n    - WHITE: has not been visited yet\n    - GRAY: is currently being investigated for a cycle\n    - BLACK: is not part of a cycle"}, "extend": ["Enum"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 21}}}, "functions": {"is_in_cycle": {"doc": {"long_description": ":param: traversal_states: for each vertex, the state it is in", "short_description": "Determines if the given vertex is in a cycle."}, "args": ["graph", "traversal_states", "vertex"], "returns": ["False", "True", "True"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 36}, "calls": ["cycle_detection.is_in_cycle"], "source_code": "def is_in_cycle(graph, traversal_states, vertex):\n    \"\"\"\n    Determines if the given vertex is in a cycle.\n\n    :param: traversal_states: for each vertex, the state it is in\n    \"\"\"\n    if traversal_states[vertex] == TraversalState.GRAY:\n        return True\n    traversal_states[vertex] = TraversalState.GRAY\n    for neighbor in graph[vertex]:\n        if is_in_cycle(graph, traversal_states, neighbor):\n            return True\n    traversal_states[vertex] = TraversalState.BLACK\n    return False"}, "contains_cycle": {"doc": {"long_description": "The graph should be given as a dictionary:\n\n    graph = {'A': ['B', 'C'],\n             'B': ['D'],\n             'C': ['F'],\n             'D': ['E', 'F'],\n             'E': ['B'],\n             'F': []}", "short_description": "Determines if there is a cycle in the given graph."}, "args": ["graph"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 56}, "calls": ["traversal_states.items", "cycle_detection.is_in_cycle"], "source_code": "def contains_cycle(graph):\n    \"\"\"\n    Determines if there is a cycle in the given graph.\n    The graph should be given as a dictionary:\n\n        graph = {'A': ['B', 'C'],\n                 'B': ['D'],\n                 'C': ['F'],\n                 'D': ['E', 'F'],\n                 'E': ['B'],\n                 'F': []}\n    \"\"\"\n    traversal_states = {vertex: TraversalState.WHITE for vertex in graph}\n    for (vertex, state) in traversal_states.items():\n        if state == TraversalState.WHITE and is_in_cycle(graph, traversal_states, vertex):\n            return True\n    return False"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/maximum_flow_bfs.py", "fileNameBase": "maximum_flow_bfs", "extension": "py", "doc": {"long_description": "it will give you a maximum flow.\nThis version use BFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23", "short_description": "Given a n*n adjacency array.", "full": "Given a n*n adjacency array.\nit will give you a maximum flow.\nThis version use BFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23"}}, "dependencies": [{"import": "copy", "type": "external", "type_element": "module"}, {"import": "queue", "type": "external", "type_element": "module"}, {"import": "math", "type": "external", "type_element": "module"}], "functions": {"maximum_flow_bfs": {"doc": {"short_description": "Get the maximum flow through a graph using a breadth first search"}, "args": ["adjacency_matrix"], "returns": ["total"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 88}, "calls": ["copy.deepcopy", "queue.Queue", "queue.Queue.put", "len", "queue.Queue.qsize", "queue.Queue.get", "range"], "store_vars_calls": {"new_array": "copy.deepcopy", "bfs": "queue.Queue", "src": "bfs.get"}, "source_code": "def maximum_flow_bfs(adjacency_matrix):\n    \"\"\"\n    Get the maximum flow through a graph using a breadth first search\n    \"\"\"\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min_flow = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        bfs = queue.Queue()\n        visited[0] = 1\n        bfs.put(0)\n        while bfs.qsize() > 0:\n            src = bfs.get()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    bfs.put(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min_flow > new_array[path[tmp]][tmp]:\n                min_flow = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min_flow\n            tmp = path[tmp]\n        total = total + min_flow\n    return total"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/check_bipartite.py", "fileNameBase": "check_bipartite", "extension": "py", "doc": {"long_description": "(https://en.wikipedia.org/wiki/Bipartite_graph)", "short_description": "Bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets.", "full": "Bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets.\n(https://en.wikipedia.org/wiki/Bipartite_graph)"}}, "functions": {"check_bipartite": {"doc": {"long_description": "Time complexity is O(|E|)\nSpace complexity is O(|V|)", "short_description": "Determine if the given graph is bipartite."}, "args": ["adj_list"], "returns": ["True", "False", "False"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 41}, "calls": ["len", "queue.pop", "range", "queue.append"], "store_vars_calls": {"vertices": "len", "current": "queue.pop"}, "source_code": "def check_bipartite(adj_list):\n    \"\"\"\n    Determine if the given graph is bipartite.\n\n    Time complexity is O(|E|)\n    Space complexity is O(|V|)\n    \"\"\"\n    vertices = len(adj_list)\n    set_type = [-1 for v in range(vertices)]\n    set_type[0] = 0\n    queue = [0]\n    while queue:\n        current = queue.pop(0)\n        if adj_list[current][current]:\n            return False\n        for adjacent in range(vertices):\n            if adj_list[current][adjacent]:\n                if set_type[adjacent] == set_type[current]:\n                    return False\n                if set_type[adjacent] == -1:\n                    set_type[adjacent] = 1 - set_type[current]\n                    queue.append(adjacent)\n    return True"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/tarjan.py", "fileNameBase": "tarjan", "extension": "py", "doc": {"long_description": "in a graph.\nhttps://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm", "short_description": "Implements Tarjan's algorithm for finding strongly connected components", "full": "Implements Tarjan's algorithm for finding strongly connected components\nin a graph.\nhttps://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm"}}, "dependencies": [{"from_module": "algorithms.graph.graph", "import": "DirectedGraph", "type": "external", "type_element": "module"}], "classes": {"Tarjan": {"doc": {"short_description": "A directed graph used for finding strongly connected components", "full": "A directed graph used for finding strongly connected components"}, "min_max_lineno": {"min_lineno": 10, "max_lineno": 66}, "methods": {"__init__": {"args": ["self", "dict_graph"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 28}, "calls": ["algorithms.graph.graph.DirectedGraph", "tarjan.Tarjan.strongconnect"], "store_vars_calls": {"self.graph": "DirectedGraph"}, "source_code": "def __init__(self, dict_graph):\n    self.graph = DirectedGraph(dict_graph)\n    self.index = 0\n    self.stack = []\n    for vertex in self.graph.nodes:\n        vertex.index = None\n    self.sccs = []\n    for vertex in self.graph.nodes:\n        if vertex.index is None:\n            self.strongconnect(vertex, self.sccs)"}, "strongconnect": {"doc": {"short_description": "Given a vertex, adds all successors of the given vertex to the same connected component"}, "args": ["self", "vertex", "sccs"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 66}, "calls": ["tarjan.Tarjan.stack.append", "scc.sort", "sccs.append", "tarjan.Tarjan.strongconnect", "min", "tarjan.Tarjan.stack.pop", "scc.append"], "store_vars_calls": {"vertex.lowlink": "min", "adjacent": "self.stack.pop"}, "source_code": "def strongconnect(self, vertex, sccs):\n    \"\"\"\n        Given a vertex, adds all successors of the given vertex to the same connected component\n        \"\"\"\n    vertex.index = self.index\n    vertex.lowlink = self.index\n    self.index += 1\n    self.stack.append(vertex)\n    vertex.on_stack = True\n    for adjacent in self.graph.adjacency_list[vertex]:\n        if adjacent.index is None:\n            self.strongconnect(adjacent, sccs)\n            vertex.lowlink = min(vertex.lowlink, adjacent.lowlink)\n        elif adjacent.on_stack:\n            vertex.lowlink = min(vertex.lowlink, adjacent.index)\n    if vertex.lowlink == vertex.index:\n        scc = []\n        while True:\n            adjacent = self.stack.pop()\n            adjacent.on_stack = False\n            scc.append(adjacent)\n            if adjacent == vertex:\n                break\n        scc.sort()\n        sccs.append(scc)"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/transitive_closure_dfs.py", "fileNameBase": "transitive_closure_dfs", "extension": "py", "doc": {"long_description": "reference: https://en.wikipedia.org/wiki/Transitive_closure#In_graph_theory", "short_description": "Finds the transitive closure of a graph.", "full": "Finds the transitive closure of a graph.\n\nreference: https://en.wikipedia.org/wiki/Transitive_closure#In_graph_theory"}}, "classes": {"Graph": {"doc": {"short_description": "This class represents a directed graph using adjacency lists", "full": "This class represents a directed graph using adjacency lists"}, "min_max_lineno": {"min_lineno": 7, "max_lineno": 56}, "methods": {"__init__": {"args": ["self", "vertices"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 20}, "calls": ["range"], "source_code": "def __init__(self, vertices):\n    self.vertex_count = vertices\n    self.graph = {}\n    self.closure = [[0 for j in range(vertices)] for i in range(vertices)]"}, "add_edge": {"doc": {"short_description": "Adds a directed edge to the graph"}, "args": ["self", "source", "target"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 29}, "calls": ["transitive_closure_dfs.Graph.graph[].append"], "source_code": "def add_edge(self, source, target):\n    \"\"\"\n        Adds a directed edge to the graph\n        \"\"\"\n    if source in self.graph:\n        self.graph[source].append(target)\n    else:\n        self.graph[source] = [target]"}, "dfs_util": {"doc": {"long_description": "all reachable vertices for source", "short_description": "A recursive DFS traversal function that finds"}, "args": ["self", "source", "target"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 43}, "calls": ["transitive_closure_dfs.Graph.dfs_util"], "source_code": "def dfs_util(self, source, target):\n    \"\"\"\n        A recursive DFS traversal function that finds\n        all reachable vertices for source\n        \"\"\"\n    self.closure[source][target] = 1\n    for adjacent in self.graph[target]:\n        if self.closure[source][adjacent] == 0:\n            self.dfs_util(source, adjacent)"}, "transitive_closure": {"doc": {"long_description": "recursive dfs_util()", "short_description": "The function to find transitive closure. It uses"}, "args": ["self"], "returns": ["self.closure"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 56}, "calls": ["range", "transitive_closure_dfs.Graph.dfs_util"], "source_code": "def transitive_closure(self):\n    \"\"\"\n        The function to find transitive closure. It uses\n        recursive dfs_util()\n        \"\"\"\n    for i in range(self.vertex_count):\n        self.dfs_util(i, i)\n    return self.closure"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/maximum_flow.py", "fileNameBase": "maximum_flow", "extension": "py", "doc": {"long_description": "computes the maximum flow from source to sink.\nInput : capacity, source, sink\nOutput : maximum flow from source to sink\nCapacity is a two-dimensional array that is v*v.\ncapacity[i][j] implies the capacity of the edge from i to j.\nIf there is no edge from i to j, capacity[i][j] should be zero.", "short_description": "Given the capacity, source and sink of a graph,", "full": "Given the capacity, source and sink of a graph,\ncomputes the maximum flow from source to sink.\nInput : capacity, source, sink\nOutput : maximum flow from source to sink\nCapacity is a two-dimensional array that is v*v.\ncapacity[i][j] implies the capacity of the edge from i to j.\nIf there is no edge from i to j, capacity[i][j] should be zero."}}, "dependencies": [{"from_module": "queue", "import": "Queue", "type": "external", "type_element": "module"}], "functions": {"dfs": {"doc": {"short_description": "Depth First Search implementation for Ford-Fulkerson algorithm."}, "args": ["capacity", "flow", "visit", "vertices", "idx", "sink", "current_flow"], "returns": ["0", "current_flow", "tmp"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 32}, "calls": ["range", "min", "maximum_flow.dfs"], "store_vars_calls": {"available_flow": "min", "tmp": "dfs"}, "source_code": "def dfs(capacity, flow, visit, vertices, idx, sink, current_flow=1 << 63):\n    \"\"\"\n    Depth First Search implementation for Ford-Fulkerson algorithm.\n    \"\"\"\n    if idx == sink:\n        return current_flow\n    visit[idx] = True\n    for nxt in range(vertices):\n        if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dfs(capacity, flow, visit, vertices, nxt, sink, available_flow)\n            if tmp:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n    return 0"}, "ford_fulkerson": {"doc": {"long_description": "Time Complexity : O(Ef)\nE is the number of edges and f is the maximum flow in the graph.", "short_description": "Computes maximum flow from source to sink using DFS."}, "args": ["capacity", "source", "sink"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 50}, "calls": ["len", "maximum_flow.dfs", "range"], "store_vars_calls": {"vertices": "len", "tmp": "dfs"}, "source_code": "def ford_fulkerson(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using DFS.\n    Time Complexity : O(Ef)\n    E is the number of edges and f is the maximum flow in the graph.\n    \"\"\"\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        visit = [False for _ in range(vertices)]\n        tmp = dfs(capacity, flow, visit, vertices, source, sink)\n        if tmp:\n            ret += tmp\n        else:\n            break\n    return ret"}, "edmonds_karp": {"doc": {"long_description": "Time complexity : O(V*E^2)\nV is the number of vertices and E is the number of edges.", "short_description": "Computes maximum flow from source to sink using BFS."}, "args": ["capacity", "source", "sink"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 51, "max_lineno": 91}, "calls": ["len", "queue.Queue", "queue.Queue.put", "queue.Queue.qsize", "range", "queue.Queue.get", "min"], "store_vars_calls": {"vertices": "len", "queue": "Queue", "front": "queue.get"}, "source_code": "def edmonds_karp(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using BFS.\n    Time complexity : O(V*E^2)\n    V is the number of vertices and E is the number of edges.\n    \"\"\"\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        tmp = 0\n        queue = Queue()\n        visit = [False for _ in range(vertices)]\n        par = [-1 for _ in range(vertices)]\n        visit[source] = True\n        queue.put((source, 1 << 63))\n        while queue.qsize():\n            front = queue.get()\n            (idx, current_flow) = front\n            if idx == sink:\n                tmp = current_flow\n                break\n            for nxt in range(vertices):\n                if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n                    visit[nxt] = True\n                    par[nxt] = idx\n                    queue.put((nxt, min(current_flow, capacity[idx][nxt] - flow[idx][nxt])))\n        if par[sink] == -1:\n            break\n        ret += tmp\n        parent = par[sink]\n        idx = sink\n        while parent != -1:\n            flow[parent][idx] += tmp\n            flow[idx][parent] -= tmp\n            idx = parent\n            parent = par[parent]\n    return ret"}, "dinic_bfs": {"doc": {"long_description": "Check whether sink is reachable only using edges that is not full.", "short_description": "BFS function for Dinic algorithm."}, "args": ["capacity", "flow", "level", "source", "sink"], "returns": ["level[sink] != -1"], "min_max_lineno": {"min_lineno": 92, "max_lineno": 108}, "calls": ["len", "queue.Queue", "queue.Queue.put", "queue.Queue.qsize", "queue.Queue.get", "range"], "store_vars_calls": {"vertices": "len", "queue": "Queue", "front": "queue.get"}, "source_code": "def dinic_bfs(capacity, flow, level, source, sink):\n    \"\"\"\n    BFS function for Dinic algorithm.\n    Check whether sink is reachable only using edges that is not full.\n    \"\"\"\n    vertices = len(capacity)\n    queue = Queue()\n    queue.put(source)\n    level[source] = 0\n    while queue.qsize():\n        front = queue.get()\n        for nxt in range(vertices):\n            if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]:\n                level[nxt] = level[front] + 1\n                queue.put(nxt)\n    return level[sink] != -1"}, "dinic_dfs": {"doc": {"long_description": "Finds new flow using edges that is not full.", "short_description": "DFS function for Dinic algorithm."}, "args": ["capacity", "flow", "level", "idx", "sink", "work", "current_flow"], "returns": ["0", "current_flow", "tmp"], "min_max_lineno": {"min_lineno": 109, "max_lineno": 128}, "calls": ["len", "min", "maximum_flow.dinic_dfs"], "store_vars_calls": {"vertices": "len", "available_flow": "min", "tmp": "dinic_dfs"}, "source_code": "def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow=1 << 63):\n    \"\"\"\n    DFS function for Dinic algorithm.\n    Finds new flow using edges that is not full.\n    \"\"\"\n    if idx == sink:\n        return current_flow\n    vertices = len(capacity)\n    while work[idx] < vertices:\n        nxt = work[idx]\n        if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, available_flow)\n            if tmp > 0:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n        work[idx] += 1\n    return 0"}, "dinic": {"doc": {"long_description": "Time complexity : O(V^2*E)\nV is the number of vertices and E is the number of edges.", "short_description": "Computes maximum flow from source to sink using Dinic algorithm."}, "args": ["capacity", "source", "sink"], "returns": ["ret"], "min_max_lineno": {"min_lineno": 129, "max_lineno": 150}, "calls": ["len", "range", "maximum_flow.dinic_bfs", "maximum_flow.dinic_dfs"], "store_vars_calls": {"vertices": "len", "tmp": "dinic_dfs"}, "source_code": "def dinic(capacity, source, sink):\n    \"\"\"\n    Computes maximum flow from source to sink using Dinic algorithm.\n    Time complexity : O(V^2*E)\n    V is the number of vertices and E is the number of edges.\n    \"\"\"\n    vertices = len(capacity)\n    flow = [[0] * vertices for i in range(vertices)]\n    ret = 0\n    while True:\n        level = [-1 for i in range(vertices)]\n        work = [0 for i in range(vertices)]\n        if not dinic_bfs(capacity, flow, level, source, sink):\n            break\n        while True:\n            tmp = dinic_dfs(capacity, flow, level, source, sink, work)\n            if tmp > 0:\n                ret += tmp\n            else:\n                break\n    return ret"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/find_path.py", "fileNameBase": "find_path", "extension": "py", "doc": {"short_description": "Functions for finding paths in graphs.", "full": "Functions for finding paths in graphs."}}, "functions": {"find_path": {"doc": {"short_description": "Find a path between two nodes using recursion and backtracking."}, "args": ["graph", "start", "end", "path"], "returns": ["None", "path", "None", "newpath"], "min_max_lineno": {"min_lineno": 6, "max_lineno": 20}, "calls": ["find_path.find_path"], "store_vars_calls": {"newpath": "find_path"}, "source_code": "def find_path(graph, start, end, path=[]):\n    \"\"\"\n    Find a path between two nodes using recursion and backtracking.\n    \"\"\"\n    path = path + [start]\n    if start == end:\n        return path\n    if not start in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_path(graph, node, end, path)\n            return newpath\n    return None"}, "find_all_path": {"doc": {"short_description": "Find all paths between two nodes using recursion and backtracking"}, "args": ["graph", "start", "end", "path"], "returns": ["paths", "[path]", "[]"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 38}, "calls": ["find_path.find_all_path", "paths.append"], "store_vars_calls": {"newpaths": "find_all_path"}, "source_code": "def find_all_path(graph, start, end, path=[]):\n    \"\"\"\n    Find all paths between two nodes using recursion and backtracking\n    \"\"\"\n    path = path + [start]\n    if start == end:\n        return [path]\n    if not start in graph:\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_path(graph, node, end, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths"}, "find_shortest_path": {"doc": {"short_description": "find the shortest path between two nodes"}, "args": ["graph", "start", "end", "path"], "returns": ["shortest", "path", "None"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 56}, "calls": ["find_path.find_shortest_path", "len"], "store_vars_calls": {"newpath": "find_shortest_path"}, "source_code": "def find_shortest_path(graph, start, end, path=[]):\n    \"\"\"\n    find the shortest path between two nodes\n    \"\"\"\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_shortest_path(graph, node, end, path)\n            if newpath:\n                if not shortest or len(newpath) < len(shortest):\n                    shortest = newpath\n    return shortest"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/clone_graph.py", "fileNameBase": "clone_graph", "extension": "py", "doc": {"long_description": "of its neighbors.\n\n\nOJ's undirected graph serialization:\nNodes are labeled uniquely.\n\nWe use # as a separator for each node, and , as a separator for node label and\neach neighbor of the node.\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\n\nThe graph has a total of three nodes, and therefore contains three parts as\nseparated by #.\n\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\nSecond node is labeled as 1. Connect node 1 to node 2.\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a\nself-cycle.\nVisually, the graph looks like the following:\n\n       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/", "short_description": "Clone an undirected graph. Each node in the graph contains a label and a list", "full": "Clone an undirected graph. Each node in the graph contains a label and a list\nof its neighbors.\n\n\nOJ's undirected graph serialization:\nNodes are labeled uniquely.\n\nWe use # as a separator for each node, and , as a separator for node label and\neach neighbor of the node.\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\n\nThe graph has a total of three nodes, and therefore contains three parts as\nseparated by #.\n\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\nSecond node is labeled as 1. Connect node 1 to node 2.\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a\nself-cycle.\nVisually, the graph looks like the following:\n\n       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/"}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "classes": {"UndirectedGraphNode": {"doc": {"long_description": "nodes (initially empty).", "short_description": "A node in an undirected graph. Contains a label and a list of neighbouring", "full": "A node in an undirected graph. Contains a label and a list of neighbouring\nnodes (initially empty)."}, "min_max_lineno": {"min_lineno": 32, "max_lineno": 53}, "methods": {"__init__": {"args": ["self", "label"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 41}, "source_code": "def __init__(self, label):\n    self.label = label\n    self.neighbors = []"}, "shallow_copy": {"doc": {"short_description": "Return a shallow copy of this node (ignoring any neighbors)"}, "args": ["self"], "returns": ["UndirectedGraphNode(self.label)"], "min_max_lineno": {"min_lineno": 42, "max_lineno": 47}, "source_code": "def shallow_copy(self):\n    \"\"\"\n        Return a shallow copy of this node (ignoring any neighbors)\n        \"\"\"\n    return UndirectedGraphNode(self.label)"}, "add_neighbor": {"doc": {"short_description": "Adds a new neighbor"}, "args": ["self", "node"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 53}, "calls": ["clone_graph.UndirectedGraphNode.neighbors.append"], "source_code": "def add_neighbor(self, node):\n    \"\"\"\n        Adds a new neighbor\n        \"\"\"\n    self.neighbors.append(node)"}}}}, "functions": {"clone_graph1": {"doc": {"short_description": "Returns a new graph as seen from the given node using a breadth first search (BFS)."}, "args": ["node"], "returns": ["node_copy", "None"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 75}, "calls": ["queue.popleft.shallow_copy", "collections.deque", "collections.deque.popleft", "neighbor.shallow_copy", "dic[].add_neighbor", "collections.deque.append"], "store_vars_calls": {"node_copy": "node.shallow_copy", "queue": "collections.deque", "node": "queue.popleft", "neighbor_copy": "neighbor.shallow_copy"}, "source_code": "def clone_graph1(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using a breadth first search (BFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    queue = collections.deque([node])\n    while queue:\n        node = queue.popleft()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                queue.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy"}, "clone_graph2": {"doc": {"short_description": "Returns a new graph as seen from the given node using an iterative depth first search (DFS)."}, "args": ["node"], "returns": ["node_copy", "None"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 97}, "calls": ["stack.pop.shallow_copy", "stack.pop", "neighbor.shallow_copy", "dic[].add_neighbor", "stack.append"], "store_vars_calls": {"node_copy": "node.shallow_copy", "node": "stack.pop", "neighbor_copy": "neighbor.shallow_copy"}, "source_code": "def clone_graph2(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using an iterative depth first search (DFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                stack.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy"}, "clone_graph": {"doc": {"short_description": "Returns a new graph as seen from the given node using a recursive depth first search (DFS)."}, "args": ["node"], "returns": ["node_copy", "None"], "min_max_lineno": {"min_lineno": 99, "max_lineno": 109}, "calls": ["node.shallow_copy", "clone_graph.dfs"], "store_vars_calls": {"node_copy": "node.shallow_copy"}, "source_code": "def clone_graph(node):\n    \"\"\"\n    Returns a new graph as seen from the given node using a recursive depth first search (DFS).\n    \"\"\"\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    dfs(node, dic)\n    return node_copy"}, "dfs": {"doc": {"long_description": "the dictionary, keyed by the original nodes.", "short_description": "Clones a graph using a recursive depth first search. Stores the clones in"}, "args": ["node", "dic"], "min_max_lineno": {"min_lineno": 111, "max_lineno": 124}, "calls": ["neighbor.shallow_copy", "dic[].add_neighbor", "clone_graph.dfs"], "store_vars_calls": {"neighbor_copy": "neighbor.shallow_copy"}, "source_code": "def dfs(node, dic):\n    \"\"\"\n    Clones a graph using a recursive depth first search. Stores the clones in\n    the dictionary, keyed by the original nodes.\n    \"\"\"\n    for neighbor in node.neighbors:\n        if neighbor not in dic:\n            neighbor_copy = neighbor.shallow_copy()\n            dic[neighbor] = neighbor_copy\n            dic[node].add_neighbor(neighbor_copy)\n            dfs(neighbor, dic)\n        else:\n            dic[node].add_neighbor(dic[neighbor])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/prims_minimum_spanning.py", "fileNameBase": "prims_minimum_spanning", "extension": "py", "doc": {"long_description": "of a connected graph.\nFor argument graph, it should be a dictionary type such as:\n\n    graph = {\n        'a': [ [3, 'b'], [8,'c'] ],\n        'b': [ [3, 'a'], [5, 'd'] ],\n        'c': [ [8, 'a'], [2, 'd'], [4, 'e'] ],\n        'd': [ [5, 'b'], [2, 'c'], [6, 'e'] ],\n        'e': [ [4, 'c'], [6, 'd'] ]\n    }\n\nwhere 'a','b','c','d','e' are nodes (these can be 1,2,3,4,5 as well)", "short_description": "This Prim's Algorithm Code is for finding weight of minimum spanning tree", "full": "This Prim's Algorithm Code is for finding weight of minimum spanning tree\nof a connected graph.\nFor argument graph, it should be a dictionary type such as:\n\n    graph = {\n        'a': [ [3, 'b'], [8,'c'] ],\n        'b': [ [3, 'a'], [5, 'd'] ],\n        'c': [ [8, 'a'], [2, 'd'], [4, 'e'] ],\n        'd': [ [5, 'b'], [2, 'c'], [6, 'e'] ],\n        'e': [ [4, 'c'], [6, 'd'] ]\n    }\n\nwhere 'a','b','c','d','e' are nodes (these can be 1,2,3,4,5 as well)"}}, "dependencies": [{"import": "heapq", "type": "external", "type_element": "module"}], "functions": {"prims_minimum_spanning": {"doc": {"short_description": "Prim's algorithm to find weight of minimum spanning tree"}, "args": ["graph_used"], "returns": ["mincost"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 43}, "calls": ["set", "len", "heapq.heappop", "set.add", "vis.append", "heapq.heappush"], "store_vars_calls": {"prim": "set"}, "source_code": "def prims_minimum_spanning(graph_used):\n    \"\"\"\n    Prim's algorithm to find weight of minimum spanning tree\n    \"\"\"\n    vis = []\n    heap = [[0, 1]]\n    prim = set()\n    mincost = 0\n    while len(heap) > 0:\n        (cost, node) = heapq.heappop(heap)\n        if node in vis:\n            continue\n        mincost += cost\n        prim.add(node)\n        vis.append(node)\n        for (distance, adjacent) in graph_used[node]:\n            if adjacent not in vis:\n                heapq.heappush(heap, [distance, adjacent])\n    return mincost"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/check_digraph_strongly_connected.py", "fileNameBase": "check_digraph_strongly_connected", "extension": "py", "doc": {"long_description": "that for any pairs of vertices u and v there exists a path (u-...-v) that\nconnects them. A graph is strongly connected if it is a single strongly\nconnected component.", "short_description": "In a directed graph, a strongly connected component is a set of vertices such", "full": "In a directed graph, a strongly connected component is a set of vertices such\nthat for any pairs of vertices u and v there exists a path (u-...-v) that\nconnects them. A graph is strongly connected if it is a single strongly\nconnected component."}}, "dependencies": [{"from_module": "collections", "import": "defaultdict", "type": "external", "type_element": "module"}], "classes": {"Graph": {"doc": {"short_description": "A directed graph where edges are one-way (a two-way edge can be represented by using two edges).", "full": "A directed graph where edges are one-way (a two-way edge can be represented by using two edges)."}, "min_max_lineno": {"min_lineno": 10, "max_lineno": 70}, "methods": {"__init__": {"doc": {"short_description": "Create a new graph with vertex_count vertices."}, "args": ["self", "vertex_count"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 22}, "calls": ["collections.defaultdict"], "store_vars_calls": {"self.graph": "defaultdict"}, "source_code": "def __init__(self, vertex_count):\n    \"\"\"\n        Create a new graph with vertex_count vertices.\n        \"\"\"\n    self.vertex_count = vertex_count\n    self.graph = defaultdict(list)"}, "add_edge": {"doc": {"short_description": "Add an edge going from source to target"}, "args": ["self", "source", "target"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 28}, "calls": ["check_digraph_strongly_connected.Graph.graph[].append"], "source_code": "def add_edge(self, source, target):\n    \"\"\"\n        Add an edge going from source to target\n        \"\"\"\n    self.graph[source].append(target)"}, "dfs": {"doc": {"short_description": "Determine if all nodes are reachable from node 0"}, "args": ["self"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 29, "max_lineno": 38}, "calls": ["check_digraph_strongly_connected.Graph.dfs_util"], "source_code": "def dfs(self):\n    \"\"\"\n        Determine if all nodes are reachable from node 0\n        \"\"\"\n    visited = [False] * self.vertex_count\n    self.dfs_util(0, visited)\n    if visited == [True] * self.vertex_count:\n        return True\n    return False"}, "dfs_util": {"doc": {"short_description": "Determine if all nodes are reachable from the given node"}, "args": ["self", "source", "visited"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 47}, "calls": ["check_digraph_strongly_connected.Graph.dfs_util"], "source_code": "def dfs_util(self, source, visited):\n    \"\"\"\n        Determine if all nodes are reachable from the given node\n        \"\"\"\n    visited[source] = True\n    for adjacent in self.graph[source]:\n        if not visited[adjacent]:\n            self.dfs_util(adjacent, visited)"}, "reverse_graph": {"doc": {"short_description": "Create a new graph where every edge a->b is replaced with an edge b->a"}, "args": ["self"], "returns": ["reverse_graph"], "min_max_lineno": {"min_lineno": 48, "max_lineno": 59}, "calls": ["check_digraph_strongly_connected.Graph.graph.items", "check_digraph_strongly_connected.Graph.add_edge"], "store_vars_calls": {"reverse_graph": "Graph"}, "source_code": "def reverse_graph(self):\n    \"\"\"\n        Create a new graph where every edge a->b is replaced with an edge b->a\n        \"\"\"\n    reverse_graph = Graph(self.vertex_count)\n    for (source, adjacent) in self.graph.items():\n        for target in adjacent:\n            reverse_graph.add_edge(target, source)\n    return reverse_graph"}, "is_strongly_connected": {"doc": {"short_description": "Determine if the graph is strongly connected."}, "args": ["self"], "returns": ["False", "True"], "min_max_lineno": {"min_lineno": 61, "max_lineno": 70}, "calls": ["check_digraph_strongly_connected.Graph.dfs", "check_digraph_strongly_connected.Graph.reverse_graph", "check_digraph_strongly_connected.Graph.dfs"], "store_vars_calls": {"reversed_graph": "self.reverse_graph"}, "source_code": "def is_strongly_connected(self):\n    \"\"\"\n        Determine if the graph is strongly connected.\n        \"\"\"\n    if self.dfs():\n        reversed_graph = self.reverse_graph()\n        if reversed_graph.dfs():\n            return True\n    return False"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/bellman_ford.py", "fileNameBase": "bellman_ford", "extension": "py", "doc": {"short_description": "Determination of single-source shortest-path.", "full": "Determination of single-source shortest-path."}}, "functions": {"bellman_ford": {"doc": {"long_description": "shortest path from given graph or not for single-source shortest-paths problem.\nIn other words, if given graph has any negative-weight cycle that is reachable\nfrom the source, then it will give answer False for \"no solution exits\".\nFor argument graph, it should be a dictionary type\nsuch as\ngraph = {\n    'a': {'b': 6, 'e': 7},\n    'b': {'c': 5, 'd': -4, 'e': 8},\n    'c': {'b': -2},\n    'd': {'a': 2, 'c': 7},\n    'e': {'b': -3}\n}", "short_description": "This Bellman-Ford Code is for determination whether we can get"}, "args": ["graph", "source"], "returns": ["True", "False"], "min_max_lineno": {"min_lineno": 5, "max_lineno": 39}, "calls": ["bellman_ford.initialize_single_source", "range", "len"], "source_code": "def bellman_ford(graph, source):\n    \"\"\"\n    This Bellman-Ford Code is for determination whether we can get\n    shortest path from given graph or not for single-source shortest-paths problem.\n    In other words, if given graph has any negative-weight cycle that is reachable\n    from the source, then it will give answer False for \"no solution exits\".\n    For argument graph, it should be a dictionary type\n    such as\n    graph = {\n        'a': {'b': 6, 'e': 7},\n        'b': {'c': 5, 'd': -4, 'e': 8},\n        'c': {'b': -2},\n        'd': {'a': 2, 'c': 7},\n        'e': {'b': -3}\n    }\n    \"\"\"\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True"}, "initialize_single_source": {"doc": {"short_description": "Initialize data structures for Bellman-Ford algorithm."}, "args": ["graph", "source", "weight", "pre_node"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 49}, "calls": ["float"], "source_code": "def initialize_single_source(graph, source, weight, pre_node):\n    \"\"\"\n    Initialize data structures for Bellman-Ford algorithm.\n    \"\"\"\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/traversal.py", "fileNameBase": "traversal", "extension": "py", "doc": {"short_description": "Different ways to traverse a graph", "full": "Different ways to traverse a graph"}}, "functions": {"dfs_traverse": {"doc": {"short_description": "Traversal by depth first search."}, "args": ["graph", "start"], "returns": ["visited"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 23}, "calls": ["set", "stack.pop", "visited.add", "stack.append"], "store_vars_calls": {"node": "stack.pop"}, "source_code": "def dfs_traverse(graph, start):\n    \"\"\"\n    Traversal by depth first search.\n    \"\"\"\n    (visited, stack) = (set(), [start])\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    stack.append(next_node)\n    return visited"}, "bfs_traverse": {"doc": {"short_description": "Traversal by breadth first search."}, "args": ["graph", "start"], "returns": ["visited"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 37}, "calls": ["set", "queue.pop", "visited.add", "queue.append"], "store_vars_calls": {"node": "queue.pop"}, "source_code": "def bfs_traverse(graph, start):\n    \"\"\"\n    Traversal by breadth first search.\n    \"\"\"\n    (visited, queue) = (set(), [start])\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    queue.append(next_node)\n    return visited"}, "dfs_traverse_recursive": {"doc": {"short_description": "Traversal by recursive depth first search."}, "args": ["graph", "start", "visited"], "returns": ["visited"], "min_max_lineno": {"min_lineno": 38, "max_lineno": 49}, "calls": ["set.add", "set", "traversal.dfs_traverse_recursive"], "store_vars_calls": {"visited": "set"}, "source_code": "def dfs_traverse_recursive(graph, start, visited=None):\n    \"\"\"\n    Traversal by recursive depth first search.\n    \"\"\"\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for next_node in graph[start]:\n        if next_node not in visited:\n            dfs_traverse_recursive(graph, next_node, visited)\n    return visited"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/all_pairs_shortest_path.py", "fileNameBase": "all_pairs_shortest_path", "extension": "py", "doc": {"long_description": "it will give you all pairs shortest path length.\nuse deepcopy to preserve the original information.\n\nTime complexity : O(E^3)\n\nexample\n\na = [[0    , 0.1  , 0.101, 0.142, 0.277],\n     [0.465, 0    , 0.191, 0.192, 0.587],\n     [0.245, 0.554, 0    , 0.333, 0.931],\n     [1.032, 0.668, 0.656, 0    , 0.151],\n     [0.867, 0.119, 0.352, 0.398, 0]]\n\nresult\n\n[[0    , 0.1  , 0.101, 0.142, 0.277],\n [0.436, 0    , 0.191, 0.192, 0.343],\n [0.245, 0.345, 0    , 0.333, 0.484],\n [0.706, 0.27 , 0.461, 0    , 0.151],\n [0.555, 0.119, 0.31 , 0.311, 0]]", "short_description": "Given a n*n adjacency array.", "full": "Given a n*n adjacency array.\nit will give you all pairs shortest path length.\nuse deepcopy to preserve the original information.\n\nTime complexity : O(E^3)\n\nexample\n\na = [[0    , 0.1  , 0.101, 0.142, 0.277],\n     [0.465, 0    , 0.191, 0.192, 0.587],\n     [0.245, 0.554, 0    , 0.333, 0.931],\n     [1.032, 0.668, 0.656, 0    , 0.151],\n     [0.867, 0.119, 0.352, 0.398, 0]]\n\nresult\n\n[[0    , 0.1  , 0.101, 0.142, 0.277],\n [0.436, 0    , 0.191, 0.192, 0.343],\n [0.245, 0.345, 0    , 0.333, 0.484],\n [0.706, 0.27 , 0.461, 0    , 0.151],\n [0.555, 0.119, 0.31 , 0.311, 0]]"}}, "dependencies": [{"import": "copy", "type": "external", "type_element": "module"}], "functions": {"all_pairs_shortest_path": {"doc": {"long_description": "matrix containing the shortest distance distance between the two nodes.", "short_description": "Given a matrix of the edge weights between respective nodes, returns a"}, "args": ["adjacency_matrix"], "returns": ["new_array"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 43}, "calls": ["copy.deepcopy", "len", "range"], "store_vars_calls": {"new_array": "copy.deepcopy", "size": "len"}, "source_code": "def all_pairs_shortest_path(adjacency_matrix):\n    \"\"\"\n    Given a matrix of the edge weights between respective nodes, returns a\n    matrix containing the shortest distance distance between the two nodes.\n    \"\"\"\n    new_array = copy.deepcopy(adjacency_matrix)\n    size = len(new_array)\n    for k in range(size):\n        for i in range(size):\n            for j in range(size):\n                if new_array[i][j] > new_array[i][k] + new_array[k][j]:\n                    new_array[i][j] = new_array[i][k] + new_array[k][j]\n    return new_array"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/markov_chain.py", "fileNameBase": "markov_chain", "extension": "py", "doc": {"long_description": "my_chain = {\n    'A': {'A': 0.6,\n          'E': 0.4},\n    'E': {'A': 0.7,\n          'E': 0.3}\n}", "short_description": "Implements a markov chain. Chains are described using a dictionary:", "full": "Implements a markov chain. Chains are described using a dictionary:\n\n    my_chain = {\n        'A': {'A': 0.6,\n              'E': 0.4},\n        'E': {'A': 0.7,\n              'E': 0.3}\n    }"}}, "dependencies": [{"import": "random", "type": "external", "type_element": "module"}], "functions": {"__choose_state": {"doc": {"short_description": "Choose the next state randomly"}, "args": ["state_map"], "returns": ["None", "state"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 25}, "calls": ["random.random", "state_map.items"], "store_vars_calls": {"choice": "random.random"}, "source_code": "def __choose_state(state_map):\n    \"\"\"\n    Choose the next state randomly\n    \"\"\"\n    choice = random.random()\n    probability_reached = 0\n    for (state, probability) in state_map.items():\n        probability_reached += probability\n        if probability_reached > choice:\n            return state\n    return None"}, "next_state": {"doc": {"short_description": "Given a markov-chain, randomly chooses the next state given the current state."}, "args": ["chain", "current_state"], "returns": ["__choose_state(next_state_map)"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 32}, "calls": ["chain.get", "markov_chain.__choose_state"], "store_vars_calls": {"next_state_map": "chain.get"}, "source_code": "def next_state(chain, current_state):\n    \"\"\"\n    Given a markov-chain, randomly chooses the next state given the current state.\n    \"\"\"\n    next_state_map = chain.get(current_state)\n    return __choose_state(next_state_map)"}, "iterating_markov_chain": {"doc": {"short_description": "Yield a sequence of states given a markov chain and the initial state"}, "args": ["chain", "state"], "min_max_lineno": {"min_lineno": 33, "max_lineno": 40}, "calls": ["markov_chain.next_state"], "store_vars_calls": {"state": "next_state"}, "source_code": "def iterating_markov_chain(chain, state):\n    \"\"\"\n    Yield a sequence of states given a markov chain and the initial state\n    \"\"\"\n    while True:\n        state = next_state(chain, state)\n        yield state"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/count_connected_number_of_component.py", "fileNameBase": "count_connected_number_of_component", "extension": "py", "doc": {"long_description": "of an undirected graph is a subgraph in which any\ntwo vertices are connected to each other by paths.", "short_description": "In graph theory, a component, sometimes called a connected component,", "full": "In graph theory, a component, sometimes called a connected component,\nof an undirected graph is a subgraph in which any\ntwo vertices are connected to each other by paths.\n\nExample:\n\n\n    1                3------------7\n    |\n    |\n    2--------4\n    |        |\n    |        |              output = 2\n    6--------5"}}, "functions": {"dfs": {"doc": {"short_description": "Function that performs DFS "}, "args": ["source", "visited", "adjacency_list"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 29}, "calls": ["count_connected_number_of_component.dfs"], "source_code": "def dfs(source, visited, adjacency_list):\n    \"\"\" Function that performs DFS \"\"\"\n    visited[source] = True\n    for child in adjacency_list[source]:\n        if not visited[child]:\n            dfs(child, visited, adjacency_list)"}, "count_components": {"doc": {"long_description": "return type : int", "short_description": "Function that counts the Connected components on bases of DFS."}, "args": ["adjacency_list", "size"], "returns": ["count"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 43}, "calls": ["range", "count_connected_number_of_component.dfs"], "source_code": "def count_components(adjacency_list, size):\n    \"\"\"\n    Function that counts the Connected components on bases of DFS.\n    return type : int\n    \"\"\"\n    count = 0\n    visited = [False] * (size + 1)\n    for i in range(1, size + 1):\n        if not visited[i]:\n            dfs(i, visited, adjacency_list)\n            count += 1\n    return count"}, "main": {"doc": {"short_description": "Example application"}, "min_max_lineno": {"min_lineno": 44, "max_lineno": 56}, "calls": ["map", "range", "print", "input().split", "adjacency[].append", "count_connected_number_of_component.count_components", "input"], "source_code": "def main():\n    \"\"\"\n    Example application\n    \"\"\"\n    (node_count, edge_count) = map(int, input('Enter the Number of Nodes and Edges \\n').split(' '))\n    adjacency = [[] for _ in range(node_count + 1)]\n    for _ in range(edge_count):\n        print(\"Enter the edge's Nodes in form of `source target`\\n\")\n        (source, target) = map(int, input().split(' '))\n        adjacency[source].append(target)\n        adjacency[target].append(source)\n    print('Total number of Connected Components are : ', count_components(adjacency, node_count))"}}, "body": {"calls": ["count_connected_number_of_component.main"], "source_code": ["main()"]}, "main_info": {"main_flag": 1, "main_function": "count_connected_number_of_component.main", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/graph.py", "fileNameBase": "graph", "extension": "py", "doc": {"long_description": "It can be shared across graph algorithms.", "short_description": "These are classes to represent a Graph and its elements.", "full": "These are classes to represent a Graph and its elements.\nIt can be shared across graph algorithms."}}, "classes": {"Node": {"doc": {"short_description": "A node/vertex in a graph.", "full": "A node/vertex in a graph."}, "min_max_lineno": {"min_lineno": 6, "max_lineno": 51}, "methods": {"__init__": {"args": ["self", "name"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 13}, "source_code": "def __init__(self, name):\n    self.name = name"}, "get_name": {"doc": {"short_description": "Return the name of the node"}, "args": ["obj"], "returns": ["''", "obj.name", "obj"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 24}, "calls": ["isinstance"], "source_code": "@staticmethod\ndef get_name(obj):\n    \"\"\"\n        Return the name of the node\n        \"\"\"\n    if isinstance(obj, Node):\n        return obj.name\n    if isinstance(obj, str):\n        return obj\n    return ''"}, "__eq__": {"args": ["self", "obj"], "returns": ["self.name == self.get_name(obj)"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 27}, "calls": ["graph.Node.get_name"], "source_code": "def __eq__(self, obj):\n    return self.name == self.get_name(obj)"}, "__repr__": {"args": ["self"], "returns": ["self.name"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 30}, "source_code": "def __repr__(self):\n    return self.name"}, "__hash__": {"args": ["self"], "returns": ["hash(self.name)"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 33}, "calls": ["hash"], "source_code": "def __hash__(self):\n    return hash(self.name)"}, "__ne__": {"args": ["self", "obj"], "returns": ["self.name != self.get_name(obj)"], "min_max_lineno": {"min_lineno": 34, "max_lineno": 36}, "calls": ["graph.Node.get_name"], "source_code": "def __ne__(self, obj):\n    return self.name != self.get_name(obj)"}, "__lt__": {"args": ["self", "obj"], "returns": ["self.name < self.get_name(obj)"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 39}, "calls": ["graph.Node.get_name"], "source_code": "def __lt__(self, obj):\n    return self.name < self.get_name(obj)"}, "__le__": {"args": ["self", "obj"], "returns": ["self.name <= self.get_name(obj)"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 42}, "calls": ["graph.Node.get_name"], "source_code": "def __le__(self, obj):\n    return self.name <= self.get_name(obj)"}, "__gt__": {"args": ["self", "obj"], "returns": ["self.name > self.get_name(obj)"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 45}, "calls": ["graph.Node.get_name"], "source_code": "def __gt__(self, obj):\n    return self.name > self.get_name(obj)"}, "__ge__": {"args": ["self", "obj"], "returns": ["self.name >= self.get_name(obj)"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 48}, "calls": ["graph.Node.get_name"], "source_code": "def __ge__(self, obj):\n    return self.name >= self.get_name(obj)"}, "__bool__": {"args": ["self"], "returns": ["self.name"], "min_max_lineno": {"min_lineno": 49, "max_lineno": 51}, "source_code": "def __bool__(self):\n    return self.name"}}}, "DirectedEdge": {"doc": {"long_description": "Stores the source and target node of the edge.", "short_description": "A directed edge in a directed graph.", "full": "A directed edge in a directed graph.\nStores the source and target node of the edge."}, "min_max_lineno": {"min_lineno": 52, "max_lineno": 69}, "methods": {"__init__": {"args": ["self", "node_from", "node_to"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 61}, "source_code": "def __init__(self, node_from, node_to):\n    self.source = node_from\n    self.target = node_to"}, "__eq__": {"args": ["self", "obj"], "returns": ["False", "obj.source == self.source and obj.target == self.target"], "min_max_lineno": {"min_lineno": 62, "max_lineno": 66}, "calls": ["isinstance"], "source_code": "def __eq__(self, obj):\n    if isinstance(obj, DirectedEdge):\n        return obj.source == self.source and obj.target == self.target\n    return False"}, "__repr__": {"args": ["self"], "returns": ["f'({self.source} -> {self.target})'"], "min_max_lineno": {"min_lineno": 67, "max_lineno": 69}, "source_code": "def __repr__(self):\n    return f'({self.source} -> {self.target})'"}}}, "DirectedGraph": {"doc": {"long_description": "Stores a set of nodes, edges and adjacency matrix.", "short_description": "A directed graph.", "full": "A directed graph.\nStores a set of nodes, edges and adjacency matrix."}, "min_max_lineno": {"min_lineno": 70, "max_lineno": 112}, "methods": {"__init__": {"args": ["self", "load_dict"], "min_max_lineno": {"min_lineno": 77, "max_lineno": 90}, "calls": ["isinstance", "graph.DirectedGraph.add_node", "graph.DirectedGraph.adjacency_list[].append", "graph.DirectedGraph.add_edge"], "store_vars_calls": {"node_from": "self.add_node", "node_to": "self.add_node"}, "source_code": "def __init__(self, load_dict={}):\n    self.nodes = []\n    self.edges = []\n    self.adjacency_list = {}\n    if load_dict and isinstance(load_dict, dict):\n        for vertex in load_dict:\n            node_from = self.add_node(vertex)\n            self.adjacency_list[node_from] = []\n            for neighbor in load_dict[vertex]:\n                node_to = self.add_node(neighbor)\n                self.adjacency_list[node_from].append(node_to)\n                self.add_edge(vertex, neighbor)"}, "add_node": {"doc": {"short_description": "Add a new named node to the graph."}, "args": ["self", "node_name"], "returns": ["self.nodes[self.nodes.index(node_name)]", "node"], "min_max_lineno": {"min_lineno": 91, "max_lineno": 101}, "calls": ["graph.DirectedGraph.nodes.index", "graph.DirectedGraph.nodes.append"], "store_vars_calls": {"node": "Node"}, "source_code": "def add_node(self, node_name):\n    \"\"\"\n        Add a new named node to the graph.\n        \"\"\"\n    try:\n        return self.nodes[self.nodes.index(node_name)]\n    except ValueError:\n        node = Node(node_name)\n        self.nodes.append(node)\n        return node"}, "add_edge": {"doc": {"short_description": "Add a new edge to the graph between two nodes."}, "args": ["self", "node_name_from", "node_name_to"], "min_max_lineno": {"min_lineno": 102, "max_lineno": 112}, "calls": ["graph.DirectedGraph.edges.append", "graph.DirectedGraph.nodes.index"], "source_code": "def add_edge(self, node_name_from, node_name_to):\n    \"\"\"\n        Add a new edge to the graph between two nodes.\n        \"\"\"\n    try:\n        node_from = self.nodes[self.nodes.index(node_name_from)]\n        node_to = self.nodes[self.nodes.index(node_name_to)]\n        self.edges.append(DirectedEdge(node_from, node_to))\n    except ValueError:\n        pass"}}}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/__init__.py", "fileNameBase": "__init__", "extension": "py", "doc": {"short_description": "Collection of algorithms on graphs.", "full": "Collection of algorithms on graphs."}}, "dependencies": [{"from_module": "tarjan", "import": "Tarjan", "type": "internal", "type_element": "class"}, {"from_module": "check_bipartite", "import": "check_bipartite", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "dfs", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "ford_fulkerson", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "edmonds_karp", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "dinic_bfs", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "dinic_dfs", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow", "import": "dinic", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow_bfs", "import": "maximum_flow_bfs", "type": "internal", "type_element": "function"}, {"from_module": "maximum_flow_dfs", "import": "maximum_flow_dfs", "type": "internal", "type_element": "function"}, {"from_module": "all_pairs_shortest_path", "import": "all_pairs_shortest_path", "type": "internal", "type_element": "function"}, {"from_module": "bellman_ford", "import": "bellman_ford", "type": "internal", "type_element": "function"}, {"from_module": "bellman_ford", "import": "initialize_single_source", "type": "internal", "type_element": "function"}, {"from_module": "prims_minimum_spanning", "import": "prims_minimum_spanning", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/find_all_cliques.py", "fileNameBase": "find_all_cliques", "extension": "py", "doc": {"long_description": "graph such that the subgraph is fully connected (ie. for any pair of nodes in\nthe subgraph there is an edge between them).", "short_description": "Finds all cliques in an undirected graph. A clique is a set of vertices in the", "full": "Finds all cliques in an undirected graph. A clique is a set of vertices in the\ngraph such that the subgraph is fully connected (ie. for any pair of nodes in\nthe subgraph there is an edge between them)."}}, "functions": {"find_all_cliques": {"doc": {"long_description": "each key is a vertex\nvalue is set of all edges connected to vertex\nreturns list of lists (each sub list is a maximal clique)\nimplementation of the basic algorithm described in:\nBron, Coen; Kerbosch, Joep (1973), \"Algorithm 457: finding all cliques of an undirected graph\",", "short_description": "takes dict of sets"}, "args": ["edges"], "returns": ["solutions", "new_set"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 43}, "calls": ["set", "find_all_cliques.find_all_cliques.expand_clique"], "store_vars_calls": {"possibles": "set", "new_set": "set", "candidates_temp": "get_connected", "nays_temp": "get_connected"}, "functions": {"expand_clique": {"args": ["candidates", "nays"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 30}, "calls": ["solutions.append", "candidates.copy", "compsub.copy", "candidates.remove", "get_connected", "compsub.append", "expand_clique", "nays.add", "compsub.pop"], "store_vars_calls": {"candidates_temp": "get_connected", "nays_temp": "get_connected"}, "source_code": "def expand_clique(candidates, nays):\n    nonlocal compsub\n    if not candidates and (not nays):\n        nonlocal solutions\n        solutions.append(compsub.copy())\n    else:\n        for selected in candidates.copy():\n            candidates.remove(selected)\n            candidates_temp = get_connected(selected, candidates)\n            nays_temp = get_connected(selected, nays)\n            compsub.append(selected)\n            expand_clique(candidates_temp, nays_temp)\n            nays.add(compsub.pop())"}, "get_connected": {"args": ["vertex", "old_set"], "returns": ["new_set"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 37}, "calls": ["set", "str", "set.add"], "store_vars_calls": {"new_set": "set"}, "source_code": "def get_connected(vertex, old_set):\n    new_set = set()\n    for neighbor in edges[str(vertex)]:\n        if neighbor in old_set:\n            new_set.add(neighbor)\n    return new_set"}}, "source_code": "def find_all_cliques(edges):\n    \"\"\"\n    takes dict of sets\n    each key is a vertex\n    value is set of all edges connected to vertex\n    returns list of lists (each sub list is a maximal clique)\n    implementation of the basic algorithm described in:\n    Bron, Coen; Kerbosch, Joep (1973), \"Algorithm 457: finding all cliques of an undirected graph\",\n    \"\"\"\n\n    def expand_clique(candidates, nays):\n        nonlocal compsub\n        if not candidates and (not nays):\n            nonlocal solutions\n            solutions.append(compsub.copy())\n        else:\n            for selected in candidates.copy():\n                candidates.remove(selected)\n                candidates_temp = get_connected(selected, candidates)\n                nays_temp = get_connected(selected, nays)\n                compsub.append(selected)\n                expand_clique(candidates_temp, nays_temp)\n                nays.add(compsub.pop())\n\n    def get_connected(vertex, old_set):\n        new_set = set()\n        for neighbor in edges[str(vertex)]:\n            if neighbor in old_set:\n                new_set.add(neighbor)\n        return new_set\n    compsub = []\n    solutions = []\n    possibles = set(edges.keys())\n    expand_clique(possibles, set())\n    return solutions"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/satisfiability.py", "fileNameBase": "satisfiability", "extension": "py", "doc": {"long_description": "True/False values to all variables to satisfy all clauses, or reports there\nis no solution.\n\nhttps://en.wikipedia.org/wiki/2-satisfiability\n\n\nFormat:\n        - each clause is a pair of literals\n        - each literal in the form (name, is_neg)\n          where name is an arbitrary identifier,\n          and is_neg is true if the literal is negated", "short_description": "Given a formula in conjunctive normal form (2-CNF), finds a way to assign", "full": "Given a formula in conjunctive normal form (2-CNF), finds a way to assign\nTrue/False values to all variables to satisfy all clauses, or reports there\nis no solution.\n\nhttps://en.wikipedia.org/wiki/2-satisfiability\n\n\nFormat:\n        - each clause is a pair of literals\n        - each literal in the form (name, is_neg)\n          where name is an arbitrary identifier,\n          and is_neg is true if the literal is negated"}}, "functions": {"dfs_transposed": {"doc": {"long_description": "Stores the order in which nodes were visited to the list, in transposed order.", "short_description": "Perform a depth first search traversal of the graph starting at the given vertex."}, "args": ["vertex", "graph", "order", "visited"], "min_max_lineno": {"min_lineno": 16, "max_lineno": 28}, "calls": ["order.append", "satisfiability.dfs_transposed"], "source_code": "def dfs_transposed(vertex, graph, order, visited):\n    \"\"\"\n    Perform a depth first search traversal of the graph starting at the given vertex.\n    Stores the order in which nodes were visited to the list, in transposed order.\n    \"\"\"\n    visited[vertex] = True\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs_transposed(adjacent, graph, order, visited)\n    order.append(vertex)"}, "dfs": {"doc": {"long_description": "Records all visited nodes as being of a certain strongly connected component.", "short_description": "Perform a depth first search traversal of the graph starting at the given vertex."}, "args": ["vertex", "current_comp", "vertex_scc", "graph", "visited"], "min_max_lineno": {"min_lineno": 30, "max_lineno": 41}, "calls": ["satisfiability.dfs"], "source_code": "def dfs(vertex, current_comp, vertex_scc, graph, visited):\n    \"\"\"\n    Perform a depth first search traversal of the graph starting at the given vertex.\n    Records all visited nodes as being of a certain strongly connected component.\n    \"\"\"\n    visited[vertex] = True\n    vertex_scc[vertex] = current_comp\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs(adjacent, current_comp, vertex_scc, graph, visited)"}, "add_edge": {"doc": {"short_description": "Add a directed edge to the graph."}, "args": ["graph", "vertex_from", "vertex_to"], "min_max_lineno": {"min_lineno": 43, "max_lineno": 51}, "calls": ["graph[].append"], "source_code": "def add_edge(graph, vertex_from, vertex_to):\n    \"\"\"\n    Add a directed edge to the graph.\n    \"\"\"\n    if vertex_from not in graph:\n        graph[vertex_from] = []\n    graph[vertex_from].append(vertex_to)"}, "scc": {"doc": {"short_description": "Computes the strongly connected components of a graph "}, "args": ["graph"], "returns": ["vertex_scc"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 79}, "calls": ["graph.iteritems", "reversed", "satisfiability.add_edge", "satisfiability.dfs_transposed", "satisfiability.dfs"], "source_code": "def scc(graph):\n    \"\"\" Computes the strongly connected components of a graph \"\"\"\n    order = []\n    visited = {vertex: False for vertex in graph}\n    graph_transposed = {vertex: [] for vertex in graph}\n    for (source, neighbours) in graph.iteritems():\n        for target in neighbours:\n            add_edge(graph_transposed, target, source)\n    for vertex in graph:\n        if not visited[vertex]:\n            dfs_transposed(vertex, graph_transposed, order, visited)\n    visited = {vertex: False for vertex in graph}\n    vertex_scc = {}\n    current_comp = 0\n    for vertex in reversed(order):\n        if not visited[vertex]:\n            dfs(vertex, current_comp, vertex_scc, graph, visited)\n            current_comp += 1\n    return vertex_scc"}, "build_graph": {"doc": {"short_description": "Builds the implication graph from the formula "}, "args": ["formula"], "returns": ["graph"], "min_max_lineno": {"min_lineno": 81, "max_lineno": 95}, "calls": ["satisfiability.add_edge"], "source_code": "def build_graph(formula):\n    \"\"\" Builds the implication graph from the formula \"\"\"\n    graph = {}\n    for clause in formula:\n        for (lit, _) in clause:\n            for neg in [False, True]:\n                graph[lit, neg] = []\n    for ((a_lit, a_neg), (b_lit, b_neg)) in formula:\n        add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg))\n        add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg))\n    return graph"}, "solve_sat": {"doc": {"short_description": "Solves the 2-SAT problem"}, "args": ["formula"], "returns": ["value", "None"], "min_max_lineno": {"min_lineno": 97, "max_lineno": 127}, "calls": ["satisfiability.build_graph", "satisfiability.scc", "sorted", "scc.values"], "store_vars_calls": {"graph": "build_graph", "vertex_scc": "scc", "components": "sorted"}, "source_code": "def solve_sat(formula):\n    \"\"\"\n    Solves the 2-SAT problem\n    \"\"\"\n    graph = build_graph(formula)\n    vertex_scc = scc(graph)\n    for (var, _) in graph:\n        if vertex_scc[var, False] == vertex_scc[var, True]:\n            return None\n    comp_repr = {}\n    for vertex in graph:\n        if not vertex_scc[vertex] in comp_repr:\n            comp_repr[vertex_scc[vertex]] = vertex\n    comp_value = {}\n    components = sorted(vertex_scc.values())\n    for comp in components:\n        if comp not in comp_value:\n            comp_value[comp] = False\n            (lit, neg) = comp_repr[comp]\n            comp_value[vertex_scc[lit, not neg]] = True\n    value = {var: comp_value[vertex_scc[var, False]] for (var, _) in graph}\n    return value"}, "main": {"doc": {"short_description": "Entry point for testing"}, "min_max_lineno": {"min_lineno": 129, "max_lineno": 143}, "calls": ["satisfiability.solve_sat", "solve_sat.items", "print"], "store_vars_calls": {"result": "solve_sat"}, "source_code": "def main():\n    \"\"\"\n    Entry point for testing\n    \"\"\"\n    formula = [(('x', False), ('y', False)), (('y', True), ('y', True)), (('a', False), ('b', False)), (('a', True), ('c', True)), (('c', False), ('b', True))]\n    result = solve_sat(formula)\n    for (variable, assign) in result.items():\n        print(f'{variable}:{assign}')"}}, "body": {"calls": ["satisfiability.main"], "source_code": ["main()"]}, "main_info": {"main_flag": 1, "main_function": "satisfiability.main", "type": "script"}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/graph/maximum_flow_dfs.py", "fileNameBase": "maximum_flow_dfs", "extension": "py", "doc": {"long_description": "it will give you a maximum flow.\nThis version use DFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23", "short_description": "Given a n*n adjacency array.", "full": "Given a n*n adjacency array.\nit will give you a maximum flow.\nThis version use DFS to search path.\n\nAssume the first is the source and the last is the sink.\n\nTime complexity - O(Ef)\n\nexample\n\ngraph = [[0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]]\n\nanswer should be\n\n23"}}, "dependencies": [{"import": "copy", "type": "external", "type_element": "module"}, {"import": "math", "type": "external", "type_element": "module"}], "functions": {"maximum_flow_dfs": {"doc": {"short_description": "Get the maximum flow through a graph using a depth first search"}, "args": ["adjacency_matrix"], "returns": ["total"], "min_max_lineno": {"min_lineno": 27, "max_lineno": 88}, "calls": ["copy.deepcopy", "stack.append", "len", "stack.pop", "range"], "store_vars_calls": {"new_array": "copy.deepcopy", "src": "stack.pop"}, "source_code": "def maximum_flow_dfs(adjacency_matrix):\n    \"\"\"\n    Get the maximum flow through a graph using a depth first search\n    \"\"\"\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        stack = []\n        visited[0] = 1\n        stack.append(0)\n        while len(stack) > 0:\n            src = stack.pop()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    stack.append(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min > new_array[path[tmp]][tmp]:\n                min = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min\n            tmp = path[tmp]\n        total = total + min\n    return total"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/set": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/set/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "find_keyboard_row", "import": "find_keyboard_row", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/set/find_keyboard_row.py", "fileNameBase": "find_keyboard_row", "extension": "py", "doc": {"long_description": "alphabet on only one row's of American keyboard.\n\nFor example:\nInput: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\nOutput: [\"Alaska\", \"Dad\"]\n\nReference: https://leetcode.com/problems/keyboard-row/description/", "short_description": "Given a List of words, return the words that can be typed using letters of", "full": "Given a List of words, return the words that can be typed using letters of\nalphabet on only one row's of American keyboard.\n\nFor example:\nInput: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\nOutput: [\"Alaska\", \"Dad\"]\n\nReference: https://leetcode.com/problems/keyboard-row/description/"}}, "functions": {"find_keyboard_row": {"args": ["words"], "returns": ["result"], "min_max_lineno": {"min_lineno": 12, "max_lineno": 28}, "calls": ["set", "set().issubset", "result.append", "word.lower"], "source_code": "def find_keyboard_row(words):\n    \"\"\"\n    :type words: List[str]\n    :rtype: List[str]\n    \"\"\"\n    keyboard = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]\n    result = []\n    for word in words:\n        for key in keyboard:\n            if set(word.lower()).issubset(key):\n                result.append(word)\n    return result"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/set/set_covering.py", "fileNameBase": "set_covering", "extension": "py"}, "dependencies": [{"from_module": "itertools", "import": "chain", "type": "external", "type_element": "module"}, {"from_module": "itertools", "import": "combinations", "type": "external", "type_element": "module"}], "functions": {"powerset": {"doc": {"long_description": "For a range of integers up to the length of the given list,\nmake all possible combinations and chain them together as one object.\nFrom https://docs.python.org/3/library/itertools.html#itertools-recipes", "short_description": "Calculate the powerset of any iterable."}, "args": ["iterable"], "returns": ["chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 35}, "calls": ["list", "itertools.chain.from_iterable", "itertools.combinations", "range", "len"], "store_vars_calls": {"s": "list"}, "source_code": "def powerset(iterable):\n    \"\"\"Calculate the powerset of any iterable.\n\n    For a range of integers up to the length of the given list,\n    make all possible combinations and chain them together as one object.\n    From https://docs.python.org/3/library/itertools.html#itertools-recipes\n    \"\"\"\n    'list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]'\n    s = list(iterable)\n    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))"}, "optimal_set_cover": {"doc": {"long_description": "Finds the minimum cost subcollection os S that covers all elements of U", "short_description": "Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!", "args": {"universe": {"description": "Universe of elements", "type_name": "list", "is_optional": false}, "subsets": {"description": "Subsets of U {S1:elements,S2:elements}", "type_name": "dict", "is_optional": false}, "costs": {"description": "Costs of each subset in S - {S1:cost, S2:cost...}", "type_name": "dict", "is_optional": false}}}, "args": ["universe", "subsets", "costs"], "returns": ["best_set"], "min_max_lineno": {"min_lineno": 37, "max_lineno": 59}, "calls": ["set_covering.powerset", "float", "subsets.keys", "set", "set.update", "len"], "store_vars_calls": {"pset": "powerset", "best_cost": "float", "covered": "set"}, "source_code": "def optimal_set_cover(universe, subsets, costs):\n    \"\"\" Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!\n    Finds the minimum cost subcollection os S that covers all elements of U\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    pset = powerset(subsets.keys())\n    best_set = None\n    best_cost = float('inf')\n    for subset in pset:\n        covered = set()\n        cost = 0\n        for s in subset:\n            covered.update(subsets[s])\n            cost += costs[s]\n        if len(covered) == len(universe) and cost < best_cost:\n            best_set = subset\n            best_cost = cost\n    return best_set"}, "greedy_set_cover": {"doc": {"long_description": "inputs - though not an optimal solution.", "short_description": "Approximate greedy algorithm for set-covering. Can be used on large", "args": {"universe": {"description": "Universe of elements", "type_name": "list", "is_optional": false}, "subsets": {"description": "Subsets of U {S1:elements,S2:elements}", "type_name": "dict", "is_optional": false}, "costs": {"description": "Costs of each subset in S - {S1:cost, S2:cost...}", "type_name": "dict", "is_optional": false}}}, "args": ["universe", "subsets", "costs"], "returns": ["cover_sets", "None"], "min_max_lineno": {"min_lineno": 61, "max_lineno": 96}, "calls": ["set", "float", "subsets.items", "cover_sets.append", "len", "subsets.keys"], "store_vars_calls": {"elements": "set", "covered": "set", "min_cost_elem_ratio": "float", "new_elements": "len"}, "source_code": "def greedy_set_cover(universe, subsets, costs):\n    \"\"\"Approximate greedy algorithm for set-covering. Can be used on large\n    inputs - though not an optimal solution.\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    elements = set((e for s in subsets.keys() for e in subsets[s]))\n    if elements != universe:\n        return None\n    covered = set()\n    cover_sets = []\n    while covered != universe:\n        min_cost_elem_ratio = float('inf')\n        min_set = None\n        for (s, elements) in subsets.items():\n            new_elements = len(elements - covered)\n            if new_elements != 0:\n                cost_elem_ratio = costs[s] / new_elements\n                if cost_elem_ratio < min_cost_elem_ratio:\n                    min_cost_elem_ratio = cost_elem_ratio\n                    min_set = s\n        cover_sets.append(min_set)\n        covered |= subsets[min_set]\n    return cover_sets"}}, "body": {"calls": ["set_covering.optimal_set_cover", "sum", "set_covering.greedy_set_cover", "print"], "store_vars_calls": {"optimal_cover": "optimal_set_cover", "optimal_cost": "sum", "greedy_cover": "greedy_set_cover", "greedy_cost": "sum"}, "source_code": ["optimal_set_cover(universe, subsets, costs)", "sum((costs[s] for s in optimal_cover))", "greedy_set_cover(universe, subsets, costs)", "sum((costs[s] for s in greedy_cover))", "print('Optimal Set Cover:')", "print(optimal_cover)", "print('Cost = %s' % optimal_cost)", "print('Greedy Set Cover:')", "print(greedy_cover)", "print('Cost = %s' % greedy_cost)"]}, "main_info": {"main_flag": 1, "main_function": "set_covering.optimal_set_cover", "type": "script"}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/backtrack": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/backtrack/subsets.py", "fileNameBase": "subsets", "extension": "py", "doc": {"long_description": "Note: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]", "short_description": "Given a set of distinct integers, nums, return all possible subsets.", "full": "Given a set of distinct integers, nums, return all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]"}}, "functions": {"subsets": {"doc": {"short_description": "O(2**n)"}, "args": ["nums"], "returns": ["res"], "min_max_lineno": {"min_lineno": 22, "max_lineno": 40}, "calls": ["subsets.subsets.backtrack"], "functions": {"backtrack": {"args": ["res", "nums", "stack", "pos"], "min_max_lineno": {"min_lineno": 26, "max_lineno": 36}, "calls": ["len", "res.append", "stack.append", "backtrack", "stack.pop", "list"], "source_code": "def backtrack(res, nums, stack, pos):\n    if pos == len(nums):\n        res.append(list(stack))\n    else:\n        stack.append(nums[pos])\n        backtrack(res, nums, stack, pos + 1)\n        stack.pop()\n        backtrack(res, nums, stack, pos + 1)"}}, "source_code": "def subsets(nums):\n    \"\"\"\n    O(2**n)\n    \"\"\"\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.append(list(stack))\n        else:\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos + 1)\n            stack.pop()\n            backtrack(res, nums, stack, pos + 1)\n    res = []\n    backtrack(res, nums, [], 0)\n    return res"}, "subsets_v2": {"args": ["nums"], "returns": ["res"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 60}, "calls": ["sorted"], "source_code": "def subsets_v2(nums):\n    res = [[]]\n    for num in sorted(nums):\n        res += [item + [num] for item in res]\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/backtrack/pattern_match.py", "fileNameBase": "pattern_match", "extension": "py", "doc": {"long_description": "find if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between\na letter in pattern and a non-empty substring in str.\n\nExamples:\npattern = \"abab\", str = \"redblueredblue\" should return true.\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters.", "short_description": "Given a pattern and a string str,", "full": "Given a pattern and a string str,\nfind if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between\na letter in pattern and a non-empty substring in str.\n\nExamples:\npattern = \"abab\", str = \"redblueredblue\" should return true.\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\nNotes:\nYou may assume both pattern and str contains only lowercase letters."}}, "functions": {"pattern_match": {"args": ["pattern", "string"], "returns": ["backtrack(pattern, string, {})", "False", "False", "True", "True", "True"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 43}, "calls": ["pattern_match.pattern_match.backtrack"], "functions": {"backtrack": {"args": ["pattern", "string", "dic"], "returns": ["False", "False", "True", "True", "True"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 41}, "calls": ["range", "len", "backtrack", "dic.values"], "source_code": "def backtrack(pattern, string, dic):\n    if len(pattern) == 0 and len(string) > 0:\n        return False\n    if len(pattern) == len(string) == 0:\n        return True\n    for end in range(1, len(string) - len(pattern) + 2):\n        if pattern[0] not in dic and string[:end] not in dic.values():\n            dic[pattern[0]] = string[:end]\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n            del dic[pattern[0]]\n        elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n    return False"}}, "source_code": "def pattern_match(pattern, string):\n    \"\"\"\n    :type pattern: str\n    :type string: str\n    :rtype: bool\n    \"\"\"\n\n    def backtrack(pattern, string, dic):\n        if len(pattern) == 0 and len(string) > 0:\n            return False\n        if len(pattern) == len(string) == 0:\n            return True\n        for end in range(1, len(string) - len(pattern) + 2):\n            if pattern[0] not in dic and string[:end] not in dic.values():\n                dic[pattern[0]] = string[:end]\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n                del dic[pattern[0]]\n            elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n        return False\n    return backtrack(pattern, string, {})"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/backtrack/subsets_unique.py", "fileNameBase": "subsets_unique", "extension": "py", "doc": {"long_description": "return all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,2], a solution is:\n\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]", "short_description": "Given a collection of integers that might contain duplicates, nums,", "full": "Given a collection of integers that might contain duplicates, nums,\nreturn all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,2], a solution is:\n\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]"}}, "functions": {"subsets_unique": {"args": ["nums"], "returns": ["list(res)"], "min_max_lineno": {"min_lineno": 21, "max_lineno": 38}, "calls": ["set", "subsets_unique.subsets_unique.backtrack"], "store_vars_calls": {"res": "set"}, "functions": {"backtrack": {"args": ["res", "nums", "stack", "pos"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 34}, "calls": ["len", "res.add", "stack.append", "backtrack", "stack.pop", "tuple"], "source_code": "def backtrack(res, nums, stack, pos):\n    if pos == len(nums):\n        res.add(tuple(stack))\n    else:\n        stack.append(nums[pos])\n        backtrack(res, nums, stack, pos + 1)\n        stack.pop()\n        backtrack(res, nums, stack, pos + 1)"}}, "source_code": "def subsets_unique(nums):\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.add(tuple(stack))\n        else:\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos + 1)\n            stack.pop()\n            backtrack(res, nums, stack, pos + 1)\n    res = set()\n    backtrack(res, nums, [], 0)\n    return list(res)"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/backtrack/permute_unique.py", "fileNameBase": "permute_unique", "extension": "py", "doc": {"long_description": "return all possible unique permutations.\n\nFor example,\n[1,1,2] have the following unique permutations:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]", "short_description": "Given a collection of numbers that might contain duplicates,", "full": "Given a collection of numbers that might contain duplicates,\nreturn all possible unique permutations.\n\nFor example,\n[1,1,2] have the following unique permutations:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]"}}, "functions": {"permute_unique": {"args": ["nums"], "returns": ["perms"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 26}, "calls": ["range", "new_perms.append", "len"], "source_code": "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l) + 1):\n                new_perms.append(l[:i] + [n] + l[i:])\n                if i < len(l) and l[i] == n:\n                    break\n        perms = new_perms\n    return perms"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/backtrack/anagram.py", "fileNameBase": "anagram", "extension": "py", "doc": {"long_description": "Examples:\n\"apple\", \"pleap\"  -> True\n\"apple\", \"cherry\" -> False", "short_description": "Given two strings, determine if they are equal after reordering.", "full": "Given two strings, determine if they are equal after reordering.\n\nExamples:\n\"apple\", \"pleap\"  -> True\n\"apple\", \"cherry\" -> False"}}, "functions": {"anagram": {"args": ["s1", "s2"], "returns": ["c1 == c2"], "min_max_lineno": {"min_lineno": 10, "max_lineno": 23}, "calls": ["ord"], "source_code": "def anagram(s1, s2):\n    c1 = [0] * 26\n    c2 = [0] * 26\n    for c in s1:\n        pos = ord(c) - ord('a')\n        c1[pos] = c1[pos] + 1\n    for c in s2:\n        pos = ord(c) - ord('a')\n        c2[pos] = c2[pos] + 1\n    return c1 == c2"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/backtrack/letter_combination.py", "fileNameBase": "letter_combination", "extension": "py", "doc": {"long_description": "combinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below:\n2: \"abc\"\n3: \"def\"\n4: \"ghi\"\n5: \"jkl\"\n6: \"mno\"\n7: \"pqrs\"\n8: \"tuv\"\n9: \"wxyz\"\n\nInput:Digit string \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].", "short_description": "Given a digit string, return all possible letter", "full": "Given a digit string, return all possible letter\ncombinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below:\n2: \"abc\"\n3: \"def\"\n4: \"ghi\"\n5: \"jkl\"\n6: \"mno\"\n7: \"pqrs\"\n8: \"tuv\"\n9: \"wxyz\"\n\nInput:Digit string \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]."}}, "functions": {"letter_combinations": {"args": ["digits"], "returns": ["ans", "[]"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 41}, "calls": ["tmp.append"], "source_code": "def letter_combinations(digits):\n    if digits == '':\n        return []\n    kmaps = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    ans = ['']\n    for num in digits:\n        tmp = []\n        for an in ans:\n            for char in kmaps[num]:\n                tmp.append(an + char)\n        ans = tmp\n    return ans"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/backtrack/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "add_operators", "import": "add_operators", "type": "internal", "type_element": "function"}, {"from_module": "anagram", "import": "anagram", "type": "internal", "type_element": "function"}, {"from_module": "array_sum_combinations", "import": "array_sum_combinations", "type": "internal", "type_element": "function"}, {"from_module": "array_sum_combinations", "import": "unique_array_sum_combinations", "type": "internal", "type_element": "function"}, {"from_module": "combination_sum", "import": "combination_sum", "type": "internal", "type_element": "function"}, {"from_module": "factor_combinations", "import": "get_factors", "type": "internal", "type_element": "function"}, {"from_module": "factor_combinations", "import": "recursive_get_factors", "type": "internal", "type_element": "function"}, {"from_module": "find_words", "import": "find_words", "type": "internal", "type_element": "function"}, {"from_module": "generate_abbreviations", "import": "generate_abbreviations", "type": "internal", "type_element": "function"}, {"from_module": "generate_parenthesis", "import": "generate_parenthesis_v1", "type": "internal", "type_element": "function"}, {"from_module": "generate_parenthesis", "import": "generate_parenthesis_v2", "type": "internal", "type_element": "function"}, {"from_module": "letter_combination", "import": "letter_combinations", "type": "internal", "type_element": "function"}, {"from_module": "palindrome_partitioning", "import": "palindromic_substrings", "type": "internal", "type_element": "function"}, {"from_module": "palindrome_partitioning", "import": "palindromic_substrings_iter", "type": "internal", "type_element": "function"}, {"from_module": "pattern_match", "import": "pattern_match", "type": "internal", "type_element": "function"}, {"from_module": "permute_unique", "import": "permute_unique", "type": "internal", "type_element": "function"}, {"from_module": "permute", "import": "permute", "type": "internal", "type_element": "function"}, {"from_module": "permute", "import": "permute_iter", "type": "internal", "type_element": "function"}, {"from_module": "permute", "import": "permute_recursive", "type": "internal", "type_element": "function"}, {"from_module": "subsets_unique", "import": "subsets_unique", "type": "internal", "type_element": "function"}, {"from_module": "subsets", "import": "subsets", "type": "internal", "type_element": "function"}, {"from_module": "subsets", "import": "subsets_v2", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/backtrack/factor_combinations.py", "fileNameBase": "factor_combinations", "extension": "py", "doc": {"long_description": "8 = 2 x 2 x 2;\n  = 2 x 4.\nWrite a function that takes an integer n\nand return all possible combinations of its factors.\n\nNote:\nYou may assume that n is always positive.\nFactors should be greater than 1 and less than n.\nExamples:\ninput: 1\noutput:\n[]\ninput: 37\noutput:\n[]\ninput: 12\noutput:\n[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]", "short_description": "Numbers can be regarded as product of its factors. For example,", "full": "Numbers can be regarded as product of its factors. For example,\n\n8 = 2 x 2 x 2;\n  = 2 x 4.\nWrite a function that takes an integer n\nand return all possible combinations of its factors.\n\nNote:\nYou may assume that n is always positive.\nFactors should be greater than 1 and less than n.\nExamples:\ninput: 1\noutput:\n[]\ninput: 37\noutput:\n[]\ninput: 12\noutput:\n[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]"}}, "functions": {"get_factors": {"args": ["n"], "returns": ["combis"], "min_max_lineno": {"min_lineno": 40, "max_lineno": 50}, "calls": ["todo.pop", "combis.append", "todo.append"], "source_code": "def get_factors(n):\n    (todo, combis) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                combis.append(combi + [i, n // i])\n                todo.append((n // i, i, combi + [i]))\n            i += 1\n    return combis"}, "recursive_get_factors": {"args": ["n"], "returns": ["factor(n, 2, [], [])", "combis"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 64}, "calls": ["factor_combinations.recursive_get_factors.factor"], "functions": {"factor": {"args": ["n", "i", "combi", "combis"], "returns": ["combis"], "min_max_lineno": {"min_lineno": 55, "max_lineno": 62}, "calls": ["factor", "combis.append"], "source_code": "def factor(n, i, combi, combis):\n    while i * i <= n:\n        if n % i == 0:\n            (combis.append(combi + [i, n // i]),)\n            factor(n // i, i, combi + [i], combis)\n        i += 1\n    return combis"}}, "source_code": "def recursive_get_factors(n):\n\n    def factor(n, i, combi, combis):\n        while i * i <= n:\n            if n % i == 0:\n                (combis.append(combi + [i, n // i]),)\n                factor(n // i, i, combi + [i], combis)\n            i += 1\n        return combis\n    return factor(n, 2, [], [])"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/backtrack/permute.py", "fileNameBase": "permute", "extension": "py", "doc": {"long_description": "For example,\n[1,2,3] have the following permutations:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]", "short_description": "Given a collection of distinct numbers, return all possible permutations.", "full": "Given a collection of distinct numbers, return all possible permutations.\n\nFor example,\n[1,2,3] have the following permutations:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]"}}, "functions": {"permute": {"doc": {"short_description": "returns a list with the permuations."}, "args": ["elements"], "returns": ["[elements]", "tmp"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 29}, "calls": ["len", "permute.permute", "range", "tmp.append"], "source_code": "def permute(elements):\n    \"\"\"\n        returns a list with the permuations.\n    \"\"\"\n    if len(elements) <= 1:\n        return [elements]\n    else:\n        tmp = []\n        for perm in permute(elements[1:]):\n            for i in range(len(elements)):\n                tmp.append(perm[:i] + elements[0:1] + perm[i:])\n        return tmp"}, "permute_iter": {"doc": {"short_description": "iterator: returns a perumation by each call."}, "args": ["elements"], "min_max_lineno": {"min_lineno": 31, "max_lineno": 41}, "calls": ["len", "permute.permute_iter", "range"], "source_code": "def permute_iter(elements):\n    \"\"\"\n        iterator: returns a perumation by each call.\n    \"\"\"\n    if len(elements) <= 1:\n        yield elements\n    else:\n        for perm in permute_iter(elements[1:]):\n            for i in range(len(elements)):\n                yield (perm[:i] + elements[0:1] + perm[i:])"}, "permute_recursive": {"args": ["nums"], "returns": ["res"], "min_max_lineno": {"min_lineno": 44, "max_lineno": 55}, "calls": ["permute.permute_recursive.dfs"], "functions": {"dfs": {"args": ["res", "nums", "path"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 51}, "calls": ["range", "res.append", "len", "print", "dfs"], "source_code": "def dfs(res, nums, path):\n    if not nums:\n        res.append(path)\n    for i in range(len(nums)):\n        print(nums[:i] + nums[i + 1:])\n        dfs(res, nums[:i] + nums[i + 1:], path + [nums[i]])"}}, "source_code": "def permute_recursive(nums):\n\n    def dfs(res, nums, path):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            print(nums[:i] + nums[i + 1:])\n            dfs(res, nums[:i] + nums[i + 1:], path + [nums[i]])\n    res = []\n    dfs(res, nums, [])\n    return res"}}, "is_test": false}], "output/keon/algorithms/algorithms/algorithms/heap": [{"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/heap/sliding_window_max.py", "fileNameBase": "sliding_window_max", "extension": "py", "doc": {"long_description": "which is moving from the very left of the array to the very right.\nYou can only see the k numbers in the window.\nEach time the sliding window moves right by one position.\n\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\n\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\nTherefore, return the max sliding window as [3,3,5,5,6,7].", "short_description": "Given an array nums, there is a sliding window of size k", "full": "Given an array nums, there is a sliding window of size k\nwhich is moving from the very left of the array to the very right.\nYou can only see the k numbers in the window.\nEach time the sliding window moves right by one position.\n\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\n\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\nTherefore, return the max sliding window as [3,3,5,5,6,7]."}}, "dependencies": [{"import": "collections", "type": "external", "type_element": "module"}], "functions": {"max_sliding_window": {"args": ["nums", "k"], "returns": ["res", "nums"], "min_max_lineno": {"min_lineno": 23, "max_lineno": 42}, "calls": ["collections.deque", "res.append", "max", "len", "collections.deque.append", "collections.deque.popleft"], "store_vars_calls": {"queue": "collections.deque"}, "source_code": "def max_sliding_window(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if not nums:\n        return nums\n    queue = collections.deque()\n    res = []\n    for num in nums:\n        if len(queue) < k:\n            queue.append(num)\n        else:\n            res.append(max(queue))\n            queue.popleft()\n            queue.append(num)\n    res.append(max(queue))\n    return res"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/heap/__init__.py", "fileNameBase": "__init__", "extension": "py"}, "dependencies": [{"from_module": "binary_heap", "import": "AbstractHeap", "type": "internal", "type_element": "class"}, {"from_module": "binary_heap", "import": "BinaryHeap", "type": "internal", "type_element": "class"}, {"from_module": "skyline", "import": "get_skyline", "type": "internal", "type_element": "function"}, {"from_module": "sliding_window_max", "import": "max_sliding_window", "type": "internal", "type_element": "function"}, {"from_module": "merge_sorted_k_lists", "import": "merge_k_lists", "type": "internal", "type_element": "function"}, {"from_module": "merge_sorted_k_lists", "import": "merge_k_lists", "type": "internal", "type_element": "function"}, {"from_module": "merge_sorted_k_lists", "import": "ListNode", "type": "internal", "type_element": "class"}, {"from_module": "k_closest_points", "import": "k_closest", "type": "internal", "type_element": "function"}, {"from_module": "k_closest_points", "import": "distance", "type": "internal", "type_element": "function"}], "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/heap/merge_sorted_k_lists.py", "fileNameBase": "merge_sorted_k_lists", "extension": "py", "doc": {"short_description": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.", "full": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity."}}, "dependencies": [{"from_module": "heapq", "import": "heappop", "type": "external", "type_element": "module"}, {"from_module": "heapq", "import": "heapreplace", "type": "external", "type_element": "module"}, {"from_module": "heapq", "import": "heapify", "type": "external", "type_element": "module"}, {"from_module": "queue", "import": "PriorityQueue", "type": "external", "type_element": "module"}], "classes": {"ListNode": {"doc": {"short_description": "ListNode Class", "full": "ListNode Class"}, "extend": ["object"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 17}, "methods": {"__init__": {"args": ["self", "val"], "min_max_lineno": {"min_lineno": 14, "max_lineno": 17}, "source_code": "def __init__(self, val):\n    self.val = val\n    self.next = None"}}}}, "functions": {"merge_k_lists": {"doc": {"short_description": "Merge List "}, "args": ["lists"], "returns": ["dummy.next"], "min_max_lineno": {"min_lineno": 36, "max_lineno": 50}, "calls": ["queue.PriorityQueue", "queue.PriorityQueue.empty", "queue.PriorityQueue.put", "queue.PriorityQueue.get"], "store_vars_calls": {"dummy": "ListNode", "q": "PriorityQueue"}, "source_code": "def merge_k_lists(lists):\n    \"\"\" Merge List \"\"\"\n    dummy = ListNode(None)\n    curr = dummy\n    q = PriorityQueue()\n    for node in lists:\n        if node:\n            q.put((node.val, node))\n    while not q.empty():\n        curr.next = q.get()[1]\n        curr = curr.next\n        if curr.next:\n            q.put((curr.next.val, curr.next))\n    return dummy.next"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/heap/k_closest_points.py", "fileNameBase": "k_closest_points", "extension": "py", "doc": {"long_description": "Idea: Maintain a max heap of k elements.\nWe can iterate through all points.\nIf a point p has a smaller distance to the origin than the top element of a\nheap, we add point p to the heap and remove the top element.\nAfter iterating through all points, our heap contains the k closest points to\nthe origin.", "short_description": "Given a list of points, find the k closest to the origin.", "full": "Given a list of points, find the k closest to the origin.\n\nIdea: Maintain a max heap of k elements.\nWe can iterate through all points.\nIf a point p has a smaller distance to the origin than the top element of a\nheap, we add point p to the heap and remove the top element.\nAfter iterating through all points, our heap contains the k closest points to\nthe origin."}}, "dependencies": [{"from_module": "heapq", "import": "heapify", "type": "external", "type_element": "module"}, {"from_module": "heapq", "import": "heappushpop", "type": "external", "type_element": "module"}], "functions": {"k_closest": {"doc": {"long_description": "Python does not support a max heap; thus we can use the default min heap\nwhere the keys (distance) are negated.", "short_description": "Initialize max heap with first k points."}, "args": ["points", "k", "origin"], "returns": ["[point for (nd, point) in heap]"], "min_max_lineno": {"min_lineno": 15, "max_lineno": 44}, "calls": ["heapq.heapify", "k_closest_points.distance", "heapq.heappushpop"], "store_vars_calls": {"dist": "distance"}, "source_code": "def k_closest(points, k, origin=(0, 0)):\n    \"\"\"Initialize max heap with first k points.\n    Python does not support a max heap; thus we can use the default min heap\n    where the keys (distance) are negated.\n    \"\"\"\n    heap = [(-distance(p, origin), p) for p in points[:k]]\n    heapify(heap)\n    '\\n    For every point p in points[k:],\\n    check if p is smaller than the root of the max heap;\\n    if it is, add p to heap and remove root. Reheapify.\\n    '\n    for point in points[k:]:\n        dist = distance(point, origin)\n        heappushpop(heap, (-dist, point))\n        'Same as:\\n            if d < -heap[0][0]:\\n                heappush(heap, (-d,p))\\n                heappop(heap)\\n\\n        Note: heappushpop is more efficient than separate push and pop calls.\\n        Each heappushpop call takes O(logk) time.\\n        '\n    return [point for (nd, point) in heap]"}, "distance": {"doc": {"short_description": "Calculates the distance for a point from origo"}, "args": ["point", "origin"], "returns": ["(point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2"], "min_max_lineno": {"min_lineno": 46, "max_lineno": 49}, "source_code": "def distance(point, origin=(0, 0)):\n    \"\"\" Calculates the distance for a point from origo\"\"\"\n    return (point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/heap/skyline.py", "fileNameBase": "skyline", "extension": "py", "doc": {"long_description": "in that city when viewed from a distance.\nNow suppose you are given the locations and height of all the buildings\nas shown on a cityscape photo (Figure A),\nwrite a program to output the skyline formed by these buildings collectively (Figure B).\n\nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi],\nwhere Li and Ri are the x coordinates of the left and right edge of the ith building, respectively,\nand Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0 < Hi \u2264 INT_MAX, and Ri - Li > 0.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nFor instance, the dimensions of all buildings in Figure A are recorded as:\n[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\n\nThe output is a list of \"key points\" (red dots in Figure B) in the format of\n[ [x1,y1], [x2, y2], [x3, y3], ... ]\nthat uniquely defines a skyline.\nA key point is the left endpoint of a horizontal line segment. Note that the last key point,\nwhere the rightmost building ends,\nis merely used to mark the termination of the skyline, and always has zero height.\nAlso, the ground in between any two adjacent buildings should be considered part of the skyline contour.\n\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\n\nNotes:\n\nThe number of buildings in any input list is guaranteed to be in the range [0, 10000].\nThe input list is already sorted in ascending order by the left x position Li.\nThe output list must be sorted by the x position.\nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance,\n[...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged\ninto one in the final output as such: [...[2 3], [4 5], [12 7], ...]", "short_description": "A city's skyline is the outer contour of the silhouette formed by all the buildings", "full": "A city's skyline is the outer contour of the silhouette formed by all the buildings\nin that city when viewed from a distance.\nNow suppose you are given the locations and height of all the buildings\nas shown on a cityscape photo (Figure A),\nwrite a program to output the skyline formed by these buildings collectively (Figure B).\n\nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi],\nwhere Li and Ri are the x coordinates of the left and right edge of the ith building, respectively,\nand Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0 < Hi \u2264 INT_MAX, and Ri - Li > 0.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nFor instance, the dimensions of all buildings in Figure A are recorded as:\n[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\n\nThe output is a list of \"key points\" (red dots in Figure B) in the format of\n[ [x1,y1], [x2, y2], [x3, y3], ... ]\nthat uniquely defines a skyline.\nA key point is the left endpoint of a horizontal line segment. Note that the last key point,\nwhere the rightmost building ends,\nis merely used to mark the termination of the skyline, and always has zero height.\nAlso, the ground in between any two adjacent buildings should be considered part of the skyline contour.\n\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\n\nNotes:\n\nThe number of buildings in any input list is guaranteed to be in the range [0, 10000].\nThe input list is already sorted in ascending order by the left x position Li.\nThe output list must be sorted by the x position.\nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance,\n[...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged\ninto one in the final output as such: [...[2 3], [4 5], [12 7], ...]"}}, "dependencies": [{"import": "heapq", "type": "external", "type_element": "module"}], "functions": {"get_skyline": {"doc": {"short_description": "Wortst Time Complexity: O(NlogN)"}, "args": ["lrh"], "returns": ["skyline"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 61}, "calls": ["len", "heapq.heappush", "heapq.heappop"], "source_code": "def get_skyline(lrh):\n    \"\"\"\n    Wortst Time Complexity: O(NlogN)\n    :type buildings: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    (skyline, live) = ([], [])\n    (i, n) = (0, len(lrh))\n    while i < n or live:\n        if not live or (i < n and lrh[i][0] <= -live[0][1]):\n            x = lrh[i][0]\n            while i < n and lrh[i][0] == x:\n                heapq.heappush(live, (-lrh[i][2], -lrh[i][1]))\n                i += 1\n        else:\n            x = -live[0][1]\n            while live and -live[0][1] <= x:\n                heapq.heappop(live)\n        height = len(live) and -live[0][0]\n        if not skyline or height != skyline[-1][1]:\n            skyline += ([x, height],)\n    return skyline"}}, "is_test": false}, {"file": {"path": "/cs/home/cd271/Documents/Project/Examples/RepoAnalysis/SemanticCodeSearch/Text2code/content/keon/algorithms/algorithms/heap/binary_heap.py", "fileNameBase": "binary_heap", "extension": "py", "doc": {"long_description": "its children. The root, therefore, is the minimum element in the tree. The min\nheap uses an array to represent the data and operation. For example a min heap:\n\n     4\n   /   \\\n  50    7\n / \\   /\n55 90 87\n\nHeap [0, 4, 50, 7, 55, 90, 87]\n\nMethod in class: insert, remove_min\nFor example insert(2) in a min heap:\n\n     4                     4                     2\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     2       -->     50    4\n / \\   /  \\           /  \\   / \\             /  \\  /  \\\n55 90 87   2         55  90 87  7           55  90 87  7\n\nFor example remove_min() in a min heap:\n\n     4                     87                    7\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     7       -->     50    87\n / \\   /              /  \\                   /  \\\n55 90 87             55  90                 55  90", "short_description": "Binary Heap. A min heap is a complete binary tree where each node is smaller than", "full": "Binary Heap. A min heap is a complete binary tree where each node is smaller than\nits children. The root, therefore, is the minimum element in the tree. The min\nheap uses an array to represent the data and operation. For example a min heap:\n\n     4\n   /   \\\n  50    7\n / \\   /\n55 90 87\n\nHeap [0, 4, 50, 7, 55, 90, 87]\n\nMethod in class: insert, remove_min\nFor example insert(2) in a min heap:\n\n     4                     4                     2\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     2       -->     50    4\n / \\   /  \\           /  \\   / \\             /  \\  /  \\\n55 90 87   2         55  90 87  7           55  90 87  7\n\nFor example remove_min() in a min heap:\n\n     4                     87                    7\n   /   \\                 /   \\                 /   \\\n  50    7      -->     50     7       -->     50    87\n / \\   /              /  \\                   /  \\\n55 90 87             55  90                 55  90"}}, "dependencies": [{"